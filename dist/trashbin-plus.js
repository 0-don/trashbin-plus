(async()=>{while(!Spicetify.React||!Spicetify.ReactDOM)await new Promise(r=>setTimeout(r,10));var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// ext:react
var require_react = __commonJS((exports, module) => {
  module.exports = Spicetify.React;
});

// ext:react-dom
var require_react_dom = __commonJS((exports, module) => {
  module.exports = Spicetify.ReactDOM;
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS((exports) => {
  var React2 = __toESM(require_react());
  (function() {
    function is2(x, y) {
      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
      didWarnOld18Alpha || React2.startTransition === undefined || (didWarnOld18Alpha = true, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var value = getSnapshot();
      if (!didWarnUncachedGetSnapshot) {
        var cachedValue = getSnapshot();
        objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true);
      }
      cachedValue = useState2({
        inst: { value, getSnapshot }
      });
      var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
      useLayoutEffect2(function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      }, [subscribe, value, getSnapshot]);
      useEffect2(function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      }, [subscribe]);
      useDebugValue2(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
      return getSnapshot();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var objectIs = typeof Object.is === "function" ? Object.is : is2, useState2 = React2.useState, useEffect2 = React2.useEffect, useLayoutEffect2 = React2.useLayoutEffect, useDebugValue2 = React2.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined" ? useSyncExternalStore$1 : useSyncExternalStore$2;
    exports.useSyncExternalStore = React2.useSyncExternalStore !== undefined ? React2.useSyncExternalStore : shim;
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS((exports, module) => {
  if (false) {} else {
    module.exports = require_use_sync_external_store_shim_development();
  }
});

// src/i18n/af.json
var require_af = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Asblik+",
    ACTION_THROW: "Plaas in asblik",
    ACTION_UNTHROW: "Verwyder uit asblik",
    ACTION_CLEAR: "Duidelik",
    ACTION_COPY: "Kopieer",
    ACTION_EXPORT: "Uitvoer",
    ACTION_IMPORT: "Invoer",
    MESSAGE_COPIED: "Gekopieer na knipbord",
    MESSAGE_CLEARED: "Asblik suksesvol skoongemaak!",
    MESSAGE_SONG_ADDED: "Liedjie by prullenmandjie gevoeg",
    MESSAGE_SONG_REMOVED: "Liedjie uit asblik verwyder",
    MESSAGE_ARTIST_ADDED: "Kunstenaar by afvalblik gevoeg",
    MESSAGE_ARTIST_REMOVED: "Kunstenaar verwyder uit asblik",
    BACKUP_SAVE_SUCCESS: "Back-up suksesvol gestoor.",
    BACKUP_SAVE_FAILED: "Kon nie rugsteunkopie stoor nie, probeer om inhoud van asblik na knipbord te kopieer en rugsteunkopie handmatig te skep.",
    BACKUP_RESTORE_SUCCESS: "Back-up suksesvol herstel.",
    BACKUP_FILE_READ_FAILED: "Het nie die lêer kon lees nie, verseker asseblief dit is 'n geldige JSON-lêer.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Papiermandjie+ Instellings",
    SETTINGS_OPTIONS: "Opsies",
    SETTINGS_FEATURES: "Kenmerke",
    SETTINGS_LOCAL_STORAGE: "Lokale Stoorruimte",
    SETTINGS_ENABLED: "Aangetrek",
    SETTINGS_SHOW_WIDGET: "Wys werktuigikoon",
    SETTINGS_AUTOPLAY: "Speel outomaties af vanaf begin",
    SETTINGS_QUEUE_TRASHBIN: "Aktiveer Wachtrashblik",
    SETTINGS_TRACKLIST_TRASHBIN: "Aktiveer Lys van nummers-asblik",
    SETTINGS_PLAYLIST_MONITOR: "Afspeellys Monitor",
    ITEMS_TITLE: "Asblik+ Items",
    ITEMS_EMPTY_SONGS: "<strong>Geen verwyderde liedjies!</strong><br/>Liedjies wat jy na die asblik toe skuif, sal hier verskyn.",
    ITEMS_EMPTY_ARTISTS: "<strong>Geen verwyderde kunstenaars!</strong><br/>Kunstenaars wat jy by die asblik voeg, sal hier verskyn.",
    ITEMS_TAB_SONGS: "Liedjies",
    ITEMS_TAB_ARTISTS: "Kunstenaars",
    ITEMS_LOADED_COUNT: "{{loaded}} van {{total}} {{type}} gelaai",
    DESCRIPTION_COPY: "Kopieer alle items in die asblik na die knipbord.",
    DESCRIPTION_EXPORT: "Stoor alle items in die asblik na 'n .json-lêer.",
    DESCRIPTION_IMPORT: "Oorskryf alle items in die asblik via .json-lêer.",
    DESCRIPTION_CLEAR: "Verwyder alle items uit die asblik (kan nie ongedaan gemaak word nie).",
    ITEMS_EMPTY_SONGS_TITLE: "Geen verwyderde liedjies nie!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Geen verwoeste kunstenaars nie!",
    DESCRIPTION_SETTINGS_ENABLED: "Meesterwisselaar om alle Trashbin+-funksies in- of uit te skakel",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Wys 'n asblikikoon in die afspeelbalk langs die huidige liedjie vir vinnige toegang",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Begin outomaties met die speel van musiek wanneer Spotify oopgaan of die uitbreiding gelaai word",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Voeg asblik-ikone langs elke liedjie in jou komende tou by vir maklike bestuur",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Voeg asblik-ikone langs liedjies by album- en afspeellys-views vir vinnige filtring",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Herstel outomaties vanaf Spotify-afspeelfoutjies deur jou laaste afspeellys voort te sit",
    SETTINGS_SKIP_TRASHED_TRACKS: "Slaan Verwoeste Spore oor",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Slaan outomaties verwyderde liedjies oor en vind die volgende toegelate liedjie tydens afspeel",
    SETTINGS_AUTO_CLEAN_QUEUE: "Outomatiese skoonmaakry",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Verwyder outomaties verwyderde liedjies uit jou Slim Skud-gids",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Afval op Volgende Sneltoets",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Verwyder outomaties die huidige liedjie wanneer Ctrl+Regs gebruik word om na die volgende snit te spring",
    SETTINGS_REMOTE_CONTROL: "Afstandbeheer",
    SETTINGS_REMOTE_TOGGLE: "Aktiveer Verweide Wisselknoppie",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Tik twee keer op speel/pouse vanaf die selfoon om verwekte oorslaan aan/af te skakel. 'n Oorskakeling van 'n nommer bevestig die skakelaar.",
    SETTINGS_REMOTE_SKIPPING: "Afstandskipping Aktief",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Wanneer dit geaktiveer is, werk die oorslaan van asblik selfs wanneer Spotify vanaf 'n ander toestel beheer word (byvoorbeeld, selfoon)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Afstandskipping toegelaat",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Afstandskipping gedeaktiveer",
    MESSAGE_SONG_ADDED_REMOTE: "Lied verwoes via afstandbeheer",
    SETTINGS_TRASH_VIA_LIKE: "Afval via Soos",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: `Soos 'n liedjie vanaf mobiel na dit te verwyder. Verwyder outomaties die "like" en slaan oor na die volgende liedjie.`,
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/am.json
var require_am = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ሳንጠቆ ሳጥን+",
    ACTION_THROW: "ውስጥ ያስቀምጡ የፍርፍር ሳጥን",
    ACTION_UNTHROW: "ከዝቧ ሳጥን ያስወግዱ",
    ACTION_CLEAR: "ጠቃሚ",
    ACTION_COPY: "ኮፒ አድርግ",
    ACTION_EXPORT: "ይገባል",
    ACTION_IMPORT: "ማስገቢያ",
    MESSAGE_COPIED: "በክሊፕቦርድ ላይ ተቀናብሷል",
    MESSAGE_CLEARED: "የመዋረድ ሳጥን በተሳካ ሁኔታ ተሰራ!",
    MESSAGE_SONG_ADDED: "ሶንግ ወደ ካሬ ተጨምሯል",
    MESSAGE_SONG_REMOVED: "አውድ ከቆሻሻው ግዙፍ ተወስዶአል",
    MESSAGE_ARTIST_ADDED: "አርቲስት ወደ ፍሳሽ ሳጥን ተጨምሯል",
    MESSAGE_ARTIST_REMOVED: "አርቲስት ከቆሻሻ ሳጥን ተወግሯል",
    BACKUP_SAVE_SUCCESS: "ደጋፊው በተሳካ ሁኔታ ተቀምጧል።",
    BACKUP_SAVE_FAILED: "ማስቀመጫ ስራ አልተሳካም፣ የዝውውር ሳጥን ውስጥ ስለሚገኘው ይቅር በክሊፕቦርድ ላይ እና በእጅ ማስቀመጫ ይሞክሩ።",
    BACKUP_RESTORE_SUCCESS: "ማስቀመጫው በተሳካ ሁኔታ ወደ መጀመሪያ ሰርተዋል።",
    BACKUP_FILE_READ_FAILED: "ማስተዋል አልተቻለም፣ እባክዎ እንደሚገባ የ JSON ፋይል መሆኑን ያረጋግጡ።",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "የመጥረቢያ ማውጫ ማውጫ",
    SETTINGS_OPTIONS: "አማራጮች",
    SETTINGS_FEATURES: "የተለያዩ ባህሪዎች",
    SETTINGS_LOCAL_STORAGE: "የአካባቢ ማከማቻ",
    SETTINGS_ENABLED: "ተቋቋመ",
    SETTINGS_SHOW_WIDGET: "አይሮ ምልክት አሳይ",
    SETTINGS_AUTOPLAY: "ራስ ማውጣት በመጀመሪያ",
    SETTINGS_QUEUE_TRASHBIN: "የአንድ አንዴ የመቀመሪያ ማዕከል መክፈቻ",
    SETTINGS_TRACKLIST_TRASHBIN: "የመተግበሪያ ዝርዝር ስንጠቀ መቋቋም አድርገው",
    SETTINGS_PLAYLIST_MONITOR: "የፕሌሊስት ቅጂ",
    ITEMS_TITLE: "የመጥፎ ነገሮች ነጥቦች",
    ITEMS_EMPTY_SONGS: "<strong>የተወረወሩ ድግስ የለም!</strong><br/>ወደ መዋረጃ ሳጥን የምትጨምሩት ድግስ በዚህ ይታያሉ።",
    ITEMS_EMPTY_ARTISTS: "<strong>ምንም የተወረወሩ አርቲስቶች የሉም!</strong><br/>ወደ መዋቅሪያ የትሸቱባቸው አርቲስቶች እዚህ ይታያሉ።",
    ITEMS_TAB_SONGS: "ዘፈረሱ ግጥሞች",
    ITEMS_TAB_ARTISTS: "አርቲስቶች",
    ITEMS_LOADED_COUNT: "{{ተጫነ}} ከ {{ጠቅላላ}} የ {{አይነት}} ጋር ተጫንቷል",
    DESCRIPTION_COPY: "ሁሉንም የተወረዱ አይጥሞች ወደ ክሊፕቦርድ ይቅዱ።",
    DESCRIPTION_EXPORT: "ሁሉንም የተወገዱ ነገሮች ወደ .json ፋይል አስቀምጥ።",
    DESCRIPTION_IMPORT: "ሁሉንም አይтем በ መቆለፊያ ውስጥ ያለውን የ .json ፋይል ይጻፉ በማዳበር።",
    DESCRIPTION_CLEAR: "ሁሉንም የተወረወሩ ነገሮች ከቆሻሻ ሳጥን ያስወግዱ (ማስመለስ አይቻልም)።",
    ITEMS_EMPTY_SONGS_TITLE: "የተወረደ ድግስ የለም!",
    ITEMS_EMPTY_ARTISTS_TITLE: "ምንም የተወረደ አርቲስቶች የሉም!",
    DESCRIPTION_SETTINGS_ENABLED: "ዋና ማጥፊያ ለማንቃት ወይም ለመጥፋት ሁሉንም የ ትራሽቢን+ ተግባራት",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "የመቀመጫ ባር ላይ ለአሁኑ የሚጫው ጣራ ከጎን ለፈጣን መዳረሻ የመቀመጫ ᆖረራ ፊደል አሳይ",
    DESCRIPTION_SETTINGS_AUTOPLAY: "ራስ ብራሱ ስፖቲፋይ ተክፈቶ ወይም ልዩ አማራጭ ተጫነ የሙዚቃ መዝሙር ይጀምር",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "የማጥፋት አይኮን ወደ የሚመጣው የሙዚቃ ዝርዝር ሁሉንም የሙዚቃ መዝሙራት አጠገብ አክሉ ለቀላል አስተዳደር",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "የመቀመጫ አይኮኖችን በאלבום እና በፕሌልስት አቀራረቦች ውስጥ ያሉ የሙዚቃ ትዕይንቶች ከጎን ያክሉ ለፍጥነት ፍልተር ለማድረግ",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "በአውቶማቲክ ከስፖቲፋይ መዝሙር መቆራረጥ ይልቅ የመጨረሻዎ የመዝሙር ዝርዝር ሲቀጥል ከዚያ ይሰርዙ",
    SETTINGS_SKIP_TRASHED_TRACKS: "ዝተገደሉ ትራኮች አስቀድም",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "ከመዝገብ ውስጥ የተወገዱ ድምፆችን በራስ በራስ ያስገድዱ እና በመዝገበ ጊዜ ውስጥ ያለውን ቀጣይ የተፈቀደ መዝገብ ያግኙ",
    SETTINGS_AUTO_CLEAN_QUEUE: "ራስ ግልጽ የሚያደርገው የአንድ ቁጥር ዝርዝር",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "ከራስ በራሱ የተወረዱ ድግስ ስብስቦችን ከስማርት ሼፍል ዋና መስመር ያስወግዱ",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "ዝናብ በሚቀጥለው የሞገድ ቁልፍ",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "አሁኑኑ የተጫነውን ግንብር በሚቀጥለው መዝሙር ለመተካት የ Ctrl+ቀኝ የመተካት ቁልፍ ሲጠቀሙ አውቶማቲክ አጥር ውስጥ ያስገቡ",
    SETTINGS_REMOTE_CONTROL: "ሪሞት ኮንትሮል",
    SETTINGS_REMOTE_TOGGLE: "የራስ ቁልፍ ማብሪያ አቋርጥ/መብራት",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "የሞባይል ማውጫ ማጉጠሚያ ለመጠቀም ለማስጀመር/ለማቆም ሁለቴ ጠቅ ያድርጉ። መዝሙር ማስቀመጥ ማውጫውን እንዲያጥፍ ያረጋግጣል።",
    SETTINGS_REMOTE_SKIPPING: "የተላላይ የመዝለል ማስቆሚያ አንቀሳቅሷል",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "በማንኛውም ማስተላለፊያ ላይ ከስፖቲፋይ (ለምሳሌ፣ ሞባይል) በሚቆጣጠርበት ጊዜ የመዋጮ ቦታ ማለፍ ከተፈቀደ ይሰራል።",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "የተጠቀሰው የማቆም ስርዓት አንቃጢ ነው",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "የተጠቀመው ችግር አልተፈቀደም",
    MESSAGE_SONG_ADDED_REMOTE: "አሶና ከራስ በር ተደብቷል",
    SETTINGS_TRASH_VIA_LIKE: "ዝር በልይክ ማስወገድ",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "እንደ ሞባይል የተላለፈ መዝሙር ወደ መዋቅር ማስወገድ አውቶማቲክ ሁኔታ ያስወግዳል እና ወደ የሚቀጥለው መዝሙር ይዝዋል።",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ar-EG.json
var require_ar_EG = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "سلة المهملات+",
    ACTION_THROW: "ضع في سلة المهملات",
    ACTION_UNTHROW: "اخرج من سلة المهملات",
    ACTION_CLEAR: "واضح",
    ACTION_COPY: "انسخ",
    ACTION_EXPORT: "تصدير",
    ACTION_IMPORT: "استيراد",
    MESSAGE_COPIED: "تم النسخ إلى الحافظة",
    MESSAGE_CLEARED: "اتممسح سلة المهملات بنجاح!",
    MESSAGE_SONG_ADDED: "اتضاف التسجيلة للسلة المهملات",
    MESSAGE_SONG_REMOVED: "تمت إزالة الأغنية من سلة المهملات",
    MESSAGE_ARTIST_ADDED: "اتضاف الفنان للسلة المهملات",
    MESSAGE_ARTIST_REMOVED: "اتمسح الفنان من سلة المهملات",
    BACKUP_SAVE_SUCCESS: "اتحفظ البك اب بنجاح.",
    BACKUP_SAVE_FAILED: "فشلت عملية حفظ النسخة الاحتياطية، جرب نسخ محتويات سلة المهملات إلى الحافظة وإنشاء نسخة احتياطية يدويًا.",
    BACKUP_RESTORE_SUCCESS: "ات\trestore النسخة الاحتياطية بنجاح.",
    BACKUP_FILE_READ_FAILED: "فشل قراءة الملف، يرجى التأكد من أنه ملف JSON صالح.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "إعدادات سلة المهملات+",
    SETTINGS_OPTIONS: "خيارات",
    SETTINGS_FEATURES: "مميزات",
    SETTINGS_LOCAL_STORAGE: "المساحة التخزينية المحلية",
    SETTINGS_ENABLED: "مُمَكَّن",
    SETTINGS_SHOW_WIDGET: "اعرض أيقونة الودجيت",
    SETTINGS_AUTOPLAY: "تشغيل تلقائي عند البدء",
    SETTINGS_QUEUE_TRASHBIN: "تفعيل سلة مهملات الطابور",
    SETTINGS_TRACKLIST_TRASHBIN: "تفعيل سلة مهملات قائمة الأغاني",
    SETTINGS_PLAYLIST_MONITOR: "مُراقب التشغيل",
    ITEMS_TITLE: "عناصر سلة المهملات+",
    ITEMS_EMPTY_SONGS: "<strong>مفيش أغانى فى السلة!</strong><br/>الأغانى اللى هتضيفها فى سلة المهملات هتظهر هنا.",
    ITEMS_EMPTY_ARTISTS: "<strong>مفيش فنانين في المزبلة!</strong><br/>الفنانين اللي تحطهم في سلة المهملات هيظهروا هنا.",
    ITEMS_TAB_SONGS: "أغانى",
    ITEMS_TAB_ARTISTS: "الفنانين",
    ITEMS_LOADED_COUNT: "تم تحميل {{loaded}} من أصل {{total}} {{type}}",
    DESCRIPTION_COPY: "انسخ كل العناصر في سلة المهملات للحافظة.",
    DESCRIPTION_EXPORT: "احفظ كل العناصر في سلة المهملات في ملف .json.",
    DESCRIPTION_IMPORT: "اكتب فوق كل العناصر في سلة المهملات باستخدام ملف .json.",
    DESCRIPTION_CLEAR: "امسح كل العناصر من سلة المهملات (مفيش رجعة).",
    ITEMS_EMPTY_SONGS_TITLE: "مفيش أغانى هبّلة!",
    ITEMS_EMPTY_ARTISTS_TITLE: "مفيش فنانين وحشين!",
    DESCRIPTION_SETTINGS_ENABLED: "مفتاح رئيسي لتفعيل أو إيقاف كل وظائف سلة المهملات+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "اعرض أيقونة سلة المهملات في شريط التشغيل بجانب التسجيل الصوتي اللي بتشتغل دلوقتي للوصول السريع",
    DESCRIPTION_SETTINGS_AUTOPLAY: "إبدأ العزف التلقائي لما يفتح سبوتيفاي أو لما يشتغل الامتداد",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "أضف أيقونات سلة المهملات بجانب كل أغنية في قائمة الانتظار الخاصة بك لإدارتها بسهولة",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "اضف أيقونات سلة مهملات بجانب الأغاني في عروض الألبوم والقوائم علشان التصفية السريعة",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "استرجاع تلقائي من أعطال تشغيل سبوتيفاي باستئناف قائم التشغيل الأخيرة بتاعك",
    SETTINGS_SKIP_TRASHED_TRACKS: "تجاوز المسارات التالفة",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "تخطي الأغاني المحذوفة تلقائيًا وإيجاد المسار المسموح به التالي أثناء التشغيل",
    SETTINGS_AUTO_CLEAN_QUEUE: "قائمة التنظيف التلقائي",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "اُحذف الأغاني الممحية من قائمة التشغيل العشوائية الذكية تلقائيًا",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "القمامة على الزر الساخن التالي",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "احذف الأغنية الحالية تلقائيًا لما تستخدم اختصار لوحة المفاتيح كترل+يمين للانتقال للأغنية الجاية",
    SETTINGS_REMOTE_CONTROL: "ريموت كنترول",
    SETTINGS_REMOTE_TOGGLE: "تفعيل التبديل عن بعد",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "اضغط مرتين على تشغيل/إيقاف من الموبايل علشان تشغل أو توقف تخطي التحكم عن بعد. تخطي الأغنية بيأكد التبديل.",
    SETTINGS_REMOTE_SKIPPING: "التخطي عن بعد مفعل",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "لو تم تفعيله، هيتم تخطي المحتوى الغير مرغوب فيه حتى لو كنت بتحكّم في سبوتيفاي من جهاز تاني (زي الموبايل)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "تم تفعيل التخطي عن بعد",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "تم إيقاف التخطي عن بعد",
    MESSAGE_SONG_ADDED_REMOTE: "اتكسرت الأغنية عن بعد",
    SETTINGS_TRASH_VIA_LIKE: "زبالة عن طريق لايك",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "زي أغنية من الموبايل تتحذف. بيشيل اللايك تلقائي وياخد الأغنية الجاية.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ar-MA.json
var require_ar_MA = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "سلة المهملات+",
    ACTION_THROW: "ضع في سلة المهملات",
    ACTION_UNTHROW: "احذف من السلة",
    ACTION_CLEAR: "واضح",
    ACTION_COPY: "انسخ",
    ACTION_EXPORT: "صّدر",
    ACTION_IMPORT: "استيراد",
    MESSAGE_COPIED: "نُسخ للحافظة",
    MESSAGE_CLEARED: "تم مسح سلة المهملات بنجاح!",
    MESSAGE_SONG_ADDED: "تزادات الأغنية للسلة دلخردة",
    MESSAGE_SONG_REMOVED: "تتمسح الأغنية من السلة",
    MESSAGE_ARTIST_ADDED: "الفنان تزاد للسلة ديال اللخرق",
    MESSAGE_ARTIST_REMOVED: "الفنان تتمسح من السلة",
    BACKUP_SAVE_SUCCESS: "النّسخ الاحتياطي تمّ حفظه بنجاح.",
    BACKUP_SAVE_FAILED: "ما تقدرتش تحفض النسخة الاحتياطية، جرب تنجمو محتوى سلة المهملات للحافظة وتحدد نسخة احتياطية يدويًا.",
    BACKUP_RESTORE_SUCCESS: "تم استرجاع النسخة الاحتياطية بنجاح.",
    BACKUP_FILE_READ_FAILED: "ما تقدرتش تقرأ الملف، تأكد منين أنو ملف JSON سليم.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "الإعدادات+سلة المهملات",
    SETTINGS_OPTIONS: "خيارات",
    SETTINGS_FEATURES: "مميزات",
    SETTINGS_LOCAL_STORAGE: "التخزين المحلي",
    SETTINGS_ENABLED: "مُفعّل",
    SETTINGS_SHOW_WIDGET: "عرض أيقونة الودجيت",
    SETTINGS_AUTOPLAY: "التشغيل التلقائي فاش تبدا",
    SETTINGS_QUEUE_TRASHBIN: "دوز على سلة المحذوفات للطابور",
    SETTINGS_TRACKLIST_TRASHBIN: "دوز على سلة مهملات اللائحة",
    SETTINGS_PLAYLIST_MONITOR: "مراقب اللائحة",
    ITEMS_TITLE: "عناصر سلة المهملات+",
    ITEMS_EMPTY_SONGS: "<strong>ماشي دواير الأغاني!</strong><br/>الآغاني اللي بغيتي تزيدها فسلة المهملات غادي تظهر هنا.",
    ITEMS_EMPTY_ARTISTS: "<strong>ماشي فنانين في السلة!</strong><br/>الفنانين اللي تزيدهم في السلة غادي يظهرو هنا.",
    ITEMS_TAB_SONGS: "أغاني",
    ITEMS_TAB_ARTISTS: "فنانين",
    ITEMS_LOADED_COUNT: "{{loaded}} من أصل {{total}} {{type}} تحمّلوا",
    DESCRIPTION_COPY: "انسخ جميع العناصر اللي فالسلة للحافظة.",
    DESCRIPTION_EXPORT: "خزن جميع العناصر اللي فالسلة فملف .json.",
    DESCRIPTION_IMPORT: "اكتب فوق جميع العناصر في سلة المهملات عبر ملف .json.",
    DESCRIPTION_CLEAR: "امسح جميع العناصر من سلة المهملات (ما يقدرش يرجع للورا).",
    ITEMS_EMPTY_SONGS_TITLE: "ماشي البلايص المزروبة!",
    ITEMS_EMPTY_ARTISTS_TITLE: "والا فنانين متدهاسين!",
    DESCRIPTION_SETTINGS_ENABLED: "مفتاح رئيسي للتفعيل أو التعطيل جميع وظائف سلة المهملات+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "عرض أيقونة السلة في شريط التشغيل بجانب التسجيل اللي كيتم تشغيله باش يسهل الوصول ليها",
    DESCRIPTION_SETTINGS_AUTOPLAY: "ابدأ بتشغيل الموسيقى أوتوماتيكيًا وقت ما يفتح فيه سبوتيفاي ولا ما يحمل فيه الامتداد",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "ضيف أيقونات الزبالة بجانب كل أغنية في قائمة الانتظار الخاصة بيك باش تديرو تدبير ساهل",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "زيد أيقونات الزبالة بجانب الأغاني في عروض الألبومات والقوائم باش تتم إزالتها بسرعة",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "استرجاع تلقائي من أعطال التشغيل في سبوتيفاي بمواصلة آخر لائحة تشغيل لك",
    SETTINGS_SKIP_TRASHED_TRACKS: "تخطى المسارات التالفة",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "تخطي تلقائي للاغاني الممسوحة وباحث تلقائي على اغنية الموافقة الجاية فاش تدوز",
    SETTINGS_AUTO_CLEAN_QUEUE: "طابور التنظيف التلقائي",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "احذف تلقائيا الأغاني الممحية من قائمة التشغيل العشوائية الذكية ديالك",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "الزبالة على الزر الساخن الجاي",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "احذف تلقائياً الأغنية الحالية باش تستخدم اختصار لوحة المفاتيح كنترول+ليمين باش تتخطى للمسار الجاي",
    SETTINGS_REMOTE_CONTROL: "الريموت كونترول",
    SETTINGS_REMOTE_TOGGLE: "شغّل التبديل عن بعد",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "اضغط مرتين على تشغيل/إيقاف من الجوال باش تبدّل تخطي التّحكم عن بعد على/إيقاف. تخطي التّسجيل تأكيد للتبديل.",
    SETTINGS_REMOTE_SKIPPING: "التنقل البعيد شغال",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "ويمكنش تخطي التّفريغ حتى لو كنتي تدير سبوتيفاي من جهاز آخر (مثلا من التيليفون)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "تمكين التخطي عن بعد",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "تم تعطيل التخطي عن بعد",
    MESSAGE_SONG_ADDED_REMOTE: "تَدَمَّر البلاصة بِالرِّيموت",
    SETTINGS_TRASH_VIA_LIKE: "النفايات عبر الاعجاب",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "بلاصة تغنية من الموبايل للسلة. يمسح الإعجاب تلقائياً ويتقدم للشيكة الجاية.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ar-SA.json
var require_ar_SA = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "سلة المهملات+",
    ACTION_THROW: "ضع في سلة المهملات",
    ACTION_UNTHROW: "أزل من سلة المهملات",
    ACTION_CLEAR: "واضح",
    ACTION_COPY: "نسخ",
    ACTION_EXPORT: "تصدير",
    ACTION_IMPORT: "استيراد",
    MESSAGE_COPIED: "تم النسخ إلى الحافظة",
    MESSAGE_CLEARED: "تم مسح سلة المهملات بنجاح!",
    MESSAGE_SONG_ADDED: "أُضيفت الأغنية إلى سلة المهملات",
    MESSAGE_SONG_REMOVED: "أُزيلت الأغنية من سلة المهملات",
    MESSAGE_ARTIST_ADDED: "تمت إضافة الفنان إلى سلة المهملات",
    MESSAGE_ARTIST_REMOVED: "تمت إزالة الفنان من سلة المهملات",
    BACKUP_SAVE_SUCCESS: "تم حفظ النسخة الاحتياطية بنجاح.",
    BACKUP_SAVE_FAILED: "فشل في حفظ النسخة الاحتياطية، جرّب نسخ محتويات سلة المهملات إلى الحافظة وإنشاء نسخة احتياطية يدويًا.",
    BACKUP_RESTORE_SUCCESS: "تم استعادة النسخة الاحتياطية بنجاح.",
    BACKUP_FILE_READ_FAILED: "فشل قراءة الملف، يرجى التأكد من أنه ملف JSON صالح.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "إعدادات سلة المهملات+",
    SETTINGS_OPTIONS: "خيارات",
    SETTINGS_FEATURES: "الميزات",
    SETTINGS_LOCAL_STORAGE: "التخزين المحلي",
    SETTINGS_ENABLED: "مُمَكَّن",
    SETTINGS_SHOW_WIDGET: "إظهار أيقونة الأداة",
    SETTINGS_AUTOPLAY: "التشغيل التلقائي عند البدء",
    SETTINGS_QUEUE_TRASHBIN: "تمكين سلة مهملات الطابور",
    SETTINGS_TRACKLIST_TRASHBIN: "تمكين سلة مهملات قائمة المسارات",
    SETTINGS_PLAYLIST_MONITOR: "مُراقبة قائمة التشغيل",
    ITEMS_TITLE: "عناصر سلة المهملات+",
    ITEMS_EMPTY_SONGS: "<strong>لا توجد أغانٍ في سلة المهملات!</strong><br/>ستظهر الأغانـي التي تضيفها إلى سلة المهملات هنا.",
    ITEMS_EMPTY_ARTISTS: "<strong>ما فيش فنانين في المهملات!</strong><br/>الفنانين اللي تضيفهم إلى سلة المهملات سيظهرون هنا.",
    ITEMS_TAB_SONGS: "أغاني",
    ITEMS_TAB_ARTISTS: "الفنانين",
    ITEMS_LOADED_COUNT: "تم تحميل {{loaded}} من أصل {{total}} {{type}}",
    DESCRIPTION_COPY: "انسخ جميع العناصر في سلة المهملات إلى الحافظة.",
    DESCRIPTION_EXPORT: "احفظ جميع العناصر في سلة المهملات في ملف .json.",
    DESCRIPTION_IMPORT: "استبدال جميع العناصر في سلة المهملات عبر ملف .json.",
    DESCRIPTION_CLEAR: "امسح جميع العناصر من سلة المهملات (لا يمكن التراجع عن هذا الإجراء).",
    ITEMS_EMPTY_SONGS_TITLE: "ما فيش أغانٍ مهملة!",
    ITEMS_EMPTY_ARTISTS_TITLE: "لا فنانين مرفوضين!",
    DESCRIPTION_SETTINGS_ENABLED: "مفتاح رئيسي لتفعيل أو تعطيل جميع وظائف سلة المهملات+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "عرض أيقونة سلة المهملات في شريط التشغيل بجانب المسار الذي يتم تشغيله حاليًا للوصول السريع",
    DESCRIPTION_SETTINGS_AUTOPLAY: "ابدأ تشغيل الموسيقى تلقائيًا عند فتح Spotify أو تحميل الإضافة",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "أضف أيقونات سلة المهملات بجانب كل أغنية في قائمة الانتظار الخاصة بك لإدارتها بسهولة",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "أضف أيقونات سلة المهملات بجانب الأغاني في عروض الألبومات وقوائم التشغيل لتصفية سريعة",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "استعادة تلقائية من أعطال تشغيل Spotify باستئناف قائمة التشغيل الأخيرة الخاصة بك",
    SETTINGS_SKIP_TRASHED_TRACKS: "تخطي المسارات المحذوفة",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "تخطي الأغاني المحذوفة تلقائيًا وإيجاد المسار المسموح به التالي أثناء التشغيل",
    SETTINGS_AUTO_CLEAN_QUEUE: "طابور التنظيف التلقائي",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "أزل تلقائيًا الأغاني المحذوفة من قائمة التشغيل العشوائية الذكية الخاصة بك",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "النفايات على مفتاح التشغيل التالي",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "حذف الأغنية الحالية تلقائيًا عند استخدام اختصار لوحة المفاتيح Ctrl+اليمين للانتقال إلى المسار التالي",
    SETTINGS_REMOTE_CONTROL: "جهاز التحكم عن بعد",
    SETTINGS_REMOTE_TOGGLE: "تمكين التبديل عن بعد",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "اضغط مرتين على تشغيل/إيقاف من الهاتف لتغيير تخطي التحكم عن بعد تشغيل/إيقاف. يؤكد تخطي المسار التبديل.",
    SETTINGS_REMOTE_SKIPPING: "التخطي عن بعد مفعل",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "عند التمكين، يعمل تخطي المهملات حتى عند التحكم في Spotify من جهاز آخر (مثلاً الهاتف)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "تم تمكين التخطي عن بعد",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "تم تعطيل التخطي عن بعد",
    MESSAGE_SONG_ADDED_REMOTE: "تم حذف الأغنية عن بعد",
    SETTINGS_TRASH_VIA_LIKE: "نفايات عبر لايك",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "مثل أغنية من الهاتف إلى سلة المهملات. يتم إزالة الإعجاب تلقائيًا والانتقال تلقائيًا إلى المسار التالي.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ar.json
var require_ar = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "سلة المهملات+",
    ACTION_THROW: "ضع في سلة المهملات",
    ACTION_UNTHROW: "إزالة من سلة المهملات",
    ACTION_CLEAR: "واضح",
    ACTION_COPY: "نسخ",
    ACTION_EXPORT: "تصدير",
    ACTION_IMPORT: "استيراد",
    MESSAGE_COPIED: "تم النسخ إلى الحافظة",
    MESSAGE_CLEARED: "تم مسح سلة المهملات بنجاح!",
    MESSAGE_SONG_ADDED: "أُضيفت الأغنية إلى سلة المهملات",
    MESSAGE_SONG_REMOVED: "تمت إزالة الأغنية من سلة المهملات",
    MESSAGE_ARTIST_ADDED: "تمت إضافة الفنان إلى سلة المهملات",
    MESSAGE_ARTIST_REMOVED: "تمت إزالة الفنان من سلة المهملات",
    BACKUP_SAVE_SUCCESS: "تم حفظ النسخة الاحتياطية بنجاح.",
    BACKUP_SAVE_FAILED: "فشل حفظ النسخة الاحتياطية، حاول نسخ محتويات سلة المهملات إلى الحافظة وإنشاء نسخة احتياطية يدويًا.",
    BACKUP_RESTORE_SUCCESS: "تم استعادة النسخة الاحتياطية بنجاح.",
    BACKUP_FILE_READ_FAILED: "فشل في قراءة الملف، يرجى التأكد من أنه ملف JSON صالح.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "إعدادات سلة المهملات+",
    SETTINGS_OPTIONS: "خيارات",
    SETTINGS_FEATURES: "الميزات",
    SETTINGS_LOCAL_STORAGE: "التخزين المحلي",
    SETTINGS_ENABLED: "مُمكَّن",
    SETTINGS_SHOW_WIDGET: "عرض أيقونة الأداة",
    SETTINGS_AUTOPLAY: "تشغيل تلقائي عند البدء",
    SETTINGS_QUEUE_TRASHBIN: "تمكين سلة مهملات الطابور",
    SETTINGS_TRACKLIST_TRASHBIN: "تمكين سلة مهملات قائمة المسارات",
    SETTINGS_PLAYLIST_MONITOR: "مُراقب القوائم التشغيلية",
    ITEMS_TITLE: "عناصر سلة المهملات+",
    ITEMS_EMPTY_SONGS: "<strong>لا توجد أغانٍ في سلة المهملات!</strong><br/>ستظهر الأغانـي التي تضيفها إلى سلة المهملات هنا.",
    ITEMS_EMPTY_ARTISTS: "<strong>لا يوجد فنانين في سلة المهملات!</strong><br/>سيظهر الفنانون الذين تضيفهم إلى سلة المهملات هنا.",
    ITEMS_TAB_SONGS: "أغاني",
    ITEMS_TAB_ARTISTS: "الفنانون",
    ITEMS_LOADED_COUNT: "تم تحميل {{loaded}} من أصل {{total}} {{type}}",
    DESCRIPTION_COPY: "نسخ جميع العناصر في سلة المهملات إلى الحافظة.",
    DESCRIPTION_EXPORT: "احفظ جميع العناصر في سلة المهملات في ملف .json.",
    DESCRIPTION_IMPORT: "استبدال جميع العناصر في سلة المهملات عبر ملف .json",
    DESCRIPTION_CLEAR: "مسح جميع العناصر من سلة المهملات (لا يمكن التراجع عن هذا الإجراء).",
    ITEMS_EMPTY_SONGS_TITLE: "لا توجد أغانٍ محذوفة!",
    ITEMS_EMPTY_ARTISTS_TITLE: "لا فنانين مهملين!",
    DESCRIPTION_SETTINGS_ENABLED: "مفتاح رئيسي لتمكين أو تعطيل جميع وظائف سلة المهملات+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "عرض أيقونة سلة المهملات في شريط التشغيل بجانب المسار الذي يتم تشغيله حاليًا للوصول السريع",
    DESCRIPTION_SETTINGS_AUTOPLAY: "تشغيل الموسيقى تلقائيًا عند فتح Spotify أو تحميل الإضافة",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "أضف أيقونات سلة المهملات بجانب كل أغنية في قائمة الانتظار الخاصة بك لإدارتها بسهولة",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "إضافة أيقونات سلة المهملات بجانب الأغاني في عروض الألبومات وقوائم التشغيل لتصفية سريعة",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "استعادة التشغيل تلقائيًا بعد حدوث أخطار في تشغيل Spotify باستئناف قائمتك الأخيرة",
    SETTINGS_SKIP_TRASHED_TRACKS: "تخطي المسارات المحذوفة",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "تخطي الأغاني المحذوفة تلقائيًا والبحث عن المسار المسموح به التالي أثناء التشغيل",
    SETTINGS_AUTO_CLEAN_QUEUE: "قائمة التنظيف التلقائي",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "قم تلقائيًا بإزالة الأغاني المحذوفة من قائمة التشغيل العشوائية الذكية الخاصة بك",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "النفايات على المفتاح الساخن التالي",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "حذف الأغنية الحالية تلقائيًا عند استخدام اختصار لوحة المفاتيح Ctrl+يمين للانتقال إلى المسار التالي",
    SETTINGS_REMOTE_CONTROL: "جهاز التحكم عن بعد",
    SETTINGS_REMOTE_TOGGLE: "تمكين التبديل عن بُعد",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "انقر مرتين على تشغيل/إيقاف من الهاتف لتغيير تخطي التحكم عن بُعد تشغيل/إيقاف. يؤكد تخطي المسار هذا التبديل.",
    SETTINGS_REMOTE_SKIPPING: "التجازؤ عن بعد نشط",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "عند التمكين، يعمل تخطي سلة المهملات حتى عند التحكم في Spotify من جهاز آخر (مثل الهاتف المحمول)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "تم تمكين التخطي عن بُعد",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "تم تعطيل التخطي عن بُعد",
    MESSAGE_SONG_ADDED_REMOTE: "تم حذف الأغنية عن بُعد",
    SETTINGS_TRASH_VIA_LIKE: "نفايات عبر الإعجاب",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "مثل أغنية من الهاتف إلى سلة المهملات. يتم إلغاء الإعجاب تلقائيًا والانتقال تلقائيًا إلى المسار التالي.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/az.json
var require_az = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Tullantı qutusu+",
    ACTION_THROW: "Tullantı qutusuna yerləşdirin",
    ACTION_UNTHROW: "Səbətdən silin",
    ACTION_CLEAR: "Açıq",
    ACTION_COPY: "Kopyalamaq",
    ACTION_EXPORT: "İxracat",
    ACTION_IMPORT: "İdxal",
    MESSAGE_COPIED: "Mübadilə buferinə köçürülüb",
    MESSAGE_CLEARED: "Zibilqutusu uğurla təmizləndi!",
    MESSAGE_SONG_ADDED: "Mahnı səbətə əlavə edildi",
    MESSAGE_SONG_REMOVED: "Mahnı səbətdən silindi",
    MESSAGE_ARTIST_ADDED: "Sənətçi tullantı qutusuna əlavə edildi",
    MESSAGE_ARTIST_REMOVED: "Sənətkar tullantı qutusundan silindi",
    BACKUP_SAVE_SUCCESS: "Ehtiyyat nüsxə uğurla saxlanıldı.",
    BACKUP_SAVE_FAILED: "Arxiv yadda saxlanılmadı, zibil qutusunun məzmununu mübadilə buferinə kopyalamağa və əl ilə arxiv yaratmağa cəhd edin.",
    BACKUP_RESTORE_SUCCESS: "Ehtiyyat nüsxə uğurla bərpa edildi.",
    BACKUP_FILE_READ_FAILED: "Fayl oxuna bilmədi, lütfən, onun düzgün JSON fayl olduğuna əmin olun.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Səbət+ Parametrləri",
    SETTINGS_OPTIONS: "Seçimlər",
    SETTINGS_FEATURES: "Xüsusiyyətlər",
    SETTINGS_LOCAL_STORAGE: "Yerli Yaddaş",
    SETTINGS_ENABLED: "Aktivləşdirildi",
    SETTINGS_SHOW_WIDGET: "Vidjet İkonunu Göstər",
    SETTINGS_AUTOPLAY: "Başlanğıcda avtomatik oynatma",
    SETTINGS_QUEUE_TRASHBIN: "Növbəni təmizləmə qutusunu aktivləşdirin",
    SETTINGS_TRACKLIST_TRASHBIN: "Treklər siyahısının səbətini aktivləşdirin",
    SETTINGS_PLAYLIST_MONITOR: "Playlist Monitoru",
    ITEMS_TITLE: "Zibildan + Məhsullar",
    ITEMS_EMPTY_SONGS: "<strong>Çöpə atılmış mahnılar yoxdur!</strong><br/>Səbətə əlavə etdiyiniz mahnılar burada görünəcək.",
    ITEMS_EMPTY_ARTISTS: "<strong>Çöp edilmiş ifaçılar yoxdur!</strong><br/>Siz çöp qutusuna əlavə etdiyiniz ifaçılar burada görünəcək.",
    ITEMS_TAB_SONGS: "Mahnılar",
    ITEMS_TAB_ARTISTS: "Sənətçilər",
    ITEMS_LOADED_COUNT: "Yüklenilib: {{loaded}}/{{total}} {{type}}",
    DESCRIPTION_COPY: "Səbətdəki bütün elementləri mübadilə buferinə kopyalayın.",
    DESCRIPTION_EXPORT: "Səbətdəki bütün elementləri .json faylına yadda saxlayın.",
    DESCRIPTION_IMPORT: "Zibilqutusundakı bütün elementləri .json faylı ilə əvəz edin.",
    DESCRIPTION_CLEAR: "Səbətdəki bütün elementləri silin (geri qaytarıla bilməz).",
    ITEMS_EMPTY_SONGS_TITLE: "Heç bir səslənmiş mahnı yoxdur!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Heç bir sənətçi təhqir olunmasın!",
    DESCRIPTION_SETTINGS_ENABLED: "Bütün Zibilqutusu+ funksiyalarını aktivləşdirmək və ya deaktivləşdirmək üçün əsas keçid",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Hazırda səsləndirilən mahnının yanında tez giriş üçün səs yazısı çubuğunda səbət ikonu göstərin",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Spotify aça və ya uzantı yüklənəndə avtomatik olaraq musiqi oxumağa başlayın",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Növbəti sırada olan hər mahnının yanına ləğv etmə ikonu əlavə edin ki, idarə etmək asan olsun",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Albom və çalma siyahısı görünüşlərində mahnıların yanında tez filtrasiya üçün səbət ikonları əlavə edin",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Son oynatma siyahısını davam etdirərək Spotify oynatma xətalarından avtomatik şəkildə bərpa edin",
    SETTINGS_SKIP_TRASHED_TRACKS: "Zibil Melodiyalardan Keç",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Səsləndirmə zamanı səbətdəki mahnıları avtomatik olaraq keçin və növbəti icazə verilən mahnını tapın",
    SETTINGS_AUTO_CLEAN_QUEUE: "Avtomatik Təmizləmə Növbəsi",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Ağıllı qarışıq növbənizdən avtomatik olaraq səsləri silin",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Növbəti qısayol düyməsində tullantılar",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Növbəti mahnıya keçmək üçün Ctrl+Sağ düyməsini istifadə etdikdə cari mahnını avtomatik olaraq səbətə at",
    SETTINGS_REMOTE_CONTROL: "Uzaqdan idarəetmə",
    SETTINGS_REMOTE_TOGGLE: "Uzaqdan Keçid Rejimini Aktivləşdirin",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Obyektin keçidini açmaq/deaktiv etmək üçün mobil cihazda oxutma/fasiləni iki dəfə basın. Mahnı keçidini təsdiqləmək üçün keçid.",
    SETTINGS_REMOTE_SKIPPING: "Uzaqdan Keçid Aktivdir",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Aktiv edildikdə, Spotify-ı digər cihazdan (məsələn, mobil) idarə edərkən belə səbətdən keçmə işləyir",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Uzaqdan keçid etmə aktivdir",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Uzaqdan keçid etmək deaktiv edildi",
    MESSAGE_SONG_ADDED_REMOTE: "Mahnı uzaqdan məhv edildi",
    SETTINGS_TRASH_VIA_LIKE: "Like vasitəsilə tullantılar",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Mobil telefonun çöp qutusuna mahnı kimi. Avtomatik olaraq bəyənməni ləğv edir və növbəti mahnıya keçir.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/bg.json
var require_bg = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Кошче+",
    ACTION_THROW: "Поставете в кошчето за боклук",
    ACTION_UNTHROW: "Премахни от кошчето",
    ACTION_CLEAR: "Ясно",
    ACTION_COPY: "Копиране",
    ACTION_EXPORT: "Експорт",
    ACTION_IMPORT: "Внос",
    MESSAGE_COPIED: "Копирано в клипборда",
    MESSAGE_CLEARED: "Кошът беше изпразнен успешно!",
    MESSAGE_SONG_ADDED: "Песента е добавена в кошчето",
    MESSAGE_SONG_REMOVED: "Песента е премахната от кошчето",
    MESSAGE_ARTIST_ADDED: "Художникът е добавен в кошчето за боклук",
    MESSAGE_ARTIST_REMOVED: "Художникът е премахнат от кошчето за боклук",
    BACKUP_SAVE_SUCCESS: "Резервното копие е запазено успешно.",
    BACKUP_SAVE_FAILED: "Неуспешно запазване на резервно копие, опитайте да копирате съдържанието на кошчето в клипборда и създайте резервно копие ръчно.",
    BACKUP_RESTORE_SUCCESS: "Резервното копие бе възстановено успешно.",
    BACKUP_FILE_READ_FAILED: "Неуспешно прочитане на файла, моля, уверете се, че е валиден JSON файл.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Настройки на кошчето+",
    SETTINGS_OPTIONS: "Опции",
    SETTINGS_FEATURES: "Характеристики",
    SETTINGS_LOCAL_STORAGE: "Локално съхранение",
    SETTINGS_ENABLED: "Активирано",
    SETTINGS_SHOW_WIDGET: "Показване на иконата за джаджа",
    SETTINGS_AUTOPLAY: "Автоматично възпроизвеждане при стартиране",
    SETTINGS_QUEUE_TRASHBIN: "Активиране на кош за опашка",
    SETTINGS_TRACKLIST_TRASHBIN: "Активиране на кошчето за списъка с песни",
    SETTINGS_PLAYLIST_MONITOR: "Плейлист Монитор",
    ITEMS_TITLE: "Елементи в кошчето+",
    ITEMS_EMPTY_SONGS: "<strong>Няма изтрити песни!</strong><br/>Песните, които добавите в кошчето, ще се появят тук.",
    ITEMS_EMPTY_ARTISTS: "<strong>Няма изтрити изпълнители!</strong><br/>Изпълнителите, които добавите в кошчето, ще се появят тук.",
    ITEMS_TAB_SONGS: "Песни",
    ITEMS_TAB_ARTISTS: "Художници",
    ITEMS_LOADED_COUNT: "{{loaded}} от {{total}} {{type}} заредени",
    DESCRIPTION_COPY: "Копиране на всички елементи в кошчето в клипборда.",
    DESCRIPTION_EXPORT: "Запазване на всички елементи в кошчето в .json файл.",
    DESCRIPTION_IMPORT: "Презаписване на всички елементи в кошчето чрез .json файл.",
    DESCRIPTION_CLEAR: "Изчистване на всички елементи от кошчето (не може да бъде възстановено).",
    ITEMS_EMPTY_SONGS_TITLE: "Няма изтрити песни!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Никакви захвърлени артисти!",
    DESCRIPTION_SETTINGS_ENABLED: "Главен превключвател за активиране или деактивиране на цялата функционалност на кошчето+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Показване на икона за кош в лентата за възпроизвеждане до текущо възпроизвеждания трек за бърз достъп",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Автоматично стартиране на музиката при отваряне на Spotify или зареждане на разширението",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Добавете икони за кошче до всяка песен в предстоящата си опашка за лесно управление",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Добавяне на икони за кошче до песните в албумите и плейлистите за бързо филтриране",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Автоматично възстановяване от проблеми с възпроизвеждането в Spotify чрез продължаване на последния ви плейлист",
    SETTINGS_SKIP_TRASHED_TRACKS: "Пропусни изтритите песни",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Автоматично пропускане на изтритите песни и намиране на следващата разрешена песен по време на възпроизвеждане",
    SETTINGS_AUTO_CLEAN_QUEUE: "Автоматично почистване на опашката",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Автоматично премахване на изтритите песни от опашката за смарт разбъркване",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Свалете със следващия бутон за бърз достъп",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Автоматично премахване на текущата песен при използване на клавишната комбинация Ctrl+дясно, за да се премине към следващата песен",
    SETTINGS_REMOTE_CONTROL: "Дистанционно управление",
    SETTINGS_REMOTE_TOGGLE: "Активиране на дистанционно превключване",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Докоснете два пъти бутона за възпроизвеждане/пауза от мобилното устройство, за да включите/изключите пропускането на песни на дистанция. Пропускането на песен потвърждава превключването.",
    SETTINGS_REMOTE_SKIPPING: "Дистанционно пропускане активно",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Когато е активирана, функцията за пропускане на кошчето работи дори когато управлявате Spotify от друго устройство (например мобилен телефон)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Активирано е дистанционно пропускане",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Дистанционното пропускане е деактивирано",
    MESSAGE_SONG_ADDED_REMOTE: "Песента е унищожена от разстояние",
    SETTINGS_TRASH_VIA_LIKE: "Смет за лайк",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Като песен от мобилно към кошчето. Автоматично премахва харесването и превърта към следващата песен.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/bho.json
var require_bho = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "कूड़ादान+",
    ACTION_THROW: "ट्रैशबिन में राखू",
    ACTION_UNTHROW: "ट्रैशबिन लेले हटा दें",
    ACTION_CLEAR: "साफ़",
    ACTION_COPY: "कॉपी",
    ACTION_EXPORT: "निर्यात",
    ACTION_IMPORT: "आयात",
    MESSAGE_COPIED: "क्लिपबोर्ड में कॉपी करलय गेल",
    MESSAGE_CLEARED: "कचरा बाल्टी सफलतापूर्वक साफ कएल गेल!",
    MESSAGE_SONG_ADDED: "गाना कें रद्दी के टोकरी में जोड़ल गेल",
    MESSAGE_SONG_REMOVED: "गाना रद्दी के टोकरी से हटा देल गेल छल",
    MESSAGE_ARTIST_ADDED: "कलाकार कें रद्दी डिब्बा में जोड़ल गेलय",
    MESSAGE_ARTIST_REMOVED: "कलाकार कें रद्दी डिब्बा लेले हटा देल गेलय हईय",
    BACKUP_SAVE_SUCCESS: "बैकअप सफलतापूर्वक सुरक्षित कएल गेलए।",
    BACKUP_SAVE_FAILED: "बैकअप सुरक्षित करे में असफल, ट्रैशबिन कें सामग्री कें क्लिपबोर्ड पर कॉपी करे आऊर मैन्युअल रूप सँ बैकअप बनाए कें कोशिश करूं।",
    BACKUP_RESTORE_SUCCESS: "बैकअप सफलतापूर्वक बहाल कएल गेल।",
    BACKUP_FILE_READ_FAILED: "फाइल पढ़े में असफल, कृपया सुनिश्चित करीं कि इ एगो मान्य JSON फाइल हई।",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ट्रैशबिन + सेटिंग्स",
    SETTINGS_OPTIONS: "विकल्प",
    SETTINGS_FEATURES: "विशेषताएं",
    SETTINGS_LOCAL_STORAGE: "स्थानीय भंडारण",
    SETTINGS_ENABLED: "सक्षम",
    SETTINGS_SHOW_WIDGET: "विजेट आइकन देखाएं",
    SETTINGS_AUTOPLAY: "शुरू में ऑटोप्ले",
    SETTINGS_QUEUE_TRASHBIN: "कतार ट्रेशबिन सक्षम करूं",
    SETTINGS_TRACKLIST_TRASHBIN: "ट्रैकलिस्ट ट्रैशबिन सक्षम करूं",
    SETTINGS_PLAYLIST_MONITOR: "प्लेलिस्ट मॉनिटर",
    ITEMS_TITLE: "ट्रैशबिन+ आइटम",
    ITEMS_EMPTY_SONGS: "<strong>कोनो गाना कें फेंकल नीं!</strong><br/>गाना जे अहां रद्दी डिब्बा में डालैत हईं इ लेल देखाई देत हईं।",
    ITEMS_EMPTY_ARTISTS: "<strong>कोनो कलाकार कें फेंकल नीं!</strong><br/>कलाकार जेकर अउ अपन रद्दी डिब्बा में जोड़त हईं इ लेल देखाई देत हईं।",
    ITEMS_TAB_SONGS: "गाना",
    ITEMS_TAB_ARTISTS: "कलाकार",
    ITEMS_LOADED_COUNT: "{{total}} में से {{loaded}} {{type}} लोड कएल गेल",
    DESCRIPTION_COPY: "ट्रैशबिन में सभी आइटम कें क्लिपबोर्ड पर कॉपी करूं।",
    DESCRIPTION_EXPORT: "ट्रैशबिन में सभी आइटम कें .json फाइल में सहेजल जाय।",
    DESCRIPTION_IMPORT: "ट्रैशबिन कें सभी आइटम कें .json फाइल कें माध्यम सँ ओवरराइट करूं।",
    DESCRIPTION_CLEAR: "कचरा बाल्टी से सभ पदार्थ निकाल दें (पलट नहीं सकैत छलई)।",
    ITEMS_EMPTY_SONGS_TITLE: "कोनो फेंकल गेल गाना नईं!",
    ITEMS_EMPTY_ARTISTS_TITLE: "कोनो निकृष्ट कलाकार नहि!",
    DESCRIPTION_SETTINGS_ENABLED: "सभ ट्रैशबिन+ कार्यक्षमता कें सक्षम या अक्षम करय कें मास्टर टॉगल",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "चलत ट्रैक कें बगल में प्लेबैक बार में त्वरित पहुंच कें लेल एक ट्रैश आइकन देखावल जाए",
    DESCRIPTION_SETTINGS_AUTOPLAY: "जब स्पॉटिफाई खुले या एक्सटेंशन लोड होए त' स्वचालित रूप सँ संगीत बजाए में शुरू करूं",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "अपन आगामी कतार में हर गीत कें बगल में कचरा आइकन जोड़ें आसान प्रबंधन कें लेल",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "एल्बम आ चलत लिस्ट देखलाइ में गाना कें बगल में कचरा आइकन जोड़ें ताकि त्वरित फ़िल्टरिंग हो सके",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "अपन पिछला प्लेलिस्ट कें फिर से शुरू कर के स्पॉटिफाई प्लेबैक गड़बड़ी से अपन आप ठीक हो जाएं",
    SETTINGS_SKIP_TRASHED_TRACKS: "हटाएल गेल ट्रैक्स छोड़ें",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "स्वचालित रूप से खराब गानान कें छोड़िया आऊर प्लेबैक के दौरान अगला अनुमति ट्रैक ढूंढिया",
    SETTINGS_AUTO_CLEAN_QUEUE: "ऑटो क्लीन कतार",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "अपन Smart Shuffle कतार में से अपनेआप फेंकल गेल गाना कें हटा दें",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "अगला हॉटकी पर ट्रैश",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "अगला ट्रैक पर जाने लेल Ctrl+Right कीबोर्ड शॉर्टकट के उपयोग करते समय स्वचालित रूप सँ वर्तमान गाना कें ट्रैश करें",
    SETTINGS_REMOTE_CONTROL: "रिमोट कंट्रोल",
    SETTINGS_REMOTE_TOGGLE: "दूरस्थ टॉगल सक्षम करें",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "मोबाइल से रिमोट स्किपिंग चालू/बंद करे कें लेल डबल-टैप प्ले/विराम दें। एगो ट्रैक स्किप टॉगल कें पुष्टि करत हई।",
    SETTINGS_REMOTE_SKIPPING: "दूरस्थ छोड़ना सक्रिय",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "जब सक्षम कएल जाईत छल, तब अन्य डिवाइस (उदाहरण के तौर पर, मोबाइल) से स्पॉटिफाई कें नियंत्रित करै कें बाद में भी ट्रैश-छलांग काम करईत छलि",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "दूरस्थ छलांग लगाबैय सक्षम छलई",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "दूरस्थ छलांग अक्षम कएल गेलए हई",
    MESSAGE_SONG_ADDED_REMOTE: "गाना रिमोट कें द्वारा नष्ट कएल गेल",
    SETTINGS_TRASH_VIA_LIKE: "लाइक कें माध्यम से कचरा",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "मोबाइल से ट्रैश कें लेल गाना कें अनलाइक करि दें। स्वचालित रूप सँ अनलाइक करि दें आ अगला ट्रैक पर स्किप करि दें।",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/bn.json
var require_bn = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "আবর্জনার বাক্স+",
    ACTION_THROW: "আবর্জনা বাক্সে রাখুন",
    ACTION_UNTHROW: "ট্রাশবিন থেকে সরান",
    ACTION_CLEAR: "স্পষ্ট",
    ACTION_COPY: "কপি",
    ACTION_EXPORT: "রপ্তানি",
    ACTION_IMPORT: "আমদানি করুন",
    MESSAGE_COPIED: "ক্লিপবোর্ডে কপি করা হয়েছে",
    MESSAGE_CLEARED: "ট্র্যাশবিন সফলভাবে খালি করা হয়েছে!",
    MESSAGE_SONG_ADDED: "গানটি আবর্জনাদণ্ডে যোগ করা হয়েছে",
    MESSAGE_SONG_REMOVED: "আবর্জনার ঝুড়ি থেকে গানটি সরানো হয়েছে",
    MESSAGE_ARTIST_ADDED: "শিল্পীকে আবর্জনাদণ্ডে যোগ করা হয়েছে",
    MESSAGE_ARTIST_REMOVED: "শিল্পীকে আবর্জনা বাক্স থেকে সরানো হয়েছে",
    BACKUP_SAVE_SUCCESS: "ব্যাকআপ সফলভাবে সংরক্ষিত হয়েছে।",
    BACKUP_SAVE_FAILED: "ব্যাকআপ সংরক্ষণ করতে ব্যর্থ হয়েছে, ট্র্যাশবিনের সামগ্রী ক্লিপবোর্ডে কপি করে ম্যানুয়ালি একটি ব্যাকআপ তৈরি করার চেষ্টা করুন।",
    BACKUP_RESTORE_SUCCESS: "ব্যাকআপ সফলভাবে পুনরুদ্ধার করা হয়েছে।",
    BACKUP_FILE_READ_FAILED: "ফাইল পড়তে ব্যর্থ হয়েছে, দয়া করে নিশ্চিত করুন যে এটি একটি বৈধ JSON ফাইল।",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ট্র্যাশবিন+ সেটিংস",
    SETTINGS_OPTIONS: "বিকল্পগুলি",
    SETTINGS_FEATURES: "বৈশিষ্ট্যগুলি",
    SETTINGS_LOCAL_STORAGE: "স্থানীয় সংরক্ষণ",
    SETTINGS_ENABLED: "সক্ষম করা হয়েছে",
    SETTINGS_SHOW_WIDGET: "উইজেট আইকন দেখান",
    SETTINGS_AUTOPLAY: "শুরুতে অটোপ্লে চালু",
    SETTINGS_QUEUE_TRASHBIN: "সারি আবর্জনা বাক্স সক্ষম করুন",
    SETTINGS_TRACKLIST_TRASHBIN: "ট্র‍্যাকলিস্ট ট্র‍্যাশবিন সক্ষম করুন",
    SETTINGS_PLAYLIST_MONITOR: "প্লেলিস্ট মনিটর",
    ITEMS_TITLE: "ট্র্যাশবিন+ আইটেমগুলি",
    ITEMS_EMPTY_SONGS: "<strong>কোন মুছে ফেলা গান নেই!</strong><br/>যে সব গান আপনি আবর্জনা বাক্সে যোগ করবেন সেগুলি এখানে দেখাবে।",
    ITEMS_EMPTY_ARTISTS: "<strong>কোনও আর্টিস্ট মুছবেন না!</strong><br/>আপনি যে আর্টিস্টদের আবর্জনা বাক্সে যোগ করবেন তারা এখানে দেখা যাবে।",
    ITEMS_TAB_SONGS: "গানগুলি",
    ITEMS_TAB_ARTISTS: "শিল্পীরা",
    ITEMS_LOADED_COUNT: "{{total}} এর {{loaded}} {{type}} লোড হয়েছে",
    DESCRIPTION_COPY: "ট্র্যাশবিনের সমস্ত আইটেম ক্লিপবোর্ডে কপি করুন।",
    DESCRIPTION_EXPORT: "ট্র্যাশবিনে সমস্ত আইটেমগুলি .json ফাইলে সংরক্ষণ করুন।",
    DESCRIPTION_IMPORT: "ট্র্যাশবিনের সমস্ত আইটেম .json ফাইলের মাধ্যমে ওভাররাইট করুন।",
    DESCRIPTION_CLEAR: "ট্র্যাশবিন থেকে সমস্ত আইটেম মুছে ফেলুন (পূর্বাবস্থায় ফিরিয়ে আনা যাবে না)।",
    ITEMS_EMPTY_SONGS_TITLE: "কোনো ত্রাশ করা গান নেই!",
    ITEMS_EMPTY_ARTISTS_TITLE: "কোনো নিকৃষ্ট শিল্পী নয়!",
    DESCRIPTION_SETTINGS_ENABLED: "সমস্ত ট্র্যাশবিন+ কার্যকারিতা চালু বা বন্ধ করার জন্য মাস্টার টগল",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "বর্তমানে চলমান ট্র‍্যাকের পাশে প্লেব্যাক বারে ট্র‍্যাশ আইকন প্রদর্শন করুন দ্রুত অ্যাক্সেসের জন্য",
    DESCRIPTION_SETTINGS_AUTOPLAY: "স্পটিফাই খোলার সময় বা এক্সটেনশন লোড হওয়ার সময় স্বয়ংক্রিয়ভাবে সঙ্গীত চালু করুন",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "আপনার আসন্ন কিউতে প্রতিটি গানের পাশে ট্র্যাশ আইকন যোগ করুন সহজ ব্যবস্থাপনার জন্য",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "অ্যালবাম এবং প্লেলিস্ট ভিউতে দ্রুত ফিল্টারিংয়ের জন্য গানগুলির পাশে ট্র্যাশ আইকন যোগ করুন",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "স্পটিফাই প্লেব্যাকের ত্রুটি থেকে স্বয়ংক্রিয়ভাবে পুনরুদ্ধার করুন আপনার শেষ প্লেলিস্টটি চালু করে",
    SETTINGS_SKIP_TRASHED_TRACKS: "মুছে ফেলা ট্র‍্যাকগুলি এড়িয়ে যান",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "স্বয়ংক্রিয়ভাবে মুছে ফেলা গানগুলি এড়িয়ে চলুন এবং চলমান অবস্থায় পরবর্তী অনুমোদিত ট্র‍্যাকটি খুঁজুন",
    SETTINGS_AUTO_CLEAN_QUEUE: "অটো ক্লিন কিউ",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "আপনার স্মার্ট শাফল সারিতে থেকে আবর্জনা গানগুলি স্বয়ংক্রিয়ভাবে সরানো হবে",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "পরবর্তী হটকি-এ আবর্জনা",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "পরবর্তী ট্র‍্যাকে যাওয়ার জন্য Ctrl+Right কীবোর্ড শর্টকাট ব্যবহার করার সময় বর্তমান গানটি স্বয়ংক্রিয়ভাবে ট্র্যাশ করুন",
    SETTINGS_REMOTE_CONTROL: "দূরবর্তী নিয়ন্ত্রণ",
    SETTINGS_REMOTE_TOGGLE: "দূরবর্তী টগল সক্ষম করুন",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "মোবাইল থেকে রিমোট স্কিপিং চালু/বন্ধ করতে প্লে/বিরতি দ্বিগুণ-ট্যাপ করুন। একটি ট্র্যাক স্কিপ টগল নিশ্চিত করে।",
    SETTINGS_REMOTE_SKIPPING: "দূরবর্তী স্কিপিং সক্রিয়",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "যখন সক্ষম করা হয়, তখন অন্য ডিভাইস (যেমন, মোবাইল) থেকে স্পটিফাই নিয়ন্ত্রণ করার সময়ও ট্র্যাশ-স্কিপিং কাজ করে",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "দূরবর্তী স্কিপিং সক্ষম করা হয়েছে",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "দূরবর্তী স্কিপিং অক্ষম",
    MESSAGE_SONG_ADDED_REMOTE: "গানটি দূর থেকে নষ্ট করা হয়েছে",
    SETTINGS_TRASH_VIA_LIKE: "লাইকের মাধ্যমে আবর্জনা",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "মোবাইল থেকে ট্র্যাশে এটি পাঠানোর জন্য একটি গানের মতো। স্বয়ংক্রিয়ভাবে অপছন্দ করে এবং পরবর্তী ট্র্যাকে চলে যায়।",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/bs.json
var require_bs = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Smeće+",
    ACTION_THROW: "Stavi u kantu za đubre",
    ACTION_UNTHROW: "Ukloni iz kante za otpatke",
    ACTION_CLEAR: "Jasno",
    ACTION_COPY: "Kopiraj",
    ACTION_EXPORT: "Izvoz",
    ACTION_IMPORT: "Uvoz",
    MESSAGE_COPIED: "Kopirano u međuspremnik",
    MESSAGE_CLEARED: "Smeće je uspješno očišćeno!",
    MESSAGE_SONG_ADDED: "Pjesma dodana u kantu za otpatke",
    MESSAGE_SONG_REMOVED: "Pjesma uklonjena iz kante za otpatke",
    MESSAGE_ARTIST_ADDED: "Umjetnik dodan u kantu za otpatke",
    MESSAGE_ARTIST_REMOVED: "Umjetnik uklonjen iz kante za otpatke",
    BACKUP_SAVE_SUCCESS: "Sigurnosna kopija je uspješno sačuvana.",
    BACKUP_SAVE_FAILED: "Nije uspjelo spremanje sigurnosne kopije, pokušajte kopirati sadržaj kante za smeće u međuspremnik i ručno kreirati sigurnosnu kopiju.",
    BACKUP_RESTORE_SUCCESS: "Sigurnosna kopija je uspješno vraćena.",
    BACKUP_FILE_READ_FAILED: "Nije uspjeo pročitati datoteku, molimo provjerite da li je validna JSON datoteka.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Postavke smeća+",
    SETTINGS_OPTIONS: "Opcije",
    SETTINGS_FEATURES: "Karakteristike",
    SETTINGS_LOCAL_STORAGE: "Lokalno skladište",
    SETTINGS_ENABLED: "Omogućeno",
    SETTINGS_SHOW_WIDGET: "Prikaži ikonu vidžeta",
    SETTINGS_AUTOPLAY: "Automatsko pokretanje pri pokretanju",
    SETTINGS_QUEUE_TRASHBIN: "Omogući korpu za otpatke reda čekanja",
    SETTINGS_TRACKLIST_TRASHBIN: "Omogući kantu za otpatke na listi staza",
    SETTINGS_PLAYLIST_MONITOR: "Plejlista Monitor",
    ITEMS_TITLE: "Stavke kantu za otpatke+",
    ITEMS_EMPTY_SONGS: "<strong>Nema pjesama u smeću!</strong><br/>Pjesme koje dodate u kantu za smeće pojaviti će se ovdje.",
    ITEMS_EMPTY_ARTISTS: "<strong>Nema odbačenih izvođača!</strong><br/>Izvođači koje dodate u kantu za otpatke pojaviti će se ovdje.",
    ITEMS_TAB_SONGS: "Pjesme",
    ITEMS_TAB_ARTISTS: "Umjetnici",
    ITEMS_LOADED_COUNT: "{{loaded}} od {{total}} {{type}} učitano",
    DESCRIPTION_COPY: "Kopiraj sve stavke u kantu za otpatke u međuspremnik.",
    DESCRIPTION_EXPORT: "Sačuvaj sve stavke u kantu za otpatke u .json datoteku.",
    DESCRIPTION_IMPORT: "Prepiši sve stavke u kanti za otpatke putem .json datoteke.",
    DESCRIPTION_CLEAR: "Obriši sve stavke iz kante za otpatke (ne može se poništiti).",
    ITEMS_EMPTY_SONGS_TITLE: "Nema odbačenih pjesama!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Nema odbačenih umjetnika!",
    DESCRIPTION_SETTINGS_ENABLED: "Glavni prekidač za omogućavanje ili onemogućavanje svih funkcija Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Prikaži ikonu kante za otpatke na traci za reprodukciju pored trenutno sviranog numerka radi brzeg pristupa",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automatski pokreni sviranje muzike kada se Spotify otvori ili kada se proširenje učita",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Dodajte ikone za otpad pored svake pjesme u vašoj nadolazećoj redu za jednostavno upravljanje",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Dodajte ikone za otpad pored pjesama u prikazima albuma i plejlista za brzo filtriranje",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatski se oporavite od kvarova pri reprodukciji na Spotifyju tako što ćete nastaviti sa svojom posljednjom plejlistom",
    SETTINGS_SKIP_TRASHED_TRACKS: "Preskoči odbačene staze",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Automatski preskoči obrisane pjesme i pronađi sljedeći dozvoljeni zapis tokom reprodukcije",
    SETTINGS_AUTO_CLEAN_QUEUE: "Automatska red čišćenja",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Automatski uklonite pjesme izbačene u smeće iz vaše Smart Shuffle reda",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Smeće na sljedećem prečicu",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Automatski bacite trenutnu pjesmu kada koristite prečicu na tastaturi Ctrl+Desno da preskočite na sljedeću pjesmu",
    SETTINGS_REMOTE_CONTROL: "Daljinski upravljač",
    SETTINGS_REMOTE_TOGGLE: "Omogući daljinsko prebacivanje",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dvaput dodirnite reprodukciju/pauzu sa mobilnog uređaja da biste uključili/isključili preskakanje na daljinu. Preskakanje numerka potvrđuje uključivanje/isključivanje.",
    SETTINGS_REMOTE_SKIPPING: "Daljinsko preskakanje aktivno",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Kada je omogućeno, preskakanje otpada funkcioniše čak i kada upravljate Spotify-om sa drugog uređaja (npr. mobilnog telefona)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Preskakanje na daljinu omogućeno",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Daljinsko preskakanje onemogućeno",
    MESSAGE_SONG_ADDED_REMOTE: "Pjesma oštećena na daljinu",
    SETTINGS_TRASH_VIA_LIKE: "Smeće putem Sviđa mi se",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Kao pjesma s mobilnog, izbaci je u otpad. Automatski uklanja sviđanje i prelazi na sljedeću pjesmu.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ca.json
var require_ca = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Paperera+",
    ACTION_THROW: "Posa a la paperera",
    ACTION_UNTHROW: "Elimina de la paperera",
    ACTION_CLEAR: "Clar",
    ACTION_COPY: "Còpia",
    ACTION_EXPORT: "Exportar",
    ACTION_IMPORT: "Importar",
    MESSAGE_COPIED: "Copiat al porta-retalls",
    MESSAGE_CLEARED: "Paperera buidada amb èxit!",
    MESSAGE_SONG_ADDED: "Cançó afegida a la paperera",
    MESSAGE_SONG_REMOVED: "Cançó eliminada de la paperera",
    MESSAGE_ARTIST_ADDED: "Artista afegit a la paperera",
    MESSAGE_ARTIST_REMOVED: "Artista eliminat de la paperera",
    BACKUP_SAVE_SUCCESS: "Còpia de seguretat desada correctament.",
    BACKUP_SAVE_FAILED: "No s'ha pogut desar la còpia de seguretat, intenta copiar el contingut de la paperera al porta-retalls i crear una còpia de seguretat manualment.",
    BACKUP_RESTORE_SUCCESS: "Còpia de seguretat restaurada amb èxit.",
    BACKUP_FILE_READ_FAILED: "No s'ha pogut llegir el fitxer, assegureu-vos que és un fitxer JSON vàlid.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Configuració de la Paperera+",
    SETTINGS_OPTIONS: "Opcions",
    SETTINGS_FEATURES: "Característiques",
    SETTINGS_LOCAL_STORAGE: "Emmagatzematge local",
    SETTINGS_ENABLED: "Habilitat",
    SETTINGS_SHOW_WIDGET: "Mostra la icona del giny",
    SETTINGS_AUTOPLAY: "Reproducció automàtica en iniciar",
    SETTINGS_QUEUE_TRASHBIN: "Habilita la paperera de la cua",
    SETTINGS_TRACKLIST_TRASHBIN: "Habilita la paperera de la llista de pistes",
    SETTINGS_PLAYLIST_MONITOR: "Monitor de llistes de reproducció",
    ITEMS_TITLE: "Elements de la paperera+",
    ITEMS_EMPTY_SONGS: "<strong>No hi ha cançons esborrades!</strong><br/>Les cançons que afegeixis a la paperera apareixeran aquí.",
    ITEMS_EMPTY_ARTISTS: "<strong>Cap artista esborrat!</strong><br/>Els artistes que afegeixis a la paperera apareixeran aquí.",
    ITEMS_TAB_SONGS: "Cançons",
    ITEMS_TAB_ARTISTS: "Artistes",
    ITEMS_LOADED_COUNT: "{{loaded}} de {{total}} {{type}} carregats",
    DESCRIPTION_COPY: "Copia tots els elements de la paperera al porta-retalls.",
    DESCRIPTION_EXPORT: "Desa tots els elements de la paperera en un fitxer .json.",
    DESCRIPTION_IMPORT: "Sobreescriu tots els elements de la paperera mitjançant el fitxer .json.",
    DESCRIPTION_CLEAR: "Esborra tots els elements de la paperera (no es pot desfer).",
    ITEMS_EMPTY_SONGS_TITLE: "Cap cançó esborrada!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Cap artista esbotzat!",
    DESCRIPTION_SETTINGS_ENABLED: "Commutador principal per activar o desactivar totes les funcionalitats de la Paperera+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Mostra una icona de paperera a la barra de reproducció al costat de la pista que s'està reproduint per accedir-hi ràpidament",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Inicia automàticament la reproducció de música quan s'obre Spotify o es carrega l'extensió",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Afegeix icones de paperera al costat de cada cançó de la teva cua propera per gestionar-les fàcilment",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Afegeix icones de paperera al costat de les cançons a les vistes d'àlbum i llista de reproducció per a un filtrat ràpid",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recupera't automàticament dels errors de reproducció del Spotify reprement l'última llista de reproducció",
    SETTINGS_SKIP_TRASHED_TRACKS: "Omet els pistes esborrats",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Omet automàticament les cançons esborrades i troba la següent pista permesa durant la reproducció",
    SETTINGS_AUTO_CLEAN_QUEUE: "Cua de neteja automàtica",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Elimina automàticament les cançons esborrades de la teva cua de reproducció aleatòria intel·ligent",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Paperera amb la següent tecla ràpida",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Elimina automàticament la cançó actual quan utilitzes la drecera de teclat Ctrl+Dreta per passar a la següent pista",
    SETTINGS_REMOTE_CONTROL: "Control remot",
    SETTINGS_REMOTE_TOGGLE: "Habilita l'activació remota",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Toca dues vegades reproduir/pausar des del mòbil per activar o desactivar el salt de pista a distància. El salt d'una pista confirma l'activació o desactivació.",
    SETTINGS_REMOTE_SKIPPING: "Omplert remot actiu",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Quan està activat, saltar-se la paperera funciona fins i tot quan es controla Spotify des d'un altre dispositiu (per exemple, mòbil)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Salt d'execució remot activat",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Salt remot desactivat",
    MESSAGE_SONG_ADDED_REMOTE: "Cançó esborrada mitjançant control remot",
    SETTINGS_TRASH_VIA_LIKE: "Brossa mitjançant Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: `Com una cançó del mòbil a la paperera. Elimina automàticament el "m'agrada" i passa a la següent pista.`,
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/cs.json
var require_cs = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Koš+",
    ACTION_THROW: "Umístit do koše",
    ACTION_UNTHROW: "Odstranit z koše",
    ACTION_CLEAR: "Jasné",
    ACTION_COPY: "Kopírovat",
    ACTION_EXPORT: "Export",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Zkopírováno do schránky",
    MESSAGE_CLEARED: "Koš byl úspěšně vyprázdněn!",
    MESSAGE_SONG_ADDED: "Píseň přidána do koše",
    MESSAGE_SONG_REMOVED: "Píseň odstraněna z koše",
    MESSAGE_ARTIST_ADDED: "Umělec přidán do koše",
    MESSAGE_ARTIST_REMOVED: "Umělec odstraněn z koše",
    BACKUP_SAVE_SUCCESS: "Záloha byla úspěšně uložena.",
    BACKUP_SAVE_FAILED: "Nepodařilo se uložit zálohu, zkuste zkopírovat obsah koše do schránky a vytvořit zálohu ručně.",
    BACKUP_RESTORE_SUCCESS: "Záloha byla úspěšně obnovena.",
    BACKUP_FILE_READ_FAILED: "Nepodařilo se přečíst soubor, ujistěte se, že jde o platný soubor JSON.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Nastavení koše+",
    SETTINGS_OPTIONS: "Možnosti",
    SETTINGS_FEATURES: "Funkce",
    SETTINGS_LOCAL_STORAGE: "Místní úložiště",
    SETTINGS_ENABLED: "Povoleno",
    SETTINGS_SHOW_WIDGET: "Zobrazit ikonu widgetu",
    SETTINGS_AUTOPLAY: "Automatické spuštění při startu",
    SETTINGS_QUEUE_TRASHBIN: "Povolit koš fronty",
    SETTINGS_TRACKLIST_TRASHBIN: "Povolit koš pro seznam stop",
    SETTINGS_PLAYLIST_MONITOR: "Monitor seznamu skladeb",
    ITEMS_TITLE: "Položky koše+",
    ITEMS_EMPTY_SONGS: "<strong>Žádné smazané skladby!</strong><br/>Skladby, které přidáte do koše, se zobrazí zde.",
    ITEMS_EMPTY_ARTISTS: "<strong>Žádní umělci ve koši!</strong><br/>Umělci, které přidáte do koše, se objeví zde.",
    ITEMS_TAB_SONGS: "Písně",
    ITEMS_TAB_ARTISTS: "Umělci",
    ITEMS_LOADED_COUNT: "Načteno {{loaded}} z {{total}} položek typu {{type}}",
    DESCRIPTION_COPY: "Zkopírovat všechny položky v koši do schránky.",
    DESCRIPTION_EXPORT: "Uložit všechny položky v koši do souboru .json.",
    DESCRIPTION_IMPORT: "Přepsat všechny položky v koši pomocí souboru .json.",
    DESCRIPTION_CLEAR: "Odstranit všechny položky z koše (nelze vrátit zpět).",
    ITEMS_EMPTY_SONGS_TITLE: "Žádné smazané skladby!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Žádní zdiskreditovaní umělci!",
    DESCRIPTION_SETTINGS_ENABLED: "Hlavní přepínač pro povolení nebo zakázání veškeré funkce Koš+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Zobrazit ikonu koše na liště přehrávání vedle právě přehrávané skladby pro rychlý přístup",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automaticky spustit přehrávání hudby při otevření Spotify nebo načtení rozšíření",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Přidejte ikony koše vedle každé skladby ve vaší nadcházející frontě pro snadnou správu",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Přidejte ikony koše vedle skladeb v zobrazení alba a seznamu skladeb pro rychlé filtrování",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatické obnovení přehrávání ve Spotify po chybách obnovením poslední playlistu",
    SETTINGS_SKIP_TRASHED_TRACKS: "Přeskočit smazané skladby",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Automaticky přeskakovat smazané skladby a během přehrávání najít další povolenou skladbu",
    SETTINGS_AUTO_CLEAN_QUEUE: "Fronta čištění vozidel",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Automaticky odstraňuj smazané skladby ze své fronty chytrého náhodného přehrávání",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Koš při dalším klávesovém zkratku",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Automaticky odstranit aktuální skladbu do koše při použití klávesové zkratky Ctrl+šipka doprava pro přeskočení na další skladbu",
    SETTINGS_REMOTE_CONTROL: "Dálkové ovládání",
    SETTINGS_REMOTE_TOGGLE: "Povolit vzdálené přepínání",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dvojitým klepnutím na přehrávání/pauzu z mobilního zařízení zapnete nebo vypnete vzdálené přeskakování. Přeskočení skladby potvrdí změnu nastavení.",
    SETTINGS_REMOTE_SKIPPING: "Vzdálené přeskočení aktivní",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Když je tato funkce povolená, přeskakování koše funguje i při ovládání Spotify z jiného zařízení (např. mobilního telefonu).",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Vzdálené přeskakování povoleno",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Vzdálené přeskakování zakázáno",
    MESSAGE_SONG_ADDED_REMOTE: "Píseň zničena na dálku",
    SETTINGS_TRASH_VIA_LIKE: "Odpadky přes Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Jako píseň z mobilu do koše. Automaticky odlajkne a přeskočí na další skladbu.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/da.json
var require_da = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Papirkurv+",
    ACTION_THROW: "Placer i papirkurven",
    ACTION_UNTHROW: "Fjern fra papirkurven",
    ACTION_CLEAR: "Klar",
    ACTION_COPY: "Kopiér",
    ACTION_EXPORT: "Eksport",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Kopieret til udklipsholder",
    MESSAGE_CLEARED: "Papirkurven er tømt med succes!",
    MESSAGE_SONG_ADDED: "Sang tilføjet til papirkurven",
    MESSAGE_SONG_REMOVED: "Sang fjernet fra papirkurven",
    MESSAGE_ARTIST_ADDED: "Kunstner tilføjet til papirkurven",
    MESSAGE_ARTIST_REMOVED: "Kunstner fjernet fra papirkurven",
    BACKUP_SAVE_SUCCESS: "Sikkerhedskopien blev gemt succesfuldt.",
    BACKUP_SAVE_FAILED: "Kunne ikke gemme sikkerhedskopien, prøv at kopiere papirkassens indhold til udklipsholderen og opret en sikkerhedskopi manuelt.",
    BACKUP_RESTORE_SUCCESS: "Sikkerhedskopien blev gendannet succesfuldt.",
    BACKUP_FILE_READ_FAILED: "Kunne ikke læse filen, sørg venligst for, at det er en gyldig JSON-fil.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Trashbin+ Indstillinger",
    SETTINGS_OPTIONS: "Valgmuligheder",
    SETTINGS_FEATURES: "Funktioner",
    SETTINGS_LOCAL_STORAGE: "Lokal lagerplads",
    SETTINGS_ENABLED: "Aktiveret",
    SETTINGS_SHOW_WIDGET: "Vis widget-ikon",
    SETTINGS_AUTOPLAY: "Automatisk afspilning ved start",
    SETTINGS_QUEUE_TRASHBIN: "Aktivér kø-papirkurv",
    SETTINGS_TRACKLIST_TRASHBIN: "Aktivér slettelsesbakke for sporliste",
    SETTINGS_PLAYLIST_MONITOR: "Aftaleskema Monitor",
    ITEMS_TITLE: "Papirkurv+ emner",
    ITEMS_EMPTY_SONGS: "<strong>Ingen slettede sange!</strong><br/>Sange, som du lægger i papirkurven, vises her.",
    ITEMS_EMPTY_ARTISTS: "<strong>Ingen slettet kunstnere!</strong><br/>Kunstnere, som du tilføjer til papirkurven, vises her.",
    ITEMS_TAB_SONGS: "Sange",
    ITEMS_TAB_ARTISTS: "Kunstnere",
    ITEMS_LOADED_COUNT: "{{loaded}} af {{total}} {{type}} indlæst",
    DESCRIPTION_COPY: "Kopier alle elementer i papirkurven til udklipsholderen.",
    DESCRIPTION_EXPORT: "Gem alle elementer i papirkurven i en .json-fil.",
    DESCRIPTION_IMPORT: "Overskriv alle elementer i papirkurven via .json-fil.",
    DESCRIPTION_CLEAR: "Ryd alle elementer fra papirkurven (kan ikke fortrydes).",
    ITEMS_EMPTY_SONGS_TITLE: "Ingen slettede sange!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Ingen kasseret kunstnere!",
    DESCRIPTION_SETTINGS_ENABLED: "Masterkontakt til at aktivere eller deaktivere al Papirkurv+-funktionalitet",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Vis et papirkurv-ikon i afspilningslinjen ved siden af den aktuelle sang for hurtig adgang",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Start automatisk afspilning af musik, når Spotify åbnes eller udvidelsen indlæses",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Tilføj papirkurv-ikoner ud for hver sang i din kommende kø for nem administration",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Tilføj papirkurv-ikoner ved siden af sange i album- og afspilningslistevisninger til hurtig filtrering",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Gendan automatisk fra afspilningsproblemer i Spotify ved at genoptage din sidste playliste",
    SETTINGS_SKIP_TRASHED_TRACKS: "Spring slettede spor over",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Spring automatisk over slettede sange og find det næste tilladte nummer under afspilning",
    SETTINGS_AUTO_CLEAN_QUEUE: "Automatisk rensning af kø",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Fjern automatisk slettede sange fra din Smart Shuffle-kø",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Papirkurv ved næste genvejstast",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Slet automatisk det nuværende nummer, når du bruger genvejen Ctrl+Højre til at springe til næste sporing",
    SETTINGS_REMOTE_CONTROL: "Fjernbetjening",
    SETTINGS_REMOTE_TOGGLE: "Aktivér fjernbetjeningstilstand",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dobbelttryk på afspil/pause fra mobilen for at slå fjernhåndtering af spring til/fra. Et spring til næste nummer bekræfter ændringen.",
    SETTINGS_REMOTE_SKIPPING: "Fjernbetjent springer aktivt over",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Når det er aktiveret, fungerer sletning uden papirkurv, selv når Spotify styres fra en anden enhed (f.eks. mobil)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Fjernhåndtering af springer aktiveret",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Fjernhåndtering af spring over deaktiveret",
    MESSAGE_SONG_ADDED_REMOTE: "Sang ødelagt via fjernbetjening",
    SETTINGS_TRASH_VIA_LIKE: "Affald via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Som en sang fra mobil til papirkurven. Fjerner automatisk like og springer til næste sporing.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/de.json
var require_de = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Papierkorb+",
    ACTION_THROW: "In den Papierkorb legen",
    ACTION_UNTHROW: "Aus dem Papierkorb entfernen",
    ACTION_CLEAR: "Klar",
    ACTION_COPY: "Kopieren",
    ACTION_EXPORT: "Export",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "In die Zwischenablage kopiert",
    MESSAGE_CLEARED: "Papierkorb erfolgreich geleert!",
    MESSAGE_SONG_ADDED: "Lied in den Papierkorb verschoben",
    MESSAGE_SONG_REMOVED: "Lied aus dem Papierkorb entfernt",
    MESSAGE_ARTIST_ADDED: "Künstler in den Papierkorb hinzugefügt",
    MESSAGE_ARTIST_REMOVED: "Künstler aus dem Papierkorb entfernt",
    BACKUP_SAVE_SUCCESS: "Sicherung erfolgreich gespeichert.",
    BACKUP_SAVE_FAILED: "Speichern der Sicherungskopie fehlgeschlagen, versuchen Sie, den Inhalt des Papierkorbs in die Zwischenablage zu kopieren und manuell eine Sicherungskopie zu erstellen.",
    BACKUP_RESTORE_SUCCESS: "Sicherung erfolgreich wiederhergestellt.",
    BACKUP_FILE_READ_FAILED: "Fehler beim Lesen der Datei, bitte stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Trashbin+ Einstellungen",
    SETTINGS_OPTIONS: "Optionen",
    SETTINGS_FEATURES: "Eigenschaften",
    SETTINGS_LOCAL_STORAGE: "Lokaler Speicher",
    SETTINGS_ENABLED: "Aktiviert",
    SETTINGS_SHOW_WIDGET: "Widget-Symbol anzeigen",
    SETTINGS_AUTOPLAY: "Automatisches Abspielen beim Start",
    SETTINGS_QUEUE_TRASHBIN: "Warteschlangen-Papierkorb aktivieren",
    SETTINGS_TRACKLIST_TRASHBIN: "Aktiviere Tracklist-Papierkorb",
    SETTINGS_PLAYLIST_MONITOR: "Playlist-Monitor",
    ITEMS_TITLE: "Papierkorb+ Elemente",
    ITEMS_EMPTY_SONGS: "<strong>Keine gelöschten Songs!</strong><br/>Songs, die du in den Papierkorb legst, werden hier angezeigt.",
    ITEMS_EMPTY_ARTISTS: "<strong>Keine gelöschten Künstler!</strong><br/>Künstler, die Sie in den Papierkorb verschieben, werden hier angezeigt.",
    ITEMS_TAB_SONGS: "Lieder",
    ITEMS_TAB_ARTISTS: "Künstler",
    ITEMS_LOADED_COUNT: "{{loaded}} von {{total}} {{type}} geladen",
    DESCRIPTION_COPY: "Kopiere alle Elemente im Papierkorb in die Zwischenablage.",
    DESCRIPTION_EXPORT: "Alle Elemente im Papierkorb in einer .json-Datei speichern.",
    DESCRIPTION_IMPORT: "Alle Elemente im Papierkorb über die .json-Datei überschreiben.",
    DESCRIPTION_CLEAR: "Alle Elemente aus dem Papierkorb löschen (kann nicht rückgängig gemacht werden).",
    ITEMS_EMPTY_SONGS_TITLE: "Keine gelöschten Songs!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Keine verworfenen Künstler!",
    DESCRIPTION_SETTINGS_ENABLED: "Hauptschalter zum Aktivieren oder Deaktivieren aller Papierkorb+-Funktionen",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Ein Papierkorb-Symbol in der Wiedergabeleiste neben dem gerade abgespielten Titel für schnellen Zugriff anzeigen",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Musik automatisch abspielen, wenn Spotify geöffnet wird oder die Erweiterung geladen wird",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Fügen Sie neben jedem Lied in Ihrer Warteschlange Papierkorb-Symbole hinzu, um eine einfache Verwaltung zu ermöglichen",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Abfall-Icons neben Songs in den Ansichten „Album“ und „Wiedergabeliste“ hinzufügen, um eine schnelle Filterung zu ermöglichen",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatische Wiederherstellung bei Spotify-Wiedergabeproblemen durch Fortsetzung Ihrer letzten Wiedergabeliste",
    SETTINGS_SKIP_TRASHED_TRACKS: "Überspringe gelöschte Titel",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Überspringe automatisch gelöschte Songs und finde während der Wiedergabe den nächsten erlaubten Titel",
    SETTINGS_AUTO_CLEAN_QUEUE: "Auto-Reinigungs-Warteschlange",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Entferne automatisch gelöschte Songs aus deiner Smart-Shuffle-Warteschlange",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Papierkorb beim nächsten Hotkey",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Aktuellen Song automatisch in den Papierkorb legen, wenn mit der Tastenkombination Strg+Rechts zum nächsten Titel gesprungen wird",
    SETTINGS_REMOTE_CONTROL: "Fernbedienung",
    SETTINGS_REMOTE_TOGGLE: "Fernumschaltung aktivieren",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Doppeltes Antippen von Wiedergabe/Pause auf dem Mobilgerät, um das Überspringen per Fernbedienung ein- oder auszuschalten. Das Überspringen eines Titels bestätigt die Umschaltung.",
    SETTINGS_REMOTE_SKIPPING: "Fernüberspringen aktiv",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Wenn aktiviert, funktioniert das Überspringen von Titeln auch dann, wenn Spotify von einem anderen Gerät (z. B. einem Mobilgerät) gesteuert wird.",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Fernüberspringen aktiviert",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Fernüberspringen deaktiviert",
    MESSAGE_SONG_ADDED_REMOTE: "Lied über Fernbedienung zerstört",
    SETTINGS_TRASH_VIA_LIKE: "Müll über Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Wie ein Lied vom Handy, um es zu löschen. Entmag automatisch und springt zum nächsten Titel.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/el.json
var require_el = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Κάδος απορριμμάτων+",
    ACTION_THROW: "Τοποθέτηση στον κάδο απορριμμάτων",
    ACTION_UNTHROW: "Αφαίρεση από τον Κάδο Απορριμμάτων",
    ACTION_CLEAR: "Ξεκάθαρο",
    ACTION_COPY: "Αντιγραφή",
    ACTION_EXPORT: "Εξαγωγή",
    ACTION_IMPORT: "Εισαγωγή",
    MESSAGE_COPIED: "Αντιγράφηκε στο πρόχειρο",
    MESSAGE_CLEARED: "Το καλάθι αχρήστων καθαρίστηκε επιτυχώς!",
    MESSAGE_SONG_ADDED: "Το τραγούδι προστέθηκε στον κάδο απορριμμάτων",
    MESSAGE_SONG_REMOVED: "Το τραγούδι αφαιρέθηκε από τον κάδο απορριμμάτων",
    MESSAGE_ARTIST_ADDED: "Ο καλλιτέχνης προστέθηκε στον κάδο απορριμμάτων",
    MESSAGE_ARTIST_REMOVED: "Ο καλλιτέχνης αφαιρέθηκε από τον κάδο απορριμμάτων",
    BACKUP_SAVE_SUCCESS: "Η αντίγραφο ασφαλείας αποθηκεύτηκε επιτυχώς.",
    BACKUP_SAVE_FAILED: "Αποτυχία αποθήκευσης αντιγράφου ασφαλείας, δοκιμάστε να αντιγράψετε τα περιεχόμενα του κάδου απορριμμάτων στο πρόχειρο και να δημιουργήσετε ένα αντίγραφο ασφαλείας χειροκίνητα.",
    BACKUP_RESTORE_SUCCESS: "Η δημιουργία αντιγράφου ασφαλείας αποκαταστάθηκε επιτυχώς.",
    BACKUP_FILE_READ_FAILED: "Αποτυχία ανάγνωσης αρχείου, παρακαλούμε βεβαιωθείτε ότι είναι έγκυρο αρχείο JSON.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Ρυθμίσεις Trashbin+",
    SETTINGS_OPTIONS: "Επιλογές",
    SETTINGS_FEATURES: "Χαρακτηριστικά",
    SETTINGS_LOCAL_STORAGE: "Τοπική αποθήκευση",
    SETTINGS_ENABLED: "Ενεργοποιημένο",
    SETTINGS_SHOW_WIDGET: "Εμφάνιση εικονιδίου γραφικού στοιχείου",
    SETTINGS_AUTOPLAY: "Αυτόματη έναρξη κατά την εκκίνηση",
    SETTINGS_QUEUE_TRASHBIN: "Ενεργοποίηση Κάδου Απορριμμάτων Ουράς",
    SETTINGS_TRACKLIST_TRASHBIN: "Ενεργοποίηση Κάδου Απορριμμάτων Λίστας Κομματιών",
    SETTINGS_PLAYLIST_MONITOR: "Παρακολούθηση λίστας αναπαραγωγής",
    ITEMS_TITLE: "Αντικείμενα Trashbin+",
    ITEMS_EMPTY_SONGS: "<strong>Καμία διαγραμμένα τραγούδια!</strong><br/>Τα τραγούδια που προσθέτετε στον κάδο απορριμμάτων θα εμφανίζονται εδώ.",
    ITEMS_EMPTY_ARTISTS: "<strong>Κανένας καλλιτέχνης στα σκουπίδια!</strong><br/>Οι καλλιτέχνες που προσθέτετε στον κάδο απορριμμάτων θα εμφανίζονται εδώ.",
    ITEMS_TAB_SONGS: "Τραγούδια",
    ITEMS_TAB_ARTISTS: "Καλλιτέχνες",
    ITEMS_LOADED_COUNT: "{{loaded}} από {{total}} {{type}} φορτώθηκαν",
    DESCRIPTION_COPY: "Αντιγραφή όλων των αντικειμένων στον κάδο απορριμμάτων στο πρόχειρο.",
    DESCRIPTION_EXPORT: "Αποθηκεύστε όλα τα αντικείμενα στον κάδο απορριμμάτων σε ένα αρχείο .json.",
    DESCRIPTION_IMPORT: "Αντικατάσταση όλων των αντικειμένων στον κάδο απορριμμάτων μέσω αρχείου .json.",
    DESCRIPTION_CLEAR: "Διαγραφή όλων των αντικειμένων από τον κάδο απορριμμάτων (δεν μπορεί να αναιρεθεί).",
    ITEMS_EMPTY_SONGS_TITLE: "Καμία διαγραμμένη μουσική!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Κανένας κατεστραμμένος καλλιτέχνης!",
    DESCRIPTION_SETTINGS_ENABLED: "Κύριος διακόπτης για ενεργοποίηση ή απενεργοποίηση όλων των λειτουργιών του Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Εμφάνιση εικονιδίου κάδου απορριμμάτων στη γραμμή αναπαραγωγής δίπλα στο τρέχον τραγούδι για γρήγορη πρόσβαση",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Αυτόματη έναρξη αναπαραγωγής μουσικής όταν ανοίγει το Spotify ή φορτώνεται η επέκταση",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Προσθέστε εικονίδια απορριμμάτων δίπλα σε κάθε τραγούδι στην ουρά σας για εύκολη διαχείριση",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Προσθέστε εικονίδια απορριμμάτων δίπλα στα τραγούδια στις προβολές άλμπουμ και λίστας αναπαραγωγής για γρήγορη φιλτράρισμα",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Αυτόματη ανάκτηση από προβλήματα αναπαραγωγής στο Spotify με τη συνέχιση της τελευταίας λίστας αναπαραγωγής σας",
    SETTINGS_SKIP_TRASHED_TRACKS: "Παράλειψη Απορριμμένων Κομματιών",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Παράκαμψη αυτόματα των διαγραμμένων τραγουδιών και εύρεση του επόμενου επιτρεπόμενου κομματιού κατά τη διάρκεια αναπαραγωγής",
    SETTINGS_AUTO_CLEAN_QUEUE: "Ουρά αυτόματου καθαρισμού",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Αυτόματη αφαίρεση διαγραμμένων τραγουδιών από την ουρά Smart Shuffle",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Άχρηστα με το επόμενο συντόμευση πλήκτρων",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Αυτόματη διαγραφή του τρέχοντος τραγουδιού όταν χρησιμοποιείται η συντόμευση πληκτρολογίου Ctrl+Δεξιά για παράκαμψη στο επόμενο κομμάτι",
    SETTINGS_REMOTE_CONTROL: "Τηλεχειριστήριο",
    SETTINGS_REMOTE_TOGGLE: "Ενεργοποίηση απομακρυσμένης εναλλαγής",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Πατήστε δύο φορές το πλήκτρο αναπαραγωγής/παύσης από το κινητό για να ενεργοποιήσετε/απενεργοποιήσετε τη λειτουργία παράκαμψης από απόσταση. Η παράκαμψη ενός κομματιού επιβεβαιώνει την εναλλαγή.",
    SETTINGS_REMOTE_SKIPPING: "Ενεργό Απομακρυσμένο Παράλειψη",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Όταν ενεργοποιηθεί, η παράκαμψη των απορριμμάτων λειτουργεί ακόμα και όταν ελέγχετε το Spotify από άλλη συσκευή (π.χ. κινητό)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Ενεργοποιημένη η απομακρυσμένη παράκαμψη",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Η απομακρυσμένη παράλειψη απενεργοποιήθηκε",
    MESSAGE_SONG_ADDED_REMOTE: "Το τραγούδι καταστράφηκε μέσω τηλεχειριστηρίου",
    SETTINGS_TRASH_VIA_LIKE: "Απορρίμματα μέσω Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Όπως ένα τραγούδι από το κινητό για να το πετάξεις. Αποδιαγράφεται αυτόματα και πηγαίνει στο επόμενο κομμάτι.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/en-GB.json
var require_en_GB = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Bin+",
    ACTION_THROW: "Put in Trashbin",
    ACTION_UNTHROW: "Remove from Trash",
    ACTION_CLEAR: "Clear",
    ACTION_COPY: "Copy",
    ACTION_EXPORT: "Export",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Copied to clipboard",
    MESSAGE_CLEARED: "Trashbin cleared successfully!",
    MESSAGE_SONG_ADDED: "Song added to bin",
    MESSAGE_SONG_REMOVED: "Song removed from trash bin",
    MESSAGE_ARTIST_ADDED: "Artist added to trash bin",
    MESSAGE_ARTIST_REMOVED: "Artist removed from trash bin",
    BACKUP_SAVE_SUCCESS: "Backup saved successfully.",
    BACKUP_SAVE_FAILED: "Failed to save backup; try copying trashbin contents to clipboard and creating a backup manually.",
    BACKUP_RESTORE_SUCCESS: "Backup restored successfully.",
    BACKUP_FILE_READ_FAILED: "Failed to read file; please ensure it is a valid JSON file.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Trashbin+ Settings",
    SETTINGS_OPTIONS: "Options",
    SETTINGS_FEATURES: "Features",
    SETTINGS_LOCAL_STORAGE: "Local Storage",
    SETTINGS_ENABLED: "Enabled",
    SETTINGS_SHOW_WIDGET: "Show Widget Icon",
    SETTINGS_AUTOPLAY: "Autoplay on Start",
    SETTINGS_QUEUE_TRASHBIN: "Enable Queue Trashbin",
    SETTINGS_TRACKLIST_TRASHBIN: "Enable Tracklist Trash Bin",
    SETTINGS_PLAYLIST_MONITOR: "Playlist Monitor",
    ITEMS_TITLE: "Trashbin+ Items",
    ITEMS_EMPTY_SONGS: "<strong>No trashed songs!</strong><br/>Songs you add to the bin will appear here.",
    ITEMS_EMPTY_ARTISTS: "<strong>No trashed artists!</strong><br/>Artists you add to the bin will appear here.",
    ITEMS_TAB_SONGS: "Songs",
    ITEMS_TAB_ARTISTS: "Artists",
    ITEMS_LOADED_COUNT: "{{loaded}} of {{total}} {{type}} loaded",
    DESCRIPTION_COPY: "Copy all items in the bin to clipboard.",
    DESCRIPTION_EXPORT: "Save all items in the trashbin to a .json file.",
    DESCRIPTION_IMPORT: "Overwrite all items in the bin via .json file.",
    DESCRIPTION_CLEAR: "Empty the trashbin (this action cannot be undone).",
    ITEMS_EMPTY_SONGS_TITLE: "No deleted songs!",
    ITEMS_EMPTY_ARTISTS_TITLE: "No artists trashed!",
    DESCRIPTION_SETTINGS_ENABLED: "Master switch to enable or disable all Trashbin+ functionality",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Display a bin icon in the playback bar next to the currently playing track for quick access",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automatically start playing music when Spotify opens or the extension loads",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Add bin icons next to each song in your upcoming queue for easy management",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Add bin icons next to songs in album and playlist views for quick filtering",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatically recover from Spotify playback glitches by resuming your last playlist",
    SETTINGS_SKIP_TRASHED_TRACKS: "Skip Trashed Tracks",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Automatically skip deleted songs and find the next available track during playback",
    SETTINGS_AUTO_CLEAN_QUEUE: "Auto Clean Queue",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Automatically remove deleted songs from your Smart Shuffle queue",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Trash on Next Hotkey",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Automatically move the current song to trash when using the Ctrl+Right keyboard shortcut to skip to the next track",
    SETTINGS_REMOTE_CONTROL: "Remote Control",
    SETTINGS_REMOTE_TOGGLE: "Enable Remote Toggle",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Double-tap play/pause on your mobile to toggle remote skipping on or off. A track skip confirms the toggle.",
    SETTINGS_REMOTE_SKIPPING: "Remote Skipping Active",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "When enabled, trash-skipping works even when controlling Spotify from another device (e.g. mobile)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Remote skipping enabled",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Skipping à distance désactivé",
    MESSAGE_SONG_ADDED_REMOTE: "Song trashed via remote",
    SETTINGS_TRASH_VIA_LIKE: "Rubbish via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Like a song from mobile to trash it. Automatically unlikes and skips to the next track.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/en.json
var require_en = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Trashbin+",
    ACTION_THROW: "Place in Trashbin",
    ACTION_UNTHROW: "Remove from Trashbin",
    ACTION_CLEAR: "Clear",
    ACTION_COPY: "Copy",
    ACTION_EXPORT: "Export",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Copied to clipboard",
    MESSAGE_CLEARED: "Trashbin cleared successfully!",
    MESSAGE_SONG_ADDED: "Song added to trashbin",
    MESSAGE_SONG_REMOVED: "Song removed from trashbin",
    MESSAGE_ARTIST_ADDED: "Artist added to trashbin",
    MESSAGE_ARTIST_REMOVED: "Artist removed from trashbin",
    BACKUP_SAVE_SUCCESS: "Backup saved successfully.",
    BACKUP_SAVE_FAILED: "Failed to save backup, try copying trashbin contents to clipboard and creating a backup manually.",
    BACKUP_RESTORE_SUCCESS: "Backup restored successfully.",
    BACKUP_FILE_READ_FAILED: "Failed to read file, please ensure it is a valid JSON file.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Trashbin+ Settings",
    SETTINGS_OPTIONS: "Options",
    SETTINGS_FEATURES: "Features",
    SETTINGS_LOCAL_STORAGE: "Local Storage",
    SETTINGS_ENABLED: "Enabled",
    SETTINGS_SHOW_WIDGET: "Show Widget Icon",
    SETTINGS_AUTOPLAY: "Autoplay on Start",
    SETTINGS_QUEUE_TRASHBIN: "Enable Queue Trashbin",
    SETTINGS_TRACKLIST_TRASHBIN: "Enable Tracklist Trashbin",
    SETTINGS_PLAYLIST_MONITOR: "Playlist Monitor",
    ITEMS_TITLE: "Trashbin+ Items",
    ITEMS_EMPTY_SONGS: "<strong>No trashed songs!</strong><br/>Songs you add to the trashbin will appear here.",
    ITEMS_EMPTY_ARTISTS: "<strong>No trashed artists!</strong><br/>Artists you add to the trashbin will appear here.",
    ITEMS_TAB_SONGS: "Songs",
    ITEMS_TAB_ARTISTS: "Artists",
    ITEMS_LOADED_COUNT: "{{loaded}} of {{total}} {{type}} loaded",
    ITEMS_SEARCH_PLACEHOLDER: "Search by name, artist, or URI...",
    DESCRIPTION_COPY: "Copy all items in trashbin to clipboard.",
    DESCRIPTION_EXPORT: "Save all items in trashbin to a .json file.",
    DESCRIPTION_IMPORT: "Overwrite all items in trashbin via .json file.",
    DESCRIPTION_CLEAR: "Clear all items from trashbin (cannot be reverted).",
    ITEMS_EMPTY_SONGS_TITLE: "No trashed songs!",
    ITEMS_EMPTY_ARTISTS_TITLE: "No trashed artists!",
    DESCRIPTION_SETTINGS_ENABLED: "Master toggle to enable or disable all Trashbin+ functionality",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Display a trash icon in the playback bar next to the currently playing track for quick access",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automatically start playing music when Spotify opens or the extension loads",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Add trash icons next to each song in your upcoming queue for easy management",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Add trash icons next to songs in album and playlist views for quick filtering",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatically recover from Spotify playback glitches by resuming your last playlist",
    SETTINGS_SKIP_TRASHED_TRACKS: "Skip Trashed Tracks",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Automatically skip trashed songs and find the next allowed track during playback",
    SETTINGS_AUTO_CLEAN_QUEUE: "Auto Clean Queue",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Automatically remove trashed songs from your Smart Shuffle queue",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Trash on Next Hotkey",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Automatically trash the current song when using Ctrl+Right keyboard shortcut to skip to next track",
    SETTINGS_REMOTE_CONTROL: "Remote Control",
    SETTINGS_REMOTE_TOGGLE: "Enable Remote Toggle",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Double-tap play/pause from mobile to toggle remote skipping on/off. A track skip confirms the toggle.",
    SETTINGS_REMOTE_SKIPPING: "Remote Skipping Active",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "When enabled, trash-skipping works even when controlling Spotify from another device (e.g., mobile)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Remote skipping enabled",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Remote skipping disabled",
    MESSAGE_SONG_ADDED_REMOTE: "Song trashed via remote",
    SETTINGS_TRASH_VIA_LIKE: "Trash via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Like a song from mobile to trash it. Automatically unlikes and skips to next track.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/es-419.json
var require_es_419 = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Papelera+",
    ACTION_THROW: "Colocar en la papelera",
    ACTION_UNTHROW: "Eliminar de la Papelera",
    ACTION_CLEAR: "Claro",
    ACTION_COPY: "Copiar",
    ACTION_EXPORT: "Exportar",
    ACTION_IMPORT: "Importar",
    MESSAGE_COPIED: "Copiado al portapapeles",
    MESSAGE_CLEARED: "¡Papelera vaciada con éxito!",
    MESSAGE_SONG_ADDED: "Canción agregada a la papelera",
    MESSAGE_SONG_REMOVED: "Canción eliminada de la papelera",
    MESSAGE_ARTIST_ADDED: "Artista agregado a la papelera",
    MESSAGE_ARTIST_REMOVED: "Artista eliminado de la papelera",
    BACKUP_SAVE_SUCCESS: "Copia de respaldo guardada exitosamente.",
    BACKUP_SAVE_FAILED: "No se pudo guardar la copia de seguridad, intente copiar el contenido de la papelera al portapapeles y crear una copia de seguridad manualmente.",
    BACKUP_RESTORE_SUCCESS: "Copia de seguridad restaurada con éxito.",
    BACKUP_FILE_READ_FAILED: "No se pudo leer el archivo, asegúrese de que sea un archivo JSON válido.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-basurero.json",
    SETTINGS_TITLE: "Configuración de Trashbin+",
    SETTINGS_OPTIONS: "Opciones",
    SETTINGS_FEATURES: "Características",
    SETTINGS_LOCAL_STORAGE: "Almacenamiento local",
    SETTINGS_ENABLED: "Habilitado",
    SETTINGS_SHOW_WIDGET: "Mostrar icono del widget",
    SETTINGS_AUTOPLAY: "Reproducción automática al iniciar",
    SETTINGS_QUEUE_TRASHBIN: "Habilitar la papelera de la cola",
    SETTINGS_TRACKLIST_TRASHBIN: "Habilitar Papelera de la Lista de Pistas",
    SETTINGS_PLAYLIST_MONITOR: "Monitor de listas de reproducción",
    ITEMS_TITLE: "Artículos de Papelera+",
    ITEMS_EMPTY_SONGS: "<strong>¡Ninguna canción en la papelera!</strong><br/>Las canciones que agregues a la papelera aparecerán aquí.",
    ITEMS_EMPTY_ARTISTS: "<strong>¡Ningún artista eliminado!</strong><br/>Los artistas que agregues a la papelera aparecerán aquí.",
    ITEMS_TAB_SONGS: "Canciones",
    ITEMS_TAB_ARTISTS: "Artistas",
    ITEMS_LOADED_COUNT: "{{loaded}} de {{total}} {{type}} cargados",
    DESCRIPTION_COPY: "Copiar todos los elementos de la papelera al portapapeles.",
    DESCRIPTION_EXPORT: "Guardar todos los elementos de la papelera en un archivo .json.",
    DESCRIPTION_IMPORT: "Sobrescribir todos los elementos en la papelera mediante el archivo .json.",
    DESCRIPTION_CLEAR: "Eliminar todos los elementos de la papelera (no se puede deshacer).",
    ITEMS_EMPTY_SONGS_TITLE: "¡Ninguna canción eliminada!",
    ITEMS_EMPTY_ARTISTS_TITLE: "¡Ningún artista eliminado!",
    DESCRIPTION_SETTINGS_ENABLED: "Conmutador principal para activar o desactivar todas las funciones de Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Mostrar un icono de papelera en la barra de reproducción junto a la pista que se está reproduciendo para un acceso rápido",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Iniciar automáticamente la reproducción de música cuando se abra Spotify o se cargue la extensión",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Agrega íconos de basura junto a cada canción en tu cola próxima para una gestión fácil",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Agregar iconos de basura junto a las canciones en las vistas de álbum y lista de reproducción para filtrado rápido",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recupérate automáticamente de errores en la reproducción de Spotify al reanudar tu última lista de reproducción",
    SETTINGS_SKIP_TRASHED_TRACKS: "Omitir pistas eliminadas",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Omitir automáticamente las canciones eliminadas y encontrar la siguiente pista permitida durante la reproducción",
    SETTINGS_AUTO_CLEAN_QUEUE: "Cola de limpieza automática",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Eliminar automáticamente canciones eliminadas de tu cola de reproducción aleatoria inteligente",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Papelera en la siguiente tecla de acceso rápido",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Mover automáticamente la canción actual a la papelera al usar el atajo de teclado Ctrl+Derecha para pasar a la siguiente pista",
    SETTINGS_REMOTE_CONTROL: "Control remoto",
    SETTINGS_REMOTE_TOGGLE: "Habilitar conmutación remota",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Toca dos veces reproducir/pausa desde el móvil para activar o desactivar el salto remoto. Saltar una pista confirma el cambio.",
    SETTINGS_REMOTE_SKIPPING: "Omisión remota activa",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Cuando está activado, omitir la papelera funciona incluso cuando se controla Spotify desde otro dispositivo (por ejemplo, móvil).",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Omisión remota habilitada",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Omisión remota desactivada",
    MESSAGE_SONG_ADDED_REMOTE: "Canción eliminada mediante control remoto",
    SETTINGS_TRASH_VIA_LIKE: "Basura a través de Me gusta",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Como una canción desde el móvil hasta eliminarla. Automáticamente deja de gustar y pasa a la siguiente pista.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/es-AR.json
var require_es_AR = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Papelera+",
    ACTION_THROW: "Colocar en la papelera",
    ACTION_UNTHROW: "Eliminar de la Papelera",
    ACTION_CLEAR: "Claro",
    ACTION_COPY: "Copiar",
    ACTION_EXPORT: "Exportar",
    ACTION_IMPORT: "Importar",
    MESSAGE_COPIED: "Copiado al portapapeles",
    MESSAGE_CLEARED: "¡Papelera vaciada con éxito!",
    MESSAGE_SONG_ADDED: "Canción agregada a la papelera",
    MESSAGE_SONG_REMOVED: "Canción eliminada de la papelera",
    MESSAGE_ARTIST_ADDED: "Artista agregado a la papelera",
    MESSAGE_ARTIST_REMOVED: "Artista eliminado de la papelera",
    BACKUP_SAVE_SUCCESS: "Copia de respaldo guardada con éxito.",
    BACKUP_SAVE_FAILED: "No se pudo guardar la copia de seguridad, intente copiar el contenido de la papelera al portapapeles y crear una copia de seguridad manualmente.",
    BACKUP_RESTORE_SUCCESS: "Copia de seguridad restaurada con éxito.",
    BACKUP_FILE_READ_FAILED: "No se pudo leer el archivo, asegúrese de que sea un archivo JSON válido.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-basurero.json",
    SETTINGS_TITLE: "Configuración de Trashbin+",
    SETTINGS_OPTIONS: "Opciones",
    SETTINGS_FEATURES: "Características",
    SETTINGS_LOCAL_STORAGE: "Almacenamiento local",
    SETTINGS_ENABLED: "Habilitado",
    SETTINGS_SHOW_WIDGET: "Mostrar ícono del widget",
    SETTINGS_AUTOPLAY: "Reproducción automática al iniciar",
    SETTINGS_QUEUE_TRASHBIN: "Habilitar la papelera de la cola",
    SETTINGS_TRACKLIST_TRASHBIN: "Habilitar Papelera de la Lista de Pistas",
    SETTINGS_PLAYLIST_MONITOR: "Monitor de listas de reproducción",
    ITEMS_TITLE: "Elementos de Papelera+",
    ITEMS_EMPTY_SONGS: "<strong>¡No hay canciones en la papelera!</strong><br/>Las canciones que agregues a la papelera aparecerán aquí.",
    ITEMS_EMPTY_ARTISTS: "<strong>¡No hay artistas en la papelera!</strong><br/>Los artistas que agregues a la papelera aparecerán aquí.",
    ITEMS_TAB_SONGS: "Canciones",
    ITEMS_TAB_ARTISTS: "Artistas",
    ITEMS_LOADED_COUNT: "{{loaded}} de {{total}} {{type}} cargados",
    DESCRIPTION_COPY: "Copiar todos los elementos de la papelera al portapapeles.",
    DESCRIPTION_EXPORT: "Guardar todos los elementos de la papelera en un archivo .json.",
    DESCRIPTION_IMPORT: "Sobrescribir todos los elementos en la papelera mediante archivo .json.",
    DESCRIPTION_CLEAR: "Eliminar todos los elementos de la papelera (no se puede deshacer).",
    ITEMS_EMPTY_SONGS_TITLE: "¡Ninguna canción eliminada!",
    ITEMS_EMPTY_ARTISTS_TITLE: "¡Nada de artistas truchos!",
    DESCRIPTION_SETTINGS_ENABLED: "Conmutador principal para activar o desactivar todas las funciones de Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Mostrar un ícono de papelera en la barra de reproducción junto a la pista que se está reproduciendo para un acceso rápido",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Iniciar automáticamente la reproducción de música cuando se abra Spotify o se cargue la extensión",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Agregá íconos de basura al lado de cada canción en tu cola próxima para una gestión fácil",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Agregar íconos de basura junto a las canciones en las vistas de álbum y lista de reproducción para filtrar rápidamente",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recupérate automáticamente de fallos en la reproducción de Spotify reanudando tu última lista de reproducción",
    SETTINGS_SKIP_TRASHED_TRACKS: "Omitir pistas eliminadas",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Omitir automáticamente las canciones eliminadas y encontrar la siguiente pista permitida durante la reproducción",
    SETTINGS_AUTO_CLEAN_QUEUE: "Cola de limpieza automática",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Eliminar automáticamente las canciones eliminadas de tu cola de reproducción aleatoria inteligente",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Basura en la próxima tecla rápida",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Mover automáticamente la canción actual a la papelera al usar el atajo de teclado Ctrl+Derecha para pasar a la siguiente pista",
    SETTINGS_REMOTE_CONTROL: "Control remoto",
    SETTINGS_REMOTE_TOGGLE: "Habilitar conmutación remota",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Toca dos veces reproducir/pausa desde el móvil para activar o desactivar el salto remoto de pistas. Saltar una pista confirma el cambio.",
    SETTINGS_REMOTE_SKIPPING: "Omisión remota activa",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Cuando está activado, omitir la papelera funciona incluso cuando se controla Spotify desde otro dispositivo (por ejemplo, móvil)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Salto remoto habilitado",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Salto remoto desactivado",
    MESSAGE_SONG_ADDED_REMOTE: "Canción eliminada a distancia",
    SETTINGS_TRASH_VIA_LIKE: "Basura a través de Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: 'Como una canción desde el móvil hasta la papelera. Automáticamente quita el "me gusta" y pasa a la siguiente pista.',
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/es-MX.json
var require_es_MX = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Papelera+",
    ACTION_THROW: "Colocar en la papelera",
    ACTION_UNTHROW: "Eliminar de la Papelera",
    ACTION_CLEAR: "Claro",
    ACTION_COPY: "Copiar",
    ACTION_EXPORT: "Exportar",
    ACTION_IMPORT: "Importar",
    MESSAGE_COPIED: "Copiado al portapapeles",
    MESSAGE_CLEARED: "¡Papelera vaciada con éxito!",
    MESSAGE_SONG_ADDED: "Canción agregada a la papelera",
    MESSAGE_SONG_REMOVED: "Canción eliminada de la papelera",
    MESSAGE_ARTIST_ADDED: "Artista agregado a la papelera",
    MESSAGE_ARTIST_REMOVED: "Artista eliminado de la papelera",
    BACKUP_SAVE_SUCCESS: "Copia de seguridad guardada correctamente.",
    BACKUP_SAVE_FAILED: "No se pudo guardar la copia de seguridad, intenta copiar el contenido de la papelera al portapapeles y crear una copia de seguridad manualmente.",
    BACKUP_RESTORE_SUCCESS: "Copia de seguridad restaurada correctamente.",
    BACKUP_FILE_READ_FAILED: "No se pudo leer el archivo, asegúrese de que sea un archivo JSON válido.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-basurero.json",
    SETTINGS_TITLE: "Configuración de Trashbin+",
    SETTINGS_OPTIONS: "Opciones",
    SETTINGS_FEATURES: "Características",
    SETTINGS_LOCAL_STORAGE: "Almacenamiento local",
    SETTINGS_ENABLED: "Habilitado",
    SETTINGS_SHOW_WIDGET: "Mostrar icono del widget",
    SETTINGS_AUTOPLAY: "Reproducción automática al iniciar",
    SETTINGS_QUEUE_TRASHBIN: "Habilitar la papelera de la cola",
    SETTINGS_TRACKLIST_TRASHBIN: "Habilitar la papelera de la lista de pistas",
    SETTINGS_PLAYLIST_MONITOR: "Monitor de listas de reproducción",
    ITEMS_TITLE: "Artículos de la papelera+",
    ITEMS_EMPTY_SONGS: "<strong>¡No hay canciones en la papelera!</strong><br/>Las canciones que agregues a la papelera aparecerán aquí.",
    ITEMS_EMPTY_ARTISTS: "<strong>¡No hay artistas en la papelera!</strong><br/>Los artistas que agregues a la papelera aparecerán aquí.",
    ITEMS_TAB_SONGS: "Canciones",
    ITEMS_TAB_ARTISTS: "Artistas",
    ITEMS_LOADED_COUNT: "{{loaded}} de {{total}} {{type}} cargados",
    DESCRIPTION_COPY: "Copiar todos los elementos de la papelera al portapapeles.",
    DESCRIPTION_EXPORT: "Guardar todos los elementos en la papelera en un archivo .json.",
    DESCRIPTION_IMPORT: "Sobrescribir todos los elementos en la papelera mediante el archivo .json.",
    DESCRIPTION_CLEAR: "Eliminar todos los elementos de la papelera (no se puede deshacer).",
    ITEMS_EMPTY_SONGS_TITLE: "¡No hay canciones eliminadas!",
    ITEMS_EMPTY_ARTISTS_TITLE: "¡Nada de artistas descartados!",
    DESCRIPTION_SETTINGS_ENABLED: "Conmutador principal para activar o desactivar todas las funciones de Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Mostrar un icono de papelera en la barra de reproducción junto a la pista que se está reproduciendo para un acceso rápido",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Iniciar automáticamente la reproducción de música cuando se abre Spotify o se carga la extensión",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Agrega íconos de basura junto a cada canción en tu cola de reproducción para una administración más fácil",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Agregar iconos de basura junto a las canciones en las vistas de álbum y lista de reproducción para filtrado rápido",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recupérate automáticamente de fallos en la reproducción de Spotify al reanudar tu última lista de reproducción",
    SETTINGS_SKIP_TRASHED_TRACKS: "Omitir pistas eliminadas",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Omitir automáticamente las canciones eliminadas y encontrar la siguiente pista permitida durante la reproducción",
    SETTINGS_AUTO_CLEAN_QUEUE: "Cola de limpieza automática",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Eliminar automáticamente las canciones eliminadas de tu cola de reproducción aleatoria inteligente",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Basura en la siguiente tecla rápida",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Mover automáticamente la canción actual a la papelera al usar el atajo de teclado Ctrl+Derecha para pasar a la siguiente pista",
    SETTINGS_REMOTE_CONTROL: "Control remoto",
    SETTINGS_REMOTE_TOGGLE: "Habilitar conmutación remota",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Toca dos veces reproducir/pausa desde el móvil para activar o desactivar el salto remoto de pistas. Saltar una pista confirma el cambio.",
    SETTINGS_REMOTE_SKIPPING: "Omisión remota activa",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Cuando está activado, omitir la papelera funciona incluso cuando se controla Spotify desde otro dispositivo (por ejemplo, móvil)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Omisión remota habilitada",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Omisión remota desactivada",
    MESSAGE_SONG_ADDED_REMOTE: "Canción eliminada mediante control remoto",
    SETTINGS_TRASH_VIA_LIKE: "Basura mediante Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: 'Como una canción desde el móvil hasta la papelera. Automáticamente quita la marca de "me gusta" y pasa a la siguiente pista.',
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/es.json
var require_es = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Papelera+",
    ACTION_THROW: "Colocar en la papelera",
    ACTION_UNTHROW: "Eliminar de la Papelera",
    ACTION_CLEAR: "Claro",
    ACTION_COPY: "Copiar",
    ACTION_EXPORT: "Exportar",
    ACTION_IMPORT: "Importar",
    MESSAGE_COPIED: "Copiado al portapapeles",
    MESSAGE_CLEARED: "¡Papelera vaciada con éxito!",
    MESSAGE_SONG_ADDED: "Canción agregada a la papelera",
    MESSAGE_SONG_REMOVED: "Canción eliminada de la papelera",
    MESSAGE_ARTIST_ADDED: "Artista agregado a la papelera",
    MESSAGE_ARTIST_REMOVED: "Artista eliminado de la papelera",
    BACKUP_SAVE_SUCCESS: "Copia de seguridad guardada correctamente.",
    BACKUP_SAVE_FAILED: "No se pudo guardar la copia de seguridad, intente copiar el contenido de la papelera al portapapeles y crear una copia de seguridad manualmente.",
    BACKUP_RESTORE_SUCCESS: "Copia de seguridad restaurada con éxito.",
    BACKUP_FILE_READ_FAILED: "No se pudo leer el archivo, asegúrese de que sea un archivo JSON válido.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Configuración de Trashbin+",
    SETTINGS_OPTIONS: "Opciones",
    SETTINGS_FEATURES: "Características",
    SETTINGS_LOCAL_STORAGE: "Almacenamiento local",
    SETTINGS_ENABLED: "Habilitado",
    SETTINGS_SHOW_WIDGET: "Mostrar icono del widget",
    SETTINGS_AUTOPLAY: "Reproducción automática al iniciar",
    SETTINGS_QUEUE_TRASHBIN: "Habilitar la papelera de la cola",
    SETTINGS_TRACKLIST_TRASHBIN: "Habilitar la papelera de la lista de pistas",
    SETTINGS_PLAYLIST_MONITOR: "Monitor de lista de reproducción",
    ITEMS_TITLE: "Elementos de la papelera+",
    ITEMS_EMPTY_SONGS: "<strong>¡No hay canciones en la papelera!</strong><br/>Las canciones que agregues a la papelera aparecerán aquí.",
    ITEMS_EMPTY_ARTISTS: "<strong>¡Ningún artista en la papelera!</strong><br/>Los artistas que agregues a la papelera aparecerán aquí.",
    ITEMS_TAB_SONGS: "Canciones",
    ITEMS_TAB_ARTISTS: "Artistas",
    ITEMS_LOADED_COUNT: "{{loaded}} de {{total}} {{type}} cargados",
    DESCRIPTION_COPY: "Copiar todos los elementos de la papelera al portapapeles.",
    DESCRIPTION_EXPORT: "Guardar todos los elementos en la papelera en un archivo .json.",
    DESCRIPTION_IMPORT: "Sobrescribir todos los elementos en la papelera mediante el archivo .json.",
    DESCRIPTION_CLEAR: "Borrar todos los elementos de la papelera (no se puede deshacer).",
    ITEMS_EMPTY_SONGS_TITLE: "¡No hay canciones eliminadas!",
    ITEMS_EMPTY_ARTISTS_TITLE: "¡Ningún artista eliminado!",
    DESCRIPTION_SETTINGS_ENABLED: "Conmutador principal para activar o desactivar todas las funciones de Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Mostrar un icono de papelera en la barra de reproducción junto a la pista que se está reproduciendo para un acceso rápido",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Iniciar automáticamente la reproducción de música cuando se abra Spotify o se cargue la extensión",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Agrega íconos de basura junto a cada canción en tu cola próxima para una fácil gestión",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Agregar iconos de basura junto a las canciones en las vistas de álbum y lista de reproducción para filtrado rápido",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recupérate automáticamente de fallos en la reproducción de Spotify reanudando tu última lista de reproducción",
    SETTINGS_SKIP_TRASHED_TRACKS: "Omitir pistas eliminadas",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Omitir automáticamente las canciones eliminadas y encontrar la siguiente pista permitida durante la reproducción",
    SETTINGS_AUTO_CLEAN_QUEUE: "Cola de limpieza automática",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Eliminar automáticamente canciones eliminadas de tu cola de reproducción aleatoria inteligente",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Basura en la próxima tecla rápida",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Eliminar automáticamente la canción actual al usar el atajo de teclado Ctrl+Derecha para pasar a la siguiente pista",
    SETTINGS_REMOTE_CONTROL: "Control remoto",
    SETTINGS_REMOTE_TOGGLE: "Habilitar alternancia remota",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Toque dos veces reproducir/pausa desde el móvil para activar o desactivar el salto remoto de pistas. Un salto de pista confirma el cambio.",
    SETTINGS_REMOTE_SKIPPING: "Omitido remoto activo",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Cuando está activado, omitir la papelera funciona incluso cuando se controla Spotify desde otro dispositivo (por ejemplo, móvil)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Omisión remota habilitada",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Salto remoto desactivado",
    MESSAGE_SONG_ADDED_REMOTE: "Canción eliminada mediante control remoto",
    SETTINGS_TRASH_VIA_LIKE: "Basura a través de Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: 'Como una canción desde el móvil hasta la papelera. Automáticamente quita el "me gusta" y pasa a la siguiente pista.',
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/et.json
var require_et = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Prügikast+",
    ACTION_THROW: "Viska prügikasti",
    ACTION_UNTHROW: "Eemalda prügikastist",
    ACTION_CLEAR: "Selge",
    ACTION_COPY: "Kopeeri",
    ACTION_EXPORT: "Ekspordi",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Kopeeritud lõikelauale",
    MESSAGE_CLEARED: "Prügikast on edukalt tühjendatud!",
    MESSAGE_SONG_ADDED: "Laul lisatud prügikasti",
    MESSAGE_SONG_REMOVED: "Lugu eemaldati prügikastist",
    MESSAGE_ARTIST_ADDED: "Kunstnik lisatud prügikasti",
    MESSAGE_ARTIST_REMOVED: "Kunstnik eemaldati prügikastist",
    BACKUP_SAVE_SUCCESS: "Varundus edukalt salvestatud.",
    BACKUP_SAVE_FAILED: "Varunduse salvestamine ebaõnnestus, proovige prügikasti sisu kopeerimist lõikelauale ja varunduse käsitsi loomist.",
    BACKUP_RESTORE_SUCCESS: "Varundus taastati edukalt.",
    BACKUP_FILE_READ_FAILED: "Faili lugemine ebaõnnestus, veenduge, et see oleks sobiv JSON-fail.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Prügikasti+ seadistused",
    SETTINGS_OPTIONS: "Valikud",
    SETTINGS_FEATURES: "Omadused",
    SETTINGS_LOCAL_STORAGE: "Kohalik salvestus",
    SETTINGS_ENABLED: "Lubatud",
    SETTINGS_SHOW_WIDGET: "Kuva vidina ikoon",
    SETTINGS_AUTOPLAY: "Automaatne esitus käivitamisel",
    SETTINGS_QUEUE_TRASHBIN: "Luba järjekorra prügikast",
    SETTINGS_TRACKLIST_TRASHBIN: "Luba trellide korvi prügikast",
    SETTINGS_PLAYLIST_MONITOR: "Esitusloendi jälgija",
    ITEMS_TITLE: "Prügikasti+ esemed",
    ITEMS_EMPTY_SONGS: "<strong>Ühtegi prakskirjutatud laulu!</strong><br/>Lood, mille prakskasti lisad, ilmuvad siia.",
    ITEMS_EMPTY_ARTISTS: "<strong>Ära viska kunstnikke prügikasti!</strong><br/>Prügikasti lisatud kunstnikud ilmuvad siin.",
    ITEMS_TAB_SONGS: "Laulud",
    ITEMS_TAB_ARTISTS: "Kunstnikud",
    ITEMS_LOADED_COUNT: "{{loaded}} / {{total}} {{type}} laaditud",
    DESCRIPTION_COPY: "Kopeeri prügikasti kõik elemendid lõikepuhvrisse.",
    DESCRIPTION_EXPORT: "Salvesta kõik prügikasti asjad .json-faili.",
    DESCRIPTION_IMPORT: "Kirjuta kõik prügikasti üksused üle .json-faili kaudu.",
    DESCRIPTION_CLEAR: "Tühjenda prügikast täielikult (tegevust ei saa tagasi võtta).",
    ITEMS_EMPTY_SONGS_TITLE: "Mitte ühtegi räpust laulu!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Mitte ühtegi prügikasti visatud kunstnikku!",
    DESCRIPTION_SETTINGS_ENABLED: "Lüliti kogu prügikasti+ funktsionaalsuse lubamiseks või keelamiseks",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Kuvage esitusribal praegu mängiva loo kõrval kiirjuurdepääsuks prügikasti ikoon",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Alusta muusika esitamist automaatselt, kui Spotify avaneb või laiendus laaditakse",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Lisa igale järgmisele loosse kuulule prügikasti ikoonid mugava haldamise jaoks",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Lisa albumi ja esitusloendi vaadetes laulude kõrvale prügikasti ikoonid kiireks filtreerimiseks",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Taasta Spotify esitus automaatselt, jätkates viimast esitusloendit",
    SETTINGS_SKIP_TRASHED_TRACKS: "Jäta vahele prügikasti visatud lood",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Jäta automaatselt vahele prügikasti saatud lood ja leia esitamise ajal järgmine lubatud loend.",
    SETTINGS_AUTO_CLEAN_QUEUE: "Automaatne puhastusjärjekord",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Eemalda automaatselt prügikasti visatud lood oma nutikast juhuslikust esitusloendist",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Prügi järgmisel kiirklahvil",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Kohe prügikasti käesolev laul, kui järgmise loo juurde liikumiseks kasutada klaviatuuril Ctrl+parem",
    SETTINGS_REMOTE_CONTROL: "Kaugarvesti",
    SETTINGS_REMOTE_TOGGLE: "Luba kauglülitus",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Puudutage mobiilis kaks korda mängimise ja peatamise nuppu, et lülitada kaugel hüppe sisse/välja. Loendi järgmisele loole üleminek kinnitab lülitamise.",
    SETTINGS_REMOTE_SKIPPING: "Kaugarvatamine aktiivne",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Kui see on lubatud, töötab prügikasti vahelejätmine isegi siis, kui Spotifyd juhitakse mõnest teisest seadmest (nt mobiiltelefonist)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Kaugarajatusega jätkamine lubatud",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Kaugaraldus keelatud",
    MESSAGE_SONG_ADDED_REMOTE: "Lugu kustutati kaugjuhtimisega",
    SETTINGS_TRASH_VIA_LIKE: "Tähtajaline prügi",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Nagu laul mobiilist prügikasti. Eemaldab meeldimise automaatselt ja liigub järgmisele loole.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/eu.json
var require_eu = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Trashbin+",
    ACTION_THROW: "Jarri zakarrontzian",
    ACTION_UNTHROW: "Ezabatu zakarrontzitik",
    ACTION_CLEAR: "Garbi",
    ACTION_COPY: "Kopiatu",
    ACTION_EXPORT: "Esportatu",
    ACTION_IMPORT: "Inportatu",
    MESSAGE_COPIED: "Arbelean kopiatua",
    MESSAGE_CLEARED: "Zaborra ontzia ondo garbitu da!",
    MESSAGE_SONG_ADDED: "Abestia zakarrontzira gehitu da",
    MESSAGE_SONG_REMOVED: "Abestia zakarrontzitik kendu da",
    MESSAGE_ARTIST_ADDED: "Artist-a zakarrontzira gehitu da",
    MESSAGE_ARTIST_REMOVED: "Artistak zakarrontzitik kendua izan da",
    BACKUP_SAVE_SUCCESS: "Gehiegizko kopia ondo gorde da.",
    BACKUP_SAVE_FAILED: "Ezin izan da babeskopia gorde, saiatu zakarrontziko edukia arbelera kopiatzen eta babeskopia eskuz sortzen.",
    BACKUP_RESTORE_SUCCESS: "Backupa ondo berreskuratu da.",
    BACKUP_FILE_READ_FAILED: "Ezin izan da fitxategia irakurri, ziurtatu baliozko JSON fitxategia dela.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Trashbin+ ezarpenak",
    SETTINGS_OPTIONS: "Aukerak",
    SETTINGS_FEATURES: "Ezaugarriak",
    SETTINGS_LOCAL_STORAGE: "Gordetze lokala",
    SETTINGS_ENABLED: "Gaituta",
    SETTINGS_SHOW_WIDGET: "Erakutsi widgetaren ikonoa",
    SETTINGS_AUTOPLAY: "Hasi ber automatikoki",
    SETTINGS_QUEUE_TRASHBIN: "Gaitu ilararen zakarrontzia",
    SETTINGS_TRACKLIST_TRASHBIN: "Gaitu erreprodukzio-zerrendaren zakarrontzia",
    SETTINGS_PLAYLIST_MONITOR: "Playlist Monitorra",
    ITEMS_TITLE: "Trashbin+ elementuak",
    ITEMS_EMPTY_SONGS: "<strong>Ez da abestirik zakarrontzian!</strong><br/>Zakarrontzira gehitutako abestiak hemen agertuko dira.",
    ITEMS_EMPTY_ARTISTS: "<strong>Ez ezabatutako artista!</strong><br/>Zakarrontzira gehitutako artistak hemen agertuko dira.",
    ITEMS_TAB_SONGS: "Abestiak",
    ITEMS_TAB_ARTISTS: "Artistak",
    ITEMS_LOADED_COUNT: "{{total}}tik {{loaded}} {{type}} kargatu da",
    DESCRIPTION_COPY: "Kopiatu zakarrontziko elementu guztiak arbelean.",
    DESCRIPTION_EXPORT: "Gordetxo guztiak zakarrontzitik .json fitxategi batean gorde.",
    DESCRIPTION_IMPORT: "Ordezkatu zaborrontziko elementu guztiak .json fitxategiaren bidez.",
    DESCRIPTION_CLEAR: "Ezabatu zaborrontziko elementu guztiak (ezin da desegin).",
    ITEMS_EMPTY_SONGS_TITLE: "Ez da abestirik ezabatu!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Ez zaborraturiko artista!",
    DESCRIPTION_SETTINGS_ENABLED: "Gaitu edo desgaitu zakarrontzi+ funtzionaltasun guztia duen botoi nagusia",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Erakutsi zakarrontzi ikonoa erreproduzitzen ari den pista alboan dagoen erreproduzio-barran, lasterbide gisa",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Abestien erreproduzioa automatikoki hasi Spotify irekitzen denean edo luzapena kargatzen denean",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Gehitu zakarrontzi ikonoak zure hurrengo ilaran dauden abesti bakoitzaren ondoan kudeatzeko errazteko",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Gehitu zakarrontzi ikonoak albumen eta erreproduzio-zerrenden ikuspegietan abestien ondoan filtro azkarra egiteko",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Berreskuratu automatikoki Spotifyren erreproduzitze arazoak zure azken erreproduzio-zerrenda berrekin",
    SETTINGS_SKIP_TRASHED_TRACKS: "Saltatu Ezabatutako Pista",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Ezabatutako abestiak automatikoki saltatu eta erreproduzitzean ondorengo pista baimendua aurkitu",
    SETTINGS_AUTO_CLEAN_QUEUE: "Auto garbitu ilara",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Kendu automatikoki zakarreratuak izan diren abestiak zure ausazko iraultza-ilaratik",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Hurrengo laster-tekla erabiliz zakarreratua",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Erabili Ctrl+Eskuina teklatu lasterbidea hurrengo pista bat pasa eta uneko kanta automatikoki zakarrontzian jartzeko",
    SETTINGS_REMOTE_CONTROL: "Urruneko kontrola",
    SETTINGS_REMOTE_TOGGLE: "Gaitu urruneko txandakaketa",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Ukitu bikoitza play/pausa mugikorrean urruneko saltaketa gaitzeko/desgaitzeko. Pista bat saltatzeak eragiketa berretsi egiten du.",
    SETTINGS_REMOTE_SKIPPING: "Urruneko saltatzea aktibatuta",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Gaituta dagoenean, zakarrira bidaltzea saltatzea beste gailu batetik (adibidez, mugikorra) Spotify kontrolatzean ere funtzionatzen du",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Urruneko saltatzea gaituta",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Urruneko saltatzea desgaituta",
    MESSAGE_SONG_ADDED_REMOTE: "Kanta hondatua urruneko bidez",
    SETTINGS_TRASH_VIA_LIKE: "Zaborra nahi bezala",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Abestia bezala mugikidetik zakarrerako. Bere kabuz ezabesten du eta hurrengo pista pasatzen da.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/fa.json
var require_fa = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "سطل زباله+",
    ACTION_THROW: "در سطل زباله قرار بده",
    ACTION_UNTHROW: "حذف از سطل آشغال",
    ACTION_CLEAR: "شفاف",
    ACTION_COPY: "کپی",
    ACTION_EXPORT: "صادرات",
    ACTION_IMPORT: "وارد کردن",
    MESSAGE_COPIED: "کپی شد در کلیپ‌بورد",
    MESSAGE_CLEARED: "سطل آشغال با موفقیت خالی شد!",
    MESSAGE_SONG_ADDED: "آهنگ به سطل آشغال اضافه شد",
    MESSAGE_SONG_REMOVED: "آهنگ از زباله‌دان حذف شد",
    MESSAGE_ARTIST_ADDED: "هنرمند به سطل زباله اضافه شد",
    MESSAGE_ARTIST_REMOVED: "هنرمند از سطل زباله حذف شد",
    BACKUP_SAVE_SUCCESS: "پشتیبان با موفقیت ذخیره شد.",
    BACKUP_SAVE_FAILED: "ذخیره پشتیبان ناموفق بود، سعی کنید محتوای سطل زباله را کپی کرده و به صورت دستی یک پشتیبان ایجاد کنید.",
    BACKUP_RESTORE_SUCCESS: "پشتیبان با موفقیت بازیابی شد.",
    BACKUP_FILE_READ_FAILED: "خواندن فایل ناموفق بود، لطفاً مطمئن شوید که یک فایل JSON معتبر است.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "تنظیمات سطل زباله+",
    SETTINGS_OPTIONS: "گزینه‌ها",
    SETTINGS_FEATURES: "ویژگی‌ها",
    SETTINGS_LOCAL_STORAGE: "ذخیره‌سازی محلی",
    SETTINGS_ENABLED: "فعال شده",
    SETTINGS_SHOW_WIDGET: "نمایش آیکون ویجت",
    SETTINGS_AUTOPLAY: "پخش خودکار هنگام شروع",
    SETTINGS_QUEUE_TRASHBIN: "فعال‌سازی سطل آشغال صف",
    SETTINGS_TRACKLIST_TRASHBIN: "فعال‌سازی سطل زباله فهرست قطعات",
    SETTINGS_PLAYLIST_MONITOR: "مانیتور لیست پخش",
    ITEMS_TITLE: "موارد سطل زباله+",
    ITEMS_EMPTY_SONGS: "<strongهیچ آهنگ حذف‌شده‌ای وجود ندارد!</strong><br/>آهنگ‌هایی که به سطل زباله اضافه می‌کنید اینجا نمایش داده می‌شوند.",
    ITEMS_EMPTY_ARTISTS: "<strong>هیچ هنرمند حذف‌شده‌ای وجود ندارد!</strong><br/>هنرمندانی که به سطل زباله اضافه می‌کنید اینجا نمایش داده می‌شوند.",
    ITEMS_TAB_SONGS: "ترانه‌ها",
    ITEMS_TAB_ARTISTS: "هنرمندان",
    ITEMS_LOADED_COUNT: "{{loaded}} از {{total}} {{type}} بارگذاری شد",
    DESCRIPTION_COPY: "همهٔ موارد موجود در سطل آشغال را به کلیپ‌بورد کپی کنید.",
    DESCRIPTION_EXPORT: "ذخیره تمام موارد در سطل آشغال به یک فایل .json",
    DESCRIPTION_IMPORT: "جایگزینی تمام موارد در سطل زباله از طریق فایل .json",
    DESCRIPTION_CLEAR: "تمام موارد را از سطل آشغال حذف کنید (قابل بازگشت نیست).",
    ITEMS_EMPTY_SONGS_TITLE: "هیچ آهنگ حذف شده‌ای وجود ندارد!",
    ITEMS_EMPTY_ARTISTS_TITLE: "هیچ هنرمند حذف شدهای!",
    DESCRIPTION_SETTINGS_ENABLED: "کلید اصلی برای فعال یا غیرفعال کردن تمام عملکردهای Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "نمایش یک آیکون سطل آشغال در نوار پخش کنار قطعه‌ای که در حال پخش است، برای دسترسی سریع",
    DESCRIPTION_SETTINGS_AUTOPLAY: "پخش خودکار موسیقی هنگام باز شدن اسپاتیفای یا بارگذاری افزونه",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "آیکون‌های سطل آشغال را کنار هر آهنگ در صف آینده‌تان اضافه کنید تا مدیریت آسان‌تری داشته باشید",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "آیکون‌های سطل آشغال را کنار آهنگ‌ها در نمای آلبوم و فهرست پخش اضافه کنید تا فیلتر سریع امکان‌پذیر شود",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "بازیابی خودکار از مشکلات پخش اسپاتیفای با ادامه دادن آخرین لیست پخش شما",
    SETTINGS_SKIP_TRASHED_TRACKS: "رد کردن مسیرهای حذف‌شده",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "به‌طور خودکار آهنگ‌های حذف‌شده را رد کنید و در هنگام پخش، قطعه بعدی مجاز را پیدا کنید",
    SETTINGS_AUTO_CLEAN_QUEUE: "صف خالی کردن خودکار",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "حذف خودکار آهنگ‌های سطل آشغال از صف پخش تصادفی هوشمند شما",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "زباله در هات‌کی بعدی",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "هنگام استفاده از میانبر کیبوردی Ctrl+راست برای پرش به قطعه بعدی، قطعه فعلی به‌طور خودکار به سطل زباله منتقل شود",
    SETTINGS_REMOTE_CONTROL: "کنترل از راه دور",
    SETTINGS_REMOTE_TOGGLE: "فعال‌سازی تغییر از راه دور",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "دو بار لمس کردن دکمه پخش/مکث از موبایل برای فعال یا غیرفعال کردن رد کردن از راه دور. رد شدن از یک قطعه، تغییر حالت را تأیید می‌کند.",
    SETTINGS_REMOTE_SKIPPING: "پرش از راه دور فعال است",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "هنگامی که فعال است، رد کردن موزیک‌های سطل آشغال حتی هنگام کنترل اسپاتیفای از دستگاه دیگری (مثلاً تلفن همراه) نیز کار می‌کند",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "پرش از راه دور فعال شد",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "پرش از راه دور غیرفعال شده است",
    MESSAGE_SONG_ADDED_REMOTE: "آهنگ از راه دور حذف شد",
    SETTINGS_TRASH_VIA_LIKE: "زباله از طریق لایک",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "مثل یک آهنگ از موبایل به سطل زباله. به صورت خودکار لایک را پس می‌گیرد و به موسیقی بعدی می‌رود.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/fi.json
var require_fi = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Roskakori+",
    ACTION_THROW: "Laita roskakoriin",
    ACTION_UNTHROW: "Poista roskakorista",
    ACTION_CLEAR: "Selkeä",
    ACTION_COPY: "Kopioi",
    ACTION_EXPORT: "Vie",
    ACTION_IMPORT: "Tuo",
    MESSAGE_COPIED: "Kopioitu leikepöydälle",
    MESSAGE_CLEARED: "Roskakori tyhjennetty onnistuneesti!",
    MESSAGE_SONG_ADDED: "Kappale lisätty roskakoriin",
    MESSAGE_SONG_REMOVED: "Kappale poistettu roskakorista",
    MESSAGE_ARTIST_ADDED: "Taiteilija lisätty roskakoriin",
    MESSAGE_ARTIST_REMOVED: "Taiteilija poistettu roskakorista",
    BACKUP_SAVE_SUCCESS: "Varmuuskopio tallennettu onnistuneesti.",
    BACKUP_SAVE_FAILED: "Varmuuskopiota ei voitu tallentaa, yritä kopioida roskakorin sisältö leikepöydälle ja luo varmuuskopio manuaalisesti.",
    BACKUP_RESTORE_SUCCESS: "Varmuuskopio palautettu onnistuneesti.",
    BACKUP_FILE_READ_FAILED: "Tiedoston lukeminen epäonnistui, varmista että se on kelvollinen JSON-tiedosto.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Roskakori+ -asetukset",
    SETTINGS_OPTIONS: "Asetukset",
    SETTINGS_FEATURES: "Ominaisuudet",
    SETTINGS_LOCAL_STORAGE: "Paikallinen tallennus",
    SETTINGS_ENABLED: "Käytössä",
    SETTINGS_SHOW_WIDGET: "Näytä widgetin kuvake",
    SETTINGS_AUTOPLAY: "Käynnistä automaattitoisto käynnistyksen yhteydessä",
    SETTINGS_QUEUE_TRASHBIN: "Ota käyttöön jonon roskakori",
    SETTINGS_TRACKLIST_TRASHBIN: "Ota käyttöön soittolistan roskakori",
    SETTINGS_PLAYLIST_MONITOR: "Soittolistan valvoja",
    ITEMS_TITLE: "Roskakori+ -tuotteet",
    ITEMS_EMPTY_SONGS: "<strong>Ei roskikseen laitettuja kappaleita!</strong><br/>Kappaleet, jotka lisäät roskikseen, ilmestyvät tähän.",
    ITEMS_EMPTY_ARTISTS: "<strong>Ei roskakoriin laitettuja artisteja!</strong><br/>Roskakoriin lisäämäsi artistit ilmestyvät tähän.",
    ITEMS_TAB_SONGS: "Laulut",
    ITEMS_TAB_ARTISTS: "Taiteilijat",
    ITEMS_LOADED_COUNT: "{{loaded}} / {{total}} {{type}} ladattu",
    DESCRIPTION_COPY: "Kopioi kaikki roskakorissa olevat kohteet leikepöydälle.",
    DESCRIPTION_EXPORT: "Tallenna kaikki roskakorissa olevat kohteet .json-tiedostoon.",
    DESCRIPTION_IMPORT: "Korvaa kaikki roskakorin kohteet .json-tiedostolla.",
    DESCRIPTION_CLEAR: "Tyhjennä kaikki kohteet roskakorista (toimintoa ei voi kumota).",
    ITEMS_EMPTY_SONGS_TITLE: "Ei hävitettyjä kappaleita!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Ei roskaa taideteoksia!",
    DESCRIPTION_SETTINGS_ENABLED: "Pääkytkin kaikkien Roskakori+-toimintojen käyttöön ottamiseksi tai poistamiseksi",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Näytä roskakorikuvake toistopalkissa pariksi toistettavan kappaleen viereen nopeaa käyttöä varten",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Käynnistä musiikin toisto automaattisesti, kun Spotify avataan tai laajennus latautuu",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Lisää roskakorikuvakkeet jokaisen kappaleen viereen tulevassa soittolistassasi helpompaa hallintaa varten",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Lisää roskakorikuvakkeet kappaleiden viereen albumi- ja soittolista-näkymissä nopeaa suodatusta varten",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Palautuu automaattisesti Spotify-soittovirheistä jatkamalla viimeistä soittolistaa",
    SETTINGS_SKIP_TRASHED_TRACKS: "Ohita poistetut kappaleet",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Ohita automaattisesti roskakoriin siirretyt kappaleet ja etsi seuraava sallittu kappale toiston aikana",
    SETTINGS_AUTO_CLEAN_QUEUE: "Automaattinen siivousjono",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Poista roskakoriin siirretyt kappaleet automaattisesti Smart Shuffle -jonostasi",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Roska seuraavalla pikakäskyllä",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Siirrä nykyinen kappale roskakoriin automaattisesti, kun seuraavaan kappaleeseen siirrytään näppäinyhdistelmällä Ctrl+Oikea",
    SETTINGS_REMOTE_CONTROL: "Kauko-ohjain",
    SETTINGS_REMOTE_TOGGLE: "Ota etäkytkin käyttöön",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Kaksoisnapauta toisto/tauko matkapuhelimessa vaihtaaksesi etäohjauksen ohituksen päälle/pois. Kappaleen ohitus vahvistaa vaihtoehdon.",
    SETTINGS_REMOTE_SKIPPING: "Etäohjattu ohitus aktiivinen",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Kun tämä on käytössä, roskakori ohitetaan myös, kun Spotifya ohjataan toisesta laitteesta (esim. mobiililaitteesta)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Etäohjattu ohitus käytössä",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Etäohjauksella ohittaminen poistettu käytöstä",
    MESSAGE_SONG_ADDED_REMOTE: "Kappale tuhottu kauko-ohjauksella",
    SETTINGS_TRASH_VIA_LIKE: "Roska via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Kuten kappale, joka siirtyy kännykästä roskikseen. Poistaa tykkäyksen automaattisesti ja siirtyy seuraavaan kappaleeseen.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/fil.json
var require_fil = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Basurahan+",
    ACTION_THROW: "Ilagay sa Trashbin",
    ACTION_UNTHROW: "Alisin mula sa Basurahan",
    ACTION_CLEAR: "Malinaw",
    ACTION_COPY: "Kopyahin",
    ACTION_EXPORT: "I-export",
    ACTION_IMPORT: "I-import",
    MESSAGE_COPIED: "Kinopya sa clipboard",
    MESSAGE_CLEARED: "Matagumpay na inalis ang basura sa basurahan!",
    MESSAGE_SONG_ADDED: "Idinagdag ang kanta sa basurahan",
    MESSAGE_SONG_REMOVED: "Inalis ang kanta mula sa basurahan",
    MESSAGE_ARTIST_ADDED: "Idinagdag ang artista sa basurahan",
    MESSAGE_ARTIST_REMOVED: "Artistang inalis mula sa basurahan",
    BACKUP_SAVE_SUCCESS: "Matagumpay na nai-save ang backup.",
    BACKUP_SAVE_FAILED: "Hindi na-save ang backup, subukang kopyahin ang nilalaman ng trashbin sa clipboard at gumawa ng backup nang manu-mano.",
    BACKUP_RESTORE_SUCCESS: "Matagumpay na naibalik ang backup.",
    BACKUP_FILE_READ_FAILED: "Hindi mabasa ang file, mangyaring tiyakin na ito ay isang wastong JSON file.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Mga Setting ng Trashbin+",
    SETTINGS_OPTIONS: "Mga Pagpipilian",
    SETTINGS_FEATURES: "Mga Tampok",
    SETTINGS_LOCAL_STORAGE: "Lokal na Imbakan",
    SETTINGS_ENABLED: "Naka-enable",
    SETTINGS_SHOW_WIDGET: "Ipakita ang Icon ng Widget",
    SETTINGS_AUTOPLAY: "I-play nang awtomatiko sa Pagbubukod",
    SETTINGS_QUEUE_TRASHBIN: "I-enable ang Queue Trashbin",
    SETTINGS_TRACKLIST_TRASHBIN: "I-enable ang Tracklist Trashbin",
    SETTINGS_PLAYLIST_MONITOR: "Playlist Monitor",
    ITEMS_TITLE: "Mga Item sa Basurahan+",
    ITEMS_EMPTY_SONGS: "<strong>Walang mga itinapon na kanta!</strong><br/>Ang mga kantang idinagdag mo sa trashbin ay lilitaw dito.",
    ITEMS_EMPTY_ARTISTS: "<strong>Walang mga itinapon na artista!</strong><br/>Ang mga artista na idinagdag mo sa trashbin ay lilitaw dito.",
    ITEMS_TAB_SONGS: "Mga kanta",
    ITEMS_TAB_ARTISTS: "Mga Artista",
    ITEMS_LOADED_COUNT: "{{loaded}} ng {{total}} {{type}} na-load",
    DESCRIPTION_COPY: "Kopyahin ang lahat ng item sa trashbin sa clipboard.",
    DESCRIPTION_EXPORT: "I-save ang lahat ng mga item sa trashbin sa isang file na .json.",
    DESCRIPTION_IMPORT: "Isulat muli ang lahat ng mga item sa trashbin gamit ang .json file.",
    DESCRIPTION_CLEAR: "Tanggalin ang lahat ng mga item mula sa basurahan (hindi ito maibabalik).",
    ITEMS_EMPTY_SONGS_TITLE: "Walang mga itinapong kanta!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Walang mga nasirang artista!",
    DESCRIPTION_SETTINGS_ENABLED: "Pangunahing toggle para paganahin o i-disable ang lahat ng mga tungkulin ng Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Ipakita ang icon ng basurahan sa playback bar sa tabi ng kasalukuyang nagpe-play na track para sa mabilis na pag-access",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Awtomatikong maglalaro ng musika kapag binuksan ang Spotify o nai-load ang extension",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Magdagdag ng mga icon ng basura sa tabi ng bawat kanta sa iyong susunod na queue para sa madaling pamamahala",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Magdagdag ng mga icon ng basura sa tabi ng mga kanta sa mga view ng album at playlist para sa mabilis na pag-filter",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Awtomatikong makabawi mula sa mga glitch sa pag-playback ng Spotify sa pamamagitan ng pagpapatuloy sa iyong huling playlist",
    SETTINGS_SKIP_TRASHED_TRACKS: "Laktawan ang mga Nasirang Track",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Awtomatikong laktawan ang mga itinapon na kanta at hanapin ang susunod na pinapayagang track habang nagpe-play",
    SETTINGS_AUTO_CLEAN_QUEUE: "Awtomatikong Linisin ang Queue",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Awtomatikong alisin ang mga itinapon na kanta mula sa iyong Smart Shuffle na pila",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Basura sa Susunod na Hotkey",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Awtomatikong itapon ang kasalukuyang kanta kapag gumagamit ng Ctrl+Right na shortcut sa keyboard upang laktawan patungo sa susunod na track",
    SETTINGS_REMOTE_CONTROL: "Remote Control",
    SETTINGS_REMOTE_TOGGLE: "Paganahin ang Remote Toggle",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "I-doble i-tap ang play/pause mula sa mobile para i-on o i-off ang remote skipping. Ang pag-skip ng track ay nagko-confirm sa toggle.",
    SETTINGS_REMOTE_SKIPPING: "Aktibong Paglilipat sa Remote",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Kapag pinagana, gumagana ang pag-skip sa basura kahit na kinokontrol ang Spotify mula sa ibang device (hal., mobile)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Pinagana ang remote skipping",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Hindi pinagana ang remote skipping",
    MESSAGE_SONG_ADDED_REMOTE: "Sinira ang kanta sa pamamagitan ng remote",
    SETTINGS_TRASH_VIA_LIKE: "Basura sa pamamagitan ng Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Tulad ng isang kanta mula sa mobile na itinapon. Awtomatikong inu-unlike at lumilipat sa susunod na track.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/fr-CA.json
var require_fr_CA = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Corbeille+",
    ACTION_THROW: "Placer dans la corbeille",
    ACTION_UNTHROW: "Supprimer de la Corbeille",
    ACTION_CLEAR: "Clair",
    ACTION_COPY: "Copier",
    ACTION_EXPORT: "Exporter",
    ACTION_IMPORT: "Importer",
    MESSAGE_COPIED: "Copié dans le presse-papiers",
    MESSAGE_CLEARED: "Corbeille vidée avec succès !",
    MESSAGE_SONG_ADDED: "Chanson ajoutée à la corbeille",
    MESSAGE_SONG_REMOVED: "Chanson supprimée de la corbeille",
    MESSAGE_ARTIST_ADDED: "Artiste ajouté à la corbeille",
    MESSAGE_ARTIST_REMOVED: "Artiste retiré de la corbeille",
    BACKUP_SAVE_SUCCESS: "Sauvegarde effectuée avec succès.",
    BACKUP_SAVE_FAILED: "Échec de la sauvegarde. Essayez de copier le contenu de la corbeille dans le presse-papiers et de créer une sauvegarde manuellement.",
    BACKUP_RESTORE_SUCCESS: "Sauvegarde restaurée avec succès.",
    BACKUP_FILE_READ_FAILED: "Échec de la lecture du fichier, veuillez vous assurer qu'il s'agit d'un fichier JSON valide.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-poubelle.json",
    SETTINGS_TITLE: "Paramètres de Trashbin+",
    SETTINGS_OPTIONS: "Options",
    SETTINGS_FEATURES: "Fonctionnalités",
    SETTINGS_LOCAL_STORAGE: "Stockage local",
    SETTINGS_ENABLED: "Activé",
    SETTINGS_SHOW_WIDGET: "Afficher l'icône du widget",
    SETTINGS_AUTOPLAY: "Lecture automatique au démarrage",
    SETTINGS_QUEUE_TRASHBIN: "Activer la corbeille de la file d'attente",
    SETTINGS_TRACKLIST_TRASHBIN: "Activer la corbeille de la liste de pistes",
    SETTINGS_PLAYLIST_MONITOR: "Moniteur de liste de lecture",
    ITEMS_TITLE: "Éléments de la corbeille+",
    ITEMS_EMPTY_SONGS: "<strong>Aucune chanson dans la corbeille !</strong><br/>Les chansons que vous ajoutez à la corbeille apparaîtront ici.",
    ITEMS_EMPTY_ARTISTS: "<strong>Aucun artiste dans la corbeille !</strong><br/>Les artistes que vous ajoutez à la corbeille apparaîtront ici.",
    ITEMS_TAB_SONGS: "Chansons",
    ITEMS_TAB_ARTISTS: "Artistes",
    ITEMS_LOADED_COUNT: "{{loaded}} sur {{total}} {{type}} chargé(s)",
    DESCRIPTION_COPY: "Copier tous les éléments de la corbeille dans le presse-papiers.",
    DESCRIPTION_EXPORT: "Enregistrer tous les éléments de la corbeille dans un fichier .json.",
    DESCRIPTION_IMPORT: "Remplacer tous les éléments de la corbeille via le fichier .json.",
    DESCRIPTION_CLEAR: "Effacer tous les éléments de la corbeille (impossible à annuler).",
    ITEMS_EMPTY_SONGS_TITLE: "Aucune chanson supprimée !",
    ITEMS_EMPTY_ARTISTS_TITLE: "Aucun artiste supprimé !",
    DESCRIPTION_SETTINGS_ENABLED: "Commande principale pour activer ou désactiver toutes les fonctionnalités de Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Afficher une icône de corbeille dans la barre de lecture à côté de la piste en cours de lecture pour un accès rapide",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Lancer automatiquement la lecture de musique lorsque Spotify s'ouvre ou que l'extension se charge",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Ajoutez des icônes de corbeille à côté de chaque chanson dans votre file d'attente à venir pour une gestion facile",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Ajouter des icônes de corbeille à côté des chansons dans les vues d'album et de liste de lecture pour un filtrage rapide",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Récupérez automatiquement des problèmes de lecture sur Spotify en reprenant votre dernière playlist",
    SETTINGS_SKIP_TRASHED_TRACKS: "Ignorer les pistes supprimées",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Passer automatiquement les chansons supprimées et trouver la piste autorisée suivante pendant la lecture",
    SETTINGS_AUTO_CLEAN_QUEUE: "File d'attente de nettoyage automatique",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Supprimer automatiquement les chansons supprimées de votre file d'attente Smart Shuffle",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Corbeille à la prochaine touche de raccourci",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Placer automatiquement la chanson actuelle dans la corbeille lors de l'utilisation du raccourci clavier Ctrl+Flèche droite pour passer au morceau suivant",
    SETTINGS_REMOTE_CONTROL: "Télécommande",
    SETTINGS_REMOTE_TOGGLE: "Activer la bascule à distance",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Appuyez deux fois sur lecture/pause depuis votre mobile pour activer ou désactiver la fonction de saut de piste à distance. Le saut d'une piste confirme le changement d'état.",
    SETTINGS_REMOTE_SKIPPING: "Passage à distance activé",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Lorsqu'elle est activée, la fonction de saut de la corbeille fonctionne même lorsque vous contrôlez Spotify à partir d'un autre appareil (par exemple, un appareil mobile).",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Ignorer à distance activé",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Saut à distance désactivé",
    MESSAGE_SONG_ADDED_REMOTE: "Chanson supprimée à distance",
    SETTINGS_TRASH_VIA_LIKE: "Déchets via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Comme une chanson provenant d'un mobile à supprimer. Supprime automatiquement le « j'aime » et passe au morceau suivant.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/fr.json
var require_fr = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Corbeille+",
    ACTION_THROW: "Placer dans la corbeille",
    ACTION_UNTHROW: "Supprimer de la corbeille",
    ACTION_CLEAR: "Clair",
    ACTION_COPY: "Copier",
    ACTION_EXPORT: "Exporter",
    ACTION_IMPORT: "Importer",
    MESSAGE_COPIED: "Copié dans le presse-papiers",
    MESSAGE_CLEARED: "Corbeille vidée avec succès !",
    MESSAGE_SONG_ADDED: "Chanson ajoutée à la corbeille",
    MESSAGE_SONG_REMOVED: "Chanson supprimée de la corbeille",
    MESSAGE_ARTIST_ADDED: "Artiste ajouté à la corbeille",
    MESSAGE_ARTIST_REMOVED: "Artiste supprimé de la corbeille",
    BACKUP_SAVE_SUCCESS: "Sauvegarde effectuée avec succès.",
    BACKUP_SAVE_FAILED: "Échec de la sauvegarde, essayez de copier le contenu de la corbeille dans le presse-papiers et de créer une sauvegarde manuellement.",
    BACKUP_RESTORE_SUCCESS: "Sauvegarde restaurée avec succès.",
    BACKUP_FILE_READ_FAILED: "Échec de la lecture du fichier, veuillez vous assurer qu'il s'agit d'un fichier JSON valide.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Paramètres de Trashbin+",
    SETTINGS_OPTIONS: "Options",
    SETTINGS_FEATURES: "Caractéristiques",
    SETTINGS_LOCAL_STORAGE: "Stockage local",
    SETTINGS_ENABLED: "Activé",
    SETTINGS_SHOW_WIDGET: "Afficher l'icône du widget",
    SETTINGS_AUTOPLAY: "Lecture automatique au démarrage",
    SETTINGS_QUEUE_TRASHBIN: "Activer la corbeille de la file d'attente",
    SETTINGS_TRACKLIST_TRASHBIN: "Activer la corbeille de la liste de lecture",
    SETTINGS_PLAYLIST_MONITOR: "Moniteur de playlist",
    ITEMS_TITLE: "Éléments de la corbeille+",
    ITEMS_EMPTY_SONGS: "<strong>Aucune chanson dans la corbeille !</strong><br/>Les chansons que vous ajoutez à la corbeille apparaîtront ici.",
    ITEMS_EMPTY_ARTISTS: "<strong>Aucun artiste supprimé !</strong><br/>Les artistes que vous ajoutez à la corbeille apparaîtront ici.",
    ITEMS_TAB_SONGS: "Chansons",
    ITEMS_TAB_ARTISTS: "Artistes",
    ITEMS_LOADED_COUNT: "{{loaded}} sur {{total}} {{type}} chargés",
    DESCRIPTION_COPY: "Copier tous les éléments de la corbeille dans le presse-papiers.",
    DESCRIPTION_EXPORT: "Enregistrer tous les éléments de la corbeille dans un fichier .json.",
    DESCRIPTION_IMPORT: "Écraser tous les éléments de la corbeille via le fichier .json.",
    DESCRIPTION_CLEAR: "Effacer tous les éléments de la corbeille (action irréversible).",
    ITEMS_EMPTY_SONGS_TITLE: "Pas de chansons supprimées !",
    ITEMS_EMPTY_ARTISTS_TITLE: "Pas d'artistes jetés !",
    DESCRIPTION_SETTINGS_ENABLED: "Commutateur principal pour activer ou désactiver toutes les fonctionnalités de Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Afficher une icône de corbeille dans la barre de lecture à côté de la piste en cours de lecture pour un accès rapide",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Lancer automatiquement la lecture de musique lorsque Spotify s'ouvre ou que l'extension se charge",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Ajoutez des icônes de corbeille à côté de chaque chanson dans votre file d'attente à venir pour une gestion facile",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Ajouter des icônes de corbeille à côté des chansons dans les vues album et playlist pour un filtrage rapide",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Récupération automatique des problèmes de lecture sur Spotify en reprenant votre dernière playlist",
    SETTINGS_SKIP_TRASHED_TRACKS: "Ignorer les pistes supprimées",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Ignorer automatiquement les chansons supprimées et trouver la prochaine piste autorisée pendant la lecture",
    SETTINGS_AUTO_CLEAN_QUEUE: "File de nettoyage automatique",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Supprimer automatiquement les chansons supprimées de votre file d'attente Smart Shuffle",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Poubelle sur le prochain raccourci clavier",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Supprimer automatiquement la chanson en cours lors de l'utilisation du raccourci clavier Ctrl+Flèche droite pour passer au morceau suivant",
    SETTINGS_REMOTE_CONTROL: "Télécommande",
    SETTINGS_REMOTE_TOGGLE: "Activer la bascule à distance",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Appuyez deux fois sur lecture/pause depuis le mobile pour activer ou désactiver la fonction de saut de piste à distance. Le saut d'une piste confirme le changement d'état.",
    SETTINGS_REMOTE_SKIPPING: "Passage à distance actif",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Lorsqu'elle est activée, la fonction de saut de la corbeille fonctionne même lorsqu'on contrôle Spotify depuis un autre appareil (par exemple, un téléphone mobile).",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Saut à distance activé",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Saut à distance désactivé",
    MESSAGE_SONG_ADDED_REMOTE: "Chanson supprimée à distance",
    SETTINGS_TRASH_VIA_LIKE: "Poubelle via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: `Comme une chanson provenant d'un mobile à supprimer. Supprime automatiquement le "like" et passe au morceau suivant.`,
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/gl.json
var require_gl = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Lixo+",
    ACTION_THROW: "Colocar no lixo",
    ACTION_UNTHROW: "Eliminar da lixeira",
    ACTION_CLEAR: "Claro",
    ACTION_COPY: "Copiar",
    ACTION_EXPORT: "Exportar",
    ACTION_IMPORT: "Importar",
    MESSAGE_COPIED: "Copiado no portapapeis",
    MESSAGE_CLEARED: "Papeleira baleirada satisfactoriamente!",
    MESSAGE_SONG_ADDED: "Canción engadida á lixeira",
    MESSAGE_SONG_REMOVED: "Canción eliminada do lixo",
    MESSAGE_ARTIST_ADDED: "Artista engadido á lixeira",
    MESSAGE_ARTIST_REMOVED: "Artista eliminado do lixo",
    BACKUP_SAVE_SUCCESS: "Copia de seguridade gardada satisfactoriamente.",
    BACKUP_SAVE_FAILED: "Non foi posíbel gardar a copia de seguridade, probe copiar o contido do lixo no portapapeis e crear unha copia de seguridade manualmente.",
    BACKUP_RESTORE_SUCCESS: "Copia de seguridade restaurada correctamente.",
    BACKUP_FILE_READ_FAILED: "Non foi posíbel ler o ficheiro, asegúrese de que é un ficheiro JSON válido.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Configuración de Trashbin+",
    SETTINGS_OPTIONS: "Opcións",
    SETTINGS_FEATURES: "Características",
    SETTINGS_LOCAL_STORAGE: "Almacenamento local",
    SETTINGS_ENABLED: "Activado",
    SETTINGS_SHOW_WIDGET: "Amosar icona do widget",
    SETTINGS_AUTOPLAY: "Reprodución automática ao iniciar",
    SETTINGS_QUEUE_TRASHBIN: "Activar a lixeira da cola",
    SETTINGS_TRACKLIST_TRASHBIN: "Activar o lixo da lista de pistas",
    SETTINGS_PLAYLIST_MONITOR: "Monitor de listas de reprodución",
    ITEMS_TITLE: "Elementos de Lixo+",
    ITEMS_EMPTY_SONGS: "<strong>Sen cancións no lixo!</strong><br/>As cancións que engadas ao lixo aparecerán aquí.",
    ITEMS_EMPTY_ARTISTS: "<strong>Sen artistas na lixeira!</strong><br/>Os artistas que engadas á lixeira aparecerán aquí.",
    ITEMS_TAB_SONGS: "Cancións",
    ITEMS_TAB_ARTISTS: "Artistas",
    ITEMS_LOADED_COUNT: "{{loaded}} de {{total}} {{type}} cargados",
    DESCRIPTION_COPY: "Copiar todos os elementos do lixo no portapapeis.",
    DESCRIPTION_EXPORT: "Gardar todos os elementos no lixo nun ficheiro .json.",
    DESCRIPTION_IMPORT: "Substituír todos os elementos no lixo mediante ficheiro .json.",
    DESCRIPTION_CLEAR: "Borrar todos os elementos da lixeira (non se pode desfacer).",
    ITEMS_EMPTY_SONGS_TITLE: "Sen cancións eliminadas!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Ningún artista eliminado!",
    DESCRIPTION_SETTINGS_ENABLED: "Interruptor principal para activar ou desactivar todas as funcións de Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Amosar unha icona de lixo na barra de reprodución xunto á pista que se está reproducindo para un acceso rápido",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Iniciar automaticamente a reprodución de música cando se abra Spotify ou cargue a extensión",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Engadir iconas de lixo ao carón de cada canción na cola próxima para unha xestión sinxela",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Engadir iconas de lixo ao lado das cancións nas vistas de álbum e lista de reprodución para un filtrado rápido",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recupera automaticamente dos fallos de reprodución de Spotify retomando a túa última lista de reprodución",
    SETTINGS_SKIP_TRASHED_TRACKS: "Omitir pistas eliminadas",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Saltar automaticamente as cancións eliminadas e atopar a seguinte pista permitida durante a reprodución",
    SETTINGS_AUTO_CLEAN_QUEUE: "Cola de limpeza automática",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Elimina automaticamente as cancións eliminadas da cola de reproducción aleatoria intelixente",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Lixeira na seguinte tecla rápida",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Eliminar automaticamente a canción actual cando se usa o atallo de teclado Ctrl+Dereita para pasar á seguinte pista",
    SETTINGS_REMOTE_CONTROL: "Control remoto",
    SETTINGS_REMOTE_TOGGLE: "Activar interruptor remoto",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Toque dúas veces en reproducir/pausa desde o móbil para activar/desactivar o salto remoto. Un salto de pista confirma o cambio.",
    SETTINGS_REMOTE_SKIPPING: "Omitido remoto activo",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Cando está activado, omitir a lixeira funciona incluso cando se controla Spotify desde outro dispositivo (por exemplo, móbil)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Omitido remoto activado",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "O salto remoto está desactivado",
    MESSAGE_SONG_ADDED_REMOTE: "Canción eliminada á distancia",
    SETTINGS_TRASH_VIA_LIKE: "Lixo vía Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: 'Como unha canción do móbil a bórlaa. Elimina o "gústame" e pasa automaticamente á seguinte pista.',
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/gu.json
var require_gu = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ટ્રાશબિન+",
    ACTION_THROW: "ટ્રાશબિનમાં મૂકો",
    ACTION_UNTHROW: "કચરાપેટીમાંથી દૂર કરો",
    ACTION_CLEAR: "સ્પષ્ટ",
    ACTION_COPY: "નકલ કરો",
    ACTION_EXPORT: "નિકાસ",
    ACTION_IMPORT: "આયાત",
    MESSAGE_COPIED: "ક્લિપબોર્ડ પર કૉપિ કર્યું",
    MESSAGE_CLEARED: "ટ્રાશબિન સફળતાપૂર્વક સાફ કરવામાં આવી!",
    MESSAGE_SONG_ADDED: "ગીત કચરાપેટીમાં ઉમેરાયું",
    MESSAGE_SONG_REMOVED: "ગીત કચરાપેટીમાંથી દૂર કરાયું",
    MESSAGE_ARTIST_ADDED: "કલાકારને કચરાપેટીમાં ઉમેરાયો",
    MESSAGE_ARTIST_REMOVED: "કલાકારને કચરાપેટીમાંથી દૂર કરવામાં આવ્યો",
    BACKUP_SAVE_SUCCESS: "બેકઅપ સફળતાપૂર્વક સાચવાયું.",
    BACKUP_SAVE_FAILED: "બેકઅપ સેવ કરવામાં નિષ્ફળ, ત્રાશબિનની સામગ્રીને ક્લિપબોર્ડ પર કૉપિ કરીને મેન્યુઅલ રીતે બેકઅપ બનાવવાનો પ્રયત્ન કરો.",
    BACKUP_RESTORE_SUCCESS: "બેકઅપ સફળતાપૂર્વક પુનઃસ્થાપિત થયું.",
    BACKUP_FILE_READ_FAILED: "ફાઇલ વાંચવામાં નિષ્ફળ, કૃપા કરીને ખાતરી કરો કે તે માન્ય JSON ફાઇલ છે.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ટ્રાશબિન+ સેટિંગ્સ",
    SETTINGS_OPTIONS: "વિકલ્પો",
    SETTINGS_FEATURES: "સુવિધાઓ",
    SETTINGS_LOCAL_STORAGE: "સ્થાનિક સંગ્રહ",
    SETTINGS_ENABLED: "સક્ષમ",
    SETTINGS_SHOW_WIDGET: "વિજેટ આઇકન બતાવો",
    SETTINGS_AUTOPLAY: "શરૂઆતમાં ઓટોપ્લે",
    SETTINGS_QUEUE_TRASHBIN: "ક્યૂ ટ્રાશબિન સક્ષમ કરો",
    SETTINGS_TRACKLIST_TRASHBIN: "ટ્રેકલિસ્ટ કચરાપેટી સક્ષમ કરો",
    SETTINGS_PLAYLIST_MONITOR: "પ્લેલિસ્ટ મોનિટર",
    ITEMS_TITLE: "ટ્રાશબિન+ આઇટમ્સ",
    ITEMS_EMPTY_SONGS: "<strong>કોઈ ફેંકાયેલા ગીતો નથી!</strong><br/>તમે કચરાપેટીમાં ઉમેરેલા ગીતો અહીં દેખાશે.",
    ITEMS_EMPTY_ARTISTS: "<strong>કોઈ કચરો કલાકારો નહીં!</strong><br/>તમે કચરાપેટીમાં ઉમેરેલા કલાકારો અહીં દેખાશે.",
    ITEMS_TAB_SONGS: "ગીતો",
    ITEMS_TAB_ARTISTS: "કલાકારો",
    ITEMS_LOADED_COUNT: "{{total}} માંથી {{loaded}} {{type}} લોડ થયેલ છે",
    DESCRIPTION_COPY: "ટ્રાશબિનમાં બધી વસ્તુઓની ક્લિપબોર્ડ પર નકલ કરો.",
    DESCRIPTION_EXPORT: "કચરાપેટીમાં બધી વસ્તુઓને .json ફાઇલમાં સેવ કરો.",
    DESCRIPTION_IMPORT: "કચરાપેટીમાં બધી વસ્તુઓને .json ફાઇલ દ્વારા ઓવરરાઇટ કરો.",
    DESCRIPTION_CLEAR: "બિનાશક કચરાપેટીમાંથી બધી વસ્તુઓ કાઢી નાખો (પાછી ખેંચી શકાશે નહીં).",
    ITEMS_EMPTY_SONGS_TITLE: "કોઈ ફેંકાયેલા ગીતો નહીં!",
    ITEMS_EMPTY_ARTISTS_TITLE: "કોઈ ફેંકાયેલ કલાકાર નહીં!",
    DESCRIPTION_SETTINGS_ENABLED: "ટ્રાશબિન+ ની બધી કાર્યક્ષમતા સક્ષમ અથવા અક્ષમ કરવા માટર ટોગલ",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "ચાલુ પ્લેબેક ટ્રેકની બાજુમાં ઝડપી ઍક્સેસ માટે પ્લેબેક બારમાં એક કચરો આઇકોન પ્રદર્શિત કરો",
    DESCRIPTION_SETTINGS_AUTOPLAY: "સ્પોટિફાય ખુલે અથવા એક્સટેન્શન લોડ થાય ત્યારે સ્વચાલિત રીતે સંગીત વગાડવાનું શરૂ કરો",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "તમારી આગામી ક્યૂમાં દરેક ગીત પાસે કચરો આઇકોન ઉમેરો તેનું સરળ સંચાલન કરવા માટે",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "એલ્બમ અને પ્લેલિસ્ટ દૃશ્યોમાં ગીતોની બાજુમાં કચરો આઇકોન ઉમેરો ઝડપી ફિલ્ટરિંગ માટે",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "સ્પોટિફાઇ પ્લેબેક ગડબડથી આપમેળે રિકવર કરો તમારી છેલ્લી પ્લેલિસ્ટ ફરીથી શરૂ કરીને",
    SETTINGS_SKIP_TRASHED_TRACKS: "ટ્રાશ કરેલ ટ્રેક છોડો",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "ઑટોમેટિક રીતે કચરો કરેલા ગીતોને છોડી દો અને પ્લેબેક દરમિયાન આગળની મંજૂર ટ્રેક શોધો",
    SETTINGS_AUTO_CLEAN_QUEUE: "ઓટો ક્લીન કતાર",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "તમારી સ્માર્ટ શફલ કતારમાંથી કચરો ગીતો સ્વચાલિત રીતે દૂર કરો",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "નેક્સ્ટ હોટકી પર કચરો",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "જ્યારે આગામી ટ્રેક પર જવા માટે Ctrl+Right કીબોર્ડ શૉર્ટકટનો ઉપયોગ કરી રહ્યાં હોય ત્યારે વર્તમાન ગીતને સ્વચાલિત રીતે ત્યાજ્ય કરો",
    SETTINGS_REMOTE_CONTROL: "રિમોટ કંટ્રોલ",
    SETTINGS_REMOTE_TOGGLE: "રિમોટ ટૉગલ સક્ષમ કરો",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "મોબાઇલ પરથી પ્લે/પૉઝ પર બે વખત ટૅપ કરીને રિમોટ સ્કિપિંગ ચાલુ/બંધ કરો. ટ્રૅક સ્કિપ કરવાથી ટૉગલ પુષ્ટિ થશે.",
    SETTINGS_REMOTE_SKIPPING: "દૂરસ્થ સ્કિપિંગ સક્રિય",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "સક્ષમ હોય ત્યારે, કચરો છોડવાનું બીજા ઉપકરણ (ઉદાહરણ તરીકે, મોબાઇલ) માંથી સ્પોટિફાય પર નિયંત્રણ કરતી વખતે પણ કામ કરે છે",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "દૂરસ્થ સ્કિપિંગ સક્ષમ છે",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "દૂરસ્થ સ્કિપિંગ અક્ષમ",
    MESSAGE_SONG_ADDED_REMOTE: "ગીત રિમોટ દ્વારા નષ્ટ કરાયું",
    SETTINGS_TRASH_VIA_LIKE: "લાઇક દ્વારા કચરો",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "મોબાઇલમાંથી ટ્રશ માટેનું ગીત જેવું. આપમેળે અનલાઇક કરે છે અને આગલા ટ્રેક પર જાય છે.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/he.json
var require_he = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "פח האשפה+",
    ACTION_THROW: "הצב באשפה",
    ACTION_UNTHROW: "הסר מהסל למחוק",
    ACTION_CLEAR: "ברור",
    ACTION_COPY: "העתק",
    ACTION_EXPORT: "ייצוא",
    ACTION_IMPORT: "ייבוא",
    MESSAGE_COPIED: "הועתק ללוח剪贴板",
    MESSAGE_CLEARED: "אשפה נוקתה בהצלחה!",
    MESSAGE_SONG_ADDED: "השיר נוסף לסל האשפה",
    MESSAGE_SONG_REMOVED: "השיר הוסר מהסל המנוקה",
    MESSAGE_ARTIST_ADDED: "אמן נוסף לסל האשפה",
    MESSAGE_ARTIST_REMOVED: "האמן הוסר מהפח",
    BACKUP_SAVE_SUCCESS: "הגיבוי נשמר בהצלחה",
    BACKUP_SAVE_FAILED: "שמירת הגיבוי נכשלה, נסה להעתיק את תוכן סל המיחזור ללוח העריכה וליצור גיבוי ידנית.",
    BACKUP_RESTORE_SUCCESS: "הגיבוי שוחזר בהצלחה",
    BACKUP_FILE_READ_FAILED: "נכשל בקריאת הקובץ, אנא ודא שמדובר בקובץ JSON תקין.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "הגדרות סל האשפה+",
    SETTINGS_OPTIONS: "אפשרויות",
    SETTINGS_FEATURES: "תכונות",
    SETTINGS_LOCAL_STORAGE: "אחסון מקומי",
    SETTINGS_ENABLED: "מופעל",
    SETTINGS_SHOW_WIDGET: "הצג סמל ווידג'ט",
    SETTINGS_AUTOPLAY: "הפעלה אוטומטית בהתחלה",
    SETTINGS_QUEUE_TRASHBIN: "הפעלת אסלה של תור",
    SETTINGS_TRACKLIST_TRASHBIN: "הפעלת אסלה לרשימת רצועות",
    SETTINGS_PLAYLIST_MONITOR: "מוניטור רשימת ניגון",
    ITEMS_TITLE: "פריטים של סל האשפה+",
    ITEMS_EMPTY_SONGS: "<strong>אין שירים באשפה!</strong><br/>שירים שתשימו לפח יופיעו כאן.",
    ITEMS_EMPTY_ARTISTS: "<strong>אין אמנים באשפה!</strong><br/>אמנים שתקלטו לסל האשפה יופיעו כאן.",
    ITEMS_TAB_SONGS: "שירים",
    ITEMS_TAB_ARTISTS: "אמנים",
    ITEMS_LOADED_COUNT: "{{loaded}} מתוך {{total}} {{type}} נטענו",
    DESCRIPTION_COPY: "העתק את כל הפריטים באסלה ללוח.",
    DESCRIPTION_EXPORT: "שמור את כל הפריטים בסל המיחזור לקובץ .json.",
    DESCRIPTION_IMPORT: "החלף את כל הפריטים בסל המיחזור דרך קובץ .json.",
    DESCRIPTION_CLEAR: "לנקות את כל הפריטים מהפח (לא ניתן לבטל)",
    ITEMS_EMPTY_SONGS_TITLE: "אין שירים מחוקים!",
    ITEMS_EMPTY_ARTISTS_TITLE: "אין אמנים מושלכים!",
    DESCRIPTION_SETTINGS_ENABLED: "כיבוי/הפעלה עיקרי להפעלת או השבתת כל תכונות האשפה+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "הצגת סמל פח האשפה בסרגל השמעה ליד הרצועה הניגנת כרגע להגעה מהירה",
    DESCRIPTION_SETTINGS_AUTOPLAY: "הפעלת מוזיקה אוטומטית בעת פתיחת Spotify או טעינת ההרחבה",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "הוסיפו סמלי פח אשפה ליד כל שיר בתור ההשמעה הבא לניהול קל יותר",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "הוספת סמלי אשפה ליד שירים בתצוגות של אלבום ורשימת נגינה לצורך סינון מהיר",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "שחזור אוטומטי מתקלות ניגון ב-Spotify על ידי המשך ניגון רשימת ההשמעה האחרונה שלך",
    SETTINGS_SKIP_TRASHED_TRACKS: "דלג על רצועות שנמחקו",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "דלג אוטומטית על שירים שנמחקו ומצא את הרצועה המותרת הבאה במהלך הנגינה",
    SETTINGS_AUTO_CLEAN_QUEUE: "תור ניקוי אוטומטי",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "הסרה אוטומטית של שירים שנמחקו מהתור של הסדר המעורבב החכם שלך",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "אשפה במקש החם הבא",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "למחוק אוטומטית את השיר הנוכחי בעת שימוש בקיצור דרך Ctrl+ימין כדי לדלג לרצועה הבאה",
    SETTINGS_REMOTE_CONTROL: "שלט רחוק",
    SETTINGS_REMOTE_TOGGLE: "הפעלת החלפה מרחוק",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "הקשה פעמיתים על lecture/השהיה מהמכשיר הנייד כדי להחליף בין מצבים של דילוג מרחוק. דילוג על שיר מאשר את המעבר בין המצבים.",
    SETTINGS_REMOTE_SKIPPING: "דילוג מרחוק פעיל",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "כאשר מופעל, דילוג על מחזור works גם כששולטים בספוטיפי ממכשיר אחר (למשל, סלולרי)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "דילוג מרחוק מופעל",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "דילוג מרחוק מבוטל",
    MESSAGE_SONG_ADDED_REMOTE: "שיר נהרס מרחוק",
    SETTINGS_TRASH_VIA_LIKE: "זבל דרך לייק",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "כמו שיר מהנייד לסל האשפה. מבטל לייק אוטומטית ומדלג לרצועה הבאה.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/hi.json
var require_hi = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ट्रैशबिन+",
    ACTION_THROW: "कचरा डिब्बे में रखें",
    ACTION_UNTHROW: "ट्रैशबिन से हटाएं",
    ACTION_CLEAR: "स्पष्ट",
    ACTION_COPY: "कॉपी",
    ACTION_EXPORT: "निर्यात",
    ACTION_IMPORT: "आयात",
    MESSAGE_COPIED: "क्लिपबोर्ड पर कॉपी किया गया",
    MESSAGE_CLEARED: "ट्रैशबिन सफलतापूर्वक साफ किया गया!",
    MESSAGE_SONG_ADDED: "गाना ट्रैशबिन में जोड़ा गया",
    MESSAGE_SONG_REMOVED: "गाना रद्दी डिब्बे से हटा दिया गया",
    MESSAGE_ARTIST_ADDED: "कलाकार को ट्रैशबिन में जोड़ा गया",
    MESSAGE_ARTIST_REMOVED: "कलाकार को ट्रैशबिन से हटा दिया गया",
    BACKUP_SAVE_SUCCESS: "बैकअप सफलतापूर्वक सहेजा गया।",
    BACKUP_SAVE_FAILED: "बैकअप सहेजने में विफल, कृपया रद्दी डिब्बे की सामग्री को क्लिपबोर्ड पर कॉपी करने और मैन्युअल रूप से बैकअप बनाने का प्रयास करें।",
    BACKUP_RESTORE_SUCCESS: "बैकअप सफलतापूर्वक बहाल किया गया।",
    BACKUP_FILE_READ_FAILED: "फ़ाइल पढ़ने में विफल, कृपया सुनिश्चित करें कि यह एक मान्य JSON फ़ाइल है।",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ट्रैशबिन+ सेटिंग्स",
    SETTINGS_OPTIONS: "विकल्प",
    SETTINGS_FEATURES: "विशेषताएँ",
    SETTINGS_LOCAL_STORAGE: "स्थानीय भंडारण",
    SETTINGS_ENABLED: "सक्षम",
    SETTINGS_SHOW_WIDGET: "विजेट आइकन दिखाएं",
    SETTINGS_AUTOPLAY: "प्रारंभ में स्वत: चलाएं",
    SETTINGS_QUEUE_TRASHBIN: "कतार महसूरदान सक्षम करें",
    SETTINGS_TRACKLIST_TRASHBIN: "ट्रैकलिस्ट ट्रैशबिन सक्षम करें",
    SETTINGS_PLAYLIST_MONITOR: "प्लेलिस्ट मॉनिटर",
    ITEMS_TITLE: "ट्रैशबिन+ आइटम",
    ITEMS_EMPTY_SONGS: "<strong>कोई नष्ट किए गए गाने नहीं!</strong><br/>गाने जो आप रद्दी डिब्बे में डालते हैं वे यहां दिखाई देंगे।",
    ITEMS_EMPTY_ARTISTS: "<strong>कोई अपशिष्ट कलाकार नहीं!</strong><br/>कलाकार जिन्हें आप ट्रैशबिन में डालते हैं वे यहां दिखाई देंगे।",
    ITEMS_TAB_SONGS: "गाने",
    ITEMS_TAB_ARTISTS: "कलाकार",
    ITEMS_LOADED_COUNT: "{{total}} में से {{loaded}} {{type}} लोड हुआ",
    DESCRIPTION_COPY: "ट्रेशबिन में सभी आइटम को क्लिपबोर्ड पर कॉपी करें।",
    DESCRIPTION_EXPORT: "ट्रैशबिन में सभी आइटम को एक .json फ़ाइल में सहेजें।",
    DESCRIPTION_IMPORT: "कचरा बक्से में सभी आइटम को .json फ़ाइल के माध्यम से ओवरराइट करें।",
    DESCRIPTION_CLEAR: "ट्रैशबिन से सभी आइटम हटाएं (वापस नहीं किया जा सकता)।",
    ITEMS_EMPTY_SONGS_TITLE: "कोई हटाए गए गाने नहीं!",
    ITEMS_EMPTY_ARTISTS_TITLE: "कोई नष्ट कलाकार नहीं!",
    DESCRIPTION_SETTINGS_ENABLED: "सभी ट्रैशबिन+ कार्यक्षमता को सक्षम या अक्षम करने के लिए मास्टर टॉगल",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "प्लेबैक बार में वर्तमान में चल रहे ट्रैक के बगल में त्वरित पहुंच के लिए एक ट्रैश आइकन प्रदर्शित करें",
    DESCRIPTION_SETTINGS_AUTOPLAY: "स्पॉटिफाई खुलते ही या एक्सटेंशन लोड होते ही स्वचालित रूप से संगीत चलाना शुरू करें",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "अपने आगामी कतार में प्रत्येक गीत के बगल में कचरा आइकन जोड़ें ताकि आसान प्रबंधन हो सके",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "एल्बम और प्लेलिस्ट दृश्यों में गानों के बगल में ट्रैश आइकन जोड़ें ताकि त्वरित फ़िल्टरिंग की जा सके",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "स्पॉटिफाई प्लेबैक त्रुटियों से अपनी अंतिम प्लेलिस्ट को फिर से शुरू करके स्वचालित रूप से ठीक करें",
    SETTINGS_SKIP_TRASHED_TRACKS: "हटाए गए ट्रैक्स को छोड़ें",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "प्लेबैक के दौरान स्वचालित रूप से हटाए गए गानों को छोड़ें और अगला अनुमत ट्रैक ढूंढें",
    SETTINGS_AUTO_CLEAN_QUEUE: "स्वचालित सफाई कतार",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "अपने स्मार्ट शफल कतार से ट्रैश किए गए गाने स्वचालित रूप से हटा दें",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "अगले हॉटकी पर ट्रैश",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "वर्तमान गीत को स्वचालित रूप से ट्रैश करें जब अगले ट्रैक पर जाने के लिए Ctrl+Right कीबोर्ड शॉर्टकट का उपयोग कर रहे हों",
    SETTINGS_REMOTE_CONTROL: "रिमोट कंट्रोल",
    SETTINGS_REMOTE_TOGGLE: "दूरस्थ टॉगल सक्षम करें",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "मोबाइल से रिमोट स्किपिंग को चालू/बंद करने के लिए दो बार टैप करें। ट्रैक स्किप करने से टॉगल की पुष्टि हो जाएगी।",
    SETTINGS_REMOTE_SKIPPING: "दूरस्थ छलांग सक्रिय",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "जब सक्षम किया जाता है, तो कचरा-छोड़ना दूसरे उपकरण (उदाहरण के लिए, मोबाइल) से स्पॉटिफाई को नियंत्रित करते समय भी काम करता है",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "दूरस्थ छलांग लगाना सक्षम है",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "दूरस्थ छलांग अक्षम",
    MESSAGE_SONG_ADDED_REMOTE: "गाना रिमोट के माध्यम से नष्ट कर दिया गया",
    SETTINGS_TRASH_VIA_LIKE: "लाइक के माध्यम से कचरा",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "मोबाइल से ट्रैश करने के लिए एक गाने की तरह। स्वचालित रूप से अनलाइक करता है और अगले ट्रैक पर जाता है।",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/hr.json
var require_hr = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Smeće+",
    ACTION_THROW: "Stavi u kantu za smeće",
    ACTION_UNTHROW: "Ukloni iz kante za smeće",
    ACTION_CLEAR: "Jasno",
    ACTION_COPY: "Kopiraj",
    ACTION_EXPORT: "Izvoz",
    ACTION_IMPORT: "Uvoz",
    MESSAGE_COPIED: "Kopirano u međuspremnik",
    MESSAGE_CLEARED: "Smeće uspješno obrisano!",
    MESSAGE_SONG_ADDED: "Pjesma dodana u smeće",
    MESSAGE_SONG_REMOVED: "Pjesma uklonjena iz smeća",
    MESSAGE_ARTIST_ADDED: "Umjetnik dodan u smeće",
    MESSAGE_ARTIST_REMOVED: "Umjetnik uklonjen iz smeća",
    BACKUP_SAVE_SUCCESS: "Sigurnosna kopija je uspješno spremljena.",
    BACKUP_SAVE_FAILED: "Nije uspjelo spremanje sigurnosne kopije, pokušajte kopirati sadržaj kante za smeće u međuspremnik i ručno kreirati sigurnosnu kopiju.",
    BACKUP_RESTORE_SUCCESS: "Sigurnosna kopija je uspješno vraćena.",
    BACKUP_FILE_READ_FAILED: "Neuspjelo čitanje datoteke, molimo provjerite je li ispravna JSON datoteka.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Postavke kantu za smeće+",
    SETTINGS_OPTIONS: "Mogućnosti",
    SETTINGS_FEATURES: "Značajke",
    SETTINGS_LOCAL_STORAGE: "Lokalno pohranjivanje",
    SETTINGS_ENABLED: "Omogućeno",
    SETTINGS_SHOW_WIDGET: "Prikaži ikonu widgeta",
    SETTINGS_AUTOPLAY: "Automatsko pokretanje pri pokretanju",
    SETTINGS_QUEUE_TRASHBIN: "Omogući red za smeće",
    SETTINGS_TRACKLIST_TRASHBIN: "Omogući kantu za otpatke popisa pjesama",
    SETTINGS_PLAYLIST_MONITOR: "Playlist Monitor",
    ITEMS_TITLE: "Stavke u kantu za smeće+",
    ITEMS_EMPTY_SONGS: "<strong>Nema pjesama u smeću!</strong><br/>Pjesme koje dodate u kantu za smeće pojaviti će se ovdje.",
    ITEMS_EMPTY_ARTISTS: "<strong>Nema umjetnika u smeću!</strong><br/>Umjetnici koje dodate u kantu za smeće pojaviti će se ovdje.",
    ITEMS_TAB_SONGS: "Pjesme",
    ITEMS_TAB_ARTISTS: "Umjetnici",
    ITEMS_LOADED_COUNT: "{{loaded}} od {{total}} {{type}} učitano",
    DESCRIPTION_COPY: "Kopiraj sve stavke u mape za smeće u međuspremnik.",
    DESCRIPTION_EXPORT: "Spremi sve stavke u kantu za smeće u .json datoteku.",
    DESCRIPTION_IMPORT: "Pregazite sve stavke u kanti za smeće putem .json datoteke.",
    DESCRIPTION_CLEAR: "Obriši sve stavke iz kante za smeće (ne može se poništiti).",
    ITEMS_EMPTY_SONGS_TITLE: "Nema izbrisanih pjesama!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Nema odbačenih umjetnika!",
    DESCRIPTION_SETTINGS_ENABLED: "Glavni prekidač za omogućavanje ili onemogućavanje svih funkcija Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Prikaži ikonu kante za smeće na traci za reprodukciju pokraj trenutno sviranog zapisivanja radi brzog pristupa",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automatski pokreni sviranje glazbe kada se Spotify otvori ili kada se proširenje učita",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Dodajte ikone za brisanje pored svake pjesme u vašem nadolazećem redu za jednostavno upravljanje",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Dodajte ikone za brisanje pored pjesama u prikazima albuma i popisa pjesama za brzo filtriranje",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatski se oporavite od poteškoća pri reprodukciji na Spotifyju tako što ćete nastaviti s posljednjom reprodukcijom",
    SETTINGS_SKIP_TRASHED_TRACKS: "Preskoči obrisane pjesme",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Automatski preskoči izbrisane pjesme i pronađi sljedeću dopuštenu pjesmu tijekom reprodukcije",
    SETTINGS_AUTO_CLEAN_QUEUE: "Red za automatsko čišćenje",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Automatski uklonite pjesme u kantu za smeće iz svoje pametne redoslijed za reprodukciju",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Smeće na sljedećem tipu za brzo izvođenje",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Automatski premjesti trenutačnu pjesmu u smeće kada koristite tipkovni prečac Ctrl+Desno za preskakanje na sljedeću pjesmu",
    SETTINGS_REMOTE_CONTROL: "Dalekovodno upravljanje",
    SETTINGS_REMOTE_TOGGLE: "Omogući daljinsko prebacivanje",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dvaput dodirnite reprodukciju/pauzu na mobilnom uređaju da biste uključili ili isključili preskakanje putem daljinskog upravljača. Preskakanje pjesme potvrđuje uključivanje ili isključivanje.",
    SETTINGS_REMOTE_SKIPPING: "Udaljeno preskakanje aktivno",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Kada je omogućeno, preskakanje otpada funkcionira čak i kada upravljate Spotifyjem s drugog uređaja (npr. mobitela)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Udaljeno preskakanje omogućeno",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Prelazak na daljinu onemogućen",
    MESSAGE_SONG_ADDED_REMOTE: "Pjesma uništena na daljinu",
    SETTINGS_TRASH_VIA_LIKE: "Smeće putem Lajk",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Poput pjesme s mobitela koju bacaš u smeće. Automatski uklanja lajk i prelazi na sljedeću pjesmu.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/hu.json
var require_hu = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Kuka+",
    ACTION_THROW: "Helyezze a kukába",
    ACTION_UNTHROW: "Eltávolítás a Kuka mappából",
    ACTION_CLEAR: "Tiszta",
    ACTION_COPY: "Másolás",
    ACTION_EXPORT: "Export",
    ACTION_IMPORT: "Importálás",
    MESSAGE_COPIED: "Vágólapra másolva",
    MESSAGE_CLEARED: "A kukát sikeresen kiürítették!",
    MESSAGE_SONG_ADDED: "Zene a kukába helyezve",
    MESSAGE_SONG_REMOVED: "A dalat törölték a kukából",
    MESSAGE_ARTIST_ADDED: "Művész hozzáadva a kukához",
    MESSAGE_ARTIST_REMOVED: "Művész eltávolítva a kukából",
    BACKUP_SAVE_SUCCESS: "A biztonsági mentés sikeresen elmentve.",
    BACKUP_SAVE_FAILED: "Nem sikerült menteni a biztonsági másolatot, próbálja meg a kukában lévő tartalmat a vágólapra másolni, és manuálisan készíteni egy biztonsági másolatot.",
    BACKUP_RESTORE_SUCCESS: "A biztonsági mentés sikeresen visszaállítva.",
    BACKUP_FILE_READ_FAILED: "Nem sikerült beolvasni a fájlt, kérjük, győződjön meg róla, hogy érvényes JSON fájl.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-kuka.json",
    SETTINGS_TITLE: "Kuka+ beállítások",
    SETTINGS_OPTIONS: "Beállítások",
    SETTINGS_FEATURES: "Jellemzők",
    SETTINGS_LOCAL_STORAGE: "Helyi tárhely",
    SETTINGS_ENABLED: "Engedélyezve",
    SETTINGS_SHOW_WIDGET: "Widget ikon megjelenítése",
    SETTINGS_AUTOPLAY: "Automatikus lejátszás indításkor",
    SETTINGS_QUEUE_TRASHBIN: "Kukás sor engedélyezése",
    SETTINGS_TRACKLIST_TRASHBIN: "Engedélyezze a lejátszási lista-kuka funkciót",
    SETTINGS_PLAYLIST_MONITOR: "Lejátszáslista-figyelő",
    ITEMS_TITLE: "Kuka+ elemek",
    ITEMS_EMPTY_SONGS: "<strong>Nincsenek törölt dalok!</strong><br/>A kukába helyezett dalok itt jelennek meg.",
    ITEMS_EMPTY_ARTISTS: "<strong>Nincsenek törölt előadók!</strong><br/>Az előadók, akiket a kukába helyezel, itt fognak megjelenni.",
    ITEMS_TAB_SONGS: "Dalok",
    ITEMS_TAB_ARTISTS: "Művészek",
    ITEMS_LOADED_COUNT: "{{loaded}} / {{total}} {{type}} betöltve",
    DESCRIPTION_COPY: "Minden elem másolása a törölt elemek gyűjtőjéből a vágólapra.",
    DESCRIPTION_EXPORT: "Minden elem mentése a törölt elemek között egy .json fájlba.",
    DESCRIPTION_IMPORT: "Az összes elem felülírása a kukában .json fájllal.",
    DESCRIPTION_CLEAR: "Az összes elem törlése a kukából (nem vonható vissza).",
    ITEMS_EMPTY_SONGS_TITLE: "Nincsenek törölt dalok!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Nem kidobott művészek!",
    DESCRIPTION_SETTINGS_ENABLED: "Főkapcsoló a Kuka+ összes funkciójának engedélyezéséhez vagy letiltásához",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Kuka ikon megjelenítése a lejátszás sávban a jelenleg játszó szám mellett gyors hozzáférés érdekében",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automatikus zenelejátszás, amikor a Spotify megnyílik vagy a bővítmény betöltődik",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Kukára dobás ikonok hozzáadása az előre beütemezett számok mellé könnyű kezelésért",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Kukával jelölje meg a számokat az album- és lejátszáslistanézetekben a gyors szűréshez",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatikus helyreállítás a Spotify lejátszásának hibáiból az utolsó lejátszólista folytatásával",
    SETTINGS_SKIP_TRASHED_TRACKS: "Kihagyás törölt számoknál",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "A törölt számok automatikus kihagyása és a következő engedélyezett szám keresése lejátszás közben",
    SETTINGS_AUTO_CLEAN_QUEUE: "Automatikus tisztítási sor",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "A törölt számok automatikus eltávolítása a Smart Shuffle-listáról",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Kuka a következő gyorsbillentyűn",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Az aktuális szám automatikus törlése a Ctrl+Jobbra billentyűkombináció használatakor a következő számra ugráshoz",
    SETTINGS_REMOTE_CONTROL: "Távirányító",
    SETTINGS_REMOTE_TOGGLE: "Távoli kapcsoló engedélyezése",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Kétszeres érintés a lejátszás/szünet gombra a mobilról a távoli átugrás be- és kikapcsolásához. Az átugrott szám megerősíti a beállítást.",
    SETTINGS_REMOTE_SKIPPING: "Távoli kihagyás aktív",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Ha engedélyezve van, a kihagyás a kukában akkor is működik, ha egy másik eszközről (például mobilról) vezéreljük a Spotifyot",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Távoli kihagyás engedélyezve",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Távoli kihagyás letiltva",
    MESSAGE_SONG_ADDED_REMOTE: "Dal törölve távolról",
    SETTINGS_TRASH_VIA_LIKE: "Szemét Like-on keresztül",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Mint egy dalt, amit a telefonról a kukába küld. Automatikusan visszavonja a kedvelést, és átugrik a következő számra.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/id.json
var require_id = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Tempat Sampah+",
    ACTION_THROW: "Masukkan ke Tempat Sampah",
    ACTION_UNTHROW: "Hapus dari Tempat Sampah",
    ACTION_CLEAR: "Jelas",
    ACTION_COPY: "Salin",
    ACTION_EXPORT: "Ekspor",
    ACTION_IMPORT: "Impor",
    MESSAGE_COPIED: "Disalin ke clipboard",
    MESSAGE_CLEARED: "Tempat sampah berhasil dikosongkan!",
    MESSAGE_SONG_ADDED: "Lagu ditambahkan ke tempat sampah",
    MESSAGE_SONG_REMOVED: "Lagu dihapus dari tempat sampah",
    MESSAGE_ARTIST_ADDED: "Artis ditambahkan ke tempat sampah",
    MESSAGE_ARTIST_REMOVED: "Artis dihapus dari tempat sampah",
    BACKUP_SAVE_SUCCESS: "Cadangan berhasil disimpan.",
    BACKUP_SAVE_FAILED: "Gagal menyimpan cadangan, coba salin isi tempat sampah ke clipboard dan buat cadangan secara manual.",
    BACKUP_RESTORE_SUCCESS: "Cadangan berhasil dipulihkan.",
    BACKUP_FILE_READ_FAILED: "Gagal membaca file, pastikan file tersebut adalah file JSON yang valid.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Pengaturan Trashbin+",
    SETTINGS_OPTIONS: "Opsi",
    SETTINGS_FEATURES: "Fitur",
    SETTINGS_LOCAL_STORAGE: "Penyimpanan Lokal",
    SETTINGS_ENABLED: "Diaktifkan",
    SETTINGS_SHOW_WIDGET: "Tampilkan Ikon Widget",
    SETTINGS_AUTOPLAY: "Putar otomatis saat Mulai",
    SETTINGS_QUEUE_TRASHBIN: "Aktifkan Tempat Sampah Antrian",
    SETTINGS_TRACKLIST_TRASHBIN: "Aktifkan Tempat Sampah Daftar Lacak",
    SETTINGS_PLAYLIST_MONITOR: "Pemantau Daftar Putar",
    ITEMS_TITLE: "Item Tempat Sampah+",
    ITEMS_EMPTY_SONGS: "<strong>Tidak ada lagu yang dihapus!</strong><br/>Lagu yang Anda tambahkan ke tempat sampah akan muncul di sini.",
    ITEMS_EMPTY_ARTISTS: "<strong>Tidak ada artis yang dihapus!</strong><br/>Artis yang Anda tambahkan ke tempat sampah akan muncul di sini.",
    ITEMS_TAB_SONGS: "Lagu-lagu",
    ITEMS_TAB_ARTISTS: "Artis",
    ITEMS_LOADED_COUNT: "{{loaded}} dari {{total}} {{type}} telah dimuat",
    DESCRIPTION_COPY: "Salin semua item di tempat sampah ke papan klip.",
    DESCRIPTION_EXPORT: "Simpan semua item di tempat sampah ke file .json.",
    DESCRIPTION_IMPORT: "Timpa semua item di tempat sampah melalui file .json.",
    DESCRIPTION_CLEAR: "Hapus semua item dari tempat sampah (tidak dapat dikembalikan).",
    ITEMS_EMPTY_SONGS_TITLE: "Tidak ada lagu yang dihapus!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Tidak ada seniman yang dibuang!",
    DESCRIPTION_SETTINGS_ENABLED: "Tombol utama untuk mengaktifkan atau menonaktifkan semua fungsi Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Tampilkan ikon tempat sampah di bilah pemutaran di sebelah trek yang sedang diputar untuk akses cepat",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Secara otomatis memutar musik saat Spotify dibuka atau ekstensi dimuat",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Tambahkan ikon tempat sampah di sebelah setiap lagu dalam antrian Anda yang akan datang untuk memudahkan pengelolaan",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Tambahkan ikon tempat sampah di sebelah lagu dalam tampilan album dan daftar putar untuk penyaringan cepat",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Pulihkan secara otomatis dari gangguan pemutaran Spotify dengan melanjutkan daftar putar terakhir Anda",
    SETTINGS_SKIP_TRASHED_TRACKS: "Lewati Lagu yang Dihapus",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Melewati lagu yang dihapus secara otomatis dan menemukan trek berikutnya yang diizinkan selama pemutaran",
    SETTINGS_AUTO_CLEAN_QUEUE: "Antrian Pembersihan Otomatis",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Hapus secara otomatis lagu yang dihapus dari antrian Smart Shuffle Anda",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Sampah pada Tombol Pintas Berikutnya",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Hapus otomatis lagu saat ini saat menggunakan pintasan keyboard Ctrl+Kanan untuk melewati ke lagu berikutnya",
    SETTINGS_REMOTE_CONTROL: "Kontrol Jarak Jauh",
    SETTINGS_REMOTE_TOGGLE: "Aktifkan Sakelar Jarak Jauh",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Ketuk dua kali putar/jeda dari perangkat seluler untuk mengaktifkan/nonaktifkan lewatan jarak jauh. Melewatkan lagu mengonfirmasi pengaktifan.",
    SETTINGS_REMOTE_SKIPPING: "Melewati dari Jarak Jauh Aktif",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Ketika diaktifkan, fitur melewatkan sampah tetap berfungsi meskipun mengendalikan Spotify dari perangkat lain (misalnya, ponsel)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Melompati jarak jauh diaktifkan",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Melompat jarak jauh dinonaktifkan",
    MESSAGE_SONG_ADDED_REMOTE: "Lagu dihapus melalui jarak jauh",
    SETTINGS_TRASH_VIA_LIKE: "Sampah melalui Suka",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Seperti lagu dari ponsel yang dibuang. Secara otomatis menghapus suka dan melompat ke lagu berikutnya.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/is.json
var require_is = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Ruslið+",
    ACTION_THROW: "Setja í ruslið",
    ACTION_UNTHROW: "Fjarlægja úr rusli",
    ACTION_CLEAR: "Klár",
    ACTION_COPY: "Afrita",
    ACTION_EXPORT: "Útflutningur",
    ACTION_IMPORT: "Framleiðsla",
    MESSAGE_COPIED: "Afritað í klippispjald",
    MESSAGE_CLEARED: "Pappírskarfan tæmd!",
    MESSAGE_SONG_ADDED: "Lag bætt í ruslið",
    MESSAGE_SONG_REMOVED: "Lag fjarlægt úr rusli",
    MESSAGE_ARTIST_ADDED: "Listamaður bættur við ruslið",
    MESSAGE_ARTIST_REMOVED: "Listamaður fjarlægður úr ruslaföllu",
    BACKUP_SAVE_SUCCESS: "Afrit vistað.",
    BACKUP_SAVE_FAILED: "Gat ekki vistað öryggisafrit, reyndu að afrita innihald ruslafótsins á klippispjald og búa til öryggisafrit handvirkt.",
    BACKUP_RESTORE_SUCCESS: "Afurðarupplýsingar endurheimtar.",
    BACKUP_FILE_READ_FAILED: "Gat ekki lesið skrá, vinsamlegast gangið úr skugga um að hún sé gild JSON skrá.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Stillingar fyrir rusli+",
    SETTINGS_OPTIONS: "Valkostir",
    SETTINGS_FEATURES: "Eiginleikar",
    SETTINGS_LOCAL_STORAGE: "Staðbundin geymsla",
    SETTINGS_ENABLED: "Virkjað",
    SETTINGS_SHOW_WIDGET: "Sýna stikuhlutatákn",
    SETTINGS_AUTOPLAY: "Sjálfvirk spilun við rás",
    SETTINGS_QUEUE_TRASHBIN: "Virkja biðröð rusliðkarans",
    SETTINGS_TRACKLIST_TRASHBIN: "Virkja ruslið fyrir lagalista",
    SETTINGS_PLAYLIST_MONITOR: "Spilunarlista fylgjendur",
    ITEMS_TITLE: "Ruslið+ Vörur",
    ITEMS_EMPTY_SONGS: "<strong>Engar ruslóður!</strong><br/>Lög sem þú bætir við rusliðkassann birtast hér.",
    ITEMS_EMPTY_ARTISTS: "<strong>Engir ruslaðir listamenn!</strong><br/>Listamenn sem þú bætir við rusliðkassann birtast hér.",
    ITEMS_TAB_SONGS: "Lög",
    ITEMS_TAB_ARTISTS: "Listarar",
    ITEMS_LOADED_COUNT: "{{loaded}} af {{total}} {{type}} hlaðið",
    DESCRIPTION_COPY: "Afritaðu öll atriði í ruslið til klippispjalds.",
    DESCRIPTION_EXPORT: "Vista öll föll í ruslið í .json skrá.",
    DESCRIPTION_IMPORT: "Skrifa yfir öllum atriðum í rusliði með .json skrá.",
    DESCRIPTION_CLEAR: "Hreinsa allar atriði úr rusli (getur ekki verið afturkallað).",
    ITEMS_EMPTY_SONGS_TITLE: "Engar ruslóttar lög!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Engir ruslsmunir!",
    DESCRIPTION_SETTINGS_ENABLED: "Aðalkippa til að virkja eða gera óvirkt allar aukin virkni ruslafóts",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Birta ruslpípu í spilunarstikunni við hliðina við núverandi lag fyrir fljótan aðgang",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Byrja að spila tónlist sjálfkrafa þegar Spotify er opnað eða viðbótin hleðst",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Bættu við ruslpunktum við hvern lagalista í komandi röðinni til auðveldri stjórnunar",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Bæta við ruslpunktum við lag í úrvali og spilunarlistum fyrir fljóta síun",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Endurlæs síðustu spilunarlista sjálfkrafa til að endurheimta eftir bil í Spotify spilun",
    SETTINGS_SKIP_TRASHED_TRACKS: "Hoppa yfir ruslslóðir",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Sleppa sjálfkrafa eyddum lögu og finna næsta leyfða lagalista í spilun",
    SETTINGS_AUTO_CLEAN_QUEUE: "Hreinsunarað rafbíla",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Fjarlægja lag sem er í rusli sjálfkrafa úr Smart Shuffle biðröðinni",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Rusl á næsta flýtileið lyklaborðs",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Fleyg núverandi lagi sjálfkrafa þegar notað er Ctrl+Hægri sniðmát til að hoppa á næsta lag",
    SETTINGS_REMOTE_CONTROL: "Fjarstýring",
    SETTINGS_REMOTE_TOGGLE: "Virkja fjarstýringu",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Tvísmelltu á spilun/í bið til að kveikja/slökkva á fjarstýringu fyrir sleppingu á lagalista. Slepping á lag staðfestir valmöguleikann.",
    SETTINGS_REMOTE_SKIPPING: "Fjartengt slepping virkt",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Þegar virkt, virkar ruslið-perlan erfiðleikar jafnvel þegar Spotify er stjórnað frá öðru tæki (t.d. síma)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Fjartengt sleppingu virkt",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Fjarvirkt sleppingu óvirkjað",
    MESSAGE_SONG_ADDED_REMOTE: "Lag eytt á fjarstýringu",
    SETTINGS_TRASH_VIA_LIKE: "Rusl í gegnum Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Eins og lag frá síma til að eyða því. Felur sjálfkrafa og hoppar á næsta lag.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/it.json
var require_it = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Cestino+",
    ACTION_THROW: "Metti nel Cestino",
    ACTION_UNTHROW: "Rimuovi dal Cestino",
    ACTION_CLEAR: "Chiaro",
    ACTION_COPY: "Copia",
    ACTION_EXPORT: "Esporta",
    ACTION_IMPORT: "Importa",
    MESSAGE_COPIED: "Copiato negli appunti",
    MESSAGE_CLEARED: "Cestino svuotato con successo!",
    MESSAGE_SONG_ADDED: "Canzone aggiunta al cestino",
    MESSAGE_SONG_REMOVED: "Canzone rimossa dal cestino",
    MESSAGE_ARTIST_ADDED: "Artista aggiunto al cestino",
    MESSAGE_ARTIST_REMOVED: "Artista rimosso dal cestino",
    BACKUP_SAVE_SUCCESS: "Backup salvato con successo.",
    BACKUP_SAVE_FAILED: "Impossibile salvare il backup, prova a copiare il contenuto del cestino negli appunti e crea un backup manualmente.",
    BACKUP_RESTORE_SUCCESS: "Backup ripristinato con successo.",
    BACKUP_FILE_READ_FAILED: "Impossibile leggere il file, assicurarsi che sia un file JSON valido.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Impostazioni del Cestino+",
    SETTINGS_OPTIONS: "Opzioni",
    SETTINGS_FEATURES: "Caratteristiche",
    SETTINGS_LOCAL_STORAGE: "Archiviazione locale",
    SETTINGS_ENABLED: "Abilitato",
    SETTINGS_SHOW_WIDGET: "Mostra icona widget",
    SETTINGS_AUTOPLAY: "Riproduzione automatica all'avvio",
    SETTINGS_QUEUE_TRASHBIN: "Abilita Cestino della Coda",
    SETTINGS_TRACKLIST_TRASHBIN: "Abilita Cestino della Playlist",
    SETTINGS_PLAYLIST_MONITOR: "Monitor della playlist",
    ITEMS_TITLE: "Elementi del Cestino+",
    ITEMS_EMPTY_SONGS: "<strong>Nessuna canzone nel cestino!</strong><br/>Le canzoni che aggiungi nel cestino appariranno qui.",
    ITEMS_EMPTY_ARTISTS: "<strong>Nessun artista nel cestino!</strong><br/>Gli artisti che aggiungi al cestino appariranno qui.",
    ITEMS_TAB_SONGS: "Canzoni",
    ITEMS_TAB_ARTISTS: "Artisti",
    ITEMS_LOADED_COUNT: "{{loaded}} di {{total}} {{type}} caricati",
    DESCRIPTION_COPY: "Copia tutti gli elementi nel cestino negli appunti.",
    DESCRIPTION_EXPORT: "Salva tutti gli elementi nel cestino in un file .json.",
    DESCRIPTION_IMPORT: "Sovrascrivi tutti gli elementi nel cestino tramite file .json.",
    DESCRIPTION_CLEAR: "Elimina tutti gli elementi dal cestino (operazione non reversibile).",
    ITEMS_EMPTY_SONGS_TITLE: "Nessuna canzone cestinata!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Nessun artista scartato!",
    DESCRIPTION_SETTINGS_ENABLED: "Interruttore principale per abilitare o disabilitare tutte le funzionalità di Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Visualizza un'icona del cestino nella barra di riproduzione accanto alla traccia in riproduzione per un accesso rapido",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Avvia automaticamente la riproduzione della musica quando Spotify si apre o quando l'estensione viene caricata",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Aggiungi icone del cestino accanto a ogni canzone nella tua coda imminente per una gestione più semplice",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Aggiungi icone del cestino accanto alle canzoni nelle visualizzazioni di album e playlist per un filtraggio rapido",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recupera automaticamente dai problemi di riproduzione di Spotify riprendendo l'ultima playlist",
    SETTINGS_SKIP_TRASHED_TRACKS: "Ignora le tracce eliminate",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Salta automaticamente le canzoni eliminate e trova la traccia successiva consentita durante la riproduzione",
    SETTINGS_AUTO_CLEAN_QUEUE: "Coda pulizia automatica",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Rimuovi automaticamente le canzoni eliminate dalla tua coda di riproduzione casuale intelligente",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Cestino sul prossimo tasto di scelta rapida",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Sposta automaticamente la canzone corrente nel cestino quando si utilizza la scorciatoia da tastiera Ctrl+Destra per passare alla traccia successiva",
    SETTINGS_REMOTE_CONTROL: "Controllo remoto",
    SETTINGS_REMOTE_TOGGLE: "Abilita interruttore remoto",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Tocca due volte riproduci/pausa dal dispositivo mobile per attivare/disattivare il salto remoto delle tracce. Il salto di una traccia conferma l'attivazione/disattivazione.",
    SETTINGS_REMOTE_SKIPPING: "Salto remoto attivo",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Quando abilitata, la funzione di saltare i brani funziona anche quando si controlla Spotify da un altro dispositivo (ad esempio, da un cellulare)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Salto remoto abilitato",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Salto remoto disabilitato",
    MESSAGE_SONG_ADDED_REMOTE: "Canzone eliminata a distanza",
    SETTINGS_TRASH_VIA_LIKE: "Rifiuti tramite Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Come una canzone da mobile a cestinarla. Annulla automaticamente il like e passa alla traccia successiva.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ja.json
var require_ja = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ゴミ箱+",
    ACTION_THROW: "ゴミ箱に入れる",
    ACTION_UNTHROW: "ゴミ箱から削除",
    ACTION_CLEAR: "クリア",
    ACTION_COPY: "コピー",
    ACTION_EXPORT: "エクスポート",
    ACTION_IMPORT: "インポート",
    MESSAGE_COPIED: "クリップボードにコピーされました",
    MESSAGE_CLEARED: "ゴミ箱を正常に空にしました！",
    MESSAGE_SONG_ADDED: "曲がゴミ箱に追加されました",
    MESSAGE_SONG_REMOVED: "ゴミ箱から曲を削除しました",
    MESSAGE_ARTIST_ADDED: "アーティストがゴミ箱に追加されました",
    MESSAGE_ARTIST_REMOVED: "アーティストがゴミ箱から削除されました",
    BACKUP_SAVE_SUCCESS: "バックアップが正常に保存されました。",
    BACKUP_SAVE_FAILED: "バックアップの保存に失敗しました。ごみ箱の内容をクリップボードにコピーして、手動でバックアップを作成してみてください。",
    BACKUP_RESTORE_SUCCESS: "バックアップの復元が正常に完了しました。",
    BACKUP_FILE_READ_FAILED: "ファイルの読み取りに失敗しました。有効なJSONファイルであることを確認してください。",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ごみ箱+ 設定",
    SETTINGS_OPTIONS: "オプション",
    SETTINGS_FEATURES: "機能",
    SETTINGS_LOCAL_STORAGE: "ローカルストレージ",
    SETTINGS_ENABLED: "有効",
    SETTINGS_SHOW_WIDGET: "ウィジェットアイコンを表示",
    SETTINGS_AUTOPLAY: "起動時に自動再生",
    SETTINGS_QUEUE_TRASHBIN: "キューごみ箱を有効にする",
    SETTINGS_TRACKLIST_TRASHBIN: "トラックリストのゴミ箱を有効にする",
    SETTINGS_PLAYLIST_MONITOR: "プレイリストモニター",
    ITEMS_TITLE: "ゴミ箱+ アイテム",
    ITEMS_EMPTY_SONGS: "<strong>ゴミ箱の曲はありません！</strong><br/>ゴミ箱に入れた曲がここに表示されます。",
    ITEMS_EMPTY_ARTISTS: "<strong>ゴミ箱のアーティストはありません！</strong><br/>ゴミ箱に追加したアーティストはここに表示されます。",
    ITEMS_TAB_SONGS: "曲",
    ITEMS_TAB_ARTISTS: "アーティスト",
    ITEMS_LOADED_COUNT: "{{total}} 中 {{loaded}} 個の{{type}}を読み込みました",
    DESCRIPTION_COPY: "ゴミ箱内のすべてのアイテムをクリップボードにコピーします。",
    DESCRIPTION_EXPORT: "ゴミ箱内のすべてのアイテムを.jsonファイルに保存します。",
    DESCRIPTION_IMPORT: "ゴミ箱内のすべての項目を.jsonファイルで上書きします。",
    DESCRIPTION_CLEAR: "ゴミ箱からすべてのアイテムを完全に削除します（元に戻せません）。",
    ITEMS_EMPTY_SONGS_TITLE: "削除された曲はありません！",
    ITEMS_EMPTY_ARTISTS_TITLE: "捨てられたアーティストはいらない！",
    DESCRIPTION_SETTINGS_ENABLED: "すべてのゴミ箱+機能を有効または無効にするメイントグル",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "再生中のトラックの横にある再生バーにごみ箱アイコンを表示して、すぐにアクセスできるようにします",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Spotifyの起動時または拡張機能の読み込み時に自動的に音楽を再生開始します",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "アップカミングキューの各曲の横にゴミ箱アイコンを追加して、簡単に管理できるようにします",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "アルバムビューとプレイリストビューの曲の横にゴミ箱アイコンを追加して、素早いフィルタリングを可能にします",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Spotifyの再生エラーを自動的に回復し、最後のプレイリストを再開します",
    SETTINGS_SKIP_TRASHED_TRACKS: "削除済みトラックをスキップ",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "削除された曲を自動的にスキップし、再生中に次に許可されたトラックを探します",
    SETTINGS_AUTO_CLEAN_QUEUE: "自動クリーンキュー",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "スマートシャッフルキューからゴミ箱に入った曲を自動的に削除する",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "次のホットキーでゴミ箱に移動",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Ctrl+右キーのショートカットを使用して次のトラックにスキップする際、現在の曲を自動的にゴミ箱に移動します",
    SETTINGS_REMOTE_CONTROL: "リモートコントロール",
    SETTINGS_REMOTE_TOGGLE: "リモート切り替えを有効にする",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "モバイル端末で再生/一時停止を2回タップして、リモートスキップのオン/オフを切り替えます。曲のスキップで切り替えが確定します。",
    SETTINGS_REMOTE_SKIPPING: "リモートスキップが有効です",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "有効にすると、他のデバイス（例：スマートフォン）からSpotifyを操作している場合でも、ゴミ箱スキップ機能が動作します",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "リモートスキップが有効になっています",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "リモートスキップは無効です",
    MESSAGE_SONG_ADDED_REMOTE: "リモートで楽曲が破壊された",
    SETTINGS_TRASH_VIA_LIKE: "いいね経由でゴミ",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "携帯からゴミ箱へと流れる曲のように。自動で「いいね」を解除し、次の曲にスキップします。",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/kn.json
var require_kn = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ಟ್ರಾಶ್‌ಬಿನ್+",
    ACTION_THROW: "ಅಪಾಯಿಕ ಬುಟ್ಟಿಯಲ್ಲಿ ಇಡಿ",
    ACTION_UNTHROW: "ಅಳಿಸಿದವುಗಳಿಂದ ತೆಗೆದುಹಾಕಿ",
    ACTION_CLEAR: "ಸ್ಪಷ್ಟವಾಗಿ",
    ACTION_COPY: "ಪ್ರತಿರೂಪ",
    ACTION_EXPORT: "ರಫ್ತು",
    ACTION_IMPORT: "ಆಮದು",
    MESSAGE_COPIED: "ಕ್ಲಿಪ್ಬೋರ್ಡ್‌ಗೆ ನಕಲಿಸಲಾಗಿದೆ",
    MESSAGE_CLEARED: "ಅಳಿಸಿಹಾಕುವ ಬುಟ್ಟಿ ಯಶಸ್ವಿಯಾಗಿ ಖಾಲಿ ಮಾಡಲಾಯಿತು!",
    MESSAGE_SONG_ADDED: "ಹಾಡನ್ನು ಅಸ್ತಿಪಂಜರಕ್ಕೆ ಸೇರಿಸಲಾಗಿದೆ",
    MESSAGE_SONG_REMOVED: "ಅಳಿಸಿಹಾಕಿದ ಫೈಲ್‌ಗಳ ಪೆಟ್ಟಿಗೆಯಿಂದ ಹಾಡನ್ನು ತೆಗೆದುಹಾಕಲಾಗಿದೆ",
    MESSAGE_ARTIST_ADDED: "ಕಲಾವಿದನನ್ನು ಅಸ್ತಿಪಂಜರಕ್ಕೆ ಸೇರಿಸಲಾಗಿದೆ",
    MESSAGE_ARTIST_REMOVED: "ಕಸದ ಬುಟ್ಟಿಯಿಂದ ಕಲಾವಿದನನ್ನು ತೆಗೆದುಹಾಕಲಾಗಿದೆ",
    BACKUP_SAVE_SUCCESS: "ಬ್ಯಾಕಪ್ ಯಶಸ್ವಿಯಾಗಿ ಉಳಿಸಲಾಗಿದೆ.",
    BACKUP_SAVE_FAILED: "ಬ್ಯಾಕಪ್ ಅನ್ನು ಉಳಿಸಲು ವಿಫಲವಾಯಿತು, ಕಸದ ಬುಟ್ಟಿಯ ವಿಷಯಗಳನ್ನು ಕ್ಲಿಪ್‌ಬೋರ್ಡ್‌ಗೆ ನಕಲಿಸಿ ಮತ್ತು ಕೈಯಾರೆ ಬ್ಯಾಕಪ್ ಅನ್ನು ರಚಿಸಲು ಪ್ರಯತ್ನಿಸಿ.",
    BACKUP_RESTORE_SUCCESS: "ಬ್ಯಾಕಪ್ ಯಶಸ್ವಿಯಾಗಿ ಮರುಸ್ಥಾಪಿಸಲಾಗಿದೆ.",
    BACKUP_FILE_READ_FAILED: "ಫೈಲ್ ಅನ್ನು ಓದಲು ವಿಫಲವಾಯಿತು, ದಯವಿಟ್ಟು ಅದು ಮಾನ್ಯ JSON ಫೈಲ್ ಆಗಿದೆಯೇ ಎಂದು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳಿ.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ಟ್ರಾಶ್‌ಬಿನ್+ ಸೆಟ್ಟಿಂಗ್ಸ್",
    SETTINGS_OPTIONS: "ಆಯ್ಕೆಗಳು",
    SETTINGS_FEATURES: "ವೈಶಿಷ್ಟ್ಯಗಳು",
    SETTINGS_LOCAL_STORAGE: "ಸ್ಥಳೀಯ ಸಂಗ್ರಹಣೆ",
    SETTINGS_ENABLED: "ಸಕ್ರಿಯಗೊಳಿಸಲಾಗಿದೆ",
    SETTINGS_SHOW_WIDGET: "ವಿಜೆಟ್ ಐಕಾನ್ ಅನ್ನು ತೋರಿಸಿ",
    SETTINGS_AUTOPLAY: "ಪ್ರಾರಂಭದಲ್ಲಿ ಆಟೋಪ್ಲೇ ಮಾಡು",
    SETTINGS_QUEUE_TRASHBIN: "ಕ್ಯೂ ಟ್ರಾಶ್‌ಬಿನ್ ಅನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಿ",
    SETTINGS_TRACKLIST_TRASHBIN: "ಟ್ರಾಕ್‌ಲಿಸ್ಟ್ ಕಸದ ಬುಟ್ಟಿಯನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಿ",
    SETTINGS_PLAYLIST_MONITOR: "ಪ್ಲೇಲಿಸ್ಟ್ ಮಾನಿಟರ್",
    ITEMS_TITLE: "ಟ್ರಾಶ್‌ಬಿನ್+ ಐಟಂಗಳು",
    ITEMS_EMPTY_SONGS: "<strong>ಅಳಿಸಿದ ಹಾಡುಗಳಿಲ್ಲ!</strong><br/>ನೀವು ಅಳಿಸುವ ಹಾಡುಗಳು ಇಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುತ್ತವೆ.",
    ITEMS_EMPTY_ARTISTS: "<strong>ಅಳಿಸಿದ ಕಲಾವಿದರು ಇಲ್ಲ!</strong><br/>ನೀವು ಅಳಿಸುವ ಕಲಾವಿದರು ಇಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುತ್ತಾರೆ.",
    ITEMS_TAB_SONGS: "ಹಾಡುಗಳು",
    ITEMS_TAB_ARTISTS: "ಕಲಾವಿದರು",
    ITEMS_LOADED_COUNT: "{{total}} ರ {{type}} ಗಳಲ್ಲಿ {{loaded}} ಲೋಡ್ ಆಗಿದೆ",
    DESCRIPTION_COPY: "ಅಳಿಸಿದ ಫೈಲ್‌ಗಳ ಪೀಠಿಕೆಯಲ್ಲಿನ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು ಕ್ಲಿಪ್‌ಬೋರ್ಡ್‌ಗೆ ನಕಲಿಸಿ.",
    DESCRIPTION_EXPORT: "ಅನಾವಶ್ಯಕ ಫೈಲ್‌ಗಳಲ್ಲಿನ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು .json ಫೈಲ್‌ಗೆ ಉಳಿಸಿ.",
    DESCRIPTION_IMPORT: "ಜೆಸಾನ್ ಕಡತದ ಮೂಲಕ ಅಳಿಸಿದ ಅಂಶಗಳನ್ನು ಬದಲಾಯಿಸಿ.",
    DESCRIPTION_CLEAR: "ಅಳಿಸಿದ ಫೈಲ್‌ಗಳ ಪೆಟ್ಟಿಗೆಯಿಂದ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು ತೆಗೆದುಹಾಕಿ (ಹಿಂತಿರುಗಿಸಲಾಗುವುದಿಲ್ಲ).",
    ITEMS_EMPTY_SONGS_TITLE: "ಯಾವುದೇ ತ್ರಾಶ್ ಮಾಡಿದ ಹಾಡುಗಳಿಲ್ಲ!",
    ITEMS_EMPTY_ARTISTS_TITLE: "ಯಾವುದೇ ಕಸದ ಕಲಾವಿದರಿಲ್ಲ!",
    DESCRIPTION_SETTINGS_ENABLED: "ಟ್ರಾಶ್‌ಬಿನ್+ ಕಾರ್ಯಗಳನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಲು ಅಥವಾ ನಿಷ್ಕ್ರಿಯಗೊಳಿಸಲು ಮಾಸ್ಟರ್ ಟಾಗಲ್",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "ಪ್ರಸ್ತುತ ವಹಿಸುತ್ತಿರುವ ಟ್ರಾಕ್ ಬದಿಯಲ್ಲಿ ವಾಡಿಕೆ ಪಟ್ಟಿಯಲ್ಲಿ ತ್ವರಿತ ಪ್ರವೇಶಕ್ಕಾಗಿ ಅಪಾಯಿಕ ಚಿಹ್ನೆಯನ್ನು ಪ್ರದರ್ಶಿಸಿ",
    DESCRIPTION_SETTINGS_AUTOPLAY: "ಸ್ಪಾಟಿಫೈ ತೆರೆಯುವಾಗ ಅಥವಾ ವಿಸ್ತರಣೆ ಲೋಡ್ ಆಗುವಾಗ ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಸಂಗೀತವನ್ನು ಪ್ಲೇ ಮಾಡಲು ಪ್ರಾರಂಭಿಸಿ",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "ನಿಮ್ಮ ಬರುವ ಸಂಗೀತದ ಸರದಿಯಲ್ಲಿರುವ ಪ್ರತಿಯೊಂದು ಹಾಡಿನ ಪಕ್ಕೆ ಅಸ್ತಿಕೆ ಐಕಾನ್‌ಗಳನ್ನು ಸುಲಭ ನಿರ್ವಹಣೆಗಾಗಿ ಸೇರಿಸಿ",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "ಆಲ್ಬಂ ಮತ್ತು ಪ್ಲೇಪಟ್ಟಿ ವೀಕ್ಷಣೆಗಳಲ್ಲಿ ಹಾಡುಗಳ ಪಕ್ಕದಲ್ಲಿ ಕಸದ ಐಕಾನ್‌ಗಳನ್ನು ಸೇರಿಸಿ ತ್ವರಿತ ಫಿಲ್ಟರಿಂಗ್ ಮಾಡಿ",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "ನಿಮ್ಮ ಕೊನೆಯ ಪ್ಲೇಲಿಸ್ಟ್ ಅನ್ನು ಮತ್ತೆ ಪ್ರಾರಂಭಿಸುವ ಮೂಲಕ ಸ್ಪಾಟಿಫೈ ಪ್ಲೇಬ್ಯಾಕ್ ತೊಂದರೆಗಳಿಂದ ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಚೇತರಿಸಿಕೊಳ್ಳಿ",
    SETTINGS_SKIP_TRASHED_TRACKS: "ಅಳಿಸಿಹಾಕಿದ ಟ್ರ್ಯಾಕ್‌ಗಳನ್ನು ಬಿಟ್ಟುಬಿಡಿ",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಅಳಿಸಿಹಾಕಿದ ಹಾಡುಗಳನ್ನು ತಪ್ಪಿಸಿ ಮತ್ತು ಪ್ಲೇಬ್ಯಾಕ್ ಸಮಯದಲ್ಲಿ ಮುಂದಿನ ಅನುಮತಿಸಲಾದ ಟ್ರ್ಯಾಕ್ ಅನ್ನು ಹುಡುಕಿ",
    SETTINGS_AUTO_CLEAN_QUEUE: "ಆಟೋ ಕ್ಲೀನ್ ಕ್ಯೂ",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "ನಿಮ್ಮ ಸ್ಮಾರ್ಟ್ ಶಫಲ್ ಸರದಿಯಿಂದ ಅಳಿಸಿಹಾಕಿದ ಹಾಡುಗಳನ್ನು ಸ್ವಯಂಚಾಲಿತವಾಗಿ ತೆಗೆದುಹಾಕಿ",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "ಮುಂದಿನ ಹಾಟ್‌ಕೀಗಾಗಿ ಅಪಾಯಿತ್ಯ",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Ctrl+ಬಲಕ್ಕೆ ಕೀಲಿಮಣೆ ಸಂಕ್ಷಿಪ್ತವಾಕ್ಯವನ್ನು ಬಳಸಿ ಮುಂದಿನ ಟ್ರಾಕ್‌ಗೆ ಹಾದುಹೋಗುವಾಗ ಪ್ರಸ್ತುತ ಹಾಡನ್ನು ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಅಳಿಸಿ",
    SETTINGS_REMOTE_CONTROL: "ರಿಮೋಟ್ ಕಂಟ್ರೋಲ್",
    SETTINGS_REMOTE_TOGGLE: "ದೂರದ ಟಾಗಲ್ ಅನ್ನು ಸಕ್ರಿಯಗೊಳಿಸು",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "ಮೊಬೈಲ್‌ನಿಂದ ಪ್ಲೇ/ಪಾಸ್ ಮಾಡಲು ಎರಡು ಬಾರಿ ಟ್ಯಾಪ್ ಮಾಡಿ ರಿಮೋಟ್ ಸ್ಕಿಪ್ಪಿಂಗ್ ಅನ್ನು ಆನ್/ಆಫ್ ಮಾಡಿ. ಟ್ರಾಕ್ ಸ್ಕಿಪ್ ಟಾಗಲ್ ಅನ್ನು ದೃಢೀಕರಿಸುತ್ತದೆ.",
    SETTINGS_REMOTE_SKIPPING: "ದೂರದ ಬೆಳಕಿನ ಚಟುವಟಿಕೆ",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "ಸಕ್ರಿಯಗೊಳಿಸಿದಾಗ, ಇನ್ನೊಂದು ಸಾಧನದಿಂದ (ಉದಾಹರಣೆಗೆ, ಮೊಬೈಲ್) ಸ್ಪಾಟಿಫೈ ಅನ್ನು ನಿಯಂತ್ರಿಸುವಾಗಲೂ ಕಸವನ್ನು ಬೈಪಾಸ್ ಮಾಡುವುದು ಕೆಲಸ ಮಾಡುತ್ತದೆ",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "ದೂರದಲ್ಲಿರುವ ಸ್ಕಿಪ್ಪಿಂಗ್ ಸಕ್ರಿಯಗೊಳಿಸಲಾಗಿದೆ",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "ದೂರದಲ್ಲಿರುವ ಕಿರುಹಾದು ನಿಷ್ಕ್ರಿಯಗೊಳಿಸಲಾಗಿದೆ",
    MESSAGE_SONG_ADDED_REMOTE: "ದೂರದಿಂದಲೇ ಹಾಡನ್ನು ನಾಶಪಡಿಸಲಾಯಿತು",
    SETTINGS_TRASH_VIA_LIKE: "ಲೈಕ್ ಮೂಲಕ ತ್ಯಾಜ್ಯ",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "ಮೊಬೈಲ್‌ನಿಂದ ಹಾಡಿನಂತೆ ಅದನ್ನು ತ್ಯಜಿಸಿ. ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಅನ್‌ಲೈಕ್ ಮಾಡಿ ಮುಂದಿನ ಟ್ರ್ಯಾಕ್‌ಗೆ ಹೋಗಿ.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ko.json
var require_ko = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "쓰레기통+",
    ACTION_THROW: "휴지통에 넣기",
    ACTION_UNTHROW: "휴지통에서 제거",
    ACTION_CLEAR: "명확함",
    ACTION_COPY: "복사",
    ACTION_EXPORT: "내보내기",
    ACTION_IMPORT: "가져오기",
    MESSAGE_COPIED: "클립보드에 복사되었습니다",
    MESSAGE_CLEARED: "휴지통이 성공적으로 비워졌습니다!",
    MESSAGE_SONG_ADDED: "노래가 휴지통에 추가되었습니다",
    MESSAGE_SONG_REMOVED: "휴지통에서 곡 삭제됨",
    MESSAGE_ARTIST_ADDED: "아티스트가 휴지통에 추가되었습니다",
    MESSAGE_ARTIST_REMOVED: "아티스트가 휴지통에서 제거되었습니다",
    BACKUP_SAVE_SUCCESS: "백업이 성공적으로 저장되었습니다.",
    BACKUP_SAVE_FAILED: "백업 저장에 실패했습니다. 휴지통 내용을 클립보드에 복사하여 수동으로 백업을 생성해 보세요.",
    BACKUP_RESTORE_SUCCESS: "백업이 성공적으로 복원되었습니다.",
    BACKUP_FILE_READ_FAILED: "파일을 읽지 못했습니다. 올바른 JSON 파일인지 확인해 주세요.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "쓰레기통+ 설정",
    SETTINGS_OPTIONS: "옵션",
    SETTINGS_FEATURES: "기능",
    SETTINGS_LOCAL_STORAGE: "로컬 스토리지",
    SETTINGS_ENABLED: "활성화됨",
    SETTINGS_SHOW_WIDGET: "위젯 아이콘 표시",
    SETTINGS_AUTOPLAY: "시작 시 자동 재생",
    SETTINGS_QUEUE_TRASHBIN: "큐 휴지통 사용 가능",
    SETTINGS_TRACKLIST_TRASHBIN: "트랙리스트 휴지통 활성화",
    SETTINGS_PLAYLIST_MONITOR: "재생 목록 모니터",
    ITEMS_TITLE: "쓰레기통+ 항목",
    ITEMS_EMPTY_SONGS: "<strong>휴지통에 있는 곡 없음!</strong><br/>휴지통에 추가한 곡들이 여기에 표시됩니다.",
    ITEMS_EMPTY_ARTISTS: "<strong>휴지통에 있는 아티스트 없음!</strong><br/>휴지통에 추가한 아티스트가 여기에 표시됩니다.",
    ITEMS_TAB_SONGS: "노래",
    ITEMS_TAB_ARTISTS: "아티스트",
    ITEMS_LOADED_COUNT: "{{total}}개 중 {{loaded}}개의 {{type}}이(가) 로드되었습니다",
    DESCRIPTION_COPY: "휴지통의 모든 항목을 클립보드에 복사합니다.",
    DESCRIPTION_EXPORT: "휴지통의 모든 항목을 .json 파일로 저장합니다.",
    DESCRIPTION_IMPORT: ".json 파일을 통해 휴지통의 모든 항목을 덮어씁니다.",
    DESCRIPTION_CLEAR: "휴지통의 모든 항목을 삭제합니다(되돌릴 수 없음).",
    ITEMS_EMPTY_SONGS_TITLE: "삭제된 곡 없음!",
    ITEMS_EMPTY_ARTISTS_TITLE: "삭제된 아티스트 없음!",
    DESCRIPTION_SETTINGS_ENABLED: "모든 휴지통+ 기능을 사용하거나 비활성화하는 메인 토글",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "재생 중인 곡 옆의 재생 바에 휴지통 아이콘을 표시하여 빠르게 접근할 수 있도록 함",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Spotify가 열리거나 확장 프로그램이 로드될 때 자동으로 음악 재생 시작",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "대기 중인 재생 목록의 각 곡 옆에 휴지통 아이콘을 추가하여 쉽게 관리할 수 있습니다",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "앨범 및 재생목록 보기에서 곡 옆에 휴지통 아이콘을 추가하여 빠른 필터링을 가능하게 함",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Spotify 재생 오류 발생 시 마지막 재생 목록을 자동으로 이어 재생하여 복구합니다",
    SETTINGS_SKIP_TRASHED_TRACKS: "삭제된 트랙 건너뛰기",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "재생 중에 휴지통으로 이동한 곡을 자동으로 건너뛰고 다음에 재생 가능한 트랙을 찾습니다.",
    SETTINGS_AUTO_CLEAN_QUEUE: "자동 정리 대기열",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "휴지통에 있는 곡을 스마트 셔플 큐에서 자동으로 제거합니다",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "다음 단축키로 휴지통으로 이동",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Ctrl+오른쪽 키보드 단축키를 사용하여 다음 곡으로 건너뛸 때 현재 곡을 자동으로 휴지통으로 이동",
    SETTINGS_REMOTE_CONTROL: "리모컨",
    SETTINGS_REMOTE_TOGGLE: "원격 토글 사용 가능",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "모바일에서 재생/일시정지 버튼을 두 번 탭하여 원격 건너뛰기 켜기/끄기 전환. 곡 건너뛰기로 전환이 확인됨.",
    SETTINGS_REMOTE_SKIPPING: "원격 건너뛰기 활성화됨",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "활성화하면 다른 기기(예: 모바일)에서 Spotify를 제어할 때에도 휴지통 건너뛰기가 작동합니다.",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "원격 건너뛰기 활성화됨",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "원격 건너뛰기 비활성화됨",
    MESSAGE_SONG_ADDED_REMOTE: "원격으로 곡 폐기됨",
    SETTINGS_TRASH_VIA_LIKE: "좋아요를 통한 쓰레기",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "휴대폰에서 재생 중인 곡을 삭제하듯이 자동으로 좋아요를 취소하고 다음 곡으로 건너뜁니다.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/lt.json
var require_lt = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Šiukšlinė+",
    ACTION_THROW: "Įdėti į šiukšliadėžę",
    ACTION_UNTHROW: "Pašalinti iš šiukšlinės",
    ACTION_CLEAR: "Aišku",
    ACTION_COPY: "Kopijuoti",
    ACTION_EXPORT: "Eksportuoti",
    ACTION_IMPORT: "Importuoti",
    MESSAGE_COPIED: "Nukopijuota į iškarpinę",
    MESSAGE_CLEARED: "Šiukšlinė sėkmingai išvalyta!",
    MESSAGE_SONG_ADDED: "Daina pridėta į šiukšlinę",
    MESSAGE_SONG_REMOVED: "Daina pašalinta iš šiukšlinės",
    MESSAGE_ARTIST_ADDED: "Dailininkas pridėtas į šiukšlinę",
    MESSAGE_ARTIST_REMOVED: "Dailininkas pašalintas iš šiukšlinės",
    BACKUP_SAVE_SUCCESS: "Atsarginė kopija sėkmingai išsaugota.",
    BACKUP_SAVE_FAILED: "Nepavyko išsaugoti atsarginės kopijos, pabandykite nukopijuoti šiukšlinės turinį į iškarpinę ir rankiniu būdu sukurti atsarginę kopiją.",
    BACKUP_RESTORE_SUCCESS: "Atsarginė kopija sėkmingai atkurta.",
    BACKUP_FILE_READ_FAILED: "Nepavyko perskaityti failo, įsitikinkite, kad tai yra galiojantis JSON failas.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Šiukšlinės+ nustatymai",
    SETTINGS_OPTIONS: "Parinktys",
    SETTINGS_FEATURES: "Funkcijos",
    SETTINGS_LOCAL_STORAGE: "Vietinis saugojimas",
    SETTINGS_ENABLED: "Įjungta",
    SETTINGS_SHOW_WIDGET: "Rodyti valdiklio piktogramą",
    SETTINGS_AUTOPLAY: "Automatinis paleidimas paleidžiant",
    SETTINGS_QUEUE_TRASHBIN: "Įgalinti eilės šiukšlinę",
    SETTINGS_TRACKLIST_TRASHBIN: "Įgalinti takelių sąrašo šiukšlinę",
    SETTINGS_PLAYLIST_MONITOR: "Grojaraščių monitorius",
    ITEMS_TITLE: "Šiukšlinės+ elementai",
    ITEMS_EMPTY_SONGS: "<strong>Jokių išmestų dainų!</strong><br/>Dainos, kurias sudėjote į šiukšlinę, bus rodomos čia.",
    ITEMS_EMPTY_ARTISTS: "<strong>Jokio šiukšlinamo meno kūrėjo!</strong><br/>Meno kūrėjai, kuriuos sudėjote į šiukšlinę, pasirodys čia.",
    ITEMS_TAB_SONGS: "Dainos",
    ITEMS_TAB_ARTISTS: "Dailininkai",
    ITEMS_LOADED_COUNT: "{{loaded}} iš {{total}} {{type}} įkelta",
    DESCRIPTION_COPY: "Kopijuoti visus šiukšlinėje esančius elementus į iškarpinę.",
    DESCRIPTION_EXPORT: "Išsaugoti visus šiukšlinės elementus į .json failą.",
    DESCRIPTION_IMPORT: "Perrašyti visus šiukšlinės elementus naudojant .json failą.",
    DESCRIPTION_CLEAR: "Išvalyti visus elementus iš šiukšlinės (negalima atšaukti).",
    ITEMS_EMPTY_SONGS_TITLE: "Nėra ištrintų dainų!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Jokių išmestų dailininkų!",
    DESCRIPTION_SETTINGS_ENABLED: "Pagrindinis jungiklis įgalinti arba išjungti visą Šiukšlinės+ funkcionalumą",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Rodyti šiukšliadėžės piktogramą paleidimo juostoje šalia dabar grojamo takelio, kad būtų greitas prieiga",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automatiškai paleisti muziką, kai atsidaro „Spotify“ arba įkeliama plėtinys",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Pridėkite šiukšlių dėžės piktogramas šalia kiekvienos dainos eilėje, kad būtų lengviau tvarkyti",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Pridėkite šiukšlių piktogramas šalia dainų albumų ir grojaraščių rodiniuose, kad būtų galima greitai filtruoti",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatiškai atkurti iš „Spotify“ grojimo sutrikimų, vėl paleidus paskutinį grojaraštį",
    SETTINGS_SKIP_TRASHED_TRACKS: "Praleisti ištrintus takelius",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Automatiškai praleisti ištrintas dainas ir grojant rasti kitą leistiną takelį",
    SETTINGS_AUTO_CLEAN_QUEUE: "Automatinio valymo eilė",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Automatiškai šalinkite ištrintas dainas iš savo išmaniųjų maišymo eilės",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Šiukšlės kitam karščiajam klavišui",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Automatiškai išmesti dabartinę dainą, naudojant Ctrl+dešinėn klavišų kombinaciją, kad pereitumėte prie kito takelio",
    SETTINGS_REMOTE_CONTROL: "Nuotolinis valdymas",
    SETTINGS_REMOTE_TOGGLE: "Įgalinti nuotolinį perjungimą",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Du kartus bakstelėkite paleisti / praleisti, kad iš mobilaus įjungtumėte nuotolinio praleidimo funkciją. Takelio praleidimas patvirtina šią funkciją.",
    SETTINGS_REMOTE_SKIPPING: "Nutolęs praleidimas aktyvus",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Įjungus šią funkciją, dainų praleidimas veikia net tada, kai „Spotify“ valdote iš kito įrenginio (pvz., iš mobilaus telefono)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Nuotolinis praleidimas įjungtas",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Nuotolinis praleidimas išjungtas",
    MESSAGE_SONG_ADDED_REMOTE: "Daina ištrinta iš toli",
    SETTINGS_TRASH_VIA_LIKE: "Šiukšlės per Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Kaip daina iš mobilaus į šiukšlyną. Automatiškai pašalina patiktuką ir pereina prie kito takelio.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/lv.json
var require_lv = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Atkritumu tvertne+",
    ACTION_THROW: "Ievietot atkritnos",
    ACTION_UNTHROW: "Izņemt no miskastes",
    ACTION_CLEAR: "Skaidrs",
    ACTION_COPY: "Kopēt",
    ACTION_EXPORT: "Eksports",
    ACTION_IMPORT: "Importēt",
    MESSAGE_COPIED: "Kopēts starpliktuvē",
    MESSAGE_CLEARED: "Atkritumu kaste veiksmīgi iztīrīta!",
    MESSAGE_SONG_ADDED: "Dziesma pievienota atkritni",
    MESSAGE_SONG_REMOVED: "Dziesma noņemta no miskastes",
    MESSAGE_ARTIST_ADDED: "Mākslinieks pievienots atkritne",
    MESSAGE_ARTIST_REMOVED: "Mākslinieks noņemts no atkritumu kastes",
    BACKUP_SAVE_SUCCESS: "Rezerves kopija veiksmīgi saglabāta.",
    BACKUP_SAVE_FAILED: "Neizdevās saglabāt rezerves kopiju, mēģiniet kopēt miskastes saturu starpliktuvē un manuāli izveidot rezerves kopiju.",
    BACKUP_RESTORE_SUCCESS: "Rezerves kopija veiksmīgi atjaunota.",
    BACKUP_FILE_READ_FAILED: "Neizdevās nolasīt failu, lūdzu, pārliecinieties, ka tas ir derīgs JSON fails.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Trashbin+ iestatījumi",
    SETTINGS_OPTIONS: "Iespējas",
    SETTINGS_FEATURES: "Iezīmes",
    SETTINGS_LOCAL_STORAGE: "Vietējā krātuve",
    SETTINGS_ENABLED: "Ieslēgts",
    SETTINGS_SHOW_WIDGET: "Rādīt logrīka ikonu",
    SETTINGS_AUTOPLAY: "Automātiska atskaņošana startējot",
    SETTINGS_QUEUE_TRASHBIN: "Iespējot rindas miskasti",
    SETTINGS_TRACKLIST_TRASHBIN: "Ieslēgt dziesmu saraksta miskasti",
    SETTINGS_PLAYLIST_MONITOR: "Reprodukcijas sarakstu pārvaldnieks",
    ITEMS_TITLE: "Priekšmeti no miskastes+",
    ITEMS_EMPTY_SONGS: "<strong>Nav dzēstas dziesmas!</strong><br/>Dziesmas, kuras jūs iemetīsiet atkritnos, parādīsies šeit.",
    ITEMS_EMPTY_ARTISTS: "<strong>Nav izmestu mākslinieku!</strong><br/>Mākslinieki, kurus jūs iemetīsiet atkritnos, parādīsies šeit.",
    ITEMS_TAB_SONGS: "Dziesmas",
    ITEMS_TAB_ARTISTS: "Mākslinieki",
    ITEMS_LOADED_COUNT: "Ielādēti {{loaded}} no {{total}} {{type}}",
    DESCRIPTION_COPY: "Kopēt visus atkritnumešā esošos vienumus starpliktuvē.",
    DESCRIPTION_EXPORT: "Saglabāt visus elementus atkritnes kastē .json failā.",
    DESCRIPTION_IMPORT: "Pārrakstīt visus elementus miskastē, izmantojot .json failu.",
    DESCRIPTION_CLEAR: "Notīrīt visus vienumus no miskastes (nevar atsaukt).",
    ITEMS_EMPTY_SONGS_TITLE: "Nav izdzēstu dziesmu!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Nē, izmestajiem māksliniekiem!",
    DESCRIPTION_SETTINGS_ENABLED: "Galvenais slēdzis, lai ieslēgtu vai izslēgtu visas miskastītes+ funkcijas",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Attēlot atkritumu ikonu atskaņošanas joslā blakus pašreizējai atskaņošanas kompilācijai ātrai piekļuvei",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automātiski sākt mūziku, kad atveras Spotify vai tiek ielādēts paplašinājums",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Pievienojiet atkritumu ikonas katram dziesmai jūsu tuvojo rindā, lai būtu vieglāk pārvaldīt",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Albumu un atskaņošanas sarakstu skatos pie dziesmām pievienot miskastīšu ikonas ātrai filtrēšanai",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automātiski atgūstieties no Spotify atskaņošanas problēmām, atsākot pēdējo sarakstu",
    SETTINGS_SKIP_TRASHED_TRACKS: "Izlaidt izdzēstos trakus",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Automātiski izlaist dziesmas, kas pārvietotas atkritnēs, un atskaņošanas laikā atrast nākamo atļauto kompozīciju",
    SETTINGS_AUTO_CLEAN_QUEUE: "Automātiskās tīrīšanas rinda",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Automātiski noņemt izdzēstās dziesmas no jūsu gudrās jaukto saraksta rindas",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Miskaste uz nākamo karstās taustiņa kombinācijas",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Automātiski izmest pašreizējo dziesmu, izmantojot taustiņu kombināciju Ctrl+pa labi, lai pārietu uz nākamo kompozīciju",
    SETTINGS_REMOTE_CONTROL: "Tālvadības pulti",
    SETTINGS_REMOTE_TOGGLE: "Iespējot attālo slēdzi",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dubultklikšķis uz atskaņošanas/pauzes mobilajā, lai ieslēgtu/izslēgtu attālinātu pārslēgšanu. Trases pārslēgšana apstiprina ieslēgšanu.",
    SETTINGS_REMOTE_SKIPPING: "Attālināta izlaišana aktīva",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Ieslēdzot, miskastē nelikšana darbojas pat tad, ja Spotify tiek kontrolēts no cita ierīces (piemēram, mobilā tālruņa)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Attālināta pārlēkšana iespējota",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Attālināta izlaišana atspējota",
    MESSAGE_SONG_ADDED_REMOTE: "Dziesma iznīcināta attālināti",
    SETTINGS_TRASH_VIA_LIKE: "Miskaste, izmantojot Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Kā dziesmu no mobilā, lai to izmestu. Automātiski noņem patīk un pāriet uz nākamo kompozīciju.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/mk.json
var require_mk = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Канта за отпадоци+",
    ACTION_THROW: "Стави во кофата за отпадоци",
    ACTION_UNTHROW: "Отстрани од кофата за отпадоци",
    ACTION_CLEAR: "Јасно",
    ACTION_COPY: "Копирај",
    ACTION_EXPORT: "Извоз",
    ACTION_IMPORT: "Увоз",
    MESSAGE_COPIED: "Копирано во таблата",
    MESSAGE_CLEARED: "Канчето за отпадоци е успешно исчистено!",
    MESSAGE_SONG_ADDED: "Песната е додадена во кофата за отпад",
    MESSAGE_SONG_REMOVED: "Песната е отстранета од кофата за отпад",
    MESSAGE_ARTIST_ADDED: "Уметникот е додаден во корпата за отпадоци",
    MESSAGE_ARTIST_REMOVED: "Уметникот е отстранет од сандучето за отпадоци",
    BACKUP_SAVE_SUCCESS: "Резервното копирање е успешно зачувано.",
    BACKUP_SAVE_FAILED: "Неуспешно зачувување на резервна копија, обидете се со копирање на содржината на кофата за ѓубре во таблата и рачно креирање на резервна копија.",
    BACKUP_RESTORE_SUCCESS: "Резервното копие е успешно вратено.",
    BACKUP_FILE_READ_FAILED: "Неуспешно читање на датотеката, ве молиме уверете се дека е валидна JSON датотека.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Поставувања за Trashbin+",
    SETTINGS_OPTIONS: "Опции",
    SETTINGS_FEATURES: "Карактеристики",
    SETTINGS_LOCAL_STORAGE: "Локален мемориски простор",
    SETTINGS_ENABLED: "Овозможено",
    SETTINGS_SHOW_WIDGET: "Прикажи икона на додатокот",
    SETTINGS_AUTOPLAY: "Автоматско пуштање при стартување",
    SETTINGS_QUEUE_TRASHBIN: "Овозможи кош за отпадоци од редоследот",
    SETTINGS_TRACKLIST_TRASHBIN: "Овозможи кошче за листата на нумери",
    SETTINGS_PLAYLIST_MONITOR: "Плејлиста Монитор",
    ITEMS_TITLE: "Предмети од кофата за отпадоци+",
    ITEMS_EMPTY_SONGS: "<strong>Нема избришани песни!</strong><br/>Песните што ги додавате во кошчето за отпад ќе се појават овде.",
    ITEMS_EMPTY_ARTISTS: "<strong>Нема избришани уметници!</strong><br/>Уметниците што ги додавате во кошчето за отпад ќе се појават овде.",
    ITEMS_TAB_SONGS: "Песни",
    ITEMS_TAB_ARTISTS: "Уметници",
    ITEMS_LOADED_COUNT: "{{loaded}} од {{total}} {{type}} вчитани",
    DESCRIPTION_COPY: "Копирај ги сите ставки во кошчето за отпад во клипборд.",
    DESCRIPTION_EXPORT: "Зачувај ги сите ставки во кошчето за отпад во .json датотека.",
    DESCRIPTION_IMPORT: "Препиши ги сите ставки во кошчето преку .json датотека.",
    DESCRIPTION_CLEAR: "Исчисти ги сите ставки од кошчето за отпадоци (не може да се врати).",
    ITEMS_EMPTY_SONGS_TITLE: "Без избришани песни!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Без уништени уметници!",
    DESCRIPTION_SETTINGS_ENABLED: "Главно преклопување за овозможување или оневозможување на сите функции на Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Прикажи икона за корпа за отпадоци на лентата за пуштање до трекот кој се пушта за брз пристап",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Автоматски започни со пуштање музика кога Спотифај ќе се отвори или кога ќе се вчита проширувањето",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Додај икони за браќе до секоја песна во редицата за следно пуштање за полесно управување",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Додај икони за браќе до песните во албумите и листите за свирење за брзо филтрирање",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Автоматско враќање од грешките при репродуцирањето на Spotify со продолжување на вашата последна плејлиста",
    SETTINGS_SKIP_TRASHED_TRACKS: "Прескокни избришани песни",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Автоматски прескокни ги избришаните песни и пронајди ја следната дозволена песна за време на репродукцијата",
    SETTINGS_AUTO_CLEAN_QUEUE: "Автоматска чистачка редица",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Автоматски отстрани ги избришаните песни од редицата за паметно мешање",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Смрдот на следната копка за брз пристап",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Автоматски испраќај ја тековната песна во корпа кога користиш ја комбинацијата Ctrl+Десно за прескокнување на следната песна",
    SETTINGS_REMOTE_CONTROL: "Далечинско управување",
    SETTINGS_REMOTE_TOGGLE: "Овозможи промена од далечина",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Два пати допрете ја иконата за пуштање/пауза од мобилното за да вклучите/исклучите прескокнување на далечинска. Прескокнувањето на песна ја потврдува промената.",
    SETTINGS_REMOTE_SKIPPING: "Активно далечинско прескокнување",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Кога е овозможено, прескокнувањето на отпадот функционира дури и кога управувате со Spotify од друг уред (на пр., мобилен телефон)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Овозможено е прескокнување од далечина",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Оддалеченото прескокнување е оневозможено",
    MESSAGE_SONG_ADDED_REMOTE: "Песната уништена преку далечинско управување",
    SETTINGS_TRASH_VIA_LIKE: "Сметче преку Сакам",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Како песна од мобилно до корпа за отпад. Автоматски ја откажува и преминува на следната песна.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ml.json
var require_ml = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ട്രാഷ്ബിൻ+",
    ACTION_THROW: "അപായ ബിന്നിൽ ഇടുക",
    ACTION_UNTHROW: "ട്രഷ്ബിനിൽ നിന്ന് നീക്കം ചെയ്യുക",
    ACTION_CLEAR: "വ്യക്തമായ",
    ACTION_COPY: "പകർപ്പ്",
    ACTION_EXPORT: "കയറ്റുമതി ചെയ്യുക",
    ACTION_IMPORT: "ഇറക്കുമതി ചെയ്യുക",
    MESSAGE_COPIED: "ക്ലിപ്പ്ബോർഡിലേക്ക് പകർത്തി",
    MESSAGE_CLEARED: "ചവറ്റുകൊട്ട വിജയകരമായി ശൂന്യമാക്കി!",
    MESSAGE_SONG_ADDED: "ഗാനം ചവറ്റുകൊട്ടയിലേക്ക് ചേർത്തു",
    MESSAGE_SONG_REMOVED: "ട്രാഷ്ബിനിൽ നിന്ന് പാട്ട് നീക്കം ചെയ്തു",
    MESSAGE_ARTIST_ADDED: "ആർട്ടിസ്റ്റ് ട്രാഷ്ബിനിലേക്ക് ചേർത്തു",
    MESSAGE_ARTIST_REMOVED: "അവശിഷ്ടങ്ങളുടെ പെട്ടിയിൽ നിന്ന് ആർട്ടിസ്റ്റിനെ നീക്കം ചെയ്തു",
    BACKUP_SAVE_SUCCESS: "ബാക്കപ്പ് വിജയകരമായി സേവ് ചെയ്തു.",
    BACKUP_SAVE_FAILED: "ബാക്കപ്പ് സംരക്ഷിക്കുന്നതിൽ പരാജയപ്പെട്ടു, ത്രാഷ്ബിന്റെ ഉള്ളടക്കങ്ങൾ ക്ലിപ്പ്ബോർഡിലേക്ക് പകർത്തി ഒരു ബാക്കപ്പ് കൈമുതലായി സൃഷ്ടിക്കാൻ ശ്രമിക്കുക.",
    BACKUP_RESTORE_SUCCESS: "ബാക്കപ്പ് വിജയകരമായി പുനഃസ്ഥാപിച്ചു.",
    BACKUP_FILE_READ_FAILED: "ഫയൽ വായിക്കുന്നതിൽ പരാജയപ്പെട്ടു, ദയവായി അത് ഒരു സാധുവായ JSON ഫയലാണെന്ന് ഉറപ്പാക്കുക.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ട്രാഷ്ബിൻ+ ക്രമീകരണങ്ങൾ",
    SETTINGS_OPTIONS: "ഓപ്ഷനുകൾ",
    SETTINGS_FEATURES: "സവിശേഷതകൾ",
    SETTINGS_LOCAL_STORAGE: "സ്ഥാനിക സംഭരണം",
    SETTINGS_ENABLED: "സജീവമാക്കി",
    SETTINGS_SHOW_WIDGET: "വിജറ്റ് ഐക്കൺ കാണിക്കുക",
    SETTINGS_AUTOPLAY: "ആരംഭത്തിൽ ഓട്ടോപ്ലേ ചെയ്യുക",
    SETTINGS_QUEUE_TRASHBIN: "അടുക്കിവയ്ക്കുന്നതിന് ട്രഷ്ബിൻ സജീവമാക്കുക",
    SETTINGS_TRACKLIST_TRASHBIN: "ട്രാക്ക്‌ലിസ്റ്റ് ട്രഷ്ബിൻ സജീവമാക്കുക",
    SETTINGS_PLAYLIST_MONITOR: "പ്ലേലിസ്റ്റ് മോണിറ്റർ",
    ITEMS_TITLE: "ട്രാഷ്ബിൻ+ ഇനങ്ങൾ",
    ITEMS_EMPTY_SONGS: "<strong>ഒന്നും നശിപ്പിച്ചിട്ടില്ല!</strong><br/>നിങ്ങൾ നശിപ്പിക്കാൻ ചേർത്ത ഗാനങ്ങൾ ഇവിടെ പ്രത്യക്ഷപ്പെടും.",
    ITEMS_EMPTY_ARTISTS: "<strong>ഒരു കലാകാരനെയും ഒഴിവാക്കരുത്!</strong><br/>നിങ്ങൾ അപ്പായത്തിലേക്ക് ചേർക്കുന്ന കലാകാരന്മാർ ഇവിടെ പ്രത്യക്ഷപ്പെടും.",
    ITEMS_TAB_SONGS: "ഗാനങ്ങൾ",
    ITEMS_TAB_ARTISTS: "കലാകാരന്മാർ",
    ITEMS_LOADED_COUNT: "{{total}} ൽ {{loaded}} {{type}} ലോഡ് ചെയ്തു",
    DESCRIPTION_COPY: "ലാവണ്യപ്പെട്ട ബിന്നിലെ എല്ലാ ഇനങ്ങളും ക്ലിപ്പ്ബോർഡിലേക്ക് പകർത്തുക.",
    DESCRIPTION_EXPORT: "ട്രാഷ്ബിനിലെ എല്ലാ ഇനങ്ങളും ഒരു .json ഫയലിൽ സംരക്ഷിക്കുക.",
    DESCRIPTION_IMPORT: "അവശേഷിക്കുന്ന എല്ലാ ഇനങ്ങളും .json ഫയലിലൂടെ ഓവർറൈറ്റ് ചെയ്യുക.",
    DESCRIPTION_CLEAR: "ട്രാഷ്ബിനിൽ നിന്ന് എല്ലാ ഇനങ്ങളും നീക്കം ചെയ്യുക (തിരികെ പുനഃസ്ഥാപിക്കാൻ കഴിയില്ല).",
    ITEMS_EMPTY_SONGS_TITLE: "ഒരു നശിപ്പിച്ച പാട്ടുകളുമില്ല!",
    ITEMS_EMPTY_ARTISTS_TITLE: "ആരും തള്ളിക്കളയരുത്!",
    DESCRIPTION_SETTINGS_ENABLED: "എല്ലാ ത്രാഷ്ബിൻ+ പ്രവർത്തനങ്ങളും സജീവമാക്കുന്നതിനോ നിഷ്ക്രിയമാക്കുന്നതിനോ ഉള്ള മാസ്റ്റർ ടോഗിൾ",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "നിലവിൽ പ്ലേ ചെയ്യുന്ന ട്രാക്കിന് അടുത്തായി പ്ലേബാക്ക് ബാറിൽ ഒരു ട്രാഷ് ഐക്കൺ പ്രദർശിപ്പിക്കുക",
    DESCRIPTION_SETTINGS_AUTOPLAY: "സ്പോട്ടിഫൈ തുറക്കുമ്പോഴോ എക്സ്റ്റൻഷൻ ലോഡ് ചെയ്യുമ്പോഴോ സ്വയമേവ സംഗീതം പ്ലേ ചെയ്യാൻ ആരംഭിക്കുക",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "നിങ്ങളുടെ അടുത്തടുത്തുള്ള ക്യൂവിൽ ഓരോ ഗാനത്തിനും അടുത്തായി ത്രാഷ് ഐക്കണുകൾ ചേർക്കുക, എളുപ്പത്തിൽ കൈകാര്യം ചെയ്യാൻ",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "ആൽബം, പ്ലേലിസ്റ്റ് വ്യൂകളിൽ പാട്ടുകൾക്ക് അടുത്ത് ചവറ്റുകുപ്പി ഐക്കണുകൾ ചേർക്കുക, വേഗത്തിലുള്ള ഫിൽട്ടറിംഗിനായി",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "അവസാന പ്ലേലിസ്റ്റ് പുനഃരാരംഭിക്കുന്നതിലൂടെ സ്പോട്ടിഫൈ പ്ലേബാക്ക് പിഴവുകളിൽ നിന്ന് സ്വയമേവ പുനഃസ്ഥാപിക്കുക",
    SETTINGS_SKIP_TRASHED_TRACKS: "തകരാറിലായ ട്രാക്കുകൾ ഉപേക്ഷിക്കുക",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "തുടച്ചുനീക്കിയ ഗാനങ്ങൾ സ്വയമേവ ഒഴിവാക്കി പ്ലേബാക്കിനിടെ അടുത്തതായി അനുവദിച്ച ട്രാക്ക് കണ്ടെത്തുക",
    SETTINGS_AUTO_CLEAN_QUEUE: "ഓട്ടോ ക്ലീൻ ക്യൂ",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "നിങ്ങളുടെ സ്മാർട്ട് ഷഫിൾ ക്യൂവിൽ നിന്ന് ത്രാഷ് ചെയ്ത പാട്ടുകൾ സ്വയമേവ നീക്കം ചെയ്യുക",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "അടുത്ത ഹോട്ട്കീയിൽ ത്രാഷ്",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "അടുത്ത ട്രാക്കിലേക്ക് ചാടാൻ Ctrl+Right കീബോർഡ് ഷോർട്ട്കട്ട് ഉപയോഗിക്കുമ്പോൾ നിലവിലെ ഗാനം സ്വയമേവ ത്രാഷ് ചെയ്യുക",
    SETTINGS_REMOTE_CONTROL: "റിമോട്ട് കൺട്രോൾ",
    SETTINGS_REMOTE_TOGGLE: "റിമോട്ട് ടോഗിൾ സജ്ജമാക്കുക",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "മൊബൈലിൽ നിന്ന് റിമോട്ട് ഉപേക്ഷിക്കുന്നത് ഓണാക്കാനും ഓഫാക്കാനും പ്ലേ/പൗസ് ഡബിൾ-ടാപ്പ് ചെയ്യുക. ഒരു ട്രാക്ക് ഉപേക്ഷിക്കൽ ടോഗിൾ സ്ഥിരീകരിക്കുന്നു.",
    SETTINGS_REMOTE_SKIPPING: "റിമോട്ട് സ്കിപ്പിംഗ് സജീവമാണ്",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "സക്രിയമാക്കിയാൽ, മറ്റൊരു ഉപകരണത്തിൽ നിന്ന് (ഉദാ: മൊബൈൽ) സ്പോട്ടിഫൈ നിയന്ത്രിക്കുമ്പോൾ പോലും ട്രാഷ് ഒഴിവാക്കൽ പ്രവർത്തിക്കുന്നു",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "ദൂരെ നിന്നുള്ള തുടര്‍ച്ചയായ ഉപേക്ഷ സജീവമാക്കി",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "ദൂരെ നിന്നുള്ള ഉപേക്ഷിക്കൽ പ്രവർത്തനരഹിതമാക്കി",
    MESSAGE_SONG_ADDED_REMOTE: "റിമോട്ട് വഴി പാട്ട് നശിപ്പിച്ചു",
    SETTINGS_TRASH_VIA_LIKE: "ലൈക്കിലൂടെ ചവറ്",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "മൊബൈലിൽ നിന്ന് ഒരു പാട്ട് തെരഞ്ഞെടുത്ത് അതിനെ ഒഴിവാക്കുന്നത് പോലെ. സ്വയമായി അൺലൈക്ക് ചെയ്ത് അടുത്ത ട്രാക്കിലേക്ക് മാറുന്നു.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/mr.json
var require_mr = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "कचऱ्याची टोपली+",
    ACTION_THROW: "कचऱ्याच्या डब्यात ठेवा",
    ACTION_UNTHROW: "कचऱ्याची टोपलीतून काढा",
    ACTION_CLEAR: "स्पष्ट",
    ACTION_COPY: "कॉपी",
    ACTION_EXPORT: "निर्यात",
    ACTION_IMPORT: "आयात",
    MESSAGE_COPIED: "क्लिपबोर्डवर कॉपी केले",
    MESSAGE_CLEARED: "कचऱ्याची टोपली यशस्वीरित्या स्वच्छ केली!",
    MESSAGE_SONG_ADDED: "गाणे रद्दीच्या टोपलीत जोडले गेले",
    MESSAGE_SONG_REMOVED: "गाणे रद्द केलेल्या फाइल्सच्या फोल्डरमधून काढून टाकले",
    MESSAGE_ARTIST_ADDED: "कलाकाराला ट्रॅशबिनमध्ये जोडले",
    MESSAGE_ARTIST_REMOVED: "कलाकाराला ट्रॅशबिनमधून काढून टाकले",
    BACKUP_SAVE_SUCCESS: "बॅकअप यशस्वीरित्या सेव्ह झाले.",
    BACKUP_SAVE_FAILED: "बॅकअप जतन करण्यात अयशस्वी, ट्रॅशबिनची सामग्री क्लिपबोर्डवर कॉपी करण्याचा प्रयत्न करा आणि स्वतःहून बॅकअप तयार करा.",
    BACKUP_RESTORE_SUCCESS: "बॅकअप यशस्वीरित्या पुन्हा स्थापित केले.",
    BACKUP_FILE_READ_FAILED: "फाइल वाचण्यात अयशस्वी, कृपया खात्री करा की ती वैध JSON फाइल आहे.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ट्रॅशबिन+ सेटिंग्ज",
    SETTINGS_OPTIONS: "पर्याय",
    SETTINGS_FEATURES: "वैशिष्ट्ये",
    SETTINGS_LOCAL_STORAGE: "स्थानिक संचय",
    SETTINGS_ENABLED: "सक्षम केले",
    SETTINGS_SHOW_WIDGET: "विडगेट आयकॉन दाखवा",
    SETTINGS_AUTOPLAY: "सुरुवातीला स्वयंचलित प्रारंभ",
    SETTINGS_QUEUE_TRASHBIN: "कतार ट्रॅशबिन सक्षम करा",
    SETTINGS_TRACKLIST_TRASHBIN: "ट्रॅकलिस्ट ट्रॅशबिन सक्षम करा",
    SETTINGS_PLAYLIST_MONITOR: "प्लेलिस्ट मॉनिटर",
    ITEMS_TITLE: "ट्रॅशबिन+ आयटम्स",
    ITEMS_EMPTY_SONGS: "<strong>कोणतेही फेकलेले गाणे नाहीत!</strong><br/>तुम्ही रद्दी पेटीमध्ये जोडलेली गाणी येथे दिसतील.",
    ITEMS_EMPTY_ARTISTS: "<strong>कोणतेही कचऱ्यात टाकलेले कलाकार नाहीत!</strong><br/>तुम्ही कचऱ्याच्या डब्यात जोडलेले कलाकार येथे दिसतील.",
    ITEMS_TAB_SONGS: "गाणी",
    ITEMS_TAB_ARTISTS: "कलाकार",
    ITEMS_LOADED_COUNT: "लोड झालेले {{total}} पैकी {{loaded}} {{type}}",
    DESCRIPTION_COPY: "ट्रॅशबिनमधील सर्व घटक क्लिपबोर्डवर कॉपी करा.",
    DESCRIPTION_EXPORT: "त्रष्टबिनमधील सर्व घटक .json फाइलमध्ये जतन करा.",
    DESCRIPTION_IMPORT: ".json फाइलद्वारे ट्रॅशबिनमधील सर्व आयटम ओव्हरराइट करा.",
    DESCRIPTION_CLEAR: "कचऱ्याच्या डब्यातील सर्व वस्तू स्पष्ट करा (परत करता येणार नाही).",
    ITEMS_EMPTY_SONGS_TITLE: "कोणतेही फेकलेले गाणे नाहीत!",
    ITEMS_EMPTY_ARTISTS_TITLE: "कोणतेही फेकलेले कलाकार नाहीत!",
    DESCRIPTION_SETTINGS_ENABLED: "सर्व ट्रॅशबिन+ कार्यक्षमता सक्षम करण्यासाठी किंवा अक्षम करण्यासाठी मास्टर टॉगल",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "सध्या चालणाऱ्या ट्रॅकच्या जवळ प्लेबॅक बारमध्ये जलद प्रवेशासाठी ट्रॅश आयकॉन दाखवा",
    DESCRIPTION_SETTINGS_AUTOPLAY: "स्पॉटिफाई उघडल्यावर किंवा एक्सटेंशन लोड झाल्यावर स्वयंचलितपणे संगीत वाजवण्यास सुरुवात करा",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "तुमच्या येणार्‍या रांगेतील प्रत्येक गाण्याजवळ सोप्या व्यवस्थापनासाठी घाण कचरा आयकॉन जोडा",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "अल्बम आणि वाजवणीयादीमधील गाण्यांच्या जवळ ट्रॅश आयकॉन्स जोडा जलद फिल्टरिंगसाठी",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "स्पॉटिफाई वरील प्लेबॅकच्या त्रुटींपासून तुमची शेवटची प्लेलिस्ट पुन्हा सुरू करून स्वयंचलितपणे वसूल होणे",
    SETTINGS_SKIP_TRASHED_TRACKS: "खंडित ट्रॅक्स वर जा",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "स्वयंचलितपणे फेकलेल्या गाण्यांना उल्लंघून प्लेबॅकदरम्यान पुढील परवानगी दिलेले ट्रॅक शोधा",
    SETTINGS_AUTO_CLEAN_QUEUE: "ऑटो क्लीन कतार",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "तुमच्या स्मार्ट शफल रांगेतून फेकलेल्या गाण्यांचे स्वयंचलितपणे काढून टाका",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "पुढील हॉटकीवर ट्रॅश",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Ctrl+Right कीबोर्ड शॉर्टकट वापरून पुढील ट्रॅकवर जाण्यासाठी सध्याचे गाणे स्वयंचलितपणे ट्रॅश करा",
    SETTINGS_REMOTE_CONTROL: "दूरस्थ नियंत्रण",
    SETTINGS_REMOTE_TOGGLE: "दूरस्थ टॉगल सक्षम करा",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "मोबाइलवरून रिमोट स्किपिंग चालू/बंद करण्यासाठी दुहेरी टॅप प्ले/थांबवा. ट्रॅक स्किप करणे हे टॉगल पुष्टी करते.",
    SETTINGS_REMOTE_SKIPPING: "दूरस्थ उद्धृत करणे सक्रिय",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "सक्षम असताना, ट्रॅश-स्किपिंग इतर डिव्हाइसवरून (उदा., मोबाइल) स्पॉटिफाय नियंत्रित करताना देखील काम करते",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "दूरस्थ स्किपिंग सक्षम केले आहे",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "दूरस्थ स्किपिंग अक्षम केले आहे",
    MESSAGE_SONG_ADDED_REMOTE: "गाणे दूरस्थरित्या नष्ट केले",
    SETTINGS_TRASH_VIA_LIKE: "लायकेसह ट्रॅश",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "मोबाइलमधून ते ट्रॅश करण्यासाठी एक गाणे. स्वयंचलितपणे आवड नाही आणि पुढील ट्रॅकवर जाते.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ms.json
var require_ms = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Tong sampah+",
    ACTION_THROW: "Letakkan dalam Tong Sampah",
    ACTION_UNTHROW: "Alih keluar dari Tong Sampah",
    ACTION_CLEAR: "Jelas",
    ACTION_COPY: "Salin",
    ACTION_EXPORT: "Eksport",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Disalin ke papan klip",
    MESSAGE_CLEARED: "Tong sampah berjaya dikosongkan!",
    MESSAGE_SONG_ADDED: "Lagu ditambah ke dalam tong sampah",
    MESSAGE_SONG_REMOVED: "Lagu dikeluarkan dari tong sampah",
    MESSAGE_ARTIST_ADDED: "Artis ditambah ke tong sampah",
    MESSAGE_ARTIST_REMOVED: "Artis dikeluarkan dari tong sampah",
    BACKUP_SAVE_SUCCESS: "Sandaran berjaya disimpan.",
    BACKUP_SAVE_FAILED: "Gagal menyimpan sandaran, cuba salin kandungan tong sampah ke papan keratan dan cipta sandaran secara manual.",
    BACKUP_RESTORE_SUCCESS: "Sandaran dipulihkan berjaya.",
    BACKUP_FILE_READ_FAILED: "Gagal membaca fail, sila pastikan ia adalah fail JSON yang sah.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Tetapan Tong Sampah+",
    SETTINGS_OPTIONS: "Pilihan",
    SETTINGS_FEATURES: "Ciri-ciri",
    SETTINGS_LOCAL_STORAGE: "Storan tempatan",
    SETTINGS_ENABLED: "Didayakan",
    SETTINGS_SHOW_WIDGET: "Tunjukkan Ikon Widget",
    SETTINGS_AUTOPLAY: "Main secara automatik pada permulaan",
    SETTINGS_QUEUE_TRASHBIN: "Dayakan Tong Sampah Barisan",
    SETTINGS_TRACKLIST_TRASHBIN: "Dayakan Tong Sampah Senarai Trek",
    SETTINGS_PLAYLIST_MONITOR: "Pemantau Senarai Main",
    ITEMS_TITLE: "Barangan Tong Sampah+",
    ITEMS_EMPTY_SONGS: "<strong>Tiada lagu yang dibuang ke tong sampah!</strong><br/>Lagu yang anda tambah ke tong sampah akan muncul di sini.",
    ITEMS_EMPTY_ARTISTS: "<strong>Tiada artis yang dibuang!</strong><br/>Artis yang anda tambah ke dalam tong sampah akan muncul di sini.",
    ITEMS_TAB_SONGS: "Lagu-lagu",
    ITEMS_TAB_ARTISTS: "Artis",
    ITEMS_LOADED_COUNT: "{{loaded}} daripada {{total}} {{type}} telah dimuatkan",
    DESCRIPTION_COPY: "Salin semua item dalam tong sampah ke papan keratan.",
    DESCRIPTION_EXPORT: "Simpan semua item dalam tong sampah ke fail .json.",
    DESCRIPTION_IMPORT: "Timpa semua item dalam tong sampah melalui fail .json.",
    DESCRIPTION_CLEAR: "Padam semua item dari tong sampah (tidak boleh dikembalikan).",
    ITEMS_EMPTY_SONGS_TITLE: "Tiada lagu yang dibuang ke sampah!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Tiada artis yang dibuang!",
    DESCRIPTION_SETTINGS_ENABLED: "Tukar utama untuk mengaktifkan atau menyahaktifkan semua fungsi Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Paparkan ikon tong sampah di bar pemainan bersebelahan trek yang sedang dimainkan untuk akses pantas",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Mainkan muzik secara automatik apabila Spotify dibuka atau pelanjutan dimuatkan",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Tambah ikon sampah di sebelah setiap lagu dalam barisan anda yang akan datang untuk pengurusan yang mudah",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Tambah ikon sampah di sebelah lagu dalam paparan album dan senarai main untuk penapisan pantas",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Pulih secara automatik daripada masalah pemain Spotify dengan meneruskan senarai main terakhir anda",
    SETTINGS_SKIP_TRASHED_TRACKS: "Langkau Trek yang Dibuang",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Langkau lagu yang dibuang secara automatik dan cari trek seterusnya yang dibenarkan semasa pemainan",
    SETTINGS_AUTO_CLEAN_QUEUE: "Barisan Pembersihan Automatik",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Alih keluar secara automatik lagu yang dibuang dari barisan Smart Shuffle anda",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Sampah pada Pintasan Berikutnya",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Buang lagu semasa secara automatik apabila menggunakan pintasan papan kekunci Ctrl+Kanan untuk melangkau ke trek seterusnya",
    SETTINGS_REMOTE_CONTROL: "Kawalan Jauh",
    SETTINGS_REMOTE_TOGGLE: "Dayakan Butang Togol Jauh",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Ketik dua kali play/jeda dari peranti mudah alih untuk mengaktifkan atau mematikan lompatan jauh. Lompatan trek mengesahkan pengaktifan tersebut.",
    SETTINGS_REMOTE_SKIPPING: "Langkau Jauh Aktif",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Apabila didayakan, langkau sampah berfungsi walaupun mengawal Spotify daripada peranti lain (contohnya, telefon bimbit)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Langkahan jauh didayakan",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Langkau jauh dilumpuhkan",
    MESSAGE_SONG_ADDED_REMOTE: "Lagu dimusnahkan melalui jarak jauh",
    SETTINGS_TRASH_VIA_LIKE: "Sampah melalui Suka",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Seperti lagu dari telefon bimbit ke tempat sampah. Secara automatik batal suka dan terus ke trek seterusnya.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/nb.json
var require_nb = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Papirkurv+",
    ACTION_THROW: "Plasser i søppelkurven",
    ACTION_UNTHROW: "Fjern fra søppelkassen",
    ACTION_CLEAR: "Klar",
    ACTION_COPY: "Kopier",
    ACTION_EXPORT: "Eksport",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Kopiert til utklippstavlen",
    MESSAGE_CLEARED: "Papirkurven er tømt!",
    MESSAGE_SONG_ADDED: "Sang lagt i søppelbøtta",
    MESSAGE_SONG_REMOVED: "Sang fjernet fra søppelkassen",
    MESSAGE_ARTIST_ADDED: "Kunstner lagt til søppelbøtta",
    MESSAGE_ARTIST_REMOVED: "Kunstner fjernet fra søppelkassen",
    BACKUP_SAVE_SUCCESS: "Sikkerhetskopi lagret vellykket.",
    BACKUP_SAVE_FAILED: "Kunne ikke lagre sikkerhetskopi, prøv å kopiere innholdet i papirkurven til utklippstavlen og lag en sikkerhetskopi manuelt.",
    BACKUP_RESTORE_SUCCESS: "Sikkerhetskopi gjenopprettet.",
    BACKUP_FILE_READ_FAILED: "Kunne ikke lese filen, vær sikker på at det er en gyldig JSON-fil.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Søppelkorg+ innstillinger",
    SETTINGS_OPTIONS: "Alternativer",
    SETTINGS_FEATURES: "Funksjoner",
    SETTINGS_LOCAL_STORAGE: "Lokal lagring",
    SETTINGS_ENABLED: "Aktivert",
    SETTINGS_SHOW_WIDGET: "Vis miniprogram-ikon",
    SETTINGS_AUTOPLAY: "Automatisk avspilling ved oppstart",
    SETTINGS_QUEUE_TRASHBIN: "Aktiver kø-papirkurv",
    SETTINGS_TRACKLIST_TRASHBIN: "Aktiver sporliste-søppelkasse",
    SETTINGS_PLAYLIST_MONITOR: "Spillelisteovervåkning",
    ITEMS_TITLE: "Papirkurv+-elementer",
    ITEMS_EMPTY_SONGS: "<strong>Ingen slettede sanger!</strong><br/>Sanger du legger i søppelbøtta vil vises her.",
    ITEMS_EMPTY_ARTISTS: "<strong>Ingen kunstnere i papirkurven!</strong><br/>Kunstnere du legger i papirkurven vil vises her.",
    ITEMS_TAB_SONGS: "Sanger",
    ITEMS_TAB_ARTISTS: "Kunstnere",
    ITEMS_LOADED_COUNT: "{{loaded}} av {{total}} {{type}} lastet inn",
    DESCRIPTION_COPY: "Kopier alle elementer i søppelkassen til utklippstavlen.",
    DESCRIPTION_EXPORT: "Lagre alle elementer i søppelkassen til en .json-fil.",
    DESCRIPTION_IMPORT: "Overskriv alle elementer i søppelkassen via .json-fil.",
    DESCRIPTION_CLEAR: "Tøm alle elementer fra søppelbøtta (kan ikke angres).",
    ITEMS_EMPTY_SONGS_TITLE: "Ingen slettede sanger!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Ingen søpla med artister!",
    DESCRIPTION_SETTINGS_ENABLED: "Hovedbryter for å aktivere eller deaktivere all papirkurv+-funksjonalitet",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Vis et søppelikon i avspillingslinjen ved siden av den nåværende sporet for rask tilgang",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Start automatisk å spille musikk når Spotify åpnes eller utvidelsen lastes",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Legg til søppelikoner ved siden av hver sang i køen din for enkel håndtering",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Legg til søppelkorg-ikoner ved siden av sanger i album- og spillelistevyer for rask filtrering",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatisk gjenoppretting fra Spotify-avspillingsproblemer ved gjenopptakelse av siste spilleliste",
    SETTINGS_SKIP_TRASHED_TRACKS: "Hopp over slettede spor",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Hopp automatisk over slettede sanger og finn neste tillatte spor under avspilling",
    SETTINGS_AUTO_CLEAN_QUEUE: "Automatisk rens av kø",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Fjern automatisk slettede sanger fra din Smart Shuffle-kø",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Papirkurv ved neste snarvei",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Legg automatisk gjeldende sang i papirkurven når du bruker Ctrl+Høyre-tastaturhurtigtast for å hoppe til neste spor",
    SETTINGS_REMOTE_CONTROL: "Fjernkontroll",
    SETTINGS_REMOTE_TOGGLE: "Aktiver fjernstyring",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dobbelttrykk på spill/pause fra mobil for å slå fjernhopp av/på. Hopping av spor bekrefter valget.",
    SETTINGS_REMOTE_SKIPPING: "Fjernhopping aktiv",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Når det er aktivert, fungerer hoppe over papirkurv selv når du styrer Spotify fra en annen enhet (for eksempel mobil)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Fjernhopping aktivert",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Fjernhopping deaktivert",
    MESSAGE_SONG_ADDED_REMOTE: "Sang slettet via fjernkontroll",
    SETTINGS_TRASH_VIA_LIKE: "Søppel via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Som en sang fra mobil til søppelbøtta. Fjerner lik automatisk og hopper til neste spor.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ne.json
var require_ne = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ट्र्याशबिन+",
    ACTION_THROW: "त्रशबिनमा राख्नुहोस्",
    ACTION_UNTHROW: "ट्रासबिनबाट हटाउनुहोस्",
    ACTION_CLEAR: "स्पष्ट",
    ACTION_COPY: "प्रतिलिपि",
    ACTION_EXPORT: "निर्यात",
    ACTION_IMPORT: "आयात",
    MESSAGE_COPIED: "क्लिपबोर्डमा प्रतिलिपि गरियो",
    MESSAGE_CLEARED: "ट्र्यास्बिन सफलतापूर्वक खाली गरियो!",
    MESSAGE_SONG_ADDED: "गीत ट्र्यास्बिनमा थपियो",
    MESSAGE_SONG_REMOVED: "ट्र्यासबिनबाट गीत हटाइयो",
    MESSAGE_ARTIST_ADDED: "कलाकारलाई ट्र्यास्बिनमा थपियो",
    MESSAGE_ARTIST_REMOVED: "कलाकारलाई फाल्ने डब्बाबाट हटाइयो",
    BACKUP_SAVE_SUCCESS: "ब्याकअप सफलतापूर्वक सुरक्षित भयो।",
    BACKUP_SAVE_FAILED: "ब्याकअप बचत गर्न असफल, कृपया ट्र्यासबिनको सामग्री क्लिपबोर्डमा कपि गर्ने र हातले ब्याकअप बनाउने प्रयास गर्नुहोस्।",
    BACKUP_RESTORE_SUCCESS: "ब्याकअप सफलतापूर्वक पुनर्स्थापित भयो।",
    BACKUP_FILE_READ_FAILED: "फाइल पढ्न असफल, कृपया सुनिश्चित गर्नुहोस् कि यो वैध जेसन फाइल हो।",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ट्र्यास्बिन+ सेटिङ्हरू",
    SETTINGS_OPTIONS: "विकल्पहरू",
    SETTINGS_FEATURES: "विशेषताहरू",
    SETTINGS_LOCAL_STORAGE: "स्थानीय भण्डारण",
    SETTINGS_ENABLED: "सक्षम गरिएको",
    SETTINGS_SHOW_WIDGET: "विजेट आइकन देखाउनुहोस्",
    SETTINGS_AUTOPLAY: "सुरुमा स्वत: प्ले गर्नुहोस्",
    SETTINGS_QUEUE_TRASHBIN: "कतार महसुस गर्ने ट्र्यासबिन सक्षम गर्नुहोस्",
    SETTINGS_TRACKLIST_TRASHBIN: "ट्र्याकलिस्ट ट्र्यास्बिन सक्षम पार्नुहोस्",
    SETTINGS_PLAYLIST_MONITOR: "प्लेलिस्ट मोनिटर",
    ITEMS_TITLE: "ट्र्याशबिन+ आइटमहरू",
    ITEMS_EMPTY_SONGS: "<strong>कुनै मेटिएका गीतहरू छैनन्!</strong><br/>तपाईंले ट्र्यासबिनमा थप्नु भएका गीतहरू यहाँ देखा पर्नेछन्।",
    ITEMS_EMPTY_ARTISTS: "<strong>कुनै फाल्तु कलाकार छैनन्!</strong><br/>तपाईंले फाल्तुपेटीमा थप्नु भएका कलाकारहरू यहाँ देखा पर्नेछन्।",
    ITEMS_TAB_SONGS: "गीतहरू",
    ITEMS_TAB_ARTISTS: "कलाकारहरू",
    ITEMS_LOADED_COUNT: "{{total}} मध्ये {{loaded}} {{type}} लोड भयो",
    DESCRIPTION_COPY: "ट्र्यासबिनमा रहेका सबै वस्तुहरू क्लिपबोर्डमा कपि गर्नुहोस्।",
    DESCRIPTION_EXPORT: "ट्र्यासबिनमा रहेका सबै वस्तुहरूलाई .json फाइलमा सुरक्षित गर्नुहोस्।",
    DESCRIPTION_IMPORT: "ट्र्यासबिनमा रहेका सबै आइटमहरूलाई .json फाइलबाट ओभरराइट गर्नुहोस्।",
    DESCRIPTION_CLEAR: "ट्र्यासबिनबाट सबै वस्तुहरू हटाउनुहोस् (फर्काउन सकिँदैन)।",
    ITEMS_EMPTY_SONGS_TITLE: "कुनै फाल्तु गीतहरू छैनन्!",
    ITEMS_EMPTY_ARTISTS_TITLE: "कुनै फाल्तु कलाकार छैनन्!",
    DESCRIPTION_SETTINGS_ENABLED: "सबै ट्र्यास्बिन+ कार्यक्षमता सक्षम वा अक्षम गर्न मास्टर टगल",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "हाल चलिरहेको ट्र्याकको प्लेब्याक बारमा छिटो पहुँचका लागि ट्र्यास आइकन प्रदर्शन गर्नुहोस्",
    DESCRIPTION_SETTINGS_AUTOPLAY: "स्पोटिफाइ खुल्दा वा एक्सटेन्सन लोड हुँदा स्वत: संगीत प्ले गर्न थाल्नुहोस्",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "तपाईंको आगामी कतारमा प्रत्येक गीतको बगैंचा आइकन थप्नुहोस् ताकि सजिलो व्यवस्थापन गर्न सकौं",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "एल्बम र प्लेलिस्टका गीतहरूको बगैचा ट्र्यास आइकनहरू थप्नुहोस् त्वरित फिल्टर गर्नका लागि",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "तपाईंको अन्तिम प्लेलिस्टलाई पुनः सुरु गरेर स्पटिफाइ प्लेब्याकको समस्याबाट स्वतः बरामद गर्नुहोस्",
    SETTINGS_SKIP_TRASHED_TRACKS: "मेटिएका ट्र्याकहरू छोड्नुहोस्",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "मेटिएका गीतहरूलाई स्वत: छोडेर प्लेब्याकको समयमा अर्को अनुमति प्राप्त ट्र्याक खोज्नुहोस्",
    SETTINGS_AUTO_CLEAN_QUEUE: "स्वतः सफा कतार",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "तपाईंको स्मार्ट शफल कतारबाट ट्र्यास सङ्गीतहरू स्वतः हटाउनुहोस्",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "अर्को हटकि ट्र्यास",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "अर्को ट्र्याकमा जानका लागि Ctrl+Right कीबोर्ड शर्टकट प्रयोग गर्दा स्वचालित रूपमा हालको गीतलाई ट्र्यासमा राख्नुहोस्",
    SETTINGS_REMOTE_CONTROL: "रिमोट कन्ट्रोल",
    SETTINGS_REMOTE_TOGGLE: "दूरस्थ टगल सक्षम पार्नुहोस्",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "मोबाइलबाट प्ले/पज दोहोरो ट्याप गरेर रिमोट स्किपिङ स्विच गर्नुहोस्। ट्र्याक स्किपले टगललाई पुष्टि गर्दछ।",
    SETTINGS_REMOTE_SKIPPING: "दूरस्थ छोड्ने सक्रिय",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "सक्षम गर्दा, अर्को उपकरणबाट (जस्तै, मोबाइल) स्पोटिफाइ नियन्त्रण गर्दा पनि ट्र्यास-छोड्न काम गर्दछ।",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "दूरस्थ छलाँग लगाउन सक्षम भयो",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "दूरस्थ स्किपिङ अक्षम गरियो",
    MESSAGE_SONG_ADDED_REMOTE: "गीत रिमोटबाट नष्ट गरियो",
    SETTINGS_TRASH_VIA_LIKE: "लाइक मार्फत फाल्तू सामग्री",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "मोबाइलबाट ट्र्यासमा यसलाई लगाउने गीत जस्तै। स्वचालित रूपमा अनलाइक गर्नुहोस् र अर्को ट्र्याकमा जानुहोस्।",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/nl.json
var require_nl = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Prullenbak+",
    ACTION_THROW: "Plaatsen in prullenbak",
    ACTION_UNTHROW: "Verwijderen uit prullenbak",
    ACTION_CLEAR: "Duidelijk",
    ACTION_COPY: "Kopieer",
    ACTION_EXPORT: "Export",
    ACTION_IMPORT: "Importeren",
    MESSAGE_COPIED: "Gekopieerd naar klembord",
    MESSAGE_CLEARED: "Prullenbak succesvol geleegd!",
    MESSAGE_SONG_ADDED: "Nummer toegevoegd aan prullenbak",
    MESSAGE_SONG_REMOVED: "Nummer verwijderd uit prullenbak",
    MESSAGE_ARTIST_ADDED: "Artiest toegevoegd aan prullenbak",
    MESSAGE_ARTIST_REMOVED: "Artiest verwijderd uit prullenbak",
    BACKUP_SAVE_SUCCESS: "Back-up succesvol opgeslagen.",
    BACKUP_SAVE_FAILED: "Kon back-up niet opslaan, probeer de inhoud van de prullenbak naar het klembord te kopiëren en handmatig een back-up te maken.",
    BACKUP_RESTORE_SUCCESS: "Back-up succesvol hersteld.",
    BACKUP_FILE_READ_FAILED: "Kan het bestand niet lezen, zorg ervoor dat het een geldig JSON-bestand is.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-prullenbak.json",
    SETTINGS_TITLE: "Instellingen van Prullenbak+",
    SETTINGS_OPTIONS: "Opties",
    SETTINGS_FEATURES: "Kenmerken",
    SETTINGS_LOCAL_STORAGE: "Lokale opslag",
    SETTINGS_ENABLED: "Ingeschakeld",
    SETTINGS_SHOW_WIDGET: "Toon widgetpictogram",
    SETTINGS_AUTOPLAY: "Automatisch afspelen bij start",
    SETTINGS_QUEUE_TRASHBIN: "Schakel wachtrijprullenbak in",
    SETTINGS_TRACKLIST_TRASHBIN: "Schakel Tracklist Prullenbak in",
    SETTINGS_PLAYLIST_MONITOR: "Afspeellijstmonitor",
    ITEMS_TITLE: "Prullenbak+ items",
    ITEMS_EMPTY_SONGS: "<strong>Geen verwijderde nummers!</strong><br/>Nummers die je in de prullenbak plaatst, verschijnen hier.",
    ITEMS_EMPTY_ARTISTS: "<strong>Geen artiesten verwijderd!</strong><br/>Artiesten die u in de prullenbak plaatst, verschijnen hier.",
    ITEMS_TAB_SONGS: "Liedjes",
    ITEMS_TAB_ARTISTS: "Artiesten",
    ITEMS_LOADED_COUNT: "{{loaded}} van de {{total}} {{type}} geladen",
    DESCRIPTION_COPY: "Kopieer alle items in de prullenbak naar het klembord.",
    DESCRIPTION_EXPORT: "Sla alle items in de prullenbak op in een .json-bestand.",
    DESCRIPTION_IMPORT: "Alle items in de prullenbak overschrijven via .json-bestand.",
    DESCRIPTION_CLEAR: "Verwijder alle items uit de prullenbak (kan niet ongedaan worden gemaakt).",
    ITEMS_EMPTY_SONGS_TITLE: "Geen verwijderde nummers!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Geen afgeschreven artiesten!",
    DESCRIPTION_SETTINGS_ENABLED: "Hoofdschakelaar om alle prullenbak+-functionaliteit in of uit te schakelen",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Toon een prullenbakpictogram in de afspeelbalk naast het momenteel afgespeelde nummer voor snelle toegang",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automatisch muziek afspelen wanneer Spotify opent of de extensie wordt geladen",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Voeg prullenbakpictogrammen toe naast elk nummer in je aankomende wachtrij voor eenvoudig beheer",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Voeg prullenbakpictogrammen toe naast nummers in album- en afspeellijstweergaven voor snel filteren",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Herstel automatisch van problemen met afspelen op Spotify door je laatste afspeellijst te hervatten",
    SETTINGS_SKIP_TRASHED_TRACKS: "Sla verwijderde nummers over",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Sla automatisch verwijderde nummers over en zoek tijdens het afspelen het volgende toegestane nummer",
    SETTINGS_AUTO_CLEAN_QUEUE: "Auto Schoonmaak Wachtrij",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Verwijder automatisch verwijderde nummers uit je Smart Shuffle-wachtrij",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Prullenbak bij volgende sneltoets",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Verplaats automatisch het huidige nummer naar de prullenbak wanneer u de toetscombinatie Ctrl+Rechts gebruikt om over te schakelen naar het volgende nummer",
    SETTINGS_REMOTE_CONTROL: "Afstandsbediening",
    SETTINGS_REMOTE_TOGGLE: "Schakel externe schakelaar in",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dubbelklik op afspelen/pauzeren vanaf de mobiele telefoon om overgaan op afstand in of uit te schakelen. Het overslaan van een nummer bevestigt de schakeling.",
    SETTINGS_REMOTE_SKIPPING: "Op afstand overslaan actief",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Wanneer ingeschakeld, werkt het overslaan van prullenbak zelfs wanneer Spotify wordt bediend vanaf een ander apparaat (bijvoorbeeld mobiel)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Afstandsbediening overslaan ingeschakeld",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Extern overslaan uitgeschakeld",
    MESSAGE_SONG_ADDED_REMOTE: "Nummer vernietigd via afstandsbediening",
    SETTINGS_TRASH_VIA_LIKE: "Afval via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Net als een nummer van mobiel naar prullenbak. Automatisch verwijderd uit de favorieten en overslaan naar het volgende nummer.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/or.json
var require_or = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ଟ୍ରାସ୍ବିନ୍+",
    ACTION_THROW: "କଚଡ଼ା ଡବାରେ ରଖନ୍ତୁ",
    ACTION_UNTHROW: "ଟ୍ରାସ୍ ବିନରୁ ଅପସାରଣ କରନ୍ତୁ",
    ACTION_CLEAR: "ସ୍ପଷ୍ଟ",
    ACTION_COPY: "କପି",
    ACTION_EXPORT: "ରପ୍ତାନି କରନ୍ତୁ",
    ACTION_IMPORT: "ଆମଦାନୀ କରନ୍ତୁ",
    MESSAGE_COPIED: "କ୍ଲିପବୋର୍ଡକୁ କପି କରାଯାଇଛି",
    MESSAGE_CLEARED: "ଟ୍ରାସ୍ ବିନ୍ ସଫଳତାର ସହ ଖାଲି ହୋଇଗଲା!",
    MESSAGE_SONG_ADDED: "ଗୀତଟି କଚରାଦାନରେ ଯୋଗ କରାଯାଇଛି",
    MESSAGE_SONG_REMOVED: "ଟ୍ରାସ୍ବିନରୁ ଗୀତ ଅପସାରଣ କରାଯାଇଛି",
    MESSAGE_ARTIST_ADDED: "କଳାକାରଙ୍କୁ କଚରା ଡବାରେ ଯୋଗ କରାଯାଇଛି",
    MESSAGE_ARTIST_REMOVED: "କଳାକାରଙ୍କୁ କଚରା ଡବାରୁ ହଟାଯାଇଛି",
    BACKUP_SAVE_SUCCESS: "ସଫଳତାର ସହ ବ୍ୟାକଅପ୍ ସଂରକ୍ଷିତ ହୋଇଛି।",
    BACKUP_SAVE_FAILED: "ବ୍ୟାକଅପ୍ ସେଭ୍ କରିବାରେ ବିଫଳ ହୋଇଛି, ଟ୍ରାସ୍ ବିନ୍‌ର ବିଷୟବସ୍ତୁଗୁଡ଼ିକୁ କ୍ଲିପବୋର୍ଡକୁ କପି କରିବା ଏବଂ ଏକ ବ୍ୟାକଅପ୍ ମ୍ୟାନୁଆଲ୍ ଭାବରେ ତିଆରି କରିବାକୁ ଚେଷ୍ଟା କରନ୍ତୁ।",
    BACKUP_RESTORE_SUCCESS: "ସଫଳତାର ସହ ବ୍ୟାକଅପ ପୁନର୍ସ୍ଥାପନ କରାଯାଇଛି।",
    BACKUP_FILE_READ_FAILED: "ଫାଇଲ୍ ପଢିବାରେ ବିଫଳ ହୋଇଛି, ଦୟାକରି ନିଶ୍ଚିତ କରନ୍ତୁ ଏହା ଏକ ବୈଧ JSON ଫାଇଲ୍ ଅଟେ।",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ଟ୍ରାସ୍ବିନ୍+ ସେଟିଂସ୍",
    SETTINGS_OPTIONS: "ବିକଳ୍ପଗୁଡ଼ିକ",
    SETTINGS_FEATURES: "ବୈଶିଷ୍ଟ୍ୟଗୁଡ଼ିକ",
    SETTINGS_LOCAL_STORAGE: "ସ୍ଥାନୀୟ ଷ୍ଟୋରେଜ୍",
    SETTINGS_ENABLED: "ସକ୍ଷମ କରାଯାଇଛି",
    SETTINGS_SHOW_WIDGET: "ଉଇଜିଟ୍ ଆଇକନ ଦର୍ଶାନ୍ତୁ",
    SETTINGS_AUTOPLAY: "ଆରମ୍ଭରେ ସ୍ୱତଃ ପ୍ଲେ ଚାଲୁ କରନ୍ତୁ",
    SETTINGS_QUEUE_TRASHBIN: "ସ୍ଥଗିତ କରିବା ପାଇଁ କଚରା ଡବା ସକ୍ରିୟ କରନ୍ତୁ",
    SETTINGS_TRACKLIST_TRASHBIN: "ଟ୍ରାକ୍ଲିଷ୍ଟ କଚରାଦାନୀ ସକ୍ରିୟ କରନ୍ତୁ",
    SETTINGS_PLAYLIST_MONITOR: "ପ୍ଲେଲିଷ୍ଟ ମନିଟର୍",
    ITEMS_TITLE: "ଟ୍ରାସ୍‌ବିନ୍+ ଆଇଟମ୍‌ଗୁଡ଼ିକ",
    ITEMS_EMPTY_SONGS: "<strong>କ no ଟ୍ରାସ୍ କରାଯାଇଥିବା ଗୀତ ନାହିଁ!</strong><br/>ଯେଉଁ ଗୀତଗୁଡ଼ିକୁ ଆପଣ ଟ୍ରାସ୍ ବାକ୍ସରେ ଯୋଗ କରିବେ ସେଗୁଡ଼ିକ ଏଠାରେ ଦେଖାଯିବ।",
    ITEMS_EMPTY_ARTISTS: "<strong>କୌଣସି ଫୋପାଡ଼ିଦିଆଯାଇଥିବା କଳାକାର ନାହାଁନ୍ତି!</strong><br/>ଯେଉଁ କଳାକାରମାନଙ୍କୁ ଆପଣ କଚାଡ଼ା ଡବାରେ ଯୋଗ କରିବେ, ସେମାନେ ଏଠାରେ ଦେଖାଯିବେ।",
    ITEMS_TAB_SONGS: "ଗୀତମାନେ",
    ITEMS_TAB_ARTISTS: "କଳାକାରମାନେ",
    ITEMS_LOADED_COUNT: "{{total}} ମଧ୍ୟରୁ {{loaded}} {{type}} ଲୋଡ୍ ହୋଇଛି",
    DESCRIPTION_COPY: "ଅପସାରଣ ପଟ୍ଟିକାରେ ଥିବା ସମସ୍ତ ଆଇଟମକୁ କ୍ଲିପବୋର୍ଡକୁ କପି କରନ୍ତୁ।",
    DESCRIPTION_EXPORT: "ଟ୍ରାସ୍ବିନରେ ସମସ୍ତ ଆଇଟମଗୁଡ଼ିକୁ ଏକ .json ଫାଇଲରେ ସେଭ୍ କରନ୍ତୁ।",
    DESCRIPTION_IMPORT: "ଟ୍ରାସ୍ ବିନ୍ ରେ ଥିବା ସମସ୍ତ ଆଇଟମ୍ କୁ .json ଫାଇଲ୍ ଦ୍ୱାରା ଓଭରରାଇଟ୍ କରନ୍ତୁ।",
    DESCRIPTION_CLEAR: "ଅପସାରଣ ବାକ୍ସରୁ ସମସ୍ତ ଆଇଟମକୁ ହଟାନ୍ତୁ (ପୁନର୍ସ୍ଥାପନ କରାଯାଇପାରିବ ନାହିଁ)।",
    ITEMS_EMPTY_SONGS_TITLE: "କୌଣସି ଫୋପାଡ଼ି ଦିଆଯାଇଥିବା ଗୀତ ନାହିଁ!",
    ITEMS_EMPTY_ARTISTS_TITLE: "କୌଣସି ନିର୍ଯ୍ୟାତନା କଳାକାର ନାହିଁ!",
    DESCRIPTION_SETTINGS_ENABLED: "ସମସ୍ତ ଟ୍ରାସ୍ବିନ୍+ କାର୍ଯ୍ୟକାରିତା ସକ୍ଷମ କରିବା କିମ୍ବା ଅକ୍ଷମ କରିବା ପାଇଁ ମାଷ୍ଟର ଟଗଲ୍",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "ଚଳିତ ଟ୍ରାକ୍ ପାଖାପାଖି ପ୍ଲେବ୍ୟାକ୍ ବାରରେ ଏକ କଚରା ଆଇକନ୍ ପ୍ରଦର୍ଶନ କରନ୍ତୁ ଯାହା ଦ୍ରୁତ ପହଞ୍ଚ ପାଇଁ ଅଟେ",
    DESCRIPTION_SETTINGS_AUTOPLAY: "ସ୍ପଟିଫାଏ ଖୋଲିବା କିମ୍ବା ଏକ୍ସଟେନ୍ସନ୍ ଲୋଡ୍ ହେବା ମାତ୍ରେ ସ୍ୱତଃ ସଙ୍ଗୀତ ଚଳାନ୍ତୁ କରନ୍ତୁ",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "ନିମ୍ନସ୍ଥ ପାଇଁ ଆପଣଙ୍କ ପାଇଁ ପ୍ରତ୍ୟେକ ଗୀତ ପାଖରେ କଚରା ଆଇକନ ଯୋଗ କରନ୍ତୁ ସହଜ ପରିଚାଳନା ପାଇଁ",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "ଆଲବମ୍ ଏବଂ ପ୍ଲେ ଲିଷ୍ଟ୍ ଦୃଶ୍ୟରେ ଗୀତ ପାଖରେ କଚରା ଆଇକନ୍ ଗୁଡ଼ିକୁ ଯୋଗ କରନ୍ତୁ ଯାହା ଦ୍ରୁତ ଫିଲ୍ଟରିଂ ପାଇଁ ସାହାଯ୍ୟ କରିବ।",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "ଶେଷ ପ୍ଲେଲିଷ୍ଟକୁ ପୁନଃସ୍ଥାପନ କରି ସ୍ପଟିଫାଏରେ ପ୍ଲେବ୍ୟାକ୍ ତ୍ରୁଟିରୁ ସ୍ୱତଃ ପୁନରୁଦ୍ଧାର କରନ୍ତୁ",
    SETTINGS_SKIP_TRASHED_TRACKS: "ଟ୍ରାଷ୍ କରାଯାଇଥିବା ଟ୍ରାକ୍ ଗୁଡ଼ିକ ବାଦ ଦିଅନ୍ତୁ",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "ସ୍ୱତଃ ଫୋପାଡ଼ି ଦିଆଯାଇଥିବା ଗୀତଗୁଡ଼ିକୁ ବାଦ୍ ଦିଅନ୍ତୁ ଏବଂ ପ୍ଲେବ୍ୟାକ୍ ଚାଲିଥିବା ସମୟରେ ପରବର୍ତ୍ତୀ ଅନୁମତିପ୍ରାପ୍ତ ଟ୍ରାକ୍ ଖୋଜନ୍ତୁ",
    SETTINGS_AUTO_CLEAN_QUEUE: "ସ୍ୱଚାଳିତ ସଫା ପାଇଁ ଅପେକ୍ଷାରତ ତାଲିକା",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "ସ୍ୱଚାଳିତ ଭାବରେ ଆପଣଙ୍କ ସ୍ମାର୍ଟ ଶଫଲ୍ ପାଇଁ ଟ୍ରାସ୍ କରାଯାଇଥିବା ଗୀତଗୁଡ଼ିକୁ ଅପସାରଣ କରନ୍ତୁ",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "ପରବର୍ତ୍ତୀ ହଟକିର ଅପଠନୀୟ ତଥ୍ୟ ଉପରେ",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "ଅଗ୍ରଗାମୀ ଟ୍ରାକକୁ ଯିବାକୁ Ctrl+Right କୀବୋର୍ଡ ଶର୍ଟକଟ ବ୍ୟବହାର କରିବା ସମୟରେ ବର୍ତ୍ତମାନ ଗୀତକୁ ସ୍ୱତଃ ଅପସାରଣ କରନ୍ତୁ",
    SETTINGS_REMOTE_CONTROL: "ଦୂରବର୍ତ୍ତୀ ନିୟନ୍ତ୍ରଣ",
    SETTINGS_REMOTE_TOGGLE: "ଦୂରବର୍ତ୍ତୀ ଟଗଲ୍ ସକ୍ଷମ କରନ୍ତୁ",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "ମୋବାଇଲରୁ ରିମୋଟ ସ୍କିପିଂକୁ ଚାଲୁ କରିବା କିମ୍ବା ବନ୍ଦ କରିବା ପାଇଁ ପ୍ଲେ/ପଜ ଉପରେ ଦୁଇଥର ଟ୍ୟାପ୍ କରନ୍ତୁ। ଏକ ଟ୍ରାକ୍ ସ୍କିପ୍ ଟଗଲ୍ ପାଇଁ ନିଶ୍ଚିତ କରେ।",
    SETTINGS_REMOTE_SKIPPING: "ଦୂରବର୍ତ୍ତୀ ଅତିକ୍ରମଣ ସକ୍ରିୟ ଅଛି",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "ସକ୍ଷମ ହେଲେ, ଅନ୍ୟ ଡିଭାଇସ୍ (ଉଦା: ମୋବାଇଲ୍) ରୁ Spotify କୁ ନିୟନ୍ତ୍ରଣ କରିବା ସମୟରେ ମଧ୍ୟ ଟ୍ରାସ୍-ଅତିକ୍ରମଣ କାର୍ଯ୍ୟ କରେ।",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "ଦୂରବର୍ତ୍ତୀ ଅତିକ୍ରମଣ ସକ୍ଷମ ହୋଇଛି",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "ଦୂରବର୍ତ୍ତୀ ଅତିକ୍ରମଣ ଅକ୍ଷମ କରାଯାଇଛି",
    MESSAGE_SONG_ADDED_REMOTE: "ସଙ୍ଗୀତକୁ ଦୂରବର୍ତ୍ତୀ ମାଧ୍ୟମରେ ନଷ୍ଟ କରାଯାଇଛି",
    SETTINGS_TRASH_VIA_LIKE: "ଲାଇକ୍ ମାଧ୍ୟମରେ କଚରା",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "ଏକ ଗୀତ ଭଳି ମୋବାଇଲରୁ ଏହାକୁ ଫୋପାଡ଼ନ୍ତୁ। ସ୍ୱତଃ ଅସମର୍ଥନ କରି ପରବର୍ତ୍ତୀ ଟ୍ରାକକୁ ଯାଏ।",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/pa-IN.json
var require_pa_IN = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ਕਚਰਾ ਬੰਦ+",
    ACTION_THROW: "ਕੂੜੇਦਾਨ ਵਿੱਚ ਪਾਓ",
    ACTION_UNTHROW: "ਕੂੜੇਦਾਨ ਤੋਂ ਹਟਾਓ",
    ACTION_CLEAR: "ਸਪਸ਼ਟ",
    ACTION_COPY: "ਕਾਪੀ",
    ACTION_EXPORT: "ਨਿਰਯਾਤ",
    ACTION_IMPORT: "ਆਯਾਤ ਕਰੋ",
    MESSAGE_COPIED: "ਕਲਿੱਪਬੋਰਡ 'ਤੇ ਕਾਪੀ ਕੀਤਾ",
    MESSAGE_CLEARED: "ਕੂੜਾਦਾਨ ਸਫਲਤਾਪੂਰਵਕ ਖਾਲੀ ਕੀਤਾ ਗਿਆ!",
    MESSAGE_SONG_ADDED: "ਗੀਤ ਨੂੰ ਕੂੜੇਦਾਨ ਵਿੱਚ ਸ਼ਾਮਲ ਕੀਤਾ ਗਿਆ",
    MESSAGE_SONG_REMOVED: "ਗੀਤ ਨੂੰ ਕੂੜੇਦਾਨ ਤੋਂ ਹਟਾ ਦਿੱਤਾ ਗਿਆ",
    MESSAGE_ARTIST_ADDED: "ਕਲਾਕਾਰ ਨੂੰ ਕੂੜੇਦਾਨ ਵਿੱਚ ਸ਼ਾਮਲ ਕੀਤਾ ਗਿਆ",
    MESSAGE_ARTIST_REMOVED: "ਕਲਾਕਾਰ ਨੂੰ ਕੂੜੇਦਾਨ ਤੋਂ ਹਟਾ ਦਿੱਤਾ ਗਿਆ",
    BACKUP_SAVE_SUCCESS: "ਬੈਕਅੱਪ ਸਫਲਤਾਪੂਰਵਕ ਸੰਭਾਲਿਆ ਗਿਆ।",
    BACKUP_SAVE_FAILED: "ਬੈਕਅਪ ਸੇਵ ਕਰਨ ਵਿੱਚ ਅਸਫਲ, ਟਰੈਸ਼ਬਿਨ ਦੀ ਸਮੱਗਰੀ ਨੂੰ ਕਲਿੱਪਬੋਰਡ 'ਤੇ ਕਾਪੀ ਕਰਨ ਦੀ ਕੋਸ਼ਿਸ਼ ਕਰੋ ਅਤੇ ਮੈਨੂਅਲ ਤੌਰ 'ਤੇ ਬੈਕਅਪ ਬਣਾਓ।",
    BACKUP_RESTORE_SUCCESS: "ਬੈਕਅੱਪ ਸਫਲਤਾਪੂਰਵਕ ਬਹਾਲ ਕੀਤਾ ਗਿਆ।",
    BACKUP_FILE_READ_FAILED: "ਫਾਇਲ ਪੜ੍ਹਨ ਵਿੱਚ ਅਸਫਲ, ਕਿਰਪਾ ਕਰਕੇ ਯਕੀਨੀ ਬਣਾਓ ਕਿ ਇਹ ਇੱਕ ਵੈਧ JSON ਫਾਇਲ ਹੈ।",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ਟਰੈਸ਼ਬਿਨ+ ਸੈਟਿੰਗਸ",
    SETTINGS_OPTIONS: "ਚੋਣਾਂ",
    SETTINGS_FEATURES: "ਵਿਸ਼ੇਸ਼ਤਾਵਾਂ",
    SETTINGS_LOCAL_STORAGE: "ਸਥਾਨਕ ਸਟੋਰੇਜ਼",
    SETTINGS_ENABLED: "ਸਮਰੱਥ ਕੀਤਾ",
    SETTINGS_SHOW_WIDGET: "ਵਿਜ਼ੇਟ ਆਈਕਾਨ ਵੇਖਾਓ",
    SETTINGS_AUTOPLAY: "ਸ਼ੁਰੂਆਤ 'ਤੇ ਆਟੋਪਲੇ ਚਾਲੂ ਕਰੋ",
    SETTINGS_QUEUE_TRASHBIN: "ਕਤਾਰ ਕੂੜਾਦਾਨ ਸਮਰੱਥ ਕਰੋ",
    SETTINGS_TRACKLIST_TRASHBIN: "ਟਰੈਕਲਿਸਟ ਟਰੈਸ਼ਬਿਨ ਨੂੰ ਸਮਰੱਥ ਕਰੋ",
    SETTINGS_PLAYLIST_MONITOR: "ਪਲੇਲਿਸਟ ਮਾਨੀਟਰ",
    ITEMS_TITLE: "ਕਚਰਾ ਬਕਸਾ+ ਆਈਟਮਾਂ",
    ITEMS_EMPTY_SONGS: "<strong>ਕੋਈ ਖਾਰਬ ਗੀਤ ਨਹੀਂ!</strong><br/>ਤੁਸੀਂ ਕੂੜੇਦਾਨ ਵਿੱਚ ਸ਼ਾਮਲ ਕੀਤੇ ਗੀਤ ਇੱਥੇ ਦਿਖਾਈ ਦੇਣਗੇ।",
    ITEMS_EMPTY_ARTISTS: "<strong>ਕੋਈ ਫੇਕੇ ਹੋਏ ਕਲਾਕਾਰ ਨਹੀਂ!</strong><br/>ਕਲਾਕਾਰ ਜਿਨ੍ਹਾਂ ਨੂੰ ਤੁਸੀਂ ਰੱਦੀ ਦੇ ਡੱਬੇ ਵਿੱਚ ਸ਼ਾਮਲ ਕਰਦੇ ਹੋ ਇੱਥੇ ਦਿਖਾਈ ਦੇਣਗੇ।",
    ITEMS_TAB_SONGS: "ਗੀਤ",
    ITEMS_TAB_ARTISTS: "ਕਲਾਕਾਰ",
    ITEMS_LOADED_COUNT: "{{total}} ਵਿੱਚੋਂ {{loaded}} {{type}} ਲੋਡ ਹੋਇਆ",
    DESCRIPTION_COPY: "ਟਰੈਸ਼ਬਿਨ ਵਿੱਚ ਸਾਰੀਆਂ ਚੀਜ਼ਾਂ ਨੂੰ ਕਲਿੱਪਬੋਰਡ 'ਤੇ ਕਾਪੀ ਕਰੋ।",
    DESCRIPTION_EXPORT: "ਕੂੜੇਦਾਨ ਵਿੱਚ ਸਾਰੀਆਂ ਚੀਜ਼ਾਂ ਨੂੰ .json ਫਾਇਲ ਵਿੱਚ ਸੰਭਾਲੋ।",
    DESCRIPTION_IMPORT: "ਕੂੜੇਦਾਨ ਵਿੱਚ ਸਾਰੀਆਂ ਚੀਜ਼ਾਂ ਨੂੰ .json ਫਾਈਲ ਰਾਹੀਂ ਓਵਰਰਾਈਟ ਕਰੋ।",
    DESCRIPTION_CLEAR: "ਕੂੜੇਦਾਨ ਤੋਂ ਸਾਰੀਆਂ ਚੀਜ਼ਾਂ ਨੂੰ ਹਟਾਓ (ਵਾਪਸ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਦਾ)।",
    ITEMS_EMPTY_SONGS_TITLE: "ਕੋਈ ਖਰਾਬ ਗੀਤ ਨਹੀਂ!",
    ITEMS_EMPTY_ARTISTS_TITLE: "ਕੋਈ ਫੇਕੇ ਕਲਾਕਾਰ ਨਹੀਂ!",
    DESCRIPTION_SETTINGS_ENABLED: "ਸਭ ਟਰੈਸ਼ਬਿਨ + ਕਾਰਜਸ਼ੀਲਤਾ ਨੂੰ ਸਮਰੱਥ ਜਾਂ ਅਯੋਗ ਕਰਨ ਲਈ ਮਾਸਟਰ ਟੌਗਲ",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "ਚਲ ਰਹੇ ਟਰੈਕ ਦੇ ਨੇੜੇ ਪਲੇਬੈਕ ਬਾਰ ਵਿੱਚ ਤੇਜ਼ ਪਹੁੰਚ ਲਈ ਇੱਕ ਕੂੜਾ ਆਈਕਾਨ ਵੇਖਾਓ",
    DESCRIPTION_SETTINGS_AUTOPLAY: "ਸਪਾਟੀਫਾਈ ਖੁੱਲ੍ਹਣ ਜਾਂ ਐਕਸਟੈਂਸ਼ਨ ਲੋਡ ਹੋਣ 'ਤੇ ਆਟੋਮੈਟਿਕ ਤੌਰ 'ਤੇ ਸੰਗੀਤ ਚਲਾਉਣਾ ਸ਼ੁਰੂ ਕਰੋ",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "ਆਪਣੀ ਆਉਣ ਵਾਲੀ ਕਤਾਰ ਵਿੱਚ ਹਰੇਕ ਗੀਤ ਦੇ ਨਾਲ-ਨਾਲ ਕਚਰਾ ਆਈਕਨ ਸ਼ਾਮਲ ਕਰੋ ਤਾਂ ਜੋ ਆਸਾਨੀ ਨਾਲ ਪਰਬੰਧ ਕੀਤਾ ਜਾ ਸਕੇ",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "ਐਲਬਮ ਅਤੇ ਪਲੇਲਿਸਟ ਵਿਊਜ਼ ਵਿੱਚ ਗੀਤਾਂ ਦੇ ਨਾਲ-ਨਾਲ ਕਚਰਾ ਆਈਕਾਨ ਸ਼ਾਮਲ ਕਰੋ ਤਾਂ ਜੋ ਤੁਰੰਤ ਫਿਲਟਰਿੰਗ ਕੀਤੀ ਜਾ ਸਕੇ",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "ਆਪਣੀ ਆਖਰੀ ਪਲੇਲਿਸਟ ਨੂੰ ਦੁਬਾਰਾ ਸ਼ੁਰੂ ਕਰਕੇ ਸਪੌਟੀਫਾਈ ਪਲੇਬੈਕ ਦੀਆਂ ਗਲਤੀਆਂ ਤੋਂ ਆਪਮੁਹਾਰਾ ਠੀਕ ਹੋ ਜਾਓ",
    SETTINGS_SKIP_TRASHED_TRACKS: "ਖਾਰਬ ਕੀਤੀਆਂ ਟਰੈਕਾਂ ਨੂੰ ਛੱਡੋ",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "ਖੇਡਣ ਦੇ ਦੌਰਾਨ ਮਿਟਾਏ ਗਏ ਗੀਤਾਂ ਨੂੰ ਆਟੋਮੈਟਿਕ ਤੌਰ 'ਤੇ ਛੱਡ ਦਿਓ ਅਤੇ ਅਗਲੀ ਆਗਿਆ ਵਾਲੀ ਟਰੈਕ ਲੱਭੋ",
    SETTINGS_AUTO_CLEAN_QUEUE: "ਆਟੋ ਸਾਫ਼ ਕਤਾਰ",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "ਆਪਣੀ ਸਮਾਰਟ ਸ਼ਫਲ ਕਤਾਰ ਤੋਂ ਕੂੜੇਦਾਨ ਵਿੱਚ ਪਏ ਗੀਤਾਂ ਨੂੰ ਆਪਮੇਲੇ ਹਟਾਓ",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "ਅਗਲੇ ਹੌਟਕੀ 'ਤੇ ਕਚਰਾ",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "ਮੌਜੂਦਾ ਗੀਤ ਨੂੰ ਅਗਲੇ ਟਰੈਕ ਤੇ ਜਾਣ ਲਈ Ctrl+Right ਕੀਬੋਰਡ ਸ਼ਾਰਟਕੱਟ ਵਰਤਦੇ ਹੋਏ ਆਟੋਮੈਟਿਕ ਤੌਰ 'ਤੇ ਤਰੈਸ਼ ਕਰੋ",
    SETTINGS_REMOTE_CONTROL: "ਰਿਮੋਟ ਕੰਟਰੋਲ",
    SETTINGS_REMOTE_TOGGLE: "ਰਿਮੋਟ ਟੌਗਲ ਨੂੰ ਸਮਰੱਥ ਕਰੋ",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "ਮੋਬਾਈਲ ਤੋਂ ਪਲੇ/ਰੋਕੋ ਨੂੰ ਟੌਗਲ ਕਰਨ ਲਈ ਡਬਲ-ਟੈਪ ਕਰੋ। ਟਰੈਕ ਸਕਿੱਪ ਕਰਨਾ ਟੌਗਲ ਨੂੰ ਪੁਸ਼ਟੀ ਕਰਦਾ ਹੈ।",
    SETTINGS_REMOTE_SKIPPING: "ਰਿਮੋਟ ਸਕਿੱਪਿੰਗ ਸਰਗਰਮ",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "ਜਦੋਂ ਚਾਲੂ ਕੀਤਾ ਜਾਂਦਾ ਹੈ, ਤਾਂ ਕਚਰਾ-ਛਾਲ ਕਿਸੇ ਹੋਰ ਡਿਵਾਈਸ (ਉਦਾਹਰਣ ਵਜੋਂ, ਮੋਬਾਈਲ) ਤੋਂ ਸਪੌਟੀਫਾਈ ਨੂੰ ਨਿਯੰਤਰਿਤ ਕਰਨ ਦੇ ਦੌਰਾਨ ਵੀ ਕੰਮ ਕਰਦਾ ਹੈ",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "ਰਿਮੋਟ ਸਕਿੱਪਿੰਗ ਸਮਰੱਥ ਕੀਤੀ ਗਈ",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "ਦੂਰਦਰਾਜ਼ ਛਾਲ ਅਯੋਗ ਕੀਤਾ ਗਿਆ",
    MESSAGE_SONG_ADDED_REMOTE: "ਗੀਤ ਰਿਮੋਟ ਰਾਹੀਂ ਖਰਾਬ ਕੀਤਾ ਗਿਆ",
    SETTINGS_TRASH_VIA_LIKE: "ਲਾਈਕ ਰਾਹੀਂ ਕਚਰਾ",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "ਮੋਬਾਈਲ ਤੋਂ ਟਰੈਸ਼ ਕਰਨ ਲਈ ਇੱਕ ਗੀਤ ਵਾਂਗ। ਆਪਣੇ ਆਪ ਅਣਲਾਈਕ ਕਰਦਾ ਹੈ ਅਤੇ ਅਗਲੇ ਟਰੈਕ 'ਤੇ ਛਾਲ ਮਾਰਦਾ ਹੈ।",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/pa-PK.json
var require_pa_PK = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "کوڑا دا ڈبہ+",
    ACTION_THROW: "کوڑا دان وچ رکھو",
    ACTION_UNTHROW: "اِس نوں کوڑا دان توں ہٹا دو",
    ACTION_CLEAR: "صاف",
    ACTION_COPY: "نقل کرو",
    ACTION_EXPORT: "برآمد کرو",
    ACTION_IMPORT: "درآمد کرو",
    MESSAGE_COPIED: "کاپی کیبورڈ تے کاپی کیتی گئی",
    MESSAGE_CLEARED: "کوڑا دان کامیابی نال صاف کر دتا گیا!",
    MESSAGE_SONG_ADDED: "گانا کوڑے دے ڈبے وچ شامل کیتا گیا",
    MESSAGE_SONG_REMOVED: "گانا کوڑا دان توں ہٹا دتا گیا",
    MESSAGE_ARTIST_ADDED: "آرٹسٹ نوں کوڑا دان وچ شامل کیتا گیا",
    MESSAGE_ARTIST_REMOVED: "آرٹسٹ کو کوڑا دان توں ہٹا دتا گیا",
    BACKUP_SAVE_SUCCESS: "بیک اپ کامیابی نال محفوظ ہو گیا۔",
    BACKUP_SAVE_FAILED: "بیک اپ نوں محفوظ کرنے وچ ناکامی، ٹریش بین دے مواد نوں کلپ بورڈ اُتے کاپی کرن دی کوشش کرو تے دستی طور اُتے بیک اپ بناؤ۔",
    BACKUP_RESTORE_SUCCESS: "بیک اپ کامیابی نال بحال کيتا گیا۔",
    BACKUP_FILE_READ_FAILED: "فائل پڑھن چ فیل، براہ کرم یقینی بنائیں کہ ایہہ درست جے سون فائل اے۔",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ترتھبِن+ سیٹنگز",
    SETTINGS_OPTIONS: "آپشنز",
    SETTINGS_FEATURES: "خوبیاں",
    SETTINGS_LOCAL_STORAGE: "مقامی اسٹوریج",
    SETTINGS_ENABLED: "چالو کیتہ ہویا",
    SETTINGS_SHOW_WIDGET: "واجیٹ آئیکن دکھائیں",
    SETTINGS_AUTOPLAY: "شروع وچ خودکار چلانا",
    SETTINGS_QUEUE_TRASHBIN: "کیو ٹریش بین چالو کرو",
    SETTINGS_TRACKLIST_TRASHBIN: "ٹریک لسٹ دا کوڑا دا ڈبہ چالو کرو",
    SETTINGS_PLAYLIST_MONITOR: "پلی لسٹ مانیٹر",
    ITEMS_TITLE: "کوڑا دباں + اشیاء",
    ITEMS_EMPTY_SONGS: "<strong>کوئی وی رَدّ کیتا گیتا گانا نہیں!</strong><br/>جہڑے گانے تساں کوڑا دان وچ ڈالدے ہو، ایتھے دسدے نیں۔",
    ITEMS_EMPTY_ARTISTS: "<strong>کوئی تباہ شدہ آرٹسٹ نہیں!</strong><br/>جِن آرٹسٹاں نوں تُساں کوڑا دان وچ شامل کرو گے او اِتھے دِسّ جاواں گے۔",
    ITEMS_TAB_SONGS: "گیت",
    ITEMS_TAB_ARTISTS: "فنکار",
    ITEMS_LOADED_COUNT: "{{total}} وچوں {{loaded}} {{type}} لوڈ ہو گیا",
    DESCRIPTION_COPY: "کوڑا دھکّے وچّ ساریاں چیزاں کلاپ بورڈ تے کاپی کروؤ۔",
    DESCRIPTION_EXPORT: "کوڑا دھکھیاں وچ تمام اشیاء نوں اک .json فائل وچ سیو کرو۔",
    DESCRIPTION_IMPORT: "کوڑے دے ڈبے وچ ساریاں چیزاں نوں .json فائل راہیں تبدیل کرو۔",
    DESCRIPTION_CLEAR: "کوڑا دان توں تمام شےواں کڈو (واپس نہیں کیتی جا سکدی)۔",
    ITEMS_EMPTY_SONGS_TITLE: "ਕੋਈ ਖਰਾਬ ਗੀਤ ਨਹੀਂ!",
    ITEMS_EMPTY_ARTISTS_TITLE: "ਕੋਈ ਫੇਹੇ ਹੋਏ ਕਲਾਕਾਰ ਨਹੀਂ!",
    DESCRIPTION_SETTINGS_ENABLED: "تمام ٹریش بین + کمیتیاں نوں چالو یا بند کرن دے لئی ماسٹر ٹوگل",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "موجودہ ویلے وچ چل رہی ٹریک دے نال نال پلی بیک بار وچ ترش آئیکن نوں دکھاؤ تاکہ تیزی توں رسائی ممکن ہو سکے",
    DESCRIPTION_SETTINGS_AUTOPLAY: "جدوں سپاٹیفائی کھلدا اے جاں ایکਸٹینشن لوڈ ہندا اے تاں خودکار طور تے میوزک چلاوݨا شروع کروؤ",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "اپنی آؤندی قطار وچ ہر گانے دے نال کوڑا دا آئیکن شامل کرو تاکہ آسانی نال انتظام کیتا جا سکے",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "البم اتے پلے لسٹ ویوراں وچ گانویں دے نال کوڑا دا آئیکن شامل کرو تاکہ تیزی نال فلٹرنگ کیتی جا سکے",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "سپاٹیفائی چلاؤن دیاں خرابیاں توں آٹومیٹک طور تے وابستہ ہووو جدوں تک جاری رکھو اوہناں دی آخیری پلے لسٹ",
    SETTINGS_SKIP_TRASHED_TRACKS: "توڑے ہوئے ٹریکس نوں چھڈو",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "خودکار طور تے تباہ شدہ گانوں نوں چھڈ کے اگلا منظور شدہ ٹریک چلاوݨ دے دوران چلاوݨ لئی تلاش کرو",
    SETTINGS_AUTO_CLEAN_QUEUE: "ਆਟੋ ਸਾਫ਼ ਕਤਾਰ",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "اپنی اسمارٹ شفل کی کیو توں کوڑا گھٹائی والے گیت خودکار طور تے ہٹا دیؤ",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "اگلے ہاٹ کی تے کوڑا کرکٹ",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "موجودہ گانا خود بخود ٹریش کرو جدوں اگلے ٹریک تے جان لئی Ctrl+Right کیبورڈ شارٹ کٹ استعمال کرو",
    SETTINGS_REMOTE_CONTROL: "دور کنٹرول",
    SETTINGS_REMOTE_TOGGLE: "دور دراز کنٹرول ٹوگل کریں",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "موبائل توں پلے/روکو نوں ڈبل ٹیپ کرو تاں ریموٹ اُتے سکِپ کرن دی تبدیلی ہووے گی۔ اک ٹریک سکِپ کرنا تبدی�ی نوں تصدیق کرے گا۔",
    SETTINGS_REMOTE_SKIPPING: "دور دراز عبور کرنا فعال ہے",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "جب چالو ہووے تاں، کوڑا کرکٹ چھڈݨ دا کم کسے وی دوجے آلے توں سپاٹیفائی نوں کنٹرول کردے ہوئے وی کم کردا ہے (مثلاً، موبائل)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "دور دراز تون چھلانگ دی اجازت دتی گئی",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "دور دراز تون چھلانگ دی اجازت منسوخ کر دتی گئی ہے",
    MESSAGE_SONG_ADDED_REMOTE: "گانا دور درشن توں تباہ کر دتا گیا",
    SETTINGS_TRASH_VIA_LIKE: "لائیک دے ذریعے کوڑا کرکٹ",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "موبائل توں ٹریش تک اک گانا وانگ جیوہ۔ خودکار طور تے ناپسند کر دے اتے اگلے ٹریک تے چلے جا۔",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/pl.json
var require_pl = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Kosz+",
    ACTION_THROW: "Umieść w koszu na śmieci",
    ACTION_UNTHROW: "Usuń z kosza na śmieci",
    ACTION_CLEAR: "Wyczyść",
    ACTION_COPY: "Kopiuj",
    ACTION_EXPORT: "Eksport",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Skopiowane do schowka",
    MESSAGE_CLEARED: "Kosz został pomyślnie opróżniony!",
    MESSAGE_SONG_ADDED: "Piosenka dodana do kosza",
    MESSAGE_SONG_REMOVED: "Piosenka usunięta z kosza",
    MESSAGE_ARTIST_ADDED: "Artysta dodany do kosza",
    MESSAGE_ARTIST_REMOVED: "Artysta usunięty z kosza na śmieci",
    BACKUP_SAVE_SUCCESS: "Kopia zapasowa została pomyślnie zapisana.",
    BACKUP_SAVE_FAILED: "Nie udało się zapisać kopii zapasowej, spróbuj skopiować zawartość kosza do schowka i ręcznie utworzyć kopię zapasową.",
    BACKUP_RESTORE_SUCCESS: "Kopia zapasowa została pomyślnie przywrócona.",
    BACKUP_FILE_READ_FAILED: "Nie udało się odczytać pliku, upewnij się, że jest to poprawny plik JSON.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Ustawienia kosza+",
    SETTINGS_OPTIONS: "Opcje",
    SETTINGS_FEATURES: "Funkcje",
    SETTINGS_LOCAL_STORAGE: "Pamięć lokalna",
    SETTINGS_ENABLED: "Włączone",
    SETTINGS_SHOW_WIDGET: "Pokaż ikonę widżetu",
    SETTINGS_AUTOPLAY: "Automatyczne odtwarzanie przy uruchomieniu",
    SETTINGS_QUEUE_TRASHBIN: "Włącz kosz na kolejkę",
    SETTINGS_TRACKLIST_TRASHBIN: "Włącz kosz na listę utworów",
    SETTINGS_PLAYLIST_MONITOR: "Monitor playlist",
    ITEMS_TITLE: "Przedmioty z kosza na śmieci+",
    ITEMS_EMPTY_SONGS: "<strong>Brak usuniętych utworów!</strong><br/>Utwory, które dodasz do kosza, pojawią się tutaj.",
    ITEMS_EMPTY_ARTISTS: "<strong>Brak artystów w koszu!</strong><br/>Artyści, których dodasz do kosza, pojawią się tutaj.",
    ITEMS_TAB_SONGS: "Piosenki",
    ITEMS_TAB_ARTISTS: "Artyści",
    ITEMS_LOADED_COUNT: "{{loaded}} z {{total}} {{type}} załadowane",
    DESCRIPTION_COPY: "Skopiuj wszystkie elementy w koszu do schowka.",
    DESCRIPTION_EXPORT: "Zapisz wszystkie elementy w koszu do pliku .json.",
    DESCRIPTION_IMPORT: "Zastąp wszystkie elementy w koszu za pomocą pliku .json.",
    DESCRIPTION_CLEAR: "Wyczyść wszystkie elementy z kosza (nie można cofnąć).",
    ITEMS_EMPTY_SONGS_TITLE: "Brak usuniętych utworów!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Bez wyrzuconych artystów!",
    DESCRIPTION_SETTINGS_ENABLED: "Przełącznik główny umożliwiający włączenie lub wyłączenie całej funkcjonalności kosza+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Wyświetl ikonę kosza na pasku odtwarzania obok aktualnie odtwarzanego utworu w celu szybkiego dostępu",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automatycznie uruchamiaj muzykę po otwarciu Spotify lub załadowaniu rozszerzenia",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Dodaj ikony kosza obok każdej piosenki w kolejce odtwarzania, aby ułatwić zarządzanie",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Dodaj ikony kosza obok utworów w widokach albumów i playlist, aby umożliwić szybkie filtrowanie",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatycznie odzyskuj po wystąpieniu błędów odtwarzania w Spotify, wznawiając ostatnią playlistę",
    SETTINGS_SKIP_TRASHED_TRACKS: "Pomiń usunięte utwory",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Automatycznie pomijaj usunięte utwory i znajdź następny dozwolony utwór podczas odtwarzania",
    SETTINGS_AUTO_CLEAN_QUEUE: "Kolejka automatycznego czyszczenia",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Automatycznie usuwaj usunięte utwory z kolejki inteligentnego odtwarzania w losowej kolejności",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Śmietnik przy następnym klawiszu szybkiego dostępu",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Automatycznie usuwaj aktualną piosenkę do kosza po użyciu skrótu klawiaturowego Ctrl+Strzałka w prawo, aby przejść do następnego utworu",
    SETTINGS_REMOTE_CONTROL: "Zdalne sterowanie",
    SETTINGS_REMOTE_TOGGLE: "Włącz zdalne przełączanie",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dotknij dwukrotnie odtwarzanie/pauza z telefonu, aby włączyć/wyłączyć zdalne pomijanie. Pominięcie utworu potwierdza przełączenie.",
    SETTINGS_REMOTE_SKIPPING: "Zdalne pomijanie aktywne",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Gdy włączone, pomijanie kosza działa nawet podczas sterowania Spotify z innego urządzenia (np. telefonu komórkowego)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Włączone pomijanie zdalne",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Pomijanie zdalne wyłączone",
    MESSAGE_SONG_ADDED_REMOTE: "Piosenka usunięta zdalnie",
    SETTINGS_TRASH_VIA_LIKE: "Śmieci przez Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Jak utwór z telefonu do kosza. Automatycznie usuwa polubienie i przechodzi do następnego utworu.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/pt-BR.json
var require_pt_BR = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Lixeira+",
    ACTION_THROW: "Colocar na Lixeira",
    ACTION_UNTHROW: "Remover da lixeira",
    ACTION_CLEAR: "Claro",
    ACTION_COPY: "Copiar",
    ACTION_EXPORT: "Exportar",
    ACTION_IMPORT: "Importar",
    MESSAGE_COPIED: "Copiado para a área de transferência",
    MESSAGE_CLEARED: "Lixeira esvaziada com sucesso!",
    MESSAGE_SONG_ADDED: "Música adicionada à lixeira",
    MESSAGE_SONG_REMOVED: "Música removida da lixeira",
    MESSAGE_ARTIST_ADDED: "Artista adicionado à lixeira",
    MESSAGE_ARTIST_REMOVED: "Artista removido da lixeira",
    BACKUP_SAVE_SUCCESS: "Backup salvo com sucesso.",
    BACKUP_SAVE_FAILED: "Falha ao salvar o backup, tente copiar o conteúdo da lixeira para a área de transferência e criar um backup manualmente.",
    BACKUP_RESTORE_SUCCESS: "Backup restaurado com sucesso.",
    BACKUP_FILE_READ_FAILED: "Falha ao ler o arquivo, por favor, certifique-se de que é um arquivo JSON válido.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-lixeira.json",
    SETTINGS_TITLE: "Configurações do Lixeira+",
    SETTINGS_OPTIONS: "Opções",
    SETTINGS_FEATURES: "Recursos",
    SETTINGS_LOCAL_STORAGE: "Armazenamento Local",
    SETTINGS_ENABLED: "Habilitado",
    SETTINGS_SHOW_WIDGET: "Mostrar Ícone do Widget",
    SETTINGS_AUTOPLAY: "Reprodução automática ao iniciar",
    SETTINGS_QUEUE_TRASHBIN: "Habilitar Lixeira da Fila",
    SETTINGS_TRACKLIST_TRASHBIN: "Habilitar Lixeira da Lista de Faixas",
    SETTINGS_PLAYLIST_MONITOR: "Monitor de Playlist",
    ITEMS_TITLE: "Itens da Lixeira+",
    ITEMS_EMPTY_SONGS: "<strong>Nenhuma música na lixeira!</strong><br/>As músicas que você adicionar à lixeira aparecerão aqui.",
    ITEMS_EMPTY_ARTISTS: "<strong>Nenhum artista na lixeira!</strong><br/>Artistas que você adicionar à lixeira aparecerão aqui.",
    ITEMS_TAB_SONGS: "Músicas",
    ITEMS_TAB_ARTISTS: "Artistas",
    ITEMS_LOADED_COUNT: "{{loaded}} de {{total}} {{type}} carregados",
    DESCRIPTION_COPY: "Copiar todos os itens na lixeira para a área de transferência.",
    DESCRIPTION_EXPORT: "Salvar todos os itens na lixeira em um arquivo .json.",
    DESCRIPTION_IMPORT: "Substituir todos os itens na lixeira por meio do arquivo .json.",
    DESCRIPTION_CLEAR: "Limpar todos os itens da lixeira (não pode ser desfeito).",
    ITEMS_EMPTY_SONGS_TITLE: "Nenhuma música excluída!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Nenhum artista excluído!",
    DESCRIPTION_SETTINGS_ENABLED: "Alternar ativação para habilitar ou desabilitar todas as funcionalidades do Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Exibir um ícone de lixeira na barra de reprodução ao lado da faixa que está sendo reproduzida para acesso rápido",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Iniciar automaticamente a reprodução de música quando o Spotify for aberto ou a extensão for carregada",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Adicione ícones de lixeira ao lado de cada música na sua fila de reprodução para facilitar o gerenciamento",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Adicionar ícones de lixeira ao lado das músicas nas visualizações de álbum e playlist para filtragem rápida",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recupere-se automaticamente de falhas na reprodução do Spotify retomando sua última playlist",
    SETTINGS_SKIP_TRASHED_TRACKS: "Pular faixas descartadas",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Pular automaticamente músicas excluídas e encontrar a próxima faixa permitida durante a reprodução",
    SETTINGS_AUTO_CLEAN_QUEUE: "Fila de Limpeza Automática",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Remova automaticamente músicas excluídas da sua fila de reprodução aleatória inteligente",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Lixeira na próxima tecla de atalho",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Mover automaticamente a música atual para a lixeira ao usar o atalho de teclado Ctrl+Direita para pular para a próxima faixa",
    SETTINGS_REMOTE_CONTROL: "Controle Remoto",
    SETTINGS_REMOTE_TOGGLE: "Habilitar Alternância Remota",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Toque duas vezes em reproduzir/pausar no celular para ativar/desativar o pulo remoto. Pular uma faixa confirma a alteração.",
    SETTINGS_REMOTE_SKIPPING: "Pulo Remoto Ativo",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Quando ativado, pular lixo funciona mesmo ao controlar o Spotify de outro dispositivo (por exemplo, celular)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Pular remoto habilitado",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Pular remoto desativado",
    MESSAGE_SONG_ADDED_REMOTE: "Música excluída via controle remoto",
    SETTINGS_TRASH_VIA_LIKE: "Lixo via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Como uma música do celular para descartá-la. Automaticamente remove o like e pula para a próxima faixa.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/pt-PT.json
var require_pt_PT = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Lixo+",
    ACTION_THROW: "Colocar na Lixeira",
    ACTION_UNTHROW: "Remover da Reciclagem",
    ACTION_CLEAR: "Claro",
    ACTION_COPY: "Copiar",
    ACTION_EXPORT: "Exportar",
    ACTION_IMPORT: "Importar",
    MESSAGE_COPIED: "Copiado para a área de transferência",
    MESSAGE_CLEARED: "Lixeira esvaziada com sucesso!",
    MESSAGE_SONG_ADDED: "Música adicionada à lixeira",
    MESSAGE_SONG_REMOVED: "Música removida da lixeira",
    MESSAGE_ARTIST_ADDED: "Artista adicionado ao lixo",
    MESSAGE_ARTIST_REMOVED: "Artista removido da lixeira",
    BACKUP_SAVE_SUCCESS: "Cópia de segurança guardada com sucesso.",
    BACKUP_SAVE_FAILED: "Falha ao guardar a cópia de segurança, tente copiar o conteúdo da lixeira para a área de transferência e criar uma cópia de segurança manualmente.",
    BACKUP_RESTORE_SUCCESS: "Cópia de segurança restaurada com sucesso.",
    BACKUP_FILE_READ_FAILED: "Falha ao ler o ficheiro, certifique-se de que é um ficheiro JSON válido.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-lixeira.json",
    SETTINGS_TITLE: "Definições da Lixeira+",
    SETTINGS_OPTIONS: "Opções",
    SETTINGS_FEATURES: "Funcionalidades",
    SETTINGS_LOCAL_STORAGE: "Armazenamento local",
    SETTINGS_ENABLED: "Ativado",
    SETTINGS_SHOW_WIDGET: "Mostrar Ícone do Widget",
    SETTINGS_AUTOPLAY: "Reprodução automática ao iniciar",
    SETTINGS_QUEUE_TRASHBIN: "Ativar a lixeira da fila",
    SETTINGS_TRACKLIST_TRASHBIN: "Ativar a Lixeira da Lista de Faixas",
    SETTINGS_PLAYLIST_MONITOR: "Monitor de Playlist",
    ITEMS_TITLE: "Itens da Lixeira+",
    ITEMS_EMPTY_SONGS: "<strong>Sem músicas na lixeira!</strong><br/>As músicas que você adicionar à lixeira aparecerão aqui.",
    ITEMS_EMPTY_ARTISTS: "<strong>Sem artistas na lixeira!</strong><br/>Os artistas que adicionar à lixeira aparecerão aqui.",
    ITEMS_TAB_SONGS: "Canções",
    ITEMS_TAB_ARTISTS: "Artistas",
    ITEMS_LOADED_COUNT: "{{loaded}} de {{total}} {{type}} carregado",
    DESCRIPTION_COPY: "Copiar todos os itens na lixeira para a área de transferência.",
    DESCRIPTION_EXPORT: "Guardar todos os itens na lixeira num ficheiro .json.",
    DESCRIPTION_IMPORT: "Substituir todos os itens na lixeira através do ficheiro .json.",
    DESCRIPTION_CLEAR: "Limpar todos os itens da lixeira (não pode ser revertido).",
    ITEMS_EMPTY_SONGS_TITLE: "Sem músicas eliminadas!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Nenhum artista eliminado!",
    DESCRIPTION_SETTINGS_ENABLED: "Comutador principal para ativar ou desativar todas as funcionalidades do Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Exibir um ícone de lixeira na barra de reprodução ao lado da faixa atualmente em reprodução para acesso rápido",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Iniciar automaticamente a reprodução de música quando o Spotify for aberto ou a extensão for carregada",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Adicione ícones de lixo junto a cada música na sua fila de reprodução para facilitar a gestão",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Adicionar ícones de lixo junto às músicas nas visualizações de álbuns e playlists para filtragem rápida",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recupere automaticamente de falhas na reprodução do Spotify retomando a sua última playlist",
    SETTINGS_SKIP_TRASHED_TRACKS: "Ignorar faixas eliminadas",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Ignorar automaticamente músicas eliminadas e encontrar a próxima faixa permitida durante a reprodução",
    SETTINGS_AUTO_CLEAN_QUEUE: "Fila de Limpeza Automática",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Remover automaticamente músicas eliminadas da sua fila de reprodução aleatória inteligente",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Lixo na próxima tecla de atalho",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Colocar automaticamente a música atual na lixeira ao usar o atalho de teclado Ctrl+Direita para avançar para a faixa seguinte",
    SETTINGS_REMOTE_CONTROL: "Controlo Remoto",
    SETTINGS_REMOTE_TOGGLE: "Ativar Alternância Remota",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Toque duas vezes em reproduzir/pausar a partir do dispositivo móvel para ativar/desativar a passagem de faixas remota. A passagem de uma faixa confirma a alteração.",
    SETTINGS_REMOTE_SKIPPING: "Pulsação remota ativa",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Quando ativado, a função de ignorar faixas funciona mesmo ao controlar o Spotify a partir de outro dispositivo (por exemplo, telemóvel)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Avanço remoto ativado",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "A passagem remota foi desativada",
    MESSAGE_SONG_ADDED_REMOTE: "Música eliminada à distância",
    SETTINGS_TRASH_VIA_LIKE: "Lixo via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Como uma música do telemóvel para a eliminar. Descurte automaticamente e passa para a faixa seguinte.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ro.json
var require_ro = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Coș de gunoi+",
    ACTION_THROW: "Așezați în coșul de gunoi",
    ACTION_UNTHROW: "Elimină din coșul de gunoi",
    ACTION_CLEAR: "Clar",
    ACTION_COPY: "Copiați",
    ACTION_EXPORT: "Export",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Copiat în clipboard",
    MESSAGE_CLEARED: "Coșul de gunoi a fost golit cu succes!",
    MESSAGE_SONG_ADDED: "Cântec adăugat în coșul de gunoi",
    MESSAGE_SONG_REMOVED: "Cântecul a fost eliminat din coșul de gunoi",
    MESSAGE_ARTIST_ADDED: "Artist adăugat în coșul de gunoi",
    MESSAGE_ARTIST_REMOVED: "Artistul a fost eliminat din coșul de gunoi",
    BACKUP_SAVE_SUCCESS: "Backup salvat cu succes.",
    BACKUP_SAVE_FAILED: "Nu s-a reușit salvarea copiei de rezervă, încercați să copiați conținutul coșului de gunoi în clipboard și să creați o copie de rezervă manual.",
    BACKUP_RESTORE_SUCCESS: "Backupul a fost restaurat cu succes.",
    BACKUP_FILE_READ_FAILED: "Eșec la citirea fișierului, vă rugăm să vă asigurați că este un fișier JSON valid.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Setări coș de gunoi+",
    SETTINGS_OPTIONS: "Opțiuni",
    SETTINGS_FEATURES: "Caracteristici",
    SETTINGS_LOCAL_STORAGE: "Stocare locală",
    SETTINGS_ENABLED: "Activat",
    SETTINGS_SHOW_WIDGET: "Afișați pictograma widgetului",
    SETTINGS_AUTOPLAY: "Redare automată la pornire",
    SETTINGS_QUEUE_TRASHBIN: "Activați coșul de gunoi al cozii",
    SETTINGS_TRACKLIST_TRASHBIN: "Activați coșul de gunoi pentru listele de redare",
    SETTINGS_PLAYLIST_MONITOR: "Monitorul listei de redare",
    ITEMS_TITLE: "Elemente din coșul de gunoi+",
    ITEMS_EMPTY_SONGS: "<strong>Niciun cântec tras la gunoi!</strong><br/>Cântecele pe care le adaugi în coșul de gunoi vor apărea aici.",
    ITEMS_EMPTY_ARTISTS: "<strong>Niciun artist eliminat!</strong><br/>Artiștii pe care îi adăugați la coșul de gunoi vor apărea aici.",
    ITEMS_TAB_SONGS: "Cântece",
    ITEMS_TAB_ARTISTS: "Artiști",
    ITEMS_LOADED_COUNT: "{{loaded}} din {{total}} {{type}} încărcate",
    DESCRIPTION_COPY: "Copiați toate elementele din coșul de gunoi în clipboard.",
    DESCRIPTION_EXPORT: "Salvați toate elementele din coșul de gunoi într-un fișier .json.",
    DESCRIPTION_IMPORT: "Suprascrie toate elementele din coșul de gunoi prin fișierul .json.",
    DESCRIPTION_CLEAR: "Ștergeți toate elementele din coșul de gunoi (acțiunea nu poate fi anulată).",
    ITEMS_EMPTY_SONGS_TITLE: "Nicio melodie ștearsă!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Niciun artist aruncat la gunoi!",
    DESCRIPTION_SETTINGS_ENABLED: "Comutare principală pentru activarea sau dezactivarea tuturor funcțiilor Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Afișează o pictogramă de coș de gunoi în bara de redare lângă piesa care se redă în prezent pentru acces rapid",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Pornește automat redarea muzicii când Spotify se deschide sau extensia se încarcă",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Adăugați iconițe de coș de gunoi lângă fiecare melodie din coada viitoare pentru o gestionare ușoară",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Adăugați pictograme de coș de gunoi lângă melodii în vizualizările de album și playlist pentru filtrare rapidă",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Recuperează automat erorile de redare de pe Spotify reluând ultima ta listă de redare",
    SETTINGS_SKIP_TRASHED_TRACKS: "Ignoră piesele șterse",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Sări automat peste piesele șterse și găsește următorul titlu permis în timpul redării",
    SETTINGS_AUTO_CLEAN_QUEUE: "Coada de curățare automată",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Eliminați automat piesele șterse din coada dvs. Smart Shuffle",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Gunoi la următoarea tastă rapidă",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Șterge automat piesa curentă când folosești combinația de taste Ctrl+Dreapta pentru a trece la următoarea piesă",
    SETTINGS_REMOTE_CONTROL: "Control la distanță",
    SETTINGS_REMOTE_TOGGLE: "Activați comutarea la distanță",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Apăsați de două ori pe redare/pauză de pe mobil pentru a activa/dezactiva săritul de la distanță. Săritul unui titlu confirmă comutarea.",
    SETTINGS_REMOTE_SKIPPING: "Săritul la distanță activ",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Când este activată, omitearea coșului de gunoi funcționează chiar și atunci când controlați Spotify de pe un alt dispozitiv (de exemplu, mobil)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Săritul la distanță activat",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Săritul la distanță dezactivat",
    MESSAGE_SONG_ADDED_REMOTE: "Melodia distrusă la distanță",
    SETTINGS_TRASH_VIA_LIKE: "Gunoi prin Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Ca un cântec de la mobil la coșul de gunoi. Dezapreciază automat și trece la următorul cântec.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ru.json
var require_ru = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Корзина+",
    ACTION_THROW: "Поместить в корзину",
    ACTION_UNTHROW: "Удалить из корзины",
    ACTION_CLEAR: "Ясно",
    ACTION_COPY: "Копировать",
    ACTION_EXPORT: "Экспорт",
    ACTION_IMPORT: "Импорт",
    MESSAGE_COPIED: "Скопировано в буфер обмена",
    MESSAGE_CLEARED: "Корзина успешно очищена!",
    MESSAGE_SONG_ADDED: "Песня добавлена в корзину",
    MESSAGE_SONG_REMOVED: "Песня удалена из корзины",
    MESSAGE_ARTIST_ADDED: "Художник добавлен в корзину",
    MESSAGE_ARTIST_REMOVED: "Художник удалён из корзины",
    BACKUP_SAVE_SUCCESS: "Резервная копия успешно сохранена.",
    BACKUP_SAVE_FAILED: "Не удалось сохранить резервную копию, попробуйте скопировать содержимое корзины в буфер обмена и создать резервную копию вручную.",
    BACKUP_RESTORE_SUCCESS: "Резервная копия успешно восстановлена.",
    BACKUP_FILE_READ_FAILED: "Не удалось прочитать файл, убедитесь, что это корректный файл JSON.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Настройки корзины+",
    SETTINGS_OPTIONS: "Опции",
    SETTINGS_FEATURES: "Особенности",
    SETTINGS_LOCAL_STORAGE: "Локальное хранилище",
    SETTINGS_ENABLED: "Включено",
    SETTINGS_SHOW_WIDGET: "Показать значок виджета",
    SETTINGS_AUTOPLAY: "Автовоспроизведение при запуске",
    SETTINGS_QUEUE_TRASHBIN: "Включить корзину очереди",
    SETTINGS_TRACKLIST_TRASHBIN: "Включить корзину для трек-листа",
    SETTINGS_PLAYLIST_MONITOR: "Монитор плейлистов",
    ITEMS_TITLE: "Элементы корзины+",
    ITEMS_EMPTY_SONGS: "<strong>Нет удалённых песен!</strong><br/>Песни, которые вы добавите в корзину, появятся здесь.",
    ITEMS_EMPTY_ARTISTS: "<strong>Нет артистов в корзине!</strong><br/>Артисты, которых вы добавите в корзину, появятся здесь.",
    ITEMS_TAB_SONGS: "Песни",
    ITEMS_TAB_ARTISTS: "Художники",
    ITEMS_LOADED_COUNT: "Загружено {{loaded}} из {{total}} {{type}}",
    DESCRIPTION_COPY: "Копировать все элементы в корзине в буфер обмена.",
    DESCRIPTION_EXPORT: "Сохранить все элементы в корзине в файл .json.",
    DESCRIPTION_IMPORT: "Перезаписать все элементы в корзине с помощью файла .json.",
    DESCRIPTION_CLEAR: "Очистить все элементы из корзины (невозможно отменить).",
    ITEMS_EMPTY_SONGS_TITLE: "Нет удалённых песен!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Никаких выброшенных художников!",
    DESCRIPTION_SETTINGS_ENABLED: "Главный переключатель для включения или отключения всех функций корзины+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Отображать значок корзины на панели воспроизведения рядом с текущим треком для быстрого доступа",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Автоматически начинать воспроизведение музыки при открытии Spotify или загрузке расширения",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Добавьте значки корзины рядом с каждой песней в очереди для удобного управления",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Добавить значки корзины рядом с песнями в альбомах и плейлистах для быстрой фильтрации",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Автоматическое восстановление после сбоев воспроизведения в Spotify путем возобновления последнего плейлиста",
    SETTINGS_SKIP_TRASHED_TRACKS: "Пропустить удалённые треки",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Автоматически пропускать удалённые песни и находить следующий доступный трек во время воспроизведения",
    SETTINGS_AUTO_CLEAN_QUEUE: "Очередь автоматической очистки",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Автоматически удалять удалённые песни из очереди умного перемешивания",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Корзина по следующему сочетанию клавиш",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Автоматически удалять текущую песню при использовании сочетания клавиш Ctrl+Вправо для перехода к следующему треку",
    SETTINGS_REMOTE_CONTROL: "Дистанционное управление",
    SETTINGS_REMOTE_TOGGLE: "Включить удалённое переключение",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Дважды коснитесь кнопки воспроизведения/паузы на мобильном устройстве, чтобы включить или отключить дистанционное пропускание. Пропуск трека подтверждает переключение.",
    SETTINGS_REMOTE_SKIPPING: "Пропуск дистанционного доступа активен",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "При включении функция пропуска трека работает даже при управлении Spotify с другого устройства (например, мобильного телефона)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Пропуск на расстоянии включен",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Дистанционное пропускание отключено",
    MESSAGE_SONG_ADDED_REMOTE: "Песня уничтожена на расстоянии",
    SETTINGS_TRASH_VIA_LIKE: "Мусор через Лайк",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Как песня с мобильного в корзину. Автоматически удаляет лайк и переходит к следующему треку.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/sk.json
var require_sk = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Kôš+",
    ACTION_THROW: "Umiestniť do koša",
    ACTION_UNTHROW: "Odstrániť z koša",
    ACTION_CLEAR: "Jasné",
    ACTION_COPY: "Kopírovať",
    ACTION_EXPORT: "Export",
    ACTION_IMPORT: "Import",
    MESSAGE_COPIED: "Skopírované do schránky",
    MESSAGE_CLEARED: "Kôš úspešne vyprázdnený!",
    MESSAGE_SONG_ADDED: "Skomponovaná pieseň odstránená",
    MESSAGE_SONG_REMOVED: "Skandlba odstránená z koša",
    MESSAGE_ARTIST_ADDED: "Umelca pridaného do koša",
    MESSAGE_ARTIST_REMOVED: "Umeniek odstránený z koša",
    BACKUP_SAVE_SUCCESS: "Záloha bola úspešne uložená.",
    BACKUP_SAVE_FAILED: "Zálohovanie sa nepodarilo, skúste skopírovať obsah kôša do schránky a vytvoriť zálohu ručne.",
    BACKUP_RESTORE_SUCCESS: "Záloha bola úspešne obnovená.",
    BACKUP_FILE_READ_FAILED: "Nepodarilo sa prečítať súbor, uistite sa, že ide o platný súbor JSON.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Nastavenia koša+",
    SETTINGS_OPTIONS: "Možnosti",
    SETTINGS_FEATURES: "Funkcie",
    SETTINGS_LOCAL_STORAGE: "Lokálne úložisko",
    SETTINGS_ENABLED: "Povolené",
    SETTINGS_SHOW_WIDGET: "Zobraziť ikonu widgetu",
    SETTINGS_AUTOPLAY: "Automatické prehrávanie pri štarte",
    SETTINGS_QUEUE_TRASHBIN: "Povoliť frontu kôša",
    SETTINGS_TRACKLIST_TRASHBIN: "Povoliť kôš pre zoznam skladieb",
    SETTINGS_PLAYLIST_MONITOR: "Monitor zoznamu skladieb",
    ITEMS_TITLE: "Položky v koši+",
    ITEMS_EMPTY_SONGS: "<strong>Žiadne zmazané skladby!</strong><br/>Skladby, ktoré odstránite do koša, sa objavia tu.",
    ITEMS_EMPTY_ARTISTS: "<strong>Žiadni umelci v koši!</strong><br/>Umelci, ktorých pridáte do koša, sa objavia tu.",
    ITEMS_TAB_SONGS: "Pesničky",
    ITEMS_TAB_ARTISTS: "Umelci",
    ITEMS_LOADED_COUNT: "Načítaných {{loaded}} z {{total}} položiek typu {{type}}",
    DESCRIPTION_COPY: "Skopírovať všetky položky v koši do schránky.",
    DESCRIPTION_EXPORT: "Uložiť všetky položky v koši do súboru .json.",
    DESCRIPTION_IMPORT: "Prepísať všetky položky v koši pomocou súboru .json.",
    DESCRIPTION_CLEAR: "Odstrániť všetky položky z koša (nie je možné vrátiť späť).",
    ITEMS_EMPTY_SONGS_TITLE: "Žiadne zmazané skladby!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Žiadni zničení umelci!",
    DESCRIPTION_SETTINGS_ENABLED: "Hlavné prepínanie na povolenie alebo zakázanie všetkých funkcií Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Zobraziť ikonu koša v prehrávacom paneli vedľa práve prehrávanej skladby pre rýchly prístup",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Automaticky spustiť prehrávanie hudby pri otvorení Spotify alebo pri načítaní rozšírenia",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Pridajte ikony koša vedľa každej skladby vo vašej nadchádzajúcej fronte pre jednoduchú správu",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Pridať ikony koša vedľa skladieb v zobrazeniach albumov a playlistov pre rýchle filtrovanie",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Automatické obnovenie prehrávania na Spotify po výpadkoch obnovením posledného zoznamu skladieb",
    SETTINGS_SKIP_TRASHED_TRACKS: "Preskočiť odstránené skladby",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Automaticky preskakovať odstránené skladby a nájsť ďalšiu povolenú skladbu počas prehrávania",
    SETTINGS_AUTO_CLEAN_QUEUE: "Auto čistenie frontu",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Automaticky odstraňujte skladby v koši z fronty Smart Shuffle",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Odpad na ďalšej klávesovej skratke",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Automaticky odstrániť aktuálnu skladbu, keď použijete klávesovú skratku Ctrl+Doprava na preskočenie na ďalšiu skladbu",
    SETTINGS_REMOTE_CONTROL: "Diaľkové ovládanie",
    SETTINGS_REMOTE_TOGGLE: "Povoliť vzdialené prepínanie",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dvojitým klepnutím na prehrávanie/pauzu z mobilného zariadenia zapnete alebo vypnete diaľkové preskakovanie. Preskočenie skladby potvrdí prepínanie.",
    SETTINGS_REMOTE_SKIPPING: "Vzdialené preskakovanie aktívne",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Ak je funkcia povolená, preskakovanie kôša funguje aj pri ovládaní Spotify z iného zariadenia (napr. mobilného).",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Vzdialené preskakovanie povolené",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Vzdialené preskakovanie je zakázané",
    MESSAGE_SONG_ADDED_REMOTE: "Skomolená skladba na diaľku",
    SETTINGS_TRASH_VIA_LIKE: "Odpad cez Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Ako skladba z mobilu do koša. Automaticky odstráni „Páči sa mi“ a prejde na ďalšiu skladbu.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/sl.json
var require_sl = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Smetnjak+",
    ACTION_THROW: "Postavi v koš za smeti",
    ACTION_UNTHROW: "Odstrani iz koša",
    ACTION_CLEAR: "Jasno",
    ACTION_COPY: "Kopiraj",
    ACTION_EXPORT: "Izvoz",
    ACTION_IMPORT: "Uvoz",
    MESSAGE_COPIED: "Kopirano v odložišče",
    MESSAGE_CLEARED: "Smetnjak uspešno izpraznjen!",
    MESSAGE_SONG_ADDED: "Pesem dodana v koš za smeti",
    MESSAGE_SONG_REMOVED: "Pesem odstranjena iz koša",
    MESSAGE_ARTIST_ADDED: "Umetnik dodan v koš za smeti",
    MESSAGE_ARTIST_REMOVED: "Umetnik odstranjen iz koša za smeti",
    BACKUP_SAVE_SUCCESS: "Varnostna kopija je bila uspešno shranjena.",
    BACKUP_SAVE_FAILED: "Shranjevanje varnostne kopije ni uspelo, poskusite kopirati vsebino koša v odložišče in ročno ustvariti varnostno kopijo.",
    BACKUP_RESTORE_SUCCESS: "Varnostna kopija je bila uspešno obnovljena.",
    BACKUP_FILE_READ_FAILED: "Ni bilo mogoče prebrati datoteke, preverite, ali je veljavna datoteka JSON.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Nastavitve koša za smeti+",
    SETTINGS_OPTIONS: "Možnosti",
    SETTINGS_FEATURES: "Lastnosti",
    SETTINGS_LOCAL_STORAGE: "Lokalni pomnilnik",
    SETTINGS_ENABLED: "Omogočeno",
    SETTINGS_SHOW_WIDGET: "Prikaži ikono gradnika",
    SETTINGS_AUTOPLAY: "Samodejno predvajaj ob zagonu",
    SETTINGS_QUEUE_TRASHBIN: "Omogoči vrsto koša",
    SETTINGS_TRACKLIST_TRASHBIN: "Omogoči koš za smeti s seznamom skladb",
    SETTINGS_PLAYLIST_MONITOR: "Sledilnik predvajalnega seznama",
    ITEMS_TITLE: "Predmeti koša+",
    ITEMS_EMPTY_SONGS: "<strong>Ni izbrisanih pesmi!</strong><br/>Pesmi, ki jih dodate v koš za smeti, bodo prikazane tukaj.",
    ITEMS_EMPTY_ARTISTS: "<strong>Brez zavrženih umetnikov!</strong><br/>Umetniki, ki jih dodate v koš za smeti, bodo prikazani tukaj.",
    ITEMS_TAB_SONGS: "Pesmi",
    ITEMS_TAB_ARTISTS: "Umjetnici",
    ITEMS_LOADED_COUNT: "{{loaded}} od {{total}} {{type}} naloženih",
    DESCRIPTION_COPY: "Kopiraj vse elemente v košu v odložišče.",
    DESCRIPTION_EXPORT: "Shrani vse elemente v košu v datoteko .json.",
    DESCRIPTION_IMPORT: "Prepiši vse elemente v košu s .json datoteko.",
    DESCRIPTION_CLEAR: "Izprazni vse predmete iz koša (ni mogoče razveljaviti).",
    ITEMS_EMPTY_SONGS_TITLE: "Brez izbrisanih pesmi!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Brez zavrglih umetnikov!",
    DESCRIPTION_SETTINGS_ENABLED: "Glavni stikalo za vklop ali izklop vseh funkcij Koša+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Prikaži ikono koša v vrstici predvajanja poleg trenutno predvajane skladbe za hitri dostop",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Samodejno začni predvajati glasbo, ko se odpre Spotify ali ko se razširitev naloži",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Dodajte ikone za smetnjak poleg vsake pesmi v vaši prihodnji vrstici za enostavno upravljanje",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Dodaj ikone smeti poleg pesmi v pogledih albumov in seznamov predvajanja za hitro filtriranje",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Samodejno obnovite predvajanje v Spotifyju po napakah tako, da znova zaženete zadnji predvajalni seznam",
    SETTINGS_SKIP_TRASHED_TRACKS: "Preskoči izbrisane skladbe",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Samodejno preskoči izbrisane pesmi in med predvajanjem poišči naslednjo dovoljeno skladbo",
    SETTINGS_AUTO_CLEAN_QUEUE: "Samodejna čistilna vrsta",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Samodejno odstrani izbrisane pesmi iz čakalne vrste pametnega mešanja",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Smeti na naslednji bližnjici",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Samodejno odstrani trenutno skladbo, ko uporabite tipkovno bližnjico Ctrl+Desno, da preskočite na naslednjo skladbo",
    SETTINGS_REMOTE_CONTROL: "Daljinski krmilnik",
    SETTINGS_REMOTE_TOGGLE: "Omogoči oddaljeno preklopno funkcijo",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Dvakrat tapnite predvajaj/pavza na mobilni napravi, da vklopite/izklopite oddaljeno preskakovanie. Preskok skladbe potrdi preklop.",
    SETTINGS_REMOTE_SKIPPING: "Oddaljeno preskakovanje je aktivno",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Ko je omogočeno, se preskakovanie smetnjaka izvaja tudi ob upravljanju s Spotifyjem z druge naprave (npr. mobilne).",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Omogočeno je oddaljeno preskakovanje",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Oddaljeno preskakovanie onemogočeno",
    MESSAGE_SONG_ADDED_REMOTE: "Pesem uničena na daljavo",
    SETTINGS_TRASH_VIA_LIKE: "Smeti prek Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Kot pesem iz mobilnega v smeti. Samodejno odstrani všeček in preklopi na naslednjo skladbo.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/sr.json
var require_sr = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Канта за смеће+",
    ACTION_THROW: "Смести у сандуче за отпатке",
    ACTION_UNTHROW: "Уклони из корпе за смеће",
    ACTION_CLEAR: "Јасно",
    ACTION_COPY: "Копирај",
    ACTION_EXPORT: "Извоз",
    ACTION_IMPORT: "Увоз",
    MESSAGE_COPIED: "Копирано у оставу",
    MESSAGE_CLEARED: "Смеће успешно очишћено!",
    MESSAGE_SONG_ADDED: "Песма додата у корпу за смеће",
    MESSAGE_SONG_REMOVED: "Песма је уклоњена из корпе за смеће",
    MESSAGE_ARTIST_ADDED: "Уметник додат у корпу за смеће",
    MESSAGE_ARTIST_REMOVED: "Уметник је уклоњен из сандуча за отпатке",
    BACKUP_SAVE_SUCCESS: "Резервна копија је успешно сачувана.",
    BACKUP_SAVE_FAILED: "Није успело чување резервне копије, покушајте да копирате садржај корпе за смеће у оставу и да ручно направите резервну копију.",
    BACKUP_RESTORE_SUCCESS: "Резервна копија је успешно враћена.",
    BACKUP_FILE_READ_FAILED: "Није успело читање датотеке, молимо проверите да ли је исправна JSON датотека.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Подешавања корпе за отпатке+",
    SETTINGS_OPTIONS: "Опције",
    SETTINGS_FEATURES: "Каркаcterистике",
    SETTINGS_LOCAL_STORAGE: "Локални складиште",
    SETTINGS_ENABLED: "Омогућено",
    SETTINGS_SHOW_WIDGET: "Прикажи икону виджета",
    SETTINGS_AUTOPLAY: "Аутоматско пуштање при покретању",
    SETTINGS_QUEUE_TRASHBIN: "Омогући корпу за отпатке реда чекања",
    SETTINGS_TRACKLIST_TRASHBIN: "Омогући корпу за отпатке листе нумера",
    SETTINGS_PLAYLIST_MONITOR: "Плејлиста монитор",
    ITEMS_TITLE: "Ставке корпе за смеће+",
    ITEMS_EMPTY_SONGS: "<strong>Нема избрисаних песама!</strong><br/>Песме које додате у корпу за смеће ће се појавити овде.",
    ITEMS_EMPTY_ARTISTS: "<strong>Нема избрисаних извођача!</strong><br/>Извођачи које додате у корпу за отпатке појавиће се овде.",
    ITEMS_TAB_SONGS: "Песме",
    ITEMS_TAB_ARTISTS: "Уметници",
    ITEMS_LOADED_COUNT: "Учитано {{loaded}} од {{total}} {{type}}",
    DESCRIPTION_COPY: "Копирај све ставке из сандучета за отпад у оставу.",
    DESCRIPTION_EXPORT: "Сачувај све ставке у корпи за смеће у .json датотеку.",
    DESCRIPTION_IMPORT: "Преписати све ставке у корпи преко .json датотеке.",
    DESCRIPTION_CLEAR: "Обриши све ставке из сандучета за отпатак (не може се опозвати).",
    ITEMS_EMPTY_SONGS_TITLE: "Нема избрисаних песама!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Без уњиштених уметника!",
    DESCRIPTION_SETTINGS_ENABLED: "Главни прекидач за омогућавање или онемогућавање свих функција Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Прикажи икону корпе за отпад у траци за репродукцију поред тренутно репродукованог нумере за брз приступ",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Аутоматско покретање музике када се Spotify отвори или када се проширење учита",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Додајте иконице за отпад поред сваке песме у вашој редоследу за лакше управљање",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Додај иконе за бациње поред песама у прегледима албума и листе песама ради брзег филтрирања",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Аутоматско опорављање од грешака при репродукцији на Спотифају настављањем ваше последње плејлисте",
    SETTINGS_SKIP_TRASHED_TRACKS: "Прескочи оbrisане нумере",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Аутоматско прескачење отпадних песама и проналажење следеће дозвољене нумере током репродукције",
    SETTINGS_AUTO_CLEAN_QUEUE: "Ред за аутоматско чишћење",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Аутоматски уклони избрисане песме из реда чувања случајног редоследа",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Смеће на следећем тастеру за брзо пребацивање",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Аутоматски баците тренутну песму у корпу за отпатак када користите пречицу на тастатури Ctrl+Десно да бисте прескочили на следећу нумеру",
    SETTINGS_REMOTE_CONTROL: "Даљинско управљање",
    SETTINGS_REMOTE_TOGGLE: "Омогући удаљено пребацивање",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Додирните двапут плеј/паузу са мобилног уређаја да бисте укључили или искључили прескакање на даљину. Прескакање нумере потврђује пребацивање.",
    SETTINGS_REMOTE_SKIPPING: "Даљинско прескачање активно",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Када је омогућено, прескакање отпада функционише чак и када управљате Спотифајом са другог уређаја (нпр. мобилног телефона)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Удаљено прескачање укључено",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Даљинско прескачање онемогућено",
    MESSAGE_SONG_ADDED_REMOTE: "Песма уништена на даљинско",
    SETTINGS_TRASH_VIA_LIKE: "Смеће преко Лайк-а",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Као песма са мобилног да бациш. Аутоматски престаје да се свиђа и прескаче на следећу нумеру.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/sv.json
var require_sv = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Papperskorg+",
    ACTION_THROW: "Placera i papperskorgen",
    ACTION_UNTHROW: "Ta bort från papperskorgen",
    ACTION_CLEAR: "Klart",
    ACTION_COPY: "Kopiera",
    ACTION_EXPORT: "Exportera",
    ACTION_IMPORT: "Importera",
    MESSAGE_COPIED: "Kopierat till urklipp",
    MESSAGE_CLEARED: "Papperskorgen tömdes framgångsrikt!",
    MESSAGE_SONG_ADDED: "Låt tillagd i papperskorgen",
    MESSAGE_SONG_REMOVED: "Låt borttagen från papperskorgen",
    MESSAGE_ARTIST_ADDED: "Konstnär tillagd i papperskorgen",
    MESSAGE_ARTIST_REMOVED: "Konstnär borttagen från papperskorgen",
    BACKUP_SAVE_SUCCESS: "Säkerhetskopia sparades framgångsrikt.",
    BACKUP_SAVE_FAILED: "Det gick inte att spara säkerhetskopia, försök att kopiera papperskorgens innehåll till urklipp och skapa en säkerhetskopia manuellt.",
    BACKUP_RESTORE_SUCCESS: "Säkerhetskopian återställdes framgångsrikt.",
    BACKUP_FILE_READ_FAILED: "Det gick inte att läsa filen, se till att det är en giltig JSON-fil.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Soptunna+ Inställningar",
    SETTINGS_OPTIONS: "Alternativ",
    SETTINGS_FEATURES: "Funktioner",
    SETTINGS_LOCAL_STORAGE: "Lokalt lagringsutrymme",
    SETTINGS_ENABLED: "Aktiverad",
    SETTINGS_SHOW_WIDGET: "Visa widgetikon",
    SETTINGS_AUTOPLAY: "Automatisk uppspelning vid start",
    SETTINGS_QUEUE_TRASHBIN: "Aktivera Kö-papperskorg",
    SETTINGS_TRACKLIST_TRASHBIN: "Aktivera spårlistans papperskorg",
    SETTINGS_PLAYLIST_MONITOR: "Spellistsövervakning",
    ITEMS_TITLE: "Papperskorg+ objekt",
    ITEMS_EMPTY_SONGS: "<strong>Inga sånger i papperskorgen!</strong><br/>Sånger du lägger i papperskorgen kommer att visas här.",
    ITEMS_EMPTY_ARTISTS: "<strong>Inga artister i papperskorgen!</strong><br/>Artister du lägger i papperskorgen kommer att visas här.",
    ITEMS_TAB_SONGS: "Låtar",
    ITEMS_TAB_ARTISTS: "Konstnärer",
    ITEMS_LOADED_COUNT: "{{loaded}} av {{total}} {{type}} inlästa",
    DESCRIPTION_COPY: "Kopiera alla objekt i papperskorgen till urklipp.",
    DESCRIPTION_EXPORT: "Spara alla objekt i papperskorgen till en .json-fil.",
    DESCRIPTION_IMPORT: "Skriv över alla objekt i papperskorgen via .json-fil.",
    DESCRIPTION_CLEAR: "Rensa alla objekt från papperskorgen (kan inte ångras).",
    ITEMS_EMPTY_SONGS_TITLE: "Inga borttagna låtar!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Inga förstörda artister!",
    DESCRIPTION_SETTINGS_ENABLED: "Huvudbrytare för att aktivera eller inaktivera all funktionalitet i Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Visa en papperskorgsikon i avspelningsfältet bredvid den spelande låten för snabb åtkomst",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Starta automatiskt spela musik när Spotify öppnas eller tillägget läses in",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Lägg till papperskorgsikoner bredvid varje låt i din kommande kö för enkel hantering",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Lägg till papperskorgsikoner bredvid låtar i album- och spellistsvyn för snabb filtrering",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Återställ automatiskt från Spotify-uppspelningsfel genom att återuppta din senaste spellista",
    SETTINGS_SKIP_TRASHED_TRACKS: "Hoppa över borttagna spår",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Hoppa automatiskt över borttagna låtar och hitta nästa tillåtna spår under uppspelning",
    SETTINGS_AUTO_CLEAN_QUEUE: "Automatisk rensningskö",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Ta automatiskt bort papperskorgsmarkerade låtar från din Smarta Shuffle-kö",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Papperskorg vid nästa snabbtangent",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Flytta automatiskt det aktuella låtet till papperskorgen när du använder kortkommandot Ctrl+Höger för att hoppa till nästa spår",
    SETTINGS_REMOTE_CONTROL: "Fjärrkontroll",
    SETTINGS_REMOTE_TOGGLE: "Aktivera fjärrväxling",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Tryck två gånger på play/pause från mobilen för att aktivera/inaktivera fjärrhoppning. Ett spårhopp bekräftar inställningen.",
    SETTINGS_REMOTE_SKIPPING: "Fjärröverhoppning Aktiv",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "När det är aktiverat fungerar papperskorgsöverhoppning även när Spotify styrs från en annan enhet (t.ex. mobil)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Fjärrhoppning aktiverad",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Fjärröversprångning inaktiverad",
    MESSAGE_SONG_ADDED_REMOTE: "Låt förstörd via fjärrkontroll",
    SETTINGS_TRASH_VIA_LIKE: "Skräp via Like",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Som en låt från mobil till papperskorgen. Tar automatiskt bort gillandet och hoppar till nästa spår.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/sw.json
var require_sw = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Kisanduku cha taka+",
    ACTION_THROW: "Weka kwenye kisanduku cha taka",
    ACTION_UNTHROW: "Ondoa kutoka kwenye Kikapu cha Taka",
    ACTION_CLEAR: "Wazi",
    ACTION_COPY: "Nakili",
    ACTION_EXPORT: "Uza nje",
    ACTION_IMPORT: "Kuletea",
    MESSAGE_COPIED: "Imekopishwa kwenye ubao",
    MESSAGE_CLEARED: "Kisanduku cha taka kimefutwa kikweli!",
    MESSAGE_SONG_ADDED: "Wimbo umewekwa kwenye kisanduku cha taka",
    MESSAGE_SONG_REMOVED: "Wimbo umefutwa kutoka kwenye kisanduku cha takataka",
    MESSAGE_ARTIST_ADDED: "Mchezaji amewekwa kwenye kikapu cha taka",
    MESSAGE_ARTIST_REMOVED: "Mchezaji wa sanaa ameondolewa kutoka kwenye kisanduku cha taka",
    BACKUP_SAVE_SUCCESS: "Usimamizi umohifadhiwa kikamilifu.",
    BACKUP_SAVE_FAILED: "Imeshindwa kuhifadhi nakala, jaribu kunakili maudhui ya kisanduku cha takataka kwenye ubao wa kunakili na kuunda nakala kwa mkono.",
    BACKUP_RESTORE_SUCCESS: "Usalimwengu umerudiwa kikamilifu.",
    BACKUP_FILE_READ_FAILED: "Imeshindwa kusoma faili, tafadhali hakikisha kwamba ni faili halali ya JSON.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Mipangilio ya Kipande cha Taka+",
    SETTINGS_OPTIONS: "Chaguzi",
    SETTINGS_FEATURES: "Vipengele",
    SETTINGS_LOCAL_STORAGE: "Hifadhi ya Lokali",
    SETTINGS_ENABLED: "Imewezeshwa",
    SETTINGS_SHOW_WIDGET: "Onyesha Ikoni ya Kiolesura",
    SETTINGS_AUTOPLAY: "Kucheza kiotomatiki kuanzia",
    SETTINGS_QUEUE_TRASHBIN: "Washa Kikapu cha Kuchukua Taka",
    SETTINGS_TRACKLIST_TRASHBIN: "Washa Kikokotoo cha Orodha ya Nyimbo",
    SETTINGS_PLAYLIST_MONITOR: "Ombwe la Orodha ya Nyimbo",
    ITEMS_TITLE: "Vitu vya kisanduku cha taka+",
    ITEMS_EMPTY_SONGS: "<strong>Hakuna wimbo uliowekwa kwenye kisanduku cha taka!</strong><br/>Wimbo unaoongeza kwenye kisanduku cha taka utaonekana hapa.",
    ITEMS_EMPTY_ARTISTS: "<strong>Hakuna wasanii wamefukuzwa!</strong><br/>Wasanii ambao utawafukuzia katika kikapu cha taka kitakuwako hapa.",
    ITEMS_TAB_SONGS: "Nyimbo",
    ITEMS_TAB_ARTISTS: "Wasanii",
    ITEMS_LOADED_COUNT: "{{loaded}} ya {{total}} {{type}} imepakia",
    DESCRIPTION_COPY: "Nakili vitu vyote kwenye kisanduku cha kuchakata kwenye ubao wa kunakili.",
    DESCRIPTION_EXPORT: "Hifadhi vitu vyote kwenye kisanduku cha kuchakata kwenye faili ya .json.",
    DESCRIPTION_IMPORT: "Andika upya vitu vyote kwenye kisanduku cha kuchakata kupitia faili ya .json.",
    DESCRIPTION_CLEAR: "Futa vitu vyote kutoka kwenye kisanduku cha taka (hauwezi kurudishwa).",
    ITEMS_EMPTY_SONGS_TITLE: "Hakuna wimbo uliowekwa kwenye kisima!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Hakuna wasanii wamevunjika!",
    DESCRIPTION_SETTINGS_ENABLED: "Bofya kuu kuwezesha au kuzima uwezo wote wa Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Onyesha ikoni ya kisanduku cha taka kwenye kivinjari cha kucheza kando ya kipande kinachotamasha sasa kwa ajili ya upatikanaji wa haraka",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Anza kucheza muziki kiotomatiki unapofungua Spotify au unapofungua extension",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Ongeza alama za kahawa kila wimbo kwenye orodha yako inayofuata kwa usimamizi rahisi",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Ongeza alama za kahawa karibu na nyimbo katika maoni ya kikosoa na orodha ya kikosoa kwa ajili ya kuchuja kwa haraka",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Rejesha kiotomatiki kutoka kwa hitilafu za kucheza kwenye Spotify kwa kurudia orodha ya nyimbo yako ya mwisho",
    SETTINGS_SKIP_TRASHED_TRACKS: "Sautisha Nyimbo Zilizoharibiwa",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Rukisha otomatiki nyimbo zilizofutwa na tafuta kipande kifuatacho kinachoruhusiwa wakati wa kucheza",
    SETTINGS_AUTO_CLEAN_QUEUE: "Ondoa Safu ya Usafi",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Ondoa kiotomatiki nyimbo zilizotupwa kutoka kwenye safu yako ya Smart Shuffle",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Taka kwenye Kitufe cha Joto cha Kifupi",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Ondoa kiotomatiki nyimbo ya sasa wakati wa kutumia快捷键 Ctrl+Right kupitia kwa nyimbo inayofuata",
    SETTINGS_REMOTE_CONTROL: "Kudhibiti mbali",
    SETTINGS_REMOTE_TOGGLE: "Washa Mgawanyiko wa Mbali",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Bonyeza mara mbili kucheza/kukataza kutoka kwa simu ili kugeuza kusonga mbele/kurekebisha. Kusonga mbele kwenye nyimbo hushtaki kugeuzwa.",
    SETTINGS_REMOTE_SKIPPING: "Ukipinga Mbali Umeanzishwa",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Unapotumia, kuzuia kufuta kinafanya kazi hata unapowatibu Spotify kutoka kifaa kingine (k.m., simu ya mkononi)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Ukomo wa mbali umewezeshwa",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Kusuka mbali kimezimwa",
    MESSAGE_SONG_ADDED_REMOTE: "Wimbo umefukuzwa kwa mbali",
    SETTINGS_TRASH_VIA_LIKE: "Taka kupitia Kama",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Kama wimbo kutoka kwenye simu kwenda kwenye kisima. Inatondoa kama kiotomatoma na kuenda moja kwa moja kwenye wimbo ujao.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ta.json
var require_ta = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "குப்பைத் தொட்டி+",
    ACTION_THROW: "குப்பைத் தொட்டியில் போடுக",
    ACTION_UNTHROW: "குப்பைத் தொட்டியிலிருந்து நீக்கு",
    ACTION_CLEAR: "தெளிவான",
    ACTION_COPY: "நகலெடுக்கவும்",
    ACTION_EXPORT: "ஏற்றுமதி",
    ACTION_IMPORT: "இறக்குமதி",
    MESSAGE_COPIED: "கிளிப்போர்டுக்கு நகலெடுக்கப்பட்டது",
    MESSAGE_CLEARED: "நெடுவரிசை வெற்றிகரமாக அழிக்கப்பட்டது!",
    MESSAGE_SONG_ADDED: "பாடல் குப்பைத் தொட்டியில் சேர்க்கப்பட்டது",
    MESSAGE_SONG_REMOVED: "பாடல் குப்பைத் தொட்டியிலிருந்து நீக்கப்பட்டது",
    MESSAGE_ARTIST_ADDED: "கலைஞர் குப்பைத் தொட்டியில் சேர்க்கப்பட்டார்",
    MESSAGE_ARTIST_REMOVED: "கலைஞர் குப்பைத் தொட்டியிலிருந்து நீக்கப்பட்டார்",
    BACKUP_SAVE_SUCCESS: "காப்பு நிகழ்த்தி சேமிப்பு வெற்றிகரமாக முடிந்தது.",
    BACKUP_SAVE_FAILED: "காப்பு நகலைச் சேமிக்க முடியவில்லை, குப்பைத் தொட்டியின் உள்ளடக்கங்களை கிளிப்போர்டுக்கு நகலெடுத்து கையேடாக ஒரு காப்பு நகலை உருவாக்க முயற்சிக்கவும்.",
    BACKUP_RESTORE_SUCCESS: "காப்பு நிலை வெற்றிகரமாக மீட்டெடுக்கப்பட்டது.",
    BACKUP_FILE_READ_FAILED: "கோப்பைப் படிக்க முடியவில்லை, தயவுசெய்து அது செல்லுபடியான JSON கோப்பா என்பதை உறுதிப்படுத்திக் கொள்ளவும்.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "குப்பைத் தொட்டி+ அமைப்புகள்",
    SETTINGS_OPTIONS: "விருப்பங்கள்",
    SETTINGS_FEATURES: "அம்சங்கள்",
    SETTINGS_LOCAL_STORAGE: "உள்ளூர் சேமிப்பு",
    SETTINGS_ENABLED: "செயல்படுத்தப்பட்டது",
    SETTINGS_SHOW_WIDGET: "விட்ஜெட் ஐகானைக் காட்டு",
    SETTINGS_AUTOPLAY: "தொடக்கத்தில் தானியங்கி இயக்கம்",
    SETTINGS_QUEUE_TRASHBIN: "கியூ குப்பைத் தொட்டியை இயக்கு",
    SETTINGS_TRACKLIST_TRASHBIN: "டிராக்லிஸ்ட் குப்பைத் தொட்டியை இயக்கு",
    SETTINGS_PLAYLIST_MONITOR: "பிளேலிஸ்ட் கண்காணிப்பு",
    ITEMS_TITLE: "குப்பைத் தொட்டி+ பொருட்கள்",
    ITEMS_EMPTY_SONGS: "<strong>நீக்கப்பட்ட பாடல்கள் இல்லை!</strong><br/>நீங்கள் குப்பைத் தொட்டியில் சேர்த்த பாடல்கள் இங்கே தோன்றும்.",
    ITEMS_EMPTY_ARTISTS: "<strong>நீக்கப்பட்ட கலைஞர்கள் இல்லை!</strong><br/>நீங்கள் குப்பைத் தொட்டியில் சேர்த்த கலைஞர்கள் இங்கே தோன்றும்.",
    ITEMS_TAB_SONGS: "பாடல்கள்",
    ITEMS_TAB_ARTISTS: "கலைஞர்கள்",
    ITEMS_LOADED_COUNT: "{{total}} இல் {{loaded}} {{type}} ஏற்றப்பட்டது",
    DESCRIPTION_COPY: "குப்பைத் தொட்டியில் உள்ள அனைத்து உருப்படிகளையும் கிளிப்போர்டுக்கு நகலெடுக்கவும்.",
    DESCRIPTION_EXPORT: "குப்பைத் தொட்டியில் உள்ள அனைத்து பொருட்களையும் .json கோப்பில் சேமிக்கவும்.",
    DESCRIPTION_IMPORT: "குப்பைத் தொட்டியில் உள்ள அனைத்து உருப்படிகளையும் .json கோப்பு மூலம் மேலெழுதுக.",
    DESCRIPTION_CLEAR: "அழிக்கப்பட்டவை கூட்டில் உள்ள அனைத்து உருப்படிகளையும் நீக்கு (மீட்டெடுக்க முடியாது).",
    ITEMS_EMPTY_SONGS_TITLE: "நீக்கப்பட்ட பாடல்கள் இல்லை!",
    ITEMS_EMPTY_ARTISTS_TITLE: "ஒரு குப்பையான கலைஞர்களும் இல்லை!",
    DESCRIPTION_SETTINGS_ENABLED: "அனைத்து குப்பைத் தொட்டி+ செயல்பாடுகளையும் இயல்பாக்கவோ அல்லது முடக்கவோ செய்யும் முதன்மை மாற்றி",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "தற்போது இயங்கும் தடத்திற்கு அருகில் இயக்குதல் பட்டியில் குப்பை ஐகானை காட்டி, விரைவான அணுகலை வழங்குங்கள்",
    DESCRIPTION_SETTINGS_AUTOPLAY: "ஸ்பாடிபை திறக்கும்போது அல்லது நீட்டிப்பு ஏற்றப்படும்போது தானியங்கியாக இசையை இயக்கவும்",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "உங்கள் வரவிருக்கும் வரிசையில் உள்ள ஒவ்வொரு பாடலுக்கும் அருகில் குப்பைத் தொட்டி ஐகான்களைச் சேர்த்து, எளிதாக நிர்வகிக்கவும்",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "ஆல்பம் மற்றும் பிளேலிஸ்ட் காட்சிகளில் பாடல்களுக்கு அருகில் குப்பைத் தொட்டி ஐகான்களைச் சேர்த்து, விரைவான வடிகட்டலுக்காக அனுமதிக்கவும்",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "ஸ்பாடிபை இசை இடைவெளி பிழைகளிலிருந்து உங்கள் கடைசி பிளேலிஸ்ட்டை மீண்டும் தொடங்குவதன் மூலம் தானியங்கியாக மீட்டெடுக்கவும்",
    SETTINGS_SKIP_TRASHED_TRACKS: "நழுவும் தடம் செய்யப்பட்ட தடங்கள்",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "குப்பையில் போடப்பட்ட பாடல்களை தானியங்கியாக தவிர்த்து, இசைப்பதின்போது அடுத்து இசைக்க அனுமதிக்கப்பட்ட பாடலை கண்டுபிடி",
    SETTINGS_AUTO_CLEAN_QUEUE: "ஆட்டோ கிளீன் கியூ",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "உங்கள் ஸ்மார்ட் ஷஃபுல் குவியலிலிருந்து தவறான பாடல்களை தானியங்கியாக நீக்கவும்",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "அடுத்த குறுக்குவழி விசையில் குப்பை",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "அடுத்த பாடலுக்கு தாவ Ctrl+வலது கீபோர்டு குறுக்குவழியைப் பயன்படுத்தும்போது தற்போதைய பாடலை தானாகவே குப்பைத் தொட்டியில் போடு",
    SETTINGS_REMOTE_CONTROL: "தொலை கட்டுப்பாடு",
    SETTINGS_REMOTE_TOGGLE: "தொலைநிலை மாற்றுதலை இயக்கு",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "மொபைலிலிருந்து இருமுறை தட்டி இயக்கு/நிறுத்து என அமைக்கவும். ஒரு பாடலைத் தாண்டுவது மாற்றத்தை உறுதிப்படுத்தும்.",
    SETTINGS_REMOTE_SKIPPING: "தொலைநிலை தவிர்ப்பு செயலில் உள்ளது",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "இது இயக்கப்பட்டால், மற்ற சாதனத்திலிருந்து (எ.கா., மொபைல்) ஸ்பாடிஃபையைக் கட்டுப்படுத்தும்போது கூட குப்பைத் தூரம் தவிர்ப்பது செயல்படும்",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "தொலைநிலை தவிர்ப்பு இயக்கப்பட்டது",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "தொலைநிலை தவிர்ப்பு முடக்கப்பட்டது",
    MESSAGE_SONG_ADDED_REMOTE: "பாடல் தொலைதூரத்திலிருந்தே அழிக்கப்பட்டது",
    SETTINGS_TRASH_VIA_LIKE: "லைக் மூலம் குப்பை",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "மொபைலிலிருந்து ஒரு பாடலை தூக்கிப்போடுவது போல, தானாகவே லைக் நீக்கி அடுத்த பாடலுக்கு செல்கிறது.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/te.json
var require_te = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "చెత్తబుట్ట+",
    ACTION_THROW: "చెత్తబుట్టలో ఉంచండి",
    ACTION_UNTHROW: "చెత్తబుట్ట నుండి తొలగించు",
    ACTION_CLEAR: "స్పష్టంగా",
    ACTION_COPY: "కాపీ",
    ACTION_EXPORT: "ఎగుమతి",
    ACTION_IMPORT: "దిగుమతి",
    MESSAGE_COPIED: "క్లిప్‌బోర్డ్‌కు కాపీ చేయబడింది",
    MESSAGE_CLEARED: "ట్రాష్ బిన్ విజయవంతంగా క్లియర్ చేయబడింది!",
    MESSAGE_SONG_ADDED: "పాట చెత్తబుట్టలో కలిపారు",
    MESSAGE_SONG_REMOVED: "పాటను చెత్తబుట్ట నుండి తీసివేశారు",
    MESSAGE_ARTIST_ADDED: "చెత్తబుట్టలో కళాకారుడు జోడించబడ్డాడు",
    MESSAGE_ARTIST_REMOVED: "చెత్తబుట్ట నుండి కళాకారుడు తొలగించబడ్డాడు",
    BACKUP_SAVE_SUCCESS: "బ్యాకప్ విజయవంతంగా సేవ్ చేయబడింది.",
    BACKUP_SAVE_FAILED: "బ్యాకప్ నిల్వ చేయడం విఫలమైంది, త్రాష్ బిన్ కంటెంట్స్ ని క్లిప్ బోర్డుకు కాపీ చేసి బ్యాకప్ ని మాన్యువల్ గా సృష్టించడానికి ప్రయత్నించండి.",
    BACKUP_RESTORE_SUCCESS: "బ్యాకప్ విజయవంతంగా పునరుద్ధరించబడింది.",
    BACKUP_FILE_READ_FAILED: "ఫైల్ చదవడం విఫలమైంది, దయచేసి అది సరైన JSON ఫైల్ అని నిర్ధారించుకోండి.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ట్రాష్‌బిన్+ సెట్టింగ్స్",
    SETTINGS_OPTIONS: "ఎంపికలు",
    SETTINGS_FEATURES: "లక్షణాలు",
    SETTINGS_LOCAL_STORAGE: "స్థానిక నిల్వ",
    SETTINGS_ENABLED: "సక్రియం చేయబడింది",
    SETTINGS_SHOW_WIDGET: "విడ్జెట్ ఐకాన్‌ను చూపించండి",
    SETTINGS_AUTOPLAY: "ప్రారంభంలో ఆటోప్లే చేయి",
    SETTINGS_QUEUE_TRASHBIN: "క్యూ ట్రాష్‌బిన్‌ను సక్రియం చేయండి",
    SETTINGS_TRACKLIST_TRASHBIN: "ట్రాక్ లిస్ట్ చెత్తబుట్టను సక్రియం చేయండి",
    SETTINGS_PLAYLIST_MONITOR: "ప్లేలిస్ట్ మానిటర్",
    ITEMS_TITLE: "ట్రాష్‌బిన్+ అంశాలు",
    ITEMS_EMPTY_SONGS: "<strong>ఏ పాడిన పాటలు లేవు!</strong><br/>మీరు చెత్తబుట్టలో జోడించిన పాటలు ఇక్కడ కనిపిస్తాయి.",
    ITEMS_EMPTY_ARTISTS: "<strong>ఏ కార్టూన్ కళాకారులు లేరు!</strong><br/>మీరు చెత్తబుట్టలో చేర్చిన కళాకారులు ఇక్కడ కనిపిస్తారు.",
    ITEMS_TAB_SONGS: "పాటలు",
    ITEMS_TAB_ARTISTS: "కళాకారులు",
    ITEMS_LOADED_COUNT: "{{total}} లో {{loaded}} {{type}} లోడ్ అయ్యాయి",
    DESCRIPTION_COPY: "పారవేసిన అంశాల పెట్టెలోని అన్ని అంశాలను క్లిప్‌బోర్డుకు కాపీ చేయండి.",
    DESCRIPTION_EXPORT: "పారవేసిన అన్ని అంశాలను .json ఫైల్‌లో సేవ్ చేయండి.",
    DESCRIPTION_IMPORT: "ట్రాష్ బిన్ లోని అన్ని అంశాలను .json ఫైల్ ద్వారా ఓవర్ రైట్ చేయండి.",
    DESCRIPTION_CLEAR: "పాతర నుండి అన్ని అంశాలను తొలగించండి (తిరిగి చేయలేరు).",
    ITEMS_EMPTY_SONGS_TITLE: "ఏ పాటలను పాడకండి!",
    ITEMS_EMPTY_ARTISTS_TITLE: "ఏ విస్మరించబడిన కళాకారులు లేరు!",
    DESCRIPTION_SETTINGS_ENABLED: "ట్రాష్‌బిన్+ యొక్క అన్ని పనితీరును ప్రారంభించడానికి లేదా నిలిపివేయడానికి మాస్టర్ టాగుల్",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "ప్రస్తుతం ప్లే అవుతున్న ట్రాక్ పక్కన ప్లేబ్యాక్ బార్‌లో త్వరగా యాక్సెస్ కోసం చెత్త ఐకాన్‌ను చూపించండి",
    DESCRIPTION_SETTINGS_AUTOPLAY: "స్పాటిఫై తెరిచినప్పుడు లేదా ఎక్స్టెన్షన్ లోడ్ అయినప్పుడు స్వయంచాలకంగా సంగీతాన్ని ప్లే చేయడం ప్రారంభించండి",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "మీ త్వరలో ఉండే క్యూలోని ప్రతి పాటకు సమీపంలో చెత్త ఐకాన్లను జోడించండి, సులభమైన నిర్వహణ కోసం",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "ఆల్బమ్ మరియు ప్లే లిస్ట్ వీక్షణలలో పాటల పక్కన చెత్త ఐకాన్లను జోడించండి, త్వరిత ఫిల్టరింగ్ కోసం",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "మీ చివరి ప్లేలిస్ట్‌ను తిరిగి ప్రారంభించడం ద్వారా స్పాటిఫై ప్లేబ్యాక్ లోపాల నుండి స్వయంచాలకంగా పునరుద్ధరించుకోండి",
    SETTINGS_SKIP_TRASHED_TRACKS: "త్రోసిపుచ్చిన ట్రాక్‌లను తప్పించుకోండి",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "ప్లేబ్యాక్ సమయంలో తొలగించబడిన పాటలను స్వయంచాలకంగా దాటి, తదుపరి అనుమతించబడిన ట్రాక్‌ను కనుగొనండి",
    SETTINGS_AUTO_CLEAN_QUEUE: "ఆటో క్లీన్ క్యూ",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "మీ స్మార్ట్ షఫుల్ క్యూ నుండి పాడుచేసిన పాటలను స్వయంచాలకంగా తొలగించండి",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "తదుపరి హాట్‌కీపై చెత్త",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Ctrl+రైట్ కీబోర్డ్ షార్ట్‌కట్ ఉపయోగించి తదుపరి ట్రాక్‌కు దాటినప్పుడు ప్రస్తుత పాటను స్వయంచాలకంగా పారవేయండి",
    SETTINGS_REMOTE_CONTROL: "రిమోట్ కంట్రోల్",
    SETTINGS_REMOTE_TOGGLE: "రిమోట్ టాగుల్ ని సక్రియం చేయండి",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "మొబైల్ నుండి రిమోట్ స్కిప్పింగ్‌ను ఆన్/ఆఫ్ చేయడానికి ప్లే/పాజ్ కోసం రెండుసార్లు నొక్కండి. ట్రాక్ స్కిప్ టాగుల్‌ను ధృవీకరిస్తుంది.",
    SETTINGS_REMOTE_SKIPPING: "రిమోట్ స్కిప్పింగ్ సక్రియంగా ఉంది",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "సక్రియం చేసినప్పుడు, మరొక పరికరం (ఉదా: మొబైల్) నుండి స్పాటిఫైని నియంత్రించినప్పటికీ ట్రాష్-స్కిప్పింగ్ పనిచేస్తుంది",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "దూరం నుండి స్కిప్ చేయడం సక్రియం చేయబడింది",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "రిమోట్ స్కిప్పింగ్ నిలిపివేయబడింది",
    MESSAGE_SONG_ADDED_REMOTE: "రిమోట్ ద్వారా పాటను పాడాడు",
    SETTINGS_TRASH_VIA_LIKE: "లైక్ ద్వారా చెత్త",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "మొబైల్ నుండి ట్రాష్ కు ఒక పాట లాగా. స్వయంచాలకంగా డిస్లైక్ చేసి తదుపరి ట్రాక్ కు దూకుతుంది.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/th.json
var require_th = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "ถังขยะ+",
    ACTION_THROW: "วางในถังขยะ",
    ACTION_UNTHROW: "ลบออกจากถังขยะ",
    ACTION_CLEAR: "ชัดเจน",
    ACTION_COPY: "คัดลอก",
    ACTION_EXPORT: "ส่งออก",
    ACTION_IMPORT: "นำเข้า",
    MESSAGE_COPIED: "คัดลอกไปยังคลิปบอร์ดแล้ว",
    MESSAGE_CLEARED: "ล้างถังขยะเรียบร้อยแล้ว!",
    MESSAGE_SONG_ADDED: "เพลงถูกลบลงถังขยะ",
    MESSAGE_SONG_REMOVED: "ลบเพลงออกจากถังขยะแล้ว",
    MESSAGE_ARTIST_ADDED: "ศิลปินถูกเพิ่มไปยังถังขยะ",
    MESSAGE_ARTIST_REMOVED: "ศิลปินถูกลบออกจากถังขยะ",
    BACKUP_SAVE_SUCCESS: "สำรองข้อมูลเรียบร้อยแล้ว",
    BACKUP_SAVE_FAILED: "ไม่สามารถบันทึกการสำรองข้อมูลได้ โปรดลองคัดลอกเนื้อหาจากถังขยะไปยังคลิปบอร์ดแล้วสร้างการสำรองข้อมูลด้วยตนเอง",
    BACKUP_RESTORE_SUCCESS: "กู้คืนข้อมูลสำรองเรียบร้อยแล้ว",
    BACKUP_FILE_READ_FAILED: "ไม่สามารถอ่านไฟล์ได้ กรุณาตรวจสอบว่าเป็นไฟล์ JSON ที่ถูกต้อง",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "การตั้งค่า Trashbin+",
    SETTINGS_OPTIONS: "ตัวเลือก",
    SETTINGS_FEATURES: "คุณสมบัติ",
    SETTINGS_LOCAL_STORAGE: "พื้นที่จัดเก็บข้อมูลในเครื่อง",
    SETTINGS_ENABLED: "เปิดใช้งาน",
    SETTINGS_SHOW_WIDGET: "แสดงไอคอนวิดเจ็ต",
    SETTINGS_AUTOPLAY: "เปิดใช้งานการเล่นอัตโนมัติเมื่อเริ่มต้น",
    SETTINGS_QUEUE_TRASHBIN: "เปิดใช้งานถังขยะของคิว",
    SETTINGS_TRACKLIST_TRASHBIN: "เปิดใช้งานถังขยะรายการแทร็ก",
    SETTINGS_PLAYLIST_MONITOR: "ตัวตรวจสอบเพลย์ลิสต์",
    ITEMS_TITLE: "รายการถังขยะ+",
    ITEMS_EMPTY_SONGS: "<strong>ไม่มีเพลงที่ถังขยะ!</strong><br/>เพลงที่คุณเพิ่มไปยังถังขยะจะแสดงที่นี่",
    ITEMS_EMPTY_ARTISTS: "<strong>ไม่มีศิลปินที่ถูกลบ!</strong><br/>ศิลปินที่คุณเพิ่มไปยังถังขยะจะแสดงที่นี่",
    ITEMS_TAB_SONGS: "เพลง",
    ITEMS_TAB_ARTISTS: "ศิลปิน",
    ITEMS_LOADED_COUNT: "โหลดแล้ว {{loaded}} จากทั้งหมด {{total}} {{type}}",
    DESCRIPTION_COPY: "คัดลอกรายการทั้งหมดในถังขยะไปยังคลิปบอร์ด",
    DESCRIPTION_EXPORT: "บันทึกรายการทั้งหมดในถังขยะเป็นไฟล์ .json",
    DESCRIPTION_IMPORT: "เขียนทับรายการทั้งหมดในถังขยะผ่านไฟล์ .json",
    DESCRIPTION_CLEAR: "ลบทุกรายการออกจากถังขยะ (ไม่สามารถย้อนกลับได้)",
    ITEMS_EMPTY_SONGS_TITLE: "ไม่มีเพลงที่ถูกลบ!",
    ITEMS_EMPTY_ARTISTS_TITLE: "ไม่มีศิลปินที่ไร้ค่า!",
    DESCRIPTION_SETTINGS_ENABLED: "ตัวสลับหลักเพื่อเปิดหรือปิดการใช้งานฟังก์ชันทั้งหมดของ Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "แสดงไอคอนถังขยะในแถบการเล่นถัดจากแทร็กที่กำลังเล่นอยู่เพื่อเข้าถึงอย่างรวดเร็ว",
    DESCRIPTION_SETTINGS_AUTOPLAY: "เริ่มเล่นเพลงโดยอัตโนมัติเมื่อเปิด Spotify หรือเมื่อส่วนขยายโหลดเสร็จ",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "เพิ่มไอคอนถังขยะถัดจากแต่ละเพลงในคิวที่กำลังจะเล่นของคุณเพื่อการจัดการที่ง่ายขึ้น",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "เพิ่มไอคอนถังขยะถัดจากเพลงในมุมมองอัลบั้มและเพลย์ลิสต์เพื่อการกรองอย่างรวดเร็ว",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "กู้คืนอัตโนมัติจากปัญหาการเล่นเพลงบน Spotify โดยการกลับมาเล่นเพลย์ลิสต์ล่าสุดของคุณอีกครั้ง",
    SETTINGS_SKIP_TRASHED_TRACKS: "ข้ามแทร็กที่ถูกลบ",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "ข้ามเพลงที่ถูกลบโดยอัตโนมัติ และค้นหาแทร็กถัดไปที่อนุญาตระหว่างการเล่น",
    SETTINGS_AUTO_CLEAN_QUEUE: "คิวทำความสะอาดอัตโนมัติ",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "ลบเพลงที่ถูกลบแล้วออกจากคิวสุ่มอัจฉริยะของคุณโดยอัตโนมัติ",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "ขยะในปุ่มลัดถัดไป",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "ลบเพลงปัจจุบันโดยอัตโนมัติเมื่อใช้แป้นพิมพ์ลัด Ctrl+ขวา เพื่อข้ามไปยังแทร็กถัดไป",
    SETTINGS_REMOTE_CONTROL: "รีโมทคอนโทรล",
    SETTINGS_REMOTE_TOGGLE: "เปิดใช้งานการสลับระยะไกล",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "แตะที่ปุ่มเล่น/หยุดสองครั้งจากมือถือเพื่อเปิดหรือปิดการข้ามแทร็กจากระยะไกล การข้ามแทร็กหนึ่งครั้งจะยืนยันการตั้งค่านี้",
    SETTINGS_REMOTE_SKIPPING: "การข้ามระยะไกลใช้งานอยู่",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "เมื่อเปิดใช้งาน ฟีเจอร์ข้ามถังขยะจะทำงานแม้คุณกำลังควบคุม Spotify จากอุปกรณ์อื่น (เช่น มือถือ)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "เปิดใช้งานการข้ามระยะไกลแล้ว",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "ปิดการข้ามระยะไกลแล้ว",
    MESSAGE_SONG_ADDED_REMOTE: "เพลงถูกลบผ่านระยะไกล",
    SETTINGS_TRASH_VIA_LIKE: "ขยะผ่านไลค์",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "เหมือนเพลงจากมือถือไปยังถังขยะ มันจะยกเลิกการถูกใจและข้ามไปยังแทร็กถัดไปโดยอัตโนมัติ",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/tr.json
var require_tr = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Çöp Kutusu+",
    ACTION_THROW: "Çöp kutusuna yerleştir",
    ACTION_UNTHROW: "Çöp Kutusundan Kaldır",
    ACTION_CLEAR: "Açık",
    ACTION_COPY: "Kopyala",
    ACTION_EXPORT: "Dışa aktar",
    ACTION_IMPORT: "İçe aktar",
    MESSAGE_COPIED: "Panoya kopyalandı",
    MESSAGE_CLEARED: "Çöp kutusu başarıyla temizlendi!",
    MESSAGE_SONG_ADDED: "Şarkı çöp kutusuna eklendi",
    MESSAGE_SONG_REMOVED: "Şarkı çöp kutusundan kaldırıldı",
    MESSAGE_ARTIST_ADDED: "Sanatçı çöp kutusuna eklendi",
    MESSAGE_ARTIST_REMOVED: "Sanatçı çöp kutusundan kaldırıldı",
    BACKUP_SAVE_SUCCESS: "Yedek başarıyla kaydedildi.",
    BACKUP_SAVE_FAILED: "Yedek kaydedilemedi, çöp kutusu içeriğini panoya kopyalamayı ve yedeği elle oluşturmayı deneyin.",
    BACKUP_RESTORE_SUCCESS: "Yedek başarıyla geri yüklendi.",
    BACKUP_FILE_READ_FAILED: "Dosya okunamadı, lütfen geçerli bir JSON dosyası olduğundan emin olun.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Çöp Kutusu+ Ayarları",
    SETTINGS_OPTIONS: "Seçenekler",
    SETTINGS_FEATURES: "Özellikler",
    SETTINGS_LOCAL_STORAGE: "Yerel Depolama",
    SETTINGS_ENABLED: "Etkinleştirildi",
    SETTINGS_SHOW_WIDGET: "Widget Simgesini Göster",
    SETTINGS_AUTOPLAY: "Başlangıçta Otomatik Oynatma",
    SETTINGS_QUEUE_TRASHBIN: "Kuyruk Çöp Kutusunu Etkinleştir",
    SETTINGS_TRACKLIST_TRASHBIN: "Parça Listesi Çöp Kutusunu Etkinleştir",
    SETTINGS_PLAYLIST_MONITOR: "Oynatma Listesi İzleyici",
    ITEMS_TITLE: "Çöp Kutusu+ Öğeleri",
    ITEMS_EMPTY_SONGS: "<strong>Çöpe atılmış şarkı yok!</strong><br/>Çöp kutusuna eklediğiniz şarkılar burada görünecek.",
    ITEMS_EMPTY_ARTISTS: "<strong>Çöpe atılmış sanatçı yok!</strong><br/>Çöp kutusuna eklediğiniz sanatçılar burada görünecek.",
    ITEMS_TAB_SONGS: "Şarkılar",
    ITEMS_TAB_ARTISTS: "Sanatçılar",
    ITEMS_LOADED_COUNT: "Yüklenen {{loaded}} / {{total}} {{type}}",
    DESCRIPTION_COPY: "Çöp kutusundaki tüm öğeleri panoya kopyala.",
    DESCRIPTION_EXPORT: "Çöp kutusundaki tüm öğeleri bir .json dosyasına kaydedin.",
    DESCRIPTION_IMPORT: "Çöp kutusundaki tüm öğeleri .json dosyası ile değiştirin.",
    DESCRIPTION_CLEAR: "Çöp kutusundaki tüm öğeleri sil (geri alınamaz).",
    ITEMS_EMPTY_SONGS_TITLE: "Hiçbir şarkı çöpe atılmadı!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Hiçbir sanatçıyı çöpe atmayın!",
    DESCRIPTION_SETTINGS_ENABLED: "Tüm Çöp Kutusu+ işlevselliğini etkinleştirmek veya devre dışı bırakmak için ana anahtar",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Çalınan parça yanında hızlı erişim için oynatma çubuğunda bir çöp ikonu görüntüleyin",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Spotify açıldığında veya eklenti yüklendiğinde otomatik olarak müzik çalmaya başlayın",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Sıradaki çalma listesindeki her şarkıya kolay yönetim için çöp ikonları ekleyin",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Albüm ve çalma listesi görünümlerinde hızlı filtreleme için şarkıların yanına çöp ikonları ekleyin",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Spotify oynatma hatalarından son oynatma listenizi devam ettirerek otomatik olarak kurtulun",
    SETTINGS_SKIP_TRASHED_TRACKS: "Çöpe Atılan Parçaları Atla",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Oynatma sırasında çöpe atılan şarkıları otomatik olarak atlayarak bir sonraki izin verilen parçayı bulun",
    SETTINGS_AUTO_CLEAN_QUEUE: "Otomatik Temizleme Sırası",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Çöpe atılmış şarkıları Akıllı Karışık Kuyruğunuzdan otomatik olarak kaldırın",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Bir Sonraki Hızlı Erişim Tuşuyla Çöp",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Bir sonraki parçaya geçmek için Ctrl+Sağ klavye kısayolunu kullandığınızda geçerli şarkıyı otomatik olarak çöpe at",
    SETTINGS_REMOTE_CONTROL: "Uzaktan kumanda",
    SETTINGS_REMOTE_TOGGLE: "Uzaktan Geçişi Etkinleştir",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Mobil cihazdan oynat/duraklat için iki kez dokunarak uzaktan atlama özelliğini aç/kapat. Bir parça atlaması, geçişi onaylar.",
    SETTINGS_REMOTE_SKIPPING: "Uzaktan Atlatma Etkin",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Etkinleştirildiğinde çöp kutusu atlaması, Spotify'ı başka bir cihazdan (örneğin mobil) kontrol ederken bile çalışır",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Uzaktan atlama etkinleştirildi",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Uzaktan atlama devre dışı",
    MESSAGE_SONG_ADDED_REMOTE: "Şarkı uzaktan yok edildi",
    SETTINGS_TRASH_VIA_LIKE: "Like ile çöp",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Bir şarkı gibi cep telefonundan çöpe atar. Otomatik olarak beğenisini kaldırır ve bir sonraki parçaya geçer.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/uk.json
var require_uk = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Смітник+",
    ACTION_THROW: "Помістити в кошик для сміття",
    ACTION_UNTHROW: "Видалити з кошика",
    ACTION_CLEAR: "Чітко",
    ACTION_COPY: "Копіювати",
    ACTION_EXPORT: "Експорт",
    ACTION_IMPORT: "Імпорт",
    MESSAGE_COPIED: "Скопійовано в буфер обміну",
    MESSAGE_CLEARED: "Смітник успішно очищено!",
    MESSAGE_SONG_ADDED: "Пісню додано до кошика для сміття",
    MESSAGE_SONG_REMOVED: "Пісню видалено з кошика",
    MESSAGE_ARTIST_ADDED: "Художника додано до кошика для сміття",
    MESSAGE_ARTIST_REMOVED: "Художника видалено з кошика для сміття",
    BACKUP_SAVE_SUCCESS: "Резервну копію успішно збережено.",
    BACKUP_SAVE_FAILED: "Не вдалося зберегти резервну копію, спробуйте скопіювати вміст кошика у буфер обміну та створити резервну копію вручну.",
    BACKUP_RESTORE_SUCCESS: "Резервну копію успішно відновлено.",
    BACKUP_FILE_READ_FAILED: "Не вдалося прочитати файл, переконайтеся, що це дійсний файл JSON.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Налаштування кошика+",
    SETTINGS_OPTIONS: "Параметри",
    SETTINGS_FEATURES: "Особливості",
    SETTINGS_LOCAL_STORAGE: "Локальне сховище",
    SETTINGS_ENABLED: "Увімкнено",
    SETTINGS_SHOW_WIDGET: "Показати піктограму віджета",
    SETTINGS_AUTOPLAY: "Автоматичний запуск при старті",
    SETTINGS_QUEUE_TRASHBIN: "Увімкнути чергу кошика для сміття",
    SETTINGS_TRACKLIST_TRASHBIN: "Увімкнути кошик для трек-листа",
    SETTINGS_PLAYLIST_MONITOR: "Монітор плейлистів",
    ITEMS_TITLE: "Предмети смітника+",
    ITEMS_EMPTY_SONGS: "<strong>Немає видалених пісень!</strong><br/>Пісні, які ви додаєте у кошик для сміття, з’являться тут.",
    ITEMS_EMPTY_ARTISTS: "<strong>Немає вилучених виконавців!</strong><br/>Виконавці, яких ви додали до кошика, з’являться тут.",
    ITEMS_TAB_SONGS: "Пісні",
    ITEMS_TAB_ARTISTS: "Художники",
    ITEMS_LOADED_COUNT: "Завантажено {{loaded}} із {{total}} {{type}}",
    DESCRIPTION_COPY: "Копіювати всі елементи у кошику в буфер обміну.",
    DESCRIPTION_EXPORT: "Зберегти всі елементи в кошику у файл .json.",
    DESCRIPTION_IMPORT: "Перезаписати всі елементи в кошику за допомогою файлу .json.",
    DESCRIPTION_CLEAR: "Очистити всі елементи з кошика (не можна скасувати).",
    ITEMS_EMPTY_SONGS_TITLE: "Жодних вилучених пісень!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Жодного викинутого артиста!",
    DESCRIPTION_SETTINGS_ENABLED: "Головний перемикач для ввімкнення або вимкнення всієї функціональності смітника+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Показувати значок кошика на панелі відтворення поруч із поточним треком для швидкого доступу",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Автоматичне відтворення музики під час відкриття Spotify або завантаження розширення",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Додайте піктограми смітника поруч із кожною піснею у вашому майбутньому черзі для легкого управління",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Додайте піктограми смітника біля пісень у перегляді альбомів і плейлистів для швидкого фільтрування",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Автоматичне відновлення після збоїв відтворення в Spotify шляхом відновлення останнього плейлиста",
    SETTINGS_SKIP_TRASHED_TRACKS: "Пропустити видалені треки",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Автоматично пропускати видалені пісні та знаходити наступний доступний трек під час відтворення",
    SETTINGS_AUTO_CLEAN_QUEUE: "Черга автоматичного очищення",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Автоматично видаляти видалені пісні з черги розумного перемішування",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Сміття на наступному гарячому клавіші",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Автоматично видаляти поточну пісню, коли використовується комбінація клавіш Ctrl+Right для переходу до наступного треку",
    SETTINGS_REMOTE_CONTROL: "Пульт дистанційного керування",
    SETTINGS_REMOTE_TOGGLE: "Увімкнути віддалене перемикання",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Двічі торкніться кнопки відтворення/паузи на мобільному пристрої, щоб увімкнути або вимкнути дистанційне перемотування. Пропуск треку підтверджує перемикання.",
    SETTINGS_REMOTE_SKIPPING: "Пропуск на відстані активний",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Коли ця функція увімкнена, пропуск треків працює навіть при керуванні Spotify з іншого пристрою (наприклад, мобільного)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Увімкнено віддалене пропускання",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Віддалене пропускання вимкнено",
    MESSAGE_SONG_ADDED_REMOTE: "Пісню видалено на відстані",
    SETTINGS_TRASH_VIA_LIKE: "Сміття через Лайк",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Як пісню з мобільного до смітника. Автоматично відміняє вподобання та переходить до наступної композиції.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/ur.json
var require_ur = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "کوڑا دان+",
    ACTION_THROW: "کوڑے دان میں ڈالیں",
    ACTION_UNTHROW: "کوڑے دان سے ہٹائیں",
    ACTION_CLEAR: "صاف",
    ACTION_COPY: "نقل کریں",
    ACTION_EXPORT: "برآمد کریں",
    ACTION_IMPORT: "درآمد",
    MESSAGE_COPIED: "کاپی کلپ بورڈ پر کر دی گئی",
    MESSAGE_CLEARED: "کوڑا دان کامیابی سے خالی کر دیا گیا!",
    MESSAGE_SONG_ADDED: "گانا کوڑے دان میں شامل کر دیا گیا",
    MESSAGE_SONG_REMOVED: "گانا کو صفائی کے ڈبے سے ہٹا دیا گیا",
    MESSAGE_ARTIST_ADDED: "آرٹسٹ کو کوڑے دان میں شامل کیا گیا",
    MESSAGE_ARTIST_REMOVED: "آرٹسٹ کو کوڑے دان سے ہٹا دیا گیا",
    BACKUP_SAVE_SUCCESS: "بیک اپ کامیابی سے محفوظ ہو گیا۔",
    BACKUP_SAVE_FAILED: "بیک اپ محفوظ کرنے میں ناکامی، کچرے کے ڈبے کی معلومات کو کلپ بورڈ پر کاپی کرنے اور دستی طور پر بیک اپ بنانے کی کوشش کریں۔",
    BACKUP_RESTORE_SUCCESS: "بیک اپ کامیابی سے بحال کر دیا گیا۔",
    BACKUP_FILE_READ_FAILED: "فائل پڑھنے میں ناکام، براہ کرم یقینی بنائیں کہ یہ ایک درست JSON فائل ہے۔",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "ٹریش بین + سیٹنگز",
    SETTINGS_OPTIONS: "اختیارات",
    SETTINGS_FEATURES: "خصوصیات",
    SETTINGS_LOCAL_STORAGE: "مقامی اسٹوریج",
    SETTINGS_ENABLED: "فعال",
    SETTINGS_SHOW_WIDGET: "وِجیٹ آئیکن دکھائیں",
    SETTINGS_AUTOPLAY: "شروع میں خودکار چلائیں",
    SETTINGS_QUEUE_TRASHBIN: "کیو ٹریش بین کو فعال کریں",
    SETTINGS_TRACKLIST_TRASHBIN: "ٹریکلسٹ کوڑا دان کو فعال کریں",
    SETTINGS_PLAYLIST_MONITOR: "پلے لسٹ مانیٹر",
    ITEMS_TITLE: "ٹریش بین + اشیاء",
    ITEMS_EMPTY_SONGS: "<strong>کوئی حذف شدہ گانے نہیں!</strong><br/>جتنے گانے آپ ریسی وین میں ڈالیں گے وہ یہاں ظاہر ہوں گے۔",
    ITEMS_EMPTY_ARTISTS: "<strong>کوئی فنکار کوڑے دان میں نہیں!</strong><br/>فنکار جنہیں آپ کوڑے دان میں شامل کریں گے وہ یہاں ظاہر ہوں گے۔",
    ITEMS_TAB_SONGS: "گانے",
    ITEMS_TAB_ARTISTS: "فنکار",
    ITEMS_LOADED_COUNT: "{{total}} میں سے {{loaded}} {{type}} لوڈ ہو چکا ہے",
    DESCRIPTION_COPY: "کوڑے دان میں تمام اشیاء کو کلپ بورڈ پر کاپی کریں۔",
    DESCRIPTION_EXPORT: "تمام اشیاء کو کوڑے دان میں ایک .json فائل میں محفوظ کریں۔",
    DESCRIPTION_IMPORT: "کچرے کے ڈبے میں تمام اشیاء کو .json فائل کے ذریعے اوور رائٹ کریں۔",
    DESCRIPTION_CLEAR: "کچرے کے ڈبے سے تمام اشیاء کو صاف کریں (واپس نہیں کیا جا سکتا)۔",
    ITEMS_EMPTY_SONGS_TITLE: "کوئی حذف شدہ گانے نہیں!",
    ITEMS_EMPTY_ARTISTS_TITLE: "کوئی تباہ شدہ فنکار نہیں!",
    DESCRIPTION_SETTINGS_ENABLED: "تمام ٹریش بین + فعالیت کو چالو یا بند کرنے کے لیے ماسٹر ٹوگل",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "موجودہ چل رہے ٹریک کے قریب پلے بیک بار میں تیزی سے رسائی کے لیے ایک کوڑا دان کا آئیکن ظاہر کریں",
    DESCRIPTION_SETTINGS_AUTOPLAY: "جب سپاٹیفائی کھلتا ہے یا ایکسٹینشن لوڈ ہوتا ہے تو خود بخود موسیقی چلانا شروع کریں",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "اپنی آنے والی قطار میں ہر گانے کے ساتھ کوڑا دان کے آئیکن شامل کریں تاکہ آسانی سے انتظام ہو سکے",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "البم اور پلے لسٹ کے مناظر میں گانوں کے قریب کوڑا کرکٹ کے آئیکن شامل کریں تاکہ تیزی سے فلٹر کیا جا سکے",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "اسپاٹی فائی کی چلانے میں آنے والی خرابیوں سے خودکار طور پر اپنی آخری پلے لسٹ دوبارہ چلا کر بحال ہو جائیں",
    SETTINGS_SKIP_TRASHED_TRACKS: "کھوئے ہوئے ٹریکس کو چھوڑ دیں",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "خود بخود ڈسکارڈ کیے گئے گانوں کو چھوڑ دیں اور چلانے کے دوران اگلا منظور شدہ ٹریک تلاش کریں",
    SETTINGS_AUTO_CLEAN_QUEUE: "خودکار صفائی کی قطار",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "اپنی اسمارٹ شفل کی قطار سے خودکار طور پر ڈسکارڈ کیے گئے گانے ہٹا دیں",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "اگلی ہاٹ کی پر کوڑا کرکٹ",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "موجودہ گانا خود بخود ٹریش کریں جب اگلے ٹریک پر جانے کے لیے Ctrl+Right کی بورڈ شارٹ کٹ استعمال کی جائے",
    SETTINGS_REMOTE_CONTROL: "دور دراز کنٹرول",
    SETTINGS_REMOTE_TOGGLE: "دور دراز کنٹرول کے لیے ٹوگل آن کریں",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "موبائل سے پلے/روک تھام کے لیے ڈبل ٹیپ کریں تاکہ دور دراز کی چھلانگ کو آن/آف کیا جا سکے۔ ٹریک چھلانگ تبدیلی کی تصدیق کرتی ہے۔",
    SETTINGS_REMOTE_SKIPPING: "دور دراز مقام سے سکیپ کرنا فعال ہے",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "جب چالو ہو، تو ٹریش کو چھوڑنا دوسرے ڈیوائس (مثلاً موبائل) سے سپاٹیفائی کو کنٹرول کرتے وقت بھی کام کرتا ہے۔",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "دور دراز سے چھلانگ لگانا فعال ہے",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "دور دراز کا اسکیپ کرنا غیر فعال ہے",
    MESSAGE_SONG_ADDED_REMOTE: "گانا دور دراز کے ذریعے تباہ کر دیا گیا",
    SETTINGS_TRASH_VIA_LIKE: "لائک کے ذریعے کوڑا کرکٹ",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "موبائل سے تراش کی طرح ایک گانا۔ خود بخود ناپسند کرتا ہے اور اگلے ٹریک پر جا تا ہے۔",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/vi.json
var require_vi = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Thùng rác+",
    ACTION_THROW: "Đặt vào thùng rác",
    ACTION_UNTHROW: "Xóa khỏi Thùng rác",
    ACTION_CLEAR: "Rõ ràng",
    ACTION_COPY: "Sao chép",
    ACTION_EXPORT: "Xuất khẩu",
    ACTION_IMPORT: "Nhập khẩu",
    MESSAGE_COPIED: "Đã sao chép vào bộ nhớ tạm",
    MESSAGE_CLEARED: "Đã xóa thùng rác thành công!",
    MESSAGE_SONG_ADDED: "Bài hát đã được thêm vào thùng rác",
    MESSAGE_SONG_REMOVED: "Bài hát đã được xóa khỏi thùng rác",
    MESSAGE_ARTIST_ADDED: "Họa sĩ đã được thêm vào thùng rác",
    MESSAGE_ARTIST_REMOVED: "Nghệ sĩ đã bị xóa khỏi thùng rác",
    BACKUP_SAVE_SUCCESS: "Sao lưu đã được lưu thành công.",
    BACKUP_SAVE_FAILED: "Không thể lưu bản sao lưu, hãy thử sao chép nội dung thùng rác vào bộ nhớ tạm và tạo bản sao lưu thủ công.",
    BACKUP_RESTORE_SUCCESS: "Sao lưu đã được khôi phục thành công.",
    BACKUP_FILE_READ_FAILED: "Không thể đọc tệp, vui lòng đảm bảo rằng đây là tệp JSON hợp lệ.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Cài đặt Trashbin+",
    SETTINGS_OPTIONS: "Tùy chọn",
    SETTINGS_FEATURES: "Tính năng",
    SETTINGS_LOCAL_STORAGE: "Lưu trữ cục bộ",
    SETTINGS_ENABLED: "Đã bật",
    SETTINGS_SHOW_WIDGET: "Hiển thị biểu tượng tiện ích",
    SETTINGS_AUTOPLAY: "Tự động phát khi khởi động",
    SETTINGS_QUEUE_TRASHBIN: "Bật thùng rác hàng đợi",
    SETTINGS_TRACKLIST_TRASHBIN: "Bật thùng rác danh sách phát",
    SETTINGS_PLAYLIST_MONITOR: "Trình theo dõi danh sách phát",
    ITEMS_TITLE: "Các mục Thùng rác+",
    ITEMS_EMPTY_SONGS: "<strong>Không có bài hát nào bị xóa!</strong><br/>Các bài hát bạn thêm vào thùng rác sẽ hiển thị ở đây.",
    ITEMS_EMPTY_ARTISTS: "<strong>Không có nghệ sĩ nào bị xóa!</strong><br/>Các nghệ sĩ bạn thêm vào thùng rác sẽ hiển thị ở đây.",
    ITEMS_TAB_SONGS: "Bài hát",
    ITEMS_TAB_ARTISTS: "Nghệ sĩ",
    ITEMS_LOADED_COUNT: "{{loaded}} trong số {{total}} {{type}} đã được tải",
    DESCRIPTION_COPY: "Sao chép tất cả các mục trong thùng rác vào bộ nhớ tạm.",
    DESCRIPTION_EXPORT: "Lưu tất cả các mục trong thùng rác vào một tệp .json.",
    DESCRIPTION_IMPORT: "Ghi đè tất cả các mục trong thùng rác thông qua tệp .json.",
    DESCRIPTION_CLEAR: "Xóa tất cả mục khỏi thùng rác (không thể hoàn tác).",
    ITEMS_EMPTY_SONGS_TITLE: "Không có bài hát nào bị xóa!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Không có nghệ sĩ nào bị xóa!",
    DESCRIPTION_SETTINGS_ENABLED: "Công tắc chính để bật hoặc tắt mọi chức năng của Trashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Hiển thị biểu tượng thùng rác trên thanh phát nhạc, bên cạnh bản nhạc đang phát để truy cập nhanh",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Tự động phát nhạc khi Spotify mở hoặc tiện ích được tải",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Thêm biểu tượng thùng rác bên cạnh mỗi bài hát trong hàng đợi sắp tới của bạn để dễ quản lý",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Thêm biểu tượng thùng rác bên cạnh các bài hát trong chế độ xem album và danh sách phát để lọc nhanh",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Tự động khôi phục khi xảy ra lỗi phát nhạc trên Spotify bằng cách tiếp tục phát lại danh sách phát gần nhất của bạn",
    SETTINGS_SKIP_TRASHED_TRACKS: "Bỏ qua các bản nhạc đã xóa",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Tự động bỏ qua các bài hát đã xóa và tìm bài hát tiếp theo được phép phát trong quá trình phát nhạc",
    SETTINGS_AUTO_CLEAN_QUEUE: "Hàng đợi làm sạch tự động",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Tự động xóa các bài hát đã xóa khỏi hàng đợi Smart Shuffle của bạn",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Rác trên phím tắt tiếp theo",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Tự động xóa bài hát hiện tại khi sử dụng phím tắt Ctrl+Phải để chuyển sang bài tiếp theo",
    SETTINGS_REMOTE_CONTROL: "Điều khiển từ xa",
    SETTINGS_REMOTE_TOGGLE: "Bật tắt từ xa",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Nhấn đúp nút phát/tạm dừng trên thiết bị di động để bật/tắt tính năng bỏ qua từ xa. Việc bỏ qua một bản nhạc sẽ xác nhận thao tác bật/tắt.",
    SETTINGS_REMOTE_SKIPPING: "Bỏ qua từ xa đang hoạt động",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Khi được bật, chức năng bỏ qua bài hát trong thùng rác vẫn hoạt động ngay cả khi điều khiển Spotify từ thiết bị khác (ví dụ: điện thoại di động)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Đã bật bỏ qua từ xa",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Đã tắt bỏ qua từ xa",
    MESSAGE_SONG_ADDED_REMOTE: "Bài hát bị xóa từ xa",
    SETTINGS_TRASH_VIA_LIKE: "Rác qua Thích",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Giống như một bài hát từ điện thoại di động chuyển vào thùng rác. Tự động bỏ thích và chuyển sang bài tiếp theo.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/zh-CN.json
var require_zh_CN = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "垃圾桶+",
    ACTION_THROW: "放入回收站",
    ACTION_UNTHROW: "从回收站中移除",
    ACTION_CLEAR: "清晰",
    ACTION_COPY: "复制",
    ACTION_EXPORT: "导出",
    ACTION_IMPORT: "导入",
    MESSAGE_COPIED: "已复制到剪贴板",
    MESSAGE_CLEARED: "垃圾桶已成功清空！",
    MESSAGE_SONG_ADDED: "歌曲已添加到回收站",
    MESSAGE_SONG_REMOVED: "歌曲已从回收站移除",
    MESSAGE_ARTIST_ADDED: "艺术家已添加到回收站",
    MESSAGE_ARTIST_REMOVED: "艺术家已从回收站移除",
    BACKUP_SAVE_SUCCESS: "备份保存成功。",
    BACKUP_SAVE_FAILED: "备份保存失败，请尝试将回收站内容复制到剪贴板并手动创建备份。",
    BACKUP_RESTORE_SUCCESS: "备份恢复成功。",
    BACKUP_FILE_READ_FAILED: "读取文件失败，请确保它是一个有效的JSON文件。",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "垃圾桶+ 设置",
    SETTINGS_OPTIONS: "选项",
    SETTINGS_FEATURES: "功能",
    SETTINGS_LOCAL_STORAGE: "本地存储",
    SETTINGS_ENABLED: "已启用",
    SETTINGS_SHOW_WIDGET: "显示小部件图标",
    SETTINGS_AUTOPLAY: "启动时自动播放",
    SETTINGS_QUEUE_TRASHBIN: "启用队列回收站",
    SETTINGS_TRACKLIST_TRASHBIN: "启用曲目列表回收站",
    SETTINGS_PLAYLIST_MONITOR: "播放列表监控",
    ITEMS_TITLE: "回收站+ 项目",
    ITEMS_EMPTY_SONGS: "<strong>没有已删除的歌曲！</strong><br/>您添加到回收站的歌曲将显示在此处。",
    ITEMS_EMPTY_ARTISTS: "<strong>没有已删除的艺术家！</strong><br/>您添加到回收站的艺术家将显示在这里。",
    ITEMS_TAB_SONGS: "歌曲",
    ITEMS_TAB_ARTISTS: "艺术家",
    ITEMS_LOADED_COUNT: "已加载 {{loaded}} / {{total}} 个 {{type}}",
    DESCRIPTION_COPY: "将回收站中的所有项目复制到剪贴板。",
    DESCRIPTION_EXPORT: "将回收站中的所有项目保存到 .json 文件中。",
    DESCRIPTION_IMPORT: "通过.json文件覆盖回收站中的所有项目。",
    DESCRIPTION_CLEAR: "清空回收站中的所有项目（无法恢复）。",
    ITEMS_EMPTY_SONGS_TITLE: "没有已删除的歌曲！",
    ITEMS_EMPTY_ARTISTS_TITLE: "没有被贬低的艺术家！",
    DESCRIPTION_SETTINGS_ENABLED: "主开关，用于启用或禁用所有回收站+功能",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "在播放栏中当前播放曲目的旁边显示一个垃圾桶图标，以便快速访问",
    DESCRIPTION_SETTINGS_AUTOPLAY: "当 Spotify 打开或扩展程序加载时自动开始播放音乐",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "在即将播放的队列中，为每首歌曲添加垃圾箱图标，以便轻松管理",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "在专辑和播放列表视图中的歌曲旁添加垃圾桶图标，以便快速筛选",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "通过恢复上一个播放列表，自动修复 Spotify 播放故障",
    SETTINGS_SKIP_TRASHED_TRACKS: "跳过已删除的曲目",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "自动跳过已删除的歌曲，并在播放期间找到下一个允许播放的曲目",
    SETTINGS_AUTO_CLEAN_QUEUE: "自动清理队列",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "自动从智能随机播放队列中移除已删除的歌曲",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "下一个快捷键清空回收站",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "使用 Ctrl+右箭头键盘快捷键跳到下一首时，自动将当前歌曲移至回收站",
    SETTINGS_REMOTE_CONTROL: "遥控器",
    SETTINGS_REMOTE_TOGGLE: "启用远程切换",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "从手机上双击播放/暂停以切换远程跳过功能的开启/关闭。跳过一首歌曲即可确认切换状态。",
    SETTINGS_REMOTE_SKIPPING: "远程跳过已激活",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "启用后，即使从其他设备（例如手机）控制 Spotify，跳过垃圾功能仍然有效",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "已启用远程跳过",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "已禁用远程跳过",
    MESSAGE_SONG_ADDED_REMOTE: "歌曲被远程删除",
    SETTINGS_TRASH_VIA_LIKE: "通过点赞清理垃圾",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "就像一首从手机传到垃圾桶的歌。自动取消喜欢并跳到下一首。",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/zh-HK.json
var require_zh_HK = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "垃圾桶+",
    ACTION_THROW: "放入垃圾桶",
    ACTION_UNTHROW: "從垃圾桶移除",
    ACTION_CLEAR: "清除",
    ACTION_COPY: "複製",
    ACTION_EXPORT: "匯出",
    ACTION_IMPORT: "匯入",
    MESSAGE_COPIED: "已複製到剪貼簿",
    MESSAGE_CLEARED: "垃圾桶已成功清空！",
    MESSAGE_SONG_ADDED: "歌曲已加入垃圾桶",
    MESSAGE_SONG_REMOVED: "歌曲已從垃圾桶移除",
    MESSAGE_ARTIST_ADDED: "藝術家已加入垃圾桶",
    MESSAGE_ARTIST_REMOVED: "藝術家已從垃圾桶中移除",
    BACKUP_SAVE_SUCCESS: "備份已成功儲存。",
    BACKUP_SAVE_FAILED: "未能儲存備份，請嘗試將垃圾桶內容複製到剪貼簿並手動建立備份。",
    BACKUP_RESTORE_SUCCESS: "備份已成功還原。",
    BACKUP_FILE_READ_FAILED: "無法讀取檔案，請確保它是一個有效的 JSON 檔案。",
    BACKUP_SUGGESTED_FILENAME: "spicetify-垃圾桶.json",
    SETTINGS_TITLE: "垃圾桶+ 設定",
    SETTINGS_OPTIONS: "選項",
    SETTINGS_FEATURES: "功能",
    SETTINGS_LOCAL_STORAGE: "本地儲存",
    SETTINGS_ENABLED: "已啟用",
    SETTINGS_SHOW_WIDGET: "顯示小工具圖示",
    SETTINGS_AUTOPLAY: "啟動時自動播放",
    SETTINGS_QUEUE_TRASHBIN: "啟用佇列回收箱",
    SETTINGS_TRACKLIST_TRASHBIN: "啟用播放清單回收筒",
    SETTINGS_PLAYLIST_MONITOR: "播放清單監控",
    ITEMS_TITLE: "垃圾筒+ 項目",
    ITEMS_EMPTY_SONGS: "<strong>沒有已刪除的歌曲！</strong><br/>你加入垃圾桶的歌曲將會出現在這裡。",
    ITEMS_EMPTY_ARTISTS: "<strong>沒有已刪除的藝術家！</strong><br/>你加入回收箱的藝術家將會出現在這裡。",
    ITEMS_TAB_SONGS: "歌曲",
    ITEMS_TAB_ARTISTS: "藝術家",
    ITEMS_LOADED_COUNT: "已載入 {{loaded}} 個中的 {{total}} 個 {{type}}",
    DESCRIPTION_COPY: "將垃圾筒內的所有項目複製到剪貼簿。",
    DESCRIPTION_EXPORT: "將回收箱中的所有項目儲存至 .json 檔案。",
    DESCRIPTION_IMPORT: "透過 .json 檔案覆蓋垃圾桶中的所有項目。",
    DESCRIPTION_CLEAR: "清除回收箱內的所有項目（不能還原）。",
    ITEMS_EMPTY_SONGS_TITLE: "沒有已刪除的歌曲！",
    ITEMS_EMPTY_ARTISTS_TITLE: "沒有被糟蹋的藝術家！",
    DESCRIPTION_SETTINGS_ENABLED: "主切換以啟用或停用所有回收桶+功能",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "在播放列中，於正在播放的項目旁顯示垃圾桶圖示，以便快速存取",
    DESCRIPTION_SETTINGS_AUTOPLAY: "當 Spotify 開啟或擴充功能載入時，自動開始播放音樂",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "在播放隊列中的每首歌曲旁邊添加垃圾桶圖示，以便輕鬆管理",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "在專輯和播放清單中，於歌曲旁邊加入垃圾桶圖示，以便快速篩選",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "自動從 Spotify 播放故障中恢復，繼續播放你最後的播放清單",
    SETTINGS_SKIP_TRASHED_TRACKS: "跳過已刪除的音軌",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "自動跳過已刪除的歌曲，並在播放期間尋找下一首允許的音軌",
    SETTINGS_AUTO_CLEAN_QUEUE: "自動清除隊列",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "自動從您的智能隨機播放清單中移除已刪除的歌曲",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "下一個快速鍵清除垃圾",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "使用 Ctrl+右箭頭鍵盤快速鍵跳至下一首歌曲時，自動將當前歌曲移至垃圾桶",
    SETTINGS_REMOTE_CONTROL: "遙控器",
    SETTINGS_REMOTE_TOGGLE: "啟用遠端切換",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "從流動裝置連按兩下播放/暫停以切換遙控跳過功能。跳過一首歌曲即可確認切換。",
    SETTINGS_REMOTE_SKIPPING: "遠程跳過已啟用",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "啟用後，即使從其他裝置（例如流動裝置）控制 Spotify，亦可跳過垃圾桶",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "已啟用遠端跳過",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "已停用遠端跳過功能",
    MESSAGE_SONG_ADDED_REMOTE: "歌曲被遠程刪除",
    SETTINGS_TRASH_VIA_LIKE: "透過按讚來丟垃圾",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "就像一首歌從手機傳送到垃圾桶一樣。自動取消喜歡並跳到下一首。",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/zh-TW.json
var require_zh_TW = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "垃圾桶+",
    ACTION_THROW: "放入垃圾桶",
    ACTION_UNTHROW: "從垃圾桶移除",
    ACTION_CLEAR: "清楚",
    ACTION_COPY: "複製",
    ACTION_EXPORT: "匯出",
    ACTION_IMPORT: "導入",
    MESSAGE_COPIED: "已複製到剪貼簿",
    MESSAGE_CLEARED: "垃圾桶已成功清空！",
    MESSAGE_SONG_ADDED: "歌曲已加入垃圾桶",
    MESSAGE_SONG_REMOVED: "歌曲已從垃圾桶移除",
    MESSAGE_ARTIST_ADDED: "藝術家已加入垃圾桶",
    MESSAGE_ARTIST_REMOVED: "藝術家已從垃圾桶中移除",
    BACKUP_SAVE_SUCCESS: "備份已成功儲存。",
    BACKUP_SAVE_FAILED: "備份儲存失敗，請嘗試將垃圾桶內容複製到剪貼簿並手動建立備份。",
    BACKUP_RESTORE_SUCCESS: "備份還原成功。",
    BACKUP_FILE_READ_FAILED: "讀取檔案失敗，請確保它是一個有效的 JSON 檔案。",
    BACKUP_SUGGESTED_FILENAME: "spicetify-垃圾桶.json",
    SETTINGS_TITLE: "垃圾桶+ 設定",
    SETTINGS_OPTIONS: "選項",
    SETTINGS_FEATURES: "功能",
    SETTINGS_LOCAL_STORAGE: "本地儲存",
    SETTINGS_ENABLED: "已啟用",
    SETTINGS_SHOW_WIDGET: "顯示小工具圖示",
    SETTINGS_AUTOPLAY: "啟動時自動播放",
    SETTINGS_QUEUE_TRASHBIN: "啟用佇列回收桶",
    SETTINGS_TRACKLIST_TRASHBIN: "啟用播放清單回收桶",
    SETTINGS_PLAYLIST_MONITOR: "播放清單監控",
    ITEMS_TITLE: "垃圾桶+ 項目",
    ITEMS_EMPTY_SONGS: "<strong>沒有已刪除的歌曲！</strong><br/>您加入垃圾桶的歌曲將會出現在這裡。",
    ITEMS_EMPTY_ARTISTS: "<strong>沒有已刪除的藝術家！</strong><br/>您加入回收筒的藝術家將會出現在這裡。",
    ITEMS_TAB_SONGS: "歌曲",
    ITEMS_TAB_ARTISTS: "藝術家",
    ITEMS_LOADED_COUNT: "已載入 {{loaded}} / {{total}} {{type}}",
    DESCRIPTION_COPY: "將垃圾桶中的所有項目複製到剪貼簿。",
    DESCRIPTION_EXPORT: "將回收筒中的所有項目儲存至 .json 檔案。",
    DESCRIPTION_IMPORT: "透過 .json 檔案覆寫垃圾桶中的所有項目。",
    DESCRIPTION_CLEAR: "清空回收筒中的所有項目（無法復原）。",
    ITEMS_EMPTY_SONGS_TITLE: "沒有被刪除的歌曲！",
    ITEMS_EMPTY_ARTISTS_TITLE: "沒有被拋棄的藝術家！",
    DESCRIPTION_SETTINGS_ENABLED: "主要切換開關，用於啟用或停用所有垃圾桶+功能",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "在播放列中，於正在播放的歌曲旁顯示垃圾桶圖示，以便快速存取",
    DESCRIPTION_SETTINGS_AUTOPLAY: "當 Spotify 開啟或擴充功能載入時，自動開始播放音樂",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "在您即將播放的歌曲隊列中，於每首歌曲旁新增垃圾桶圖示，以便輕鬆管理",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "在專輯和播放清單檢視中，於歌曲旁新增垃圾桶圖示，以便快速篩選",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "自動從 Spotify 播放故障中恢復，繼續播放您最後的播放清單",
    SETTINGS_SKIP_TRASHED_TRACKS: "跳過已刪除的音軌",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "自動跳過已刪除的歌曲，並在播放期間尋找下一首允許的曲目",
    SETTINGS_AUTO_CLEAN_QUEUE: "自動清除佇列",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "自動從您的智慧隨機播放佇列中移除已刪除的歌曲",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "下一個快速鍵為垃圾桶",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "使用 Ctrl+右鍵盤快速鍵跳至下一首時，自動將目前歌曲移至垃圾桶",
    SETTINGS_REMOTE_CONTROL: "遙控器",
    SETTINGS_REMOTE_TOGGLE: "啟用遠端切換",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "從手機上連按兩下播放/暫停以切換遠端跳過功能的開關。跳過一首歌曲即可確認切換。",
    SETTINGS_REMOTE_SKIPPING: "遠端跳過已啟用",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "啟用後，即使從其他裝置（例如手機）控制 Spotify，也能跳過垃圾桶。",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "已啟用遠端跳過",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "已停用遠端跳過功能",
    MESSAGE_SONG_ADDED_REMOTE: "歌曲透過遠端刪除",
    SETTINGS_TRASH_VIA_LIKE: "垃圾透過按讚",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "就像一首從手機傳送到垃圾桶的歌曲。自動取消喜歡並跳到下一首。",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/i18n/zu.json
var require_zu = __commonJS((exports, module) => {
  module.exports = {
    TRASHBIN_NAME: "Trashbin+",
    ACTION_THROW: "Faka esikhenkathini",
    ACTION_UNTHROW: "Susa kusindvo yesitsha",
    ACTION_CLEAR: "Vula",
    ACTION_COPY: "Kopisha",
    ACTION_EXPORT: "Thumela kuwandle",
    ACTION_IMPORT: "Ngenisa",
    MESSAGE_COPIED: "Kukhopyiwe kubhodi yokhokha",
    MESSAGE_CLEARED: "Inkunkuma yasuswa ngempumelelo!",
    MESSAGE_SONG_ADDED: "Umusi wongezwe kususini",
    MESSAGE_SONG_REMOVED: "Umbhali wususwe kususini",
    MESSAGE_ARTIST_ADDED: "Umculo wengezwe kususini",
    MESSAGE_ARTIST_REMOVED: "Umdlali wususwe kususini",
    BACKUP_SAVE_SUCCESS: "Gcwaliswe kabusha ngempumelelo.",
    BACKUP_SAVE_FAILED: "Akuphumelela ukugcina kopi yokuphinda, uzame ukukopisha okwakhiwe kikhweli futhi ukudala ikopi yokuphinda ngendlela yokuphawula.",
    BACKUP_RESTORE_SUCCESS: "Kuvuselelwe kahle kubeka-phambili.",
    BACKUP_FILE_READ_FAILED: "Ayikwazi ukufunda ifayela, sicela uqiniseke ukuthi yifayela efanayo ye-JSON.",
    BACKUP_SUGGESTED_FILENAME: "spicetify-trashbin.json",
    SETTINGS_TITLE: "Izilungiselelo zeTrashbin+",
    SETTINGS_OPTIONS: "Izinketho",
    SETTINGS_FEATURES: "Izinto ezikhethekileyo",
    SETTINGS_LOCAL_STORAGE: "Isitroli seNdawonye",
    SETTINGS_ENABLED: "Kuvulwe",
    SETTINGS_SHOW_WIDGET: "Bonisa Isithonjana Sekhona",
    SETTINGS_AUTOPLAY: "Ukudlala Ngokuzenzakalela Ekuvuleni",
    SETTINGS_QUEUE_TRASHBIN: "Vula I-Queue Trashbin",
    SETTINGS_TRACKLIST_TRASHBIN: "Vula Isithuthi seTrashbin ye-Tracklist",
    SETTINGS_PLAYLIST_MONITOR: "Umlayizi we-Playlist",
    ITEMS_TITLE: "Izinto ze-Trashbin+",
    ITEMS_EMPTY_SONGS: "<strong>Azikho izinhloso ezilahliwe!</strong><br/>Izinhloso ozodinga kuzilahla kuzovela lapha.",
    ITEMS_EMPTY_ARTISTS: "<strong>Azikho abagciniwe!</strong><br/>Abagcini bageza lapha.",
    ITEMS_TAB_SONGS: "Izindima",
    ITEMS_TAB_ARTISTS: "Abakhetha umfanekiso",
    ITEMS_LOADED_COUNT: "{{loaded}} kwe {{total}} {{type}} ekulandelwe",
    DESCRIPTION_COPY: "Kopisha konke okungeni isikhwama esibhetshe klayiphebholide.",
    DESCRIPTION_EXPORT: "Londoloza konke okwakhiweni kufayela .json.",
    DESCRIPTION_IMPORT: "Bekephetha konke okungeni ibhethi ngendlela ye-.json.",
    DESCRIPTION_CLEAR: "Susa konke okhokhelwe ku-trashbin (akukwenzekanga ukubuyisela).",
    ITEMS_EMPTY_SONGS_TITLE: "Akukho lolizo elidotiwe!",
    ITEMS_EMPTY_ARTISTS_TITLE: "Akukho zokwakha izithombe zilahlekile!",
    DESCRIPTION_SETTINGS_ENABLED: "Isilungiso esigcwele sokuvula noma kuvimba wonke umsebenzi kaTrashbin+",
    DESCRIPTION_SETTINGS_SHOW_WIDGET: "Bonisa ikhona yekhobhotho ekhesheji yokuqhubeka ngasekhohlo kwegama eliqhubekayo ukuze kube lula ukufinyelela",
    DESCRIPTION_SETTINGS_AUTOPLAY: "Qala ngokuzenzakalelayo ukudlala imiziki xa i-Spotify ivulwe noma isiphindezelo sifaka",
    DESCRIPTION_SETTINGS_QUEUE_TRASHBIN: "Faka izithombe zedolobha ezinguqulunga ngasinye kusihlalo sakho esizofika ukuze kube lula ukuphatha",
    DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN: "Faka izithombe zedolobha ezizungezile kumabhasi kumzobo nomhala wokudlala ukuze ukhethwe ngokushesha",
    DESCRIPTION_SETTINGS_PLAYLIST_MONITOR: "Duthukutshela ngokuzenzakalelayo kusindiswa kukaSpotify ngokubuyisela kusihloko sakho esisendulo",
    SETTINGS_SKIP_TRASHED_TRACKS: "Yeqela Izindimana Ezilahlekile",
    DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS: "Yeqeda ngokuzenzakalelayo izindima ezithunyelwe kususini bese uthola indima engavunyelwa elandelayo ngexesha lokudlala",
    SETTINGS_AUTO_CLEAN_QUEUE: "Gcina ukuqeda umgwaqo",
    DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE: "Susa ngokuzenzakalelayo izindima ezithunyelwe ku-inthanethi kusikhwama sakho se-Shuffle esinamandla",
    SETTINGS_TRASH_ON_NEXT_HOTKEY: "Trash kwi-Hotkey elandelayo",
    DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY: "Cima ngokuzenzakalelayo iminikelo yamanje uma usebenzisa i-Ctrl+Right ukuthi uthule kumunye umgaga",
    SETTINGS_REMOTE_CONTROL: "Isivumelwano esingaphandle",
    SETTINGS_REMOTE_TOGGLE: "Vula Ukumisa Kude",
    DESCRIPTION_SETTINGS_REMOTE_TOGGLE: "Cindezela kabombindlela ukudlala/ukumisa ukumisa kuselulekini ukuze uguqule ukukhuphaza kude kuvule/ukuvula. Ukukhuphaza kwe-trakhu kuyavikela ukuguquleka.",
    SETTINGS_REMOTE_SKIPPING: "Ukuphazamisa Kude Kusebenza",
    DESCRIPTION_SETTINGS_REMOTE_SKIPPING: "Xa kusekelwe, ukubuyisela kususwa kusebenza noma kube wasebenzisa i-Spotify kusihlangothini esinye (umzekelo, ihhandi)",
    MESSAGE_REMOTE_SKIPPING_ENABLED: "Ukuzoshaya kude kuvuselelwe",
    MESSAGE_REMOTE_SKIPPING_DISABLED: "Ukungena kude kuvivinyelwe",
    MESSAGE_SONG_ADDED_REMOTE: "Umusi wadiliselwe ngaphandle",
    SETTINGS_TRASH_VIA_LIKE: "Trash ngaphandle kukaLike",
    DESCRIPTION_SETTINGS_TRASH_VIA_LIKE: "Njengomculo ukusuka kumobile ukususa kususini. Ukucima okungafani kusenzo futhi ukhupha kumculo ongemuva.",
    SETTINGS_AI_DETECTION: "AI Detection",
    SETTINGS_AI_DETECTION_ENABLED: "AI Song Detection",
    DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED: "Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",
    AI_ASSETS_DOWNLOADING: "Downloading AI model...",
    AI_ASSETS_READY: "AI model ready",
    AI_ASSETS_NOT_READY: "AI model not available"
  };
});

// src/app.tsx
var import_react27 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// src/components/features/ai-detection-widget.tsx
var import_react7 = __toESM(require_react(), 1);

// src/lib/ai-asset-manager.ts
var DB_NAME = "trashbin-ai";
var STORE_NAME = "assets";
var DB_VERSION = 1;
var VERSION_STORAGE_KEY = "trashbin-ai-assets-version";
var GITHUB_RELEASE_BASE = "https://github.com/0-don/trashbin-plus/releases/download/ai-assets";
var ASSET_NAMES = {
  MODEL: "sonics_model.onnx",
  WASM_SIMD: "ort-wasm-simd.wasm",
  WASM_FALLBACK: "ort-wasm.wasm",
  VERSION: "version.json"
};
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onupgradeneeded = () => {
      const db = request.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: "name" });
      }
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}
async function getAsset(name) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    const request = store.get(name);
    request.onsuccess = () => {
      db.close();
      resolve(request.result?.data ?? null);
    };
    request.onerror = () => {
      db.close();
      reject(request.error);
    };
  });
}
async function storeAsset(name, data, version) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, "readwrite");
    const store = tx.objectStore(STORE_NAME);
    const request = store.put({ name, data, version });
    request.onsuccess = () => {
      db.close();
      resolve();
    };
    request.onerror = () => {
      db.close();
      reject(request.error);
    };
  });
}
async function downloadAsset(name) {
  const url = `${GITHUB_RELEASE_BASE}/${name}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to download ${name}: ${response.status}`);
  }
  return response.arrayBuffer();
}
async function fetchRemoteVersion() {
  try {
    const url = `${GITHUB_RELEASE_BASE}/${ASSET_NAMES.VERSION}`;
    const response = await fetch(url);
    if (!response.ok)
      return null;
    const data = await response.json();
    return data.version ?? null;
  } catch {
    return null;
  }
}
function getStoredVersion() {
  return Spicetify.LocalStorage.get(VERSION_STORAGE_KEY) ?? null;
}
function setStoredVersion(version) {
  Spicetify.LocalStorage.set(VERSION_STORAGE_KEY, version);
}
async function ensureAssets(onProgress) {
  try {
    const remoteVersion = await fetchRemoteVersion();
    if (!remoteVersion) {
      console.error("[trashbin+ AI] Could not fetch remote version");
      return false;
    }
    const localVersion = getStoredVersion();
    const modelExists = await getAsset(ASSET_NAMES.MODEL);
    const wasmExists = await getAsset(ASSET_NAMES.WASM_SIMD);
    if (localVersion === remoteVersion && modelExists && wasmExists) {
      onProgress?.("Assets up to date");
      return true;
    }
    onProgress?.("Downloading WASM runtime...");
    const wasmData = await downloadAsset(ASSET_NAMES.WASM_SIMD);
    await storeAsset(ASSET_NAMES.WASM_SIMD, wasmData, remoteVersion);
    onProgress?.("Downloading AI model...");
    const modelData = await downloadAsset(ASSET_NAMES.MODEL);
    await storeAsset(ASSET_NAMES.MODEL, modelData, remoteVersion);
    setStoredVersion(remoteVersion);
    onProgress?.("Assets ready");
    return true;
  } catch (error) {
    console.error("[trashbin+ AI] Failed to ensure assets:", error);
    return false;
  }
}

// node_modules/onnxruntime-web/dist/ort.bundle.min.mjs
/*!
 * ONNX Runtime Web v1.24.1
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Wn = Object.defineProperty;
var gf = Object.getOwnPropertyDescriptor;
var yf = Object.getOwnPropertyNames;
var bf = Object.prototype.hasOwnProperty;
var Gn = ((t) => "function" < "u" ? __require : typeof Proxy < "u" ? new Proxy(t, { get: (e, r) => ("function" < "u" ? __require : e)[r] }) : t)(function(t) {
  if ("function" < "u")
    return __require.apply(this, arguments);
  throw Error('Dynamic require of "' + t + '" is not supported');
});
var V = (t, e) => () => (t && (e = t(t = 0)), e);
var Vt = (t, e) => {
  for (var r in e)
    Wn(t, r, { get: e[r], enumerable: true });
};
var wf = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o of yf(e))
      !bf.call(t, o) && o !== r && Wn(t, o, { get: () => e[o], enumerable: !(n = gf(e, o)) || n.enumerable });
  return t;
};
var Yt = (t) => wf(Wn({}, "__esModule", { value: true }), t);
var $r;
var Et;
var kt;
var _f;
var za;
var Hn = V(() => {
  $r = new Map, Et = [], kt = (t, e, r) => {
    if (e && typeof e.init == "function" && typeof e.createInferenceSessionHandler == "function") {
      let n = $r.get(t);
      if (n === undefined)
        $r.set(t, { backend: e, priority: r });
      else {
        if (n.priority > r)
          return;
        if (n.priority === r && n.backend !== e)
          throw new Error(`cannot register backend "${t}" using priority ${r}`);
      }
      if (r >= 0) {
        let o = Et.indexOf(t);
        o !== -1 && Et.splice(o, 1);
        for (let i = 0;i < Et.length; i++)
          if ($r.get(Et[i]).priority <= r) {
            Et.splice(i, 0, t);
            return;
          }
        Et.push(t);
      }
      return;
    }
    throw new TypeError("not a valid backend");
  }, _f = async (t) => {
    let e = $r.get(t);
    if (!e)
      return "backend not found.";
    if (e.initialized)
      return e.backend;
    if (e.aborted)
      return e.error;
    {
      let r = !!e.initPromise;
      try {
        return r || (e.initPromise = e.backend.init(t)), await e.initPromise, e.initialized = true, e.backend;
      } catch (n) {
        return r || (e.error = `${n}`, e.aborted = true), e.error;
      } finally {
        delete e.initPromise;
      }
    }
  }, za = async (t) => {
    let e = t.executionProviders || [], r = e.map((d) => typeof d == "string" ? d : d.name), n = r.length === 0 ? Et : r, o, i = [], s = new Set;
    for (let d of n) {
      let c = await _f(d);
      typeof c == "string" ? i.push({ name: d, err: c }) : (o || (o = c), o === c && s.add(d));
    }
    if (!o)
      throw new Error(`no available backend found. ERR: ${i.map((d) => `[${d.name}] ${d.err}`).join(", ")}`);
    for (let { name: d, err: c } of i)
      r.includes(d) && console.warn(`removing requested execution provider "${d}" from session options because it is not available: ${c}`);
    let u = e.filter((d) => s.has(typeof d == "string" ? d : d.name));
    return [o, new Proxy(t, { get: (d, c) => c === "executionProviders" ? u : Reflect.get(d, c) })];
  };
});
var Da = V(() => {
  Hn();
});
var Ba;
var Ma = V(() => {
  Ba = "1.24.1";
});
var Ra;
var ke;
var Fn = V(() => {
  Ma();
  Ra = "warning", ke = { wasm: {}, webgl: {}, webgpu: {}, versions: { common: Ba }, set logLevel(t) {
    if (t !== undefined) {
      if (typeof t != "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(t) === -1)
        throw new Error(`Unsupported logging level: ${t}`);
      Ra = t;
    }
  }, get logLevel() {
    return Ra;
  } };
  Object.defineProperty(ke, "logLevel", { enumerable: true });
});
var ye;
var Ua = V(() => {
  Fn();
  ye = ke;
});
var Na;
var Va;
var La = V(() => {
  Na = (t, e) => {
    let r = typeof document < "u" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
    r.width = t.dims[3], r.height = t.dims[2];
    let n = r.getContext("2d");
    if (n != null) {
      let o, i;
      e?.tensorLayout !== undefined && e.tensorLayout === "NHWC" ? (o = t.dims[2], i = t.dims[3]) : (o = t.dims[3], i = t.dims[2]);
      let s = e?.format !== undefined ? e.format : "RGB", u = e?.norm, d, c;
      u === undefined || u.mean === undefined ? d = [255, 255, 255, 255] : typeof u.mean == "number" ? d = [u.mean, u.mean, u.mean, u.mean] : (d = [u.mean[0], u.mean[1], u.mean[2], 0], u.mean[3] !== undefined && (d[3] = u.mean[3])), u === undefined || u.bias === undefined ? c = [0, 0, 0, 0] : typeof u.bias == "number" ? c = [u.bias, u.bias, u.bias, u.bias] : (c = [u.bias[0], u.bias[1], u.bias[2], 0], u.bias[3] !== undefined && (c[3] = u.bias[3]));
      let p = i * o, m = 0, g = p, b = p * 2, y = -1;
      s === "RGBA" ? (m = 0, g = p, b = p * 2, y = p * 3) : s === "RGB" ? (m = 0, g = p, b = p * 2) : s === "RBG" && (m = 0, b = p, g = p * 2);
      for (let w = 0;w < i; w++)
        for (let S = 0;S < o; S++) {
          let x = (t.data[m++] - c[0]) * d[0], $ = (t.data[g++] - c[1]) * d[1], T = (t.data[b++] - c[2]) * d[2], I = y === -1 ? 255 : (t.data[y++] - c[3]) * d[3];
          n.fillStyle = "rgba(" + x + "," + $ + "," + T + "," + I + ")", n.fillRect(S, w, 1, 1);
        }
      if ("toDataURL" in r)
        return r.toDataURL();
      throw new Error("toDataURL is not supported");
    } else
      throw new Error("Can not access image data");
  }, Va = (t, e) => {
    let r = typeof document < "u" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d"), n;
    if (r != null) {
      let o, i, s;
      e?.tensorLayout !== undefined && e.tensorLayout === "NHWC" ? (o = t.dims[2], i = t.dims[1], s = t.dims[3]) : (o = t.dims[3], i = t.dims[2], s = t.dims[1]);
      let u = e !== undefined && e.format !== undefined ? e.format : "RGB", d = e?.norm, c, p;
      d === undefined || d.mean === undefined ? c = [255, 255, 255, 255] : typeof d.mean == "number" ? c = [d.mean, d.mean, d.mean, d.mean] : (c = [d.mean[0], d.mean[1], d.mean[2], 255], d.mean[3] !== undefined && (c[3] = d.mean[3])), d === undefined || d.bias === undefined ? p = [0, 0, 0, 0] : typeof d.bias == "number" ? p = [d.bias, d.bias, d.bias, d.bias] : (p = [d.bias[0], d.bias[1], d.bias[2], 0], d.bias[3] !== undefined && (p[3] = d.bias[3]));
      let m = i * o;
      if (e !== undefined && (e.format !== undefined && s === 4 && e.format !== "RGBA" || s === 3 && e.format !== "RGB" && e.format !== "BGR"))
        throw new Error("Tensor format doesn't match input tensor dims");
      let g = 4, b = 0, y = 1, w = 2, S = 3, x = 0, $ = m, T = m * 2, I = -1;
      u === "RGBA" ? (x = 0, $ = m, T = m * 2, I = m * 3) : u === "RGB" ? (x = 0, $ = m, T = m * 2) : u === "RBG" && (x = 0, T = m, $ = m * 2), n = r.createImageData(o, i);
      for (let E = 0;E < i * o; b += g, y += g, w += g, S += g, E++)
        n.data[b] = (t.data[x++] - p[0]) * c[0], n.data[y] = (t.data[$++] - p[1]) * c[1], n.data[w] = (t.data[T++] - p[2]) * c[2], n.data[S] = I === -1 ? 255 : (t.data[I++] - p[3]) * c[3];
    } else
      throw new Error("Can not access image data");
    return n;
  };
});
var qn;
var Wa;
var Ga;
var Ha;
var Fa;
var qa;
var Ka = V(() => {
  xr();
  qn = (t, e) => {
    if (t === undefined)
      throw new Error("Image buffer must be defined");
    if (e.height === undefined || e.width === undefined)
      throw new Error("Image height and width must be defined");
    if (e.tensorLayout === "NHWC")
      throw new Error("NHWC Tensor layout is not supported yet");
    let { height: r, width: n } = e, o = e.norm ?? { mean: 255, bias: 0 }, i, s;
    typeof o.mean == "number" ? i = [o.mean, o.mean, o.mean, o.mean] : i = [o.mean[0], o.mean[1], o.mean[2], o.mean[3] ?? 255], typeof o.bias == "number" ? s = [o.bias, o.bias, o.bias, o.bias] : s = [o.bias[0], o.bias[1], o.bias[2], o.bias[3] ?? 0];
    let u = e.format !== undefined ? e.format : "RGBA", d = e.tensorFormat !== undefined && e.tensorFormat !== undefined ? e.tensorFormat : "RGB", c = r * n, p = d === "RGBA" ? new Float32Array(c * 4) : new Float32Array(c * 3), m = 4, g = 0, b = 1, y = 2, w = 3, S = 0, x = c, $ = c * 2, T = -1;
    u === "RGB" && (m = 3, g = 0, b = 1, y = 2, w = -1), d === "RGBA" ? T = c * 3 : d === "RBG" ? (S = 0, $ = c, x = c * 2) : d === "BGR" && ($ = 0, x = c, S = c * 2);
    for (let E = 0;E < c; E++, g += m, y += m, b += m, w += m)
      p[S++] = (t[g] + s[0]) / i[0], p[x++] = (t[b] + s[1]) / i[1], p[$++] = (t[y] + s[2]) / i[2], T !== -1 && w !== -1 && (p[T++] = (t[w] + s[3]) / i[3]);
    return d === "RGBA" ? new De("float32", p, [1, 4, r, n]) : new De("float32", p, [1, 3, r, n]);
  }, Wa = async (t, e) => {
    let r = typeof HTMLImageElement < "u" && t instanceof HTMLImageElement, n = typeof ImageData < "u" && t instanceof ImageData, o = typeof ImageBitmap < "u" && t instanceof ImageBitmap, i = typeof t == "string", s, u = e ?? {}, d = () => {
      if (typeof document < "u")
        return document.createElement("canvas");
      if (typeof OffscreenCanvas < "u")
        return new OffscreenCanvas(1, 1);
      throw new Error("Canvas is not supported");
    }, c = (p) => typeof HTMLCanvasElement < "u" && p instanceof HTMLCanvasElement || p instanceof OffscreenCanvas ? p.getContext("2d") : null;
    if (r) {
      let p = d();
      p.width = t.width, p.height = t.height;
      let m = c(p);
      if (m != null) {
        let { height: g, width: b } = t;
        if (e !== undefined && e.resizedHeight !== undefined && e.resizedWidth !== undefined && (g = e.resizedHeight, b = e.resizedWidth), e !== undefined) {
          if (u = e, e.tensorFormat !== undefined)
            throw new Error("Image input config format must be RGBA for HTMLImageElement");
          u.tensorFormat = "RGBA", u.height = g, u.width = b;
        } else
          u.tensorFormat = "RGBA", u.height = g, u.width = b;
        m.drawImage(t, 0, 0), s = m.getImageData(0, 0, b, g).data;
      } else
        throw new Error("Can not access image data");
    } else if (n) {
      let p, m;
      if (e !== undefined && e.resizedWidth !== undefined && e.resizedHeight !== undefined ? (p = e.resizedHeight, m = e.resizedWidth) : (p = t.height, m = t.width), e !== undefined && (u = e), u.format = "RGBA", u.height = p, u.width = m, e !== undefined) {
        let g = d();
        g.width = m, g.height = p;
        let b = c(g);
        if (b != null)
          b.putImageData(t, 0, 0), s = b.getImageData(0, 0, m, p).data;
        else
          throw new Error("Can not access image data");
      } else
        s = t.data;
    } else if (o) {
      if (e === undefined)
        throw new Error("Please provide image config with format for Imagebitmap");
      let p = d();
      p.width = t.width, p.height = t.height;
      let m = c(p);
      if (m != null) {
        let { height: g, width: b } = t;
        return m.drawImage(t, 0, 0, b, g), s = m.getImageData(0, 0, b, g).data, u.height = g, u.width = b, qn(s, u);
      } else
        throw new Error("Can not access image data");
    } else {
      if (i)
        return new Promise((p, m) => {
          let g = d(), b = c(g);
          if (!t || !b)
            return m();
          let y = new Image;
          y.crossOrigin = "Anonymous", y.src = t, y.onload = () => {
            g.width = y.width, g.height = y.height, b.drawImage(y, 0, 0, g.width, g.height);
            let w = b.getImageData(0, 0, g.width, g.height);
            u.height = g.height, u.width = g.width, p(qn(w.data, u));
          };
        });
      throw new Error("Input data provided is not supported - aborted tensor creation");
    }
    if (s !== undefined)
      return qn(s, u);
    throw new Error("Input data provided is not supported - aborted tensor creation");
  }, Ga = (t, e) => {
    let { width: r, height: n, download: o, dispose: i } = e, s = [1, n, r, 4];
    return new De({ location: "texture", type: "float32", texture: t, dims: s, download: o, dispose: i });
  }, Ha = (t, e) => {
    let { dataType: r, dims: n, download: o, dispose: i } = e;
    return new De({ location: "gpu-buffer", type: r ?? "float32", gpuBuffer: t, dims: n, download: o, dispose: i });
  }, Fa = (t, e) => {
    let { dataType: r, dims: n, download: o, dispose: i } = e;
    return new De({ location: "ml-tensor", type: r ?? "float32", mlTensor: t, dims: n, download: o, dispose: i });
  }, qa = (t, e, r) => new De({ location: "cpu-pinned", type: t, data: e, dims: r ?? [e.length] });
});
var Pt;
var Xt;
var ja;
var Za;
var Qa = V(() => {
  Pt = new Map([["float32", Float32Array], ["uint8", Uint8Array], ["int8", Int8Array], ["uint16", Uint16Array], ["int16", Int16Array], ["int32", Int32Array], ["bool", Uint8Array], ["float64", Float64Array], ["uint32", Uint32Array], ["int4", Uint8Array], ["uint4", Uint8Array]]), Xt = new Map([[Float32Array, "float32"], [Uint8Array, "uint8"], [Int8Array, "int8"], [Uint16Array, "uint16"], [Int16Array, "int16"], [Int32Array, "int32"], [Float64Array, "float64"], [Uint32Array, "uint32"]]), ja = false, Za = () => {
    if (!ja) {
      ja = true;
      let t = typeof BigInt64Array < "u" && BigInt64Array.from, e = typeof BigUint64Array < "u" && BigUint64Array.from, r = globalThis.Float16Array, n = typeof r < "u" && r.from;
      t && (Pt.set("int64", BigInt64Array), Xt.set(BigInt64Array, "int64")), e && (Pt.set("uint64", BigUint64Array), Xt.set(BigUint64Array, "uint64")), n ? (Pt.set("float16", r), Xt.set(r, "float16")) : Pt.set("float16", Uint16Array);
    }
  };
});
var Ya;
var Xa;
var Ja = V(() => {
  xr();
  Ya = (t) => {
    let e = 1;
    for (let r = 0;r < t.length; r++) {
      let n = t[r];
      if (typeof n != "number" || !Number.isSafeInteger(n))
        throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);
      if (n < 0)
        throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);
      e *= n;
    }
    return e;
  }, Xa = (t, e) => {
    switch (t.location) {
      case "cpu":
        return new De(t.type, t.data, e);
      case "cpu-pinned":
        return new De({ location: "cpu-pinned", data: t.data, type: t.type, dims: e });
      case "texture":
        return new De({ location: "texture", texture: t.texture, type: t.type, dims: e });
      case "gpu-buffer":
        return new De({ location: "gpu-buffer", gpuBuffer: t.gpuBuffer, type: t.type, dims: e });
      case "ml-tensor":
        return new De({ location: "ml-tensor", mlTensor: t.mlTensor, type: t.type, dims: e });
      default:
        throw new Error(`tensorReshape: tensor location ${t.location} is not supported`);
    }
  };
});
var De;
var xr = V(() => {
  La();
  Ka();
  Qa();
  Ja();
  De = class {
    constructor(e, r, n) {
      Za();
      let o, i;
      if (typeof e == "object" && "location" in e)
        switch (this.dataLocation = e.location, o = e.type, i = e.dims, e.location) {
          case "cpu-pinned": {
            let u = Pt.get(o);
            if (!u)
              throw new TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);
            if (!(e.data instanceof u))
              throw new TypeError(`buffer should be of type ${u.name}`);
            this.cpuData = e.data;
            break;
          }
          case "texture": {
            if (o !== "float32")
              throw new TypeError(`unsupported type "${o}" to create tensor from texture`);
            this.gpuTextureData = e.texture, this.downloader = e.download, this.disposer = e.dispose;
            break;
          }
          case "gpu-buffer": {
            if (o !== "float32" && o !== "float16" && o !== "int32" && o !== "int64" && o !== "uint32" && o !== "uint8" && o !== "bool" && o !== "uint4" && o !== "int4")
              throw new TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);
            this.gpuBufferData = e.gpuBuffer, this.downloader = e.download, this.disposer = e.dispose;
            break;
          }
          case "ml-tensor": {
            if (o !== "float32" && o !== "float16" && o !== "int32" && o !== "int64" && o !== "uint32" && o !== "uint64" && o !== "int8" && o !== "uint8" && o !== "bool" && o !== "uint4" && o !== "int4")
              throw new TypeError(`unsupported type "${o}" to create tensor from MLTensor`);
            this.mlTensorData = e.mlTensor, this.downloader = e.download, this.disposer = e.dispose;
            break;
          }
          default:
            throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
        }
      else {
        let u, d;
        if (typeof e == "string")
          if (o = e, d = n, e === "string") {
            if (!Array.isArray(r))
              throw new TypeError("A string tensor's data must be a string array.");
            u = r;
          } else {
            let c = Pt.get(e);
            if (c === undefined)
              throw new TypeError(`Unsupported tensor type: ${e}.`);
            if (Array.isArray(r)) {
              if (e === "float16" && c === Uint16Array || e === "uint4" || e === "int4")
                throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${c.name} as data.`);
              e === "uint64" || e === "int64" ? u = c.from(r, BigInt) : u = c.from(r);
            } else if (r instanceof c)
              u = r;
            else if (r instanceof Uint8ClampedArray)
              if (e === "uint8")
                u = Uint8Array.from(r);
              else
                throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");
            else if (e === "float16" && r instanceof Uint16Array && c !== Uint16Array)
              u = new globalThis.Float16Array(r.buffer, r.byteOffset, r.length);
            else
              throw new TypeError(`A ${o} tensor's data must be type of ${c}`);
          }
        else if (d = r, Array.isArray(e)) {
          if (e.length === 0)
            throw new TypeError("Tensor type cannot be inferred from an empty array.");
          let c = typeof e[0];
          if (c === "string")
            o = "string", u = e;
          else if (c === "boolean")
            o = "bool", u = Uint8Array.from(e);
          else
            throw new TypeError(`Invalid element type of data array: ${c}.`);
        } else if (e instanceof Uint8ClampedArray)
          o = "uint8", u = Uint8Array.from(e);
        else {
          let c = Xt.get(e.constructor);
          if (c === undefined)
            throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);
          o = c, u = e;
        }
        if (d === undefined)
          d = [u.length];
        else if (!Array.isArray(d))
          throw new TypeError("A tensor's dims must be a number array");
        i = d, this.cpuData = u, this.dataLocation = "cpu";
      }
      let s = Ya(i);
      if (this.cpuData && s !== this.cpuData.length && !((o === "uint4" || o === "int4") && Math.ceil(s / 2) === this.cpuData.length))
        throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);
      this.type = o, this.dims = i, this.size = s;
    }
    static async fromImage(e, r) {
      return Wa(e, r);
    }
    static fromTexture(e, r) {
      return Ga(e, r);
    }
    static fromGpuBuffer(e, r) {
      return Ha(e, r);
    }
    static fromMLTensor(e, r) {
      return Fa(e, r);
    }
    static fromPinnedBuffer(e, r, n) {
      return qa(e, r, n);
    }
    toDataURL(e) {
      return Na(this, e);
    }
    toImageData(e) {
      return Va(this, e);
    }
    get data() {
      if (this.ensureValid(), !this.cpuData)
        throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
      return this.cpuData;
    }
    get location() {
      return this.dataLocation;
    }
    get texture() {
      if (this.ensureValid(), !this.gpuTextureData)
        throw new Error("The data is not stored as a WebGL texture.");
      return this.gpuTextureData;
    }
    get gpuBuffer() {
      if (this.ensureValid(), !this.gpuBufferData)
        throw new Error("The data is not stored as a WebGPU buffer.");
      return this.gpuBufferData;
    }
    get mlTensor() {
      if (this.ensureValid(), !this.mlTensorData)
        throw new Error("The data is not stored as a WebNN MLTensor.");
      return this.mlTensorData;
    }
    async getData(e) {
      switch (this.ensureValid(), this.dataLocation) {
        case "cpu":
        case "cpu-pinned":
          return this.data;
        case "texture":
        case "gpu-buffer":
        case "ml-tensor": {
          if (!this.downloader)
            throw new Error("The current tensor is not created with a specified data downloader.");
          if (this.isDownloading)
            throw new Error("The current tensor is being downloaded.");
          try {
            this.isDownloading = true;
            let r = await this.downloader();
            return this.downloader = undefined, this.dataLocation = "cpu", this.cpuData = r, e && this.disposer && (this.disposer(), this.disposer = undefined), r;
          } finally {
            this.isDownloading = false;
          }
        }
        default:
          throw new Error(`cannot get data from location: ${this.dataLocation}`);
      }
    }
    dispose() {
      if (this.isDownloading)
        throw new Error("The current tensor is being downloaded.");
      this.disposer && (this.disposer(), this.disposer = undefined), this.cpuData = undefined, this.gpuTextureData = undefined, this.gpuBufferData = undefined, this.mlTensorData = undefined, this.downloader = undefined, this.isDownloading = undefined, this.dataLocation = "none";
    }
    ensureValid() {
      if (this.dataLocation === "none")
        throw new Error("The tensor is disposed.");
    }
    reshape(e) {
      if (this.ensureValid(), this.downloader || this.disposer)
        throw new Error("Cannot reshape a tensor that owns GPU resource.");
      return Xa(this, e);
    }
  };
});
var Ke;
var Kn = V(() => {
  xr();
  Ke = De;
});
var Sr;
var es;
var Ne;
var Me;
var wt;
var _t;
var jn = V(() => {
  Fn();
  Sr = (t, e) => {
    (typeof ke.trace > "u" ? !ke.wasm.trace : !ke.trace) || console.timeStamp(`${t}::ORT::${e}`);
  }, es = (t, e) => {
    let r = new Error().stack?.split(/\r\n|\r|\n/g) || [], n = false;
    for (let o = 0;o < r.length; o++) {
      if (n && !r[o].includes("TRACE_FUNC")) {
        let i = `FUNC_${t}::${r[o].trim().split(" ")[1]}`;
        e && (i += `::${e}`), Sr("CPU", i);
        return;
      }
      r[o].includes("TRACE_FUNC") && (n = true);
    }
  }, Ne = (t) => {
    (typeof ke.trace > "u" ? !ke.wasm.trace : !ke.trace) || es("BEGIN", t);
  }, Me = (t) => {
    (typeof ke.trace > "u" ? !ke.wasm.trace : !ke.trace) || es("END", t);
  }, wt = (t) => {
    (typeof ke.trace > "u" ? !ke.wasm.trace : !ke.trace) || console.time(`ORT::${t}`);
  }, _t = (t) => {
    (typeof ke.trace > "u" ? !ke.wasm.trace : !ke.trace) || console.timeEnd(`ORT::${t}`);
  };
});
var Tr;
var ts = V(() => {
  Hn();
  Kn();
  jn();
  Tr = class t {
    constructor(e) {
      this.handler = e;
    }
    async run(e, r, n) {
      Ne(), wt("InferenceSession.run");
      let o = {}, i = {};
      if (typeof e != "object" || e === null || e instanceof Ke || Array.isArray(e))
        throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
      let s = true;
      if (typeof r == "object") {
        if (r === null)
          throw new TypeError("Unexpected argument[1]: cannot be null.");
        if (r instanceof Ke)
          throw new TypeError("'fetches' cannot be a Tensor");
        if (Array.isArray(r)) {
          if (r.length === 0)
            throw new TypeError("'fetches' cannot be an empty array.");
          s = false;
          for (let c of r) {
            if (typeof c != "string")
              throw new TypeError("'fetches' must be a string array or an object.");
            if (this.outputNames.indexOf(c) === -1)
              throw new RangeError(`'fetches' contains invalid output name: ${c}.`);
            o[c] = null;
          }
          if (typeof n == "object" && n !== null)
            i = n;
          else if (typeof n < "u")
            throw new TypeError("'options' must be an object.");
        } else {
          let c = false, p = Object.getOwnPropertyNames(r);
          for (let m of this.outputNames)
            if (p.indexOf(m) !== -1) {
              let g = r[m];
              (g === null || g instanceof Ke) && (c = true, s = false, o[m] = g);
            }
          if (c) {
            if (typeof n == "object" && n !== null)
              i = n;
            else if (typeof n < "u")
              throw new TypeError("'options' must be an object.");
          } else
            i = r;
        }
      } else if (typeof r < "u")
        throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
      for (let c of this.inputNames)
        if (typeof e[c] > "u")
          throw new Error(`input '${c}' is missing in 'feeds'.`);
      if (s)
        for (let c of this.outputNames)
          o[c] = null;
      let u = await this.handler.run(e, o, i), d = {};
      for (let c in u)
        if (Object.hasOwnProperty.call(u, c)) {
          let p = u[c];
          p instanceof Ke ? d[c] = p : d[c] = new Ke(p.type, p.data, p.dims);
        }
      return _t("InferenceSession.run"), Me(), d;
    }
    async release() {
      return this.handler.dispose();
    }
    static async create(e, r, n, o) {
      Ne(), wt("InferenceSession.create");
      let i, s = {};
      if (typeof e == "string") {
        if (i = e, typeof r == "object" && r !== null)
          s = r;
        else if (typeof r < "u")
          throw new TypeError("'options' must be an object.");
      } else if (e instanceof Uint8Array) {
        if (i = e, typeof r == "object" && r !== null)
          s = r;
        else if (typeof r < "u")
          throw new TypeError("'options' must be an object.");
      } else if (e instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer) {
        let p = e, m = 0, g = e.byteLength;
        if (typeof r == "object" && r !== null)
          s = r;
        else if (typeof r == "number") {
          if (m = r, !Number.isSafeInteger(m))
            throw new RangeError("'byteOffset' must be an integer.");
          if (m < 0 || m >= p.byteLength)
            throw new RangeError(`'byteOffset' is out of range [0, ${p.byteLength}).`);
          if (g = e.byteLength - m, typeof n == "number") {
            if (g = n, !Number.isSafeInteger(g))
              throw new RangeError("'byteLength' must be an integer.");
            if (g <= 0 || m + g > p.byteLength)
              throw new RangeError(`'byteLength' is out of range (0, ${p.byteLength - m}].`);
            if (typeof o == "object" && o !== null)
              s = o;
            else if (typeof o < "u")
              throw new TypeError("'options' must be an object.");
          } else if (typeof n < "u")
            throw new TypeError("'byteLength' must be a number.");
        } else if (typeof r < "u")
          throw new TypeError("'options' must be an object.");
        i = new Uint8Array(p, m, g);
      } else
        throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
      let [u, d] = await za(s), c = await u.createInferenceSessionHandler(i, d);
      return _t("InferenceSession.create"), Me(), new t(c);
    }
    startProfiling() {
      this.handler.startProfiling();
    }
    endProfiling() {
      this.handler.endProfiling();
    }
    get inputNames() {
      return this.handler.inputNames;
    }
    get outputNames() {
      return this.handler.outputNames;
    }
    get inputMetadata() {
      return this.handler.inputMetadata;
    }
    get outputMetadata() {
      return this.handler.outputMetadata;
    }
  };
});
var vf;
var rs = V(() => {
  ts();
  vf = Tr;
});
var ns = V(() => {});
var os = V(() => {});
var is = V(() => {});
var as = V(() => {});
var Zn = {};
Vt(Zn, { InferenceSession: () => vf, TRACE: () => Sr, TRACE_EVENT_BEGIN: () => wt, TRACE_EVENT_END: () => _t, TRACE_FUNC_BEGIN: () => Ne, TRACE_FUNC_END: () => Me, Tensor: () => Ke, env: () => ye, registerBackend: () => kt });
var Ve = V(() => {
  Da();
  Ua();
  rs();
  Kn();
  ns();
  os();
  jn();
  is();
  as();
});
var Ir = V(() => {});
var ls = {};
Vt(ls, { default: () => $f });
var us;
var ds;
var $f;
var cs = V(() => {
  Qn();
  vt();
  Cr();
  us = "ort-wasm-proxy-worker", ds = globalThis.self?.name === us;
  ds && (self.onmessage = (t) => {
    let { type: e, in: r } = t.data;
    try {
      switch (e) {
        case "init-wasm":
          Ar(r.wasm).then(() => {
            Er(r).then(() => {
              postMessage({ type: e });
            }, (n) => {
              postMessage({ type: e, err: n });
            });
          }, (n) => {
            postMessage({ type: e, err: n });
          });
          break;
        case "init-ep": {
          let { epName: n, env: o } = r;
          kr(o, n).then(() => {
            postMessage({ type: e });
          }, (i) => {
            postMessage({ type: e, err: i });
          });
          break;
        }
        case "copy-from": {
          let { buffer: n } = r, o = Jt(n);
          postMessage({ type: e, out: o });
          break;
        }
        case "create": {
          let { model: n, options: o } = r;
          Pr(n, o).then((i) => {
            postMessage({ type: e, out: i });
          }, (i) => {
            postMessage({ type: e, err: i });
          });
          break;
        }
        case "release":
          Or(r), postMessage({ type: e });
          break;
        case "run": {
          let { sessionId: n, inputIndices: o, inputs: i, outputIndices: s, options: u } = r;
          zr(n, o, i, s, new Array(s.length).fill(null), u).then((d) => {
            d.some((c) => c[3] !== "cpu") ? postMessage({ type: e, err: "Proxy does not support non-cpu tensor location." }) : postMessage({ type: e, out: d }, Br([...i, ...d]));
          }, (d) => {
            postMessage({ type: e, err: d });
          });
          break;
        }
        case "end-profiling":
          Dr(r), postMessage({ type: e });
          break;
        default:
      }
    } catch (n) {
      postMessage({ type: e, err: n });
    }
  });
  $f = ds ? null : (t) => new Worker(t ?? Le, { type: "module", name: us });
});
var ms = {};
Vt(ms, { default: () => xf });
async function ps(t = {}) {
  var e = t, r = !!globalThis.window, n = !!globalThis.WorkerGlobalScope, o = n && self.name?.startsWith("em-pthread");
  e.mountExternalData = (a, l) => {
    a.startsWith("./") && (a = a.substring(2)), (e.Zc || (e.Zc = new Map)).set(a, l);
  }, e.unmountExternalData = () => {
    delete e.Zc;
  }, globalThis.SharedArrayBuffer ?? new WebAssembly.Memory({ initial: 0, maximum: 0, ae: true }).buffer.constructor;
  let i = (a) => async (...l) => {
    try {
      if (e.$c)
        throw Error("Session already started");
      let h = e.$c = { Nd: l[0], errors: [] }, f = await a(...l);
      if (e.$c !== h)
        throw Error("Session mismatch");
      e.gd?.flush();
      let _ = h.errors;
      if (0 < _.length) {
        let C = await Promise.all(_);
        if (C = C.filter((P) => P), 0 < C.length)
          throw Error(C.join(`
`));
      }
      return f;
    } finally {
      e.$c = null;
    }
  };
  e.jsepInit = (a, l) => {
    if (a === "webgpu") {
      [e.gd, e.Dd, e.Hd, e.jd, e.Gd, e.ac, e.Id, e.Kd, e.Ed, e.Fd, e.Jd] = l;
      let h = e.gd;
      e.jsepRegisterBuffer = (f, _, C, P) => h.registerBuffer(f, _, C, P), e.jsepGetBuffer = (f) => h.getBuffer(f), e.jsepCreateDownloader = (f, _, C) => h.createDownloader(f, _, C), e.jsepOnCreateSession = (f) => {
        h.onCreateSession(f);
      }, e.jsepOnReleaseSession = (f) => {
        h.onReleaseSession(f);
      }, e.jsepOnRunStart = (f) => h.onRunStart(f), e.Ld = (f, _) => {
        h.upload(f, _);
      };
    } else if (a === "webnn") {
      let h = l[0];
      [e.Zd, e.vd, e.webnnEnsureTensor, e.xd, e.webnnDownloadTensor, e.Yd, e.webnnEnableTraceEvent] = l.slice(1), e.webnnReleaseTensorId = e.vd, e.webnnUploadTensor = e.xd, e.webnnRegisterMLContext = e.Yd, e.webnnOnRunStart = (f) => h.onRunStart(f), e.webnnOnRunEnd = h.onRunEnd.bind(h), e.webnnOnReleaseSession = (f) => {
        h.onReleaseSession(f);
      }, e.webnnCreateMLTensorDownloader = (f, _) => h.createMLTensorDownloader(f, _), e.webnnRegisterMLTensor = (f, _, C, P) => h.registerMLTensor(f, _, C, P), e.webnnCreateMLContext = (f) => h.createMLContext(f), e.webnnRegisterMLConstant = (f, _, C, P, B, G) => h.registerMLConstant(f, _, C, P, B, e.Zc, G), e.webnnRegisterGraphInput = h.registerGraphInput.bind(h), e.webnnIsGraphInput = h.isGraphInput.bind(h), e.webnnRegisterGraphOutput = h.registerGraphOutput.bind(h), e.webnnIsGraphOutput = h.isGraphOutput.bind(h), e.webnnCreateTemporaryTensor = h.createTemporaryTensor.bind(h), e.webnnIsGraphInputOutputTypeSupported = h.isGraphInputOutputTypeSupported.bind(h);
    }
  };
  let s = () => {
    let a = (l) => (...h) => {
      let f = et;
      return h = l(...h), et != f ? new Promise((_, C) => {
        En = { resolve: _, reject: C };
      }) : h;
    };
    (() => {
      for (let l of ["_OrtAppendExecutionProvider", "_OrtCreateSession", "_OrtRun", "_OrtRunWithBinding", "_OrtBindInput"])
        e[l] = a(e[l]);
    })(), i !== undefined && (e._OrtRun = i(e._OrtRun), e._OrtRunWithBinding = i(e._OrtRunWithBinding)), s = undefined;
  };
  e.asyncInit = () => {
    s?.();
  };
  var u, d, c = (a, l) => {
    throw l;
  }, p = import.meta.url, m = "";
  if (r || n) {
    try {
      m = new URL(".", p).href;
    } catch {}
    n && (d = (a) => {
      var l = new XMLHttpRequest;
      return l.open("GET", a, false), l.responseType = "arraybuffer", l.send(null), new Uint8Array(l.response);
    }), u = async (a) => {
      if (z(a))
        return new Promise((h, f) => {
          var _ = new XMLHttpRequest;
          _.open("GET", a, true), _.responseType = "arraybuffer", _.onload = () => {
            _.status == 200 || _.status == 0 && _.response ? h(_.response) : f(_.status);
          }, _.onerror = f, _.send(null);
        });
      var l = await fetch(a, { credentials: "same-origin" });
      if (l.ok)
        return l.arrayBuffer();
      throw Error(l.status + " : " + l.url);
    };
  }
  var g, b, y, w, S, x, $ = console.log.bind(console), T = console.error.bind(console), I = $, E = T, A = false, z = (a) => a.startsWith("file://");
  function v() {
    ht.buffer != N.buffer && Te();
  }
  if (o) {
    let a = function(l) {
      try {
        var h = l.data, f = h.Uc;
        if (f === "load") {
          let _ = [];
          self.onmessage = (C) => _.push(C), x = () => {
            postMessage({ Uc: "loaded" });
            for (let C of _)
              a(C);
            self.onmessage = a;
          };
          for (let C of h.Ad)
            e[C] && !e[C].proxy || (e[C] = (...P) => {
              postMessage({ Uc: "callHandler", zd: C, args: P });
            }, C == "print" && (I = e[C]), C == "printErr" && (E = e[C]));
          ht = h.Vd, Te(), b = h.Wd, Se(), vr();
        } else if (f === "run") {
          (function(_) {
            var C = (v(), W)[_ + 52 >>> 2 >>> 0];
            _ = (v(), W)[_ + 56 >>> 2 >>> 0], Wi(C, C - _), de(C);
          })(h.Tc), Dn(h.Tc, 0, 0, 1, 0, 0), Go(), In(h.Tc), M || (Mi(), M = true);
          try {
            op(h.Pd, h.dd);
          } catch (_) {
            if (_ != "unwind")
              throw _;
          }
        } else
          h.target !== "setimmediate" && (f === "checkMailbox" ? M && fr() : f && (E(`worker: received unknown command ${f}`), E(h)));
      } catch (_) {
        throw Ri(), _;
      }
    };
    var Yy = a, M = false;
    self.onunhandledrejection = (l) => {
      throw l.reason || l;
    }, self.onmessage = a;
  }
  var N, K, q, Q, D, W, j, Y, Z, te, ie, we = false;
  function Te() {
    var a = ht.buffer;
    e.HEAP8 = N = new Int8Array(a), q = new Int16Array(a), e.HEAPU8 = K = new Uint8Array(a), Q = new Uint16Array(a), e.HEAP32 = D = new Int32Array(a), e.HEAPU32 = W = new Uint32Array(a), j = new Float32Array(a), Y = new Float64Array(a), Z = new BigInt64Array(a), te = new BigUint64Array(a);
  }
  function re() {
    we = true, o ? x() : ct.tb();
  }
  function U(a) {
    throw E(a = "Aborted(" + a + ")"), A = true, a = new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info."), S?.(a), a;
  }
  function X() {
    return { a: { ma: Em, hb: Am, g: ip, J: ap, f: sp, o: up, h: dp, ha: lp, b: cp, T: pp, Ia: Zo, n: mp, _: Jo, Ya: ei, Ea: ti, Ga: ri, Za: ni, Wa: oi, Pa: ii, Va: ai, ka: si, Fa: ui, Ca: di, Xa: li, Da: ci, cb: fp, ea: gp, xa: yp, va: wp, da: vp, O: $p, H: xp, wa: Sp, Z: Pp, ya: Op, Sa: zp, Aa: Bp, Ja: Mp, ta: Rp, fa: Up, Ra: In, $a: Np, R: Gp, s: jp, c: Sn, ib: Zp, y: Qp, M: Yp, D: Xp, m: Jp, t: wi, jb: em, I: tm, S: rm, j: nm, v: om, r: im, l: am, Ma: sm, Na: um, Oa: dm, Ka: xi, La: Si, ua: Ti, eb: cm, bb: fm, u: hm, aa: gm, ga: ym, ab: pm, V: bm, _a: wm, Ba: _m, F: lm, U: vm, la: wr, za: xm, gb: $m, fb: Sm, Ta: Ei, Ua: ki, Ha: wn, $: Pi, ja: Oi, Qa: zi, ia: Di, lb: mf, na: af, mb: pf, oa: of, G: Zm, d: zm, q: Pm, w: km, B: Gm, pb: tf, K: qm, x: Bm, pa: rf, X: sf, ba: ef, nb: cf, ob: lf, ra: Qm, qa: Jm, qb: Ym, N: Km, Y: nf, e: Dm, A: Mm, k: Om, kb: ff, p: Um, z: Nm, C: Rm, E: Vm, L: Hm, rb: jm, Q: uf, ca: Fm, W: df, sb: Wm, sa: Lm, P: Xm, i: Im, a: ht, db: dr } };
  }
  async function Se() {
    function a(f, _) {
      var C = ct = f.exports;
      f = {};
      for (let [P, B] of Object.entries(C))
        typeof B == "function" ? (C = Vp(B), f[P] = C) : f[P] = B;
      return ct = f, ct = function() {
        var P = ct, B = (H) => (ue) => H(ue) >>> 0, G = (H) => () => H() >>> 0;
        return (P = Object.assign({}, P)).ub = B(P.ub), P.Yb = G(P.Yb), P._b = B(P._b), P.mc = B(P.mc), P.nc = G(P.nc), P.rc = B(P.rc), P;
      }(), Lo.push(ct.$b), Bi = (f = ct).ub, Mi = f.vb, e._OrtInit = f.wb, e._OrtGetLastError = f.xb, e._OrtCreateSessionOptions = f.yb, e._OrtAppendExecutionProvider = f.zb, e._OrtAddFreeDimensionOverride = f.Ab, e._OrtAddSessionConfigEntry = f.Bb, e._OrtReleaseSessionOptions = f.Cb, e._OrtCreateSession = f.Db, e._OrtReleaseSession = f.Eb, e._OrtGetInputOutputCount = f.Fb, e._OrtGetInputOutputMetadata = f.Gb, e._OrtFree = f.Hb, e._OrtCreateTensor = f.Ib, e._OrtGetTensorData = f.Jb, e._OrtReleaseTensor = f.Kb, e._OrtCreateRunOptions = f.Lb, e._OrtAddRunConfigEntry = f.Mb, e._OrtReleaseRunOptions = f.Nb, e._OrtCreateBinding = f.Ob, e._OrtBindInput = f.Pb, e._OrtBindOutput = f.Qb, e._OrtClearBoundOutputs = f.Rb, e._OrtReleaseBinding = f.Sb, e._OrtRunWithBinding = f.Tb, e._OrtRun = f.Ub, e._OrtEndProfiling = f.Vb, e._JsepOutput = f.Wb, e._JsepGetNodeName = f.Xb, _r = f.Yb, tt = e._free = f.Zb, Zt = e._malloc = f._b, Dn = f.bc, Ri = f.cc, Ui = f.dc, Ni = f.ec, Bn = f.fc, Vi = f.gc, Li = f.hc, ce = f.ic, Qt = f.jc, Wi = f.kc, de = f.lc, Mn = f.mc, le = f.nc, Gi = f.oc, Rn = f.pc, Hi = f.qc, Fi = f.rc, qi = f.sc, Un = f.tc, Ki = f.uc, ji = f.vc, Zi = f.wc, Qi = f.xc, Yi = f.yc, Xi = f.zc, Ji = f.Ac, ea = f.Bc, ta = f.Cc, ra = f.Dc, na = f.Ec, oa = f.Fc, ia = f.Gc, aa = f.Hc, sa = f.Ic, ua = f.Jc, da = f.Kc, la = f.Lc, ca = f.Mc, pa = f.Nc, ma = f.Oc, fa = f.Pc, ha = f.Rc, ga = f.Sc, ya = f.bd, ba = f.cd, wa = f.hd, _a = f.kd, va = f.ld, $a = f.md, xa = f.nd, Sa = f.od, Ta = f.pd, Ia = f.qd, Ca = f.rd, Aa = f.wd, Ea = f.Rd, ka = f.Sd, Pa = f.Td, Oa = f.Ud, b = _, ct;
    }
    var l, h = X();
    return e.instantiateWasm ? new Promise((f) => {
      e.instantiateWasm(h, (_, C) => {
        f(a(_, C));
      });
    }) : o ? a(new WebAssembly.Instance(b, X()), b) : (ie ??= e.locateFile ? e.locateFile ? e.locateFile("ort-wasm-simd-threaded.jsep.wasm", m) : m + "ort-wasm-simd-threaded.jsep.wasm" : new URL("ort-wasm-simd-threaded.jsep.wasm", import.meta.url).href, l = await async function(f) {
      var _ = ie;
      if (!g && !z(_))
        try {
          var C = fetch(_, { credentials: "same-origin" });
          return await WebAssembly.instantiateStreaming(C, f);
        } catch (P) {
          E(`wasm streaming compile failed: ${P}`), E("falling back to ArrayBuffer instantiation");
        }
      return async function(P, B) {
        try {
          var G = await async function(H) {
            if (!g)
              try {
                var ue = await u(H);
                return new Uint8Array(ue);
              } catch {}
            if (H == ie && g)
              H = new Uint8Array(g);
            else {
              if (!d)
                throw "both async and sync fetching of the wasm failed";
              H = d(H);
            }
            return H;
          }(P);
          return await WebAssembly.instantiate(G, B);
        } catch (H) {
          E(`failed to asynchronously prepare wasm: ${H}`), U(H);
        }
      }(_, f);
    }(h), a(l.instance, l.module));
  }

  class Be {
    name = "ExitStatus";
    constructor(l) {
      this.message = `Program terminated with exit(${l})`, this.status = l;
    }
  }
  var ze = (a) => {
    a.terminate(), a.onmessage = () => {};
  }, Xe = [], Ce = 0, $e = null, Fe = (a) => {
    ft.length == 0 && (Fo(), Ho(ft[0]));
    var l = ft.pop();
    if (!l)
      return 6;
    Kt.push(l), It[a.Tc] = l, l.Tc = a.Tc;
    var h = { Uc: "run", Pd: a.Od, dd: a.dd, Tc: a.Tc };
    return l.postMessage(h, a.ud), 0;
  }, Ue = 0, ve = (a, l, ...h) => {
    var f, _ = 16 * h.length, C = le(), P = Mn(_), B = P >>> 3;
    for (f of h)
      typeof f == "bigint" ? ((v(), Z)[B++ >>> 0] = 1n, (v(), Z)[B++ >>> 0] = f) : ((v(), Z)[B++ >>> 0] = 0n, (v(), Y)[B++ >>> 0] = f);
    return a = Ui(a, 0, _, P, l), de(C), a;
  };
  function dr(a) {
    if (o)
      return ve(0, 1, a);
    if (y = a, !(0 < Ue)) {
      for (var l of Kt)
        ze(l);
      for (l of ft)
        ze(l);
      ft = [], Kt = [], It = {}, A = true;
    }
    c(0, new Be(a));
  }
  function Vo(a) {
    if (o)
      return ve(1, 0, a);
    wn(a);
  }
  var wn = (a) => {
    if (y = a, o)
      throw Vo(a), "unwind";
    dr(a);
  }, ft = [], Kt = [], Lo = [], It = {}, Wo = (a) => {
    var l = a.Tc;
    delete It[l], ft.push(a), Kt.splice(Kt.indexOf(a), 1), a.Tc = 0, Ni(l);
  };
  function Go() {
    Lo.forEach((a) => a());
  }
  var Ho = (a) => new Promise((l) => {
    a.onmessage = (_) => {
      var C = _.data;
      if (_ = C.Uc, C.ad && C.ad != _r()) {
        var P = It[C.ad];
        P ? P.postMessage(C, C.ud) : E(`Internal error! Worker sent a message "${_}" to target pthread ${C.ad}, but that thread no longer exists!`);
      } else
        _ === "checkMailbox" ? fr() : _ === "spawnThread" ? Fe(C) : _ === "cleanupThread" ? mr(() => {
          Wo(It[C.Qd]);
        }) : _ === "loaded" ? (a.loaded = true, l(a)) : C.target === "setimmediate" ? a.postMessage(C) : _ === "uncaughtException" ? a.onerror(C.error) : _ === "callHandler" ? e[C.zd](...C.args) : _ && E(`worker sent an unknown command ${_}`);
    }, a.onerror = (_) => {
      throw E(`worker sent an error! ${_.filename}:${_.lineno}: ${_.message}`), _;
    };
    var h, f = [];
    for (h of [])
      e.propertyIsEnumerable(h) && f.push(h);
    a.postMessage({ Uc: "load", Ad: f, Vd: ht, Wd: b });
  });
  function Fo() {
    var a = new Worker((() => {
      let l = URL;
      return import.meta.url > "file:" && import.meta.url < "file;" ? new l("ort.bundle.min.mjs", import.meta.url) : new URL(import.meta.url);
    })(), { type: "module", workerData: "em-pthread", name: "em-pthread" });
    ft.push(a);
  }
  var ht, op = (a, l) => {
    Ue = 0, a = Un(a, l), 0 < Ue ? y = a : Bn(a);
  }, lr = [], cr = 0;
  function ip(a) {
    var l = new _n(a >>>= 0);
    return (v(), N)[l.Vc + 12 >>> 0] == 0 && (qo(l, true), cr--), Ko(l, false), lr.push(l), Fi(a);
  }
  var Ut = 0, ap = () => {
    ce(0, 0);
    var a = lr.pop();
    Gi(a.ed), Ut = 0;
  };
  function qo(a, l) {
    l = l ? 1 : 0, (v(), N)[a.Vc + 12 >>> 0] = l;
  }
  function Ko(a, l) {
    l = l ? 1 : 0, (v(), N)[a.Vc + 13 >>> 0] = l;
  }

  class _n {
    constructor(l) {
      this.ed = l, this.Vc = l - 24;
    }
  }
  var vn = (a) => {
    var l = Ut;
    if (!l)
      return Qt(0), 0;
    var h = new _n(l);
    (v(), W)[h.Vc + 16 >>> 2 >>> 0] = l;
    var f = (v(), W)[h.Vc + 4 >>> 2 >>> 0];
    if (!f)
      return Qt(0), l;
    for (var _ of a) {
      if (_ === 0 || _ === f)
        break;
      if (Hi(_, f, h.Vc + 16))
        return Qt(_), l;
    }
    return Qt(f), l;
  };
  function sp() {
    return vn([]);
  }
  function up(a) {
    return vn([a >>> 0]);
  }
  function dp(a, l, h, f) {
    return vn([a >>> 0, l >>> 0, h >>> 0, f >>> 0]);
  }
  var lp = () => {
    var a = lr.pop();
    a || U("no exception to throw");
    var l = a.ed;
    throw (v(), N)[a.Vc + 13 >>> 0] == 0 && (lr.push(a), Ko(a, true), qo(a, false), cr++), Rn(l), Ut = l;
  };
  function cp(a, l, h) {
    var f = new _n(a >>>= 0);
    throw l >>>= 0, h >>>= 0, (v(), W)[f.Vc + 16 >>> 2 >>> 0] = 0, (v(), W)[f.Vc + 4 >>> 2 >>> 0] = l, (v(), W)[f.Vc + 8 >>> 2 >>> 0] = h, Rn(a), cr++, Ut = a;
  }
  var pp = () => cr;
  function jo(a, l, h, f) {
    return o ? ve(2, 1, a, l, h, f) : Zo(a, l, h, f);
  }
  function Zo(a, l, h, f) {
    if (a >>>= 0, l >>>= 0, h >>>= 0, f >>>= 0, !globalThis.SharedArrayBuffer)
      return 6;
    var _ = [];
    return o && _.length === 0 ? jo(a, l, h, f) : (a = { Od: h, Tc: a, dd: f, ud: _ }, o ? (a.Uc = "spawnThread", postMessage(a, _), 0) : Fe(a));
  }
  function mp(a) {
    throw Ut ||= a >>> 0, Ut;
  }
  var Qo = globalThis.TextDecoder && new TextDecoder, Yo = (a, l, h, f) => {
    if (h = l + h, f)
      return h;
    for (;a[l] && !(l >= h); )
      ++l;
    return l;
  }, Xo = (a, l = 0, h, f) => {
    if (16 < (h = Yo(a, l >>>= 0, h, f)) - l && a.buffer && Qo)
      return Qo.decode(a.buffer instanceof ArrayBuffer ? a.subarray(l, h) : a.slice(l, h));
    for (f = "";l < h; ) {
      var _ = a[l++];
      if (128 & _) {
        var C = 63 & a[l++];
        if ((224 & _) == 192)
          f += String.fromCharCode((31 & _) << 6 | C);
        else {
          var P = 63 & a[l++];
          65536 > (_ = (240 & _) == 224 ? (15 & _) << 12 | C << 6 | P : (7 & _) << 18 | C << 12 | P << 6 | 63 & a[l++]) ? f += String.fromCharCode(_) : (_ -= 65536, f += String.fromCharCode(55296 | _ >> 10, 56320 | 1023 & _));
        }
      } else
        f += String.fromCharCode(_);
    }
    return f;
  }, Ae = (a, l, h) => (a >>>= 0) ? Xo((v(), K), a, l, h) : "";
  function Jo(a, l, h) {
    return o ? ve(3, 1, a, l, h) : 0;
  }
  function ei(a, l) {
    if (o)
      return ve(4, 1, a, l);
  }
  function ti(a, l) {
    if (o)
      return ve(5, 1, a, l);
  }
  function ri(a, l, h) {
    if (o)
      return ve(6, 1, a, l, h);
  }
  function ni(a, l, h) {
    return o ? ve(7, 1, a, l, h) : 0;
  }
  function oi(a, l) {
    if (o)
      return ve(8, 1, a, l);
  }
  function ii(a, l, h) {
    if (o)
      return ve(9, 1, a, l, h);
  }
  function ai(a, l, h, f) {
    if (o)
      return ve(10, 1, a, l, h, f);
  }
  function si(a, l, h, f) {
    if (o)
      return ve(11, 1, a, l, h, f);
  }
  function ui(a, l, h, f) {
    if (o)
      return ve(12, 1, a, l, h, f);
  }
  function di(a) {
    if (o)
      return ve(13, 1, a);
  }
  function li(a, l) {
    if (o)
      return ve(14, 1, a, l);
  }
  function ci(a, l, h) {
    if (o)
      return ve(15, 1, a, l, h);
  }
  var fp = () => U(""), Je = (a) => {
    a >>>= 0;
    for (var l = "";; ) {
      var h = (v(), K)[a++ >>> 0];
      if (!h)
        return l;
      l += String.fromCharCode(h);
    }
  }, $n = {}, xn = {}, hp = {}, Nt = class extends Error {
    constructor(a) {
      super(a), this.name = "BindingError";
    }
  };
  function lt(a, l, h = {}) {
    return function(f, _, C = {}) {
      var P = _.name;
      if (!f)
        throw new Nt(`type "${P}" must have a positive integer typeid pointer`);
      if (xn.hasOwnProperty(f)) {
        if (C.Bd)
          return;
        throw new Nt(`Cannot register type '${P}' twice`);
      }
      xn[f] = _, delete hp[f], $n.hasOwnProperty(f) && (_ = $n[f], delete $n[f], _.forEach((B) => B()));
    }(a, l, h);
  }
  var pi = (a, l, h) => {
    switch (l) {
      case 1:
        return h ? (f) => (v(), N)[f >>> 0] : (f) => (v(), K)[f >>> 0];
      case 2:
        return h ? (f) => (v(), q)[f >>> 1 >>> 0] : (f) => (v(), Q)[f >>> 1 >>> 0];
      case 4:
        return h ? (f) => (v(), D)[f >>> 2 >>> 0] : (f) => (v(), W)[f >>> 2 >>> 0];
      case 8:
        return h ? (f) => (v(), Z)[f >>> 3 >>> 0] : (f) => (v(), te)[f >>> 3 >>> 0];
      default:
        throw new TypeError(`invalid integer width (${l}): ${a}`);
    }
  };
  function gp(a, l, h, f, _) {
    a >>>= 0, h >>>= 0, l = Je(l >>> 0);
    let C = (P) => P;
    if (f = f === 0n) {
      let P = 8 * h;
      C = (B) => BigInt.asUintN(P, B), _ = C(_);
    }
    lt(a, { name: l, Qc: C, Xc: (P, B) => (typeof B == "number" && (B = BigInt(B)), B), Wc: pi(l, h, !f), Yc: null });
  }
  function yp(a, l, h, f) {
    lt(a >>>= 0, { name: l = Je(l >>> 0), Qc: function(_) {
      return !!_;
    }, Xc: function(_, C) {
      return C ? h : f;
    }, Wc: function(_) {
      return this.Qc((v(), K)[_ >>> 0]);
    }, Yc: null });
  }
  var mi = [], Ct = [0, 1, , 1, null, 1, true, 1, false, 1];
  function Sn(a) {
    9 < (a >>>= 0) && --Ct[a + 1] == 0 && (Ct[a] = undefined, mi.push(a));
  }
  var Ge = (a) => {
    if (!a)
      throw new Nt(`Cannot use deleted val. handle = ${a}`);
    return Ct[a];
  }, qe = (a) => {
    switch (a) {
      case undefined:
        return 2;
      case null:
        return 4;
      case true:
        return 6;
      case false:
        return 8;
      default:
        let l = mi.pop() || Ct.length;
        return Ct[l] = a, Ct[l + 1] = 1, l;
    }
  };
  function Tn(a) {
    return this.Qc((v(), W)[a >>> 2 >>> 0]);
  }
  var bp = { name: "emscripten::val", Qc: (a) => {
    var l = Ge(a);
    return Sn(a), l;
  }, Xc: (a, l) => qe(l), Wc: Tn, Yc: null };
  function wp(a) {
    return lt(a >>> 0, bp);
  }
  var _p = (a, l) => {
    switch (l) {
      case 4:
        return function(h) {
          return this.Qc((v(), j)[h >>> 2 >>> 0]);
        };
      case 8:
        return function(h) {
          return this.Qc((v(), Y)[h >>> 3 >>> 0]);
        };
      default:
        throw new TypeError(`invalid float width (${l}): ${a}`);
    }
  };
  function vp(a, l, h) {
    h >>>= 0, lt(a >>>= 0, { name: l = Je(l >>> 0), Qc: (f) => f, Xc: (f, _) => _, Wc: _p(l, h), Yc: null });
  }
  function $p(a, l, h, f, _) {
    a >>>= 0, h >>>= 0, l = Je(l >>> 0);
    let C = (B) => B;
    if (f === 0) {
      var P = 32 - 8 * h;
      C = (B) => B << P >>> P, _ = C(_);
    }
    lt(a, { name: l, Qc: C, Xc: (B, G) => G, Wc: pi(l, h, f !== 0), Yc: null });
  }
  function xp(a, l, h) {
    function f(C) {
      var P = (v(), W)[C >>> 2 >>> 0];
      return C = (v(), W)[C + 4 >>> 2 >>> 0], new _((v(), N).buffer, C, P);
    }
    var _ = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, BigInt64Array, BigUint64Array][l];
    lt(a >>>= 0, { name: h = Je(h >>> 0), Qc: f, Wc: f }, { Bd: true });
  }
  var gt = (a, l, h) => {
    var f = (v(), K);
    if (l >>>= 0, 0 < h) {
      var _ = l;
      h = l + h - 1;
      for (var C = 0;C < a.length; ++C) {
        var P = a.codePointAt(C);
        if (127 >= P) {
          if (l >= h)
            break;
          f[l++ >>> 0] = P;
        } else if (2047 >= P) {
          if (l + 1 >= h)
            break;
          f[l++ >>> 0] = 192 | P >> 6, f[l++ >>> 0] = 128 | 63 & P;
        } else if (65535 >= P) {
          if (l + 2 >= h)
            break;
          f[l++ >>> 0] = 224 | P >> 12, f[l++ >>> 0] = 128 | P >> 6 & 63, f[l++ >>> 0] = 128 | 63 & P;
        } else {
          if (l + 3 >= h)
            break;
          f[l++ >>> 0] = 240 | P >> 18, f[l++ >>> 0] = 128 | P >> 12 & 63, f[l++ >>> 0] = 128 | P >> 6 & 63, f[l++ >>> 0] = 128 | 63 & P, C++;
        }
      }
      f[l >>> 0] = 0, a = l - _;
    } else
      a = 0;
    return a;
  }, pr = (a) => {
    for (var l = 0, h = 0;h < a.length; ++h) {
      var f = a.charCodeAt(h);
      127 >= f ? l++ : 2047 >= f ? l += 2 : 55296 <= f && 57343 >= f ? (l += 4, ++h) : l += 3;
    }
    return l;
  };
  function Sp(a, l) {
    lt(a >>>= 0, { name: l = Je(l >>> 0), Qc(h) {
      var f = (v(), W)[h >>> 2 >>> 0];
      return f = Ae(h + 4, f, true), tt(h), f;
    }, Xc(h, f) {
      f instanceof ArrayBuffer && (f = new Uint8Array(f));
      var _ = typeof f == "string";
      if (!(_ || ArrayBuffer.isView(f) && f.BYTES_PER_ELEMENT == 1))
        throw new Nt("Cannot pass non-string to std::string");
      var C = _ ? pr(f) : f.length, P = Zt(4 + C + 1), B = P + 4;
      return (v(), W)[P >>> 2 >>> 0] = C, _ ? gt(f, B, C + 1) : (v(), K).set(f, B >>> 0), h !== null && h.push(tt, P), P;
    }, Wc: Tn, Yc(h) {
      tt(h);
    } });
  }
  var fi = globalThis.TextDecoder ? new TextDecoder("utf-16le") : undefined, Tp = (a, l, h) => {
    if (a >>>= 1, 16 < (l = Yo((v(), Q), a, l / 2, h)) - a && fi)
      return fi.decode((v(), Q).slice(a, l));
    for (h = "";a < l; ++a) {
      var f = (v(), Q)[a >>> 0];
      h += String.fromCharCode(f);
    }
    return h;
  }, Ip = (a, l, h) => {
    if (h ??= 2147483647, 2 > h)
      return 0;
    var f = l;
    h = (h -= 2) < 2 * a.length ? h / 2 : a.length;
    for (var _ = 0;_ < h; ++_) {
      var C = a.charCodeAt(_);
      (v(), q)[l >>> 1 >>> 0] = C, l += 2;
    }
    return (v(), q)[l >>> 1 >>> 0] = 0, l - f;
  }, Cp = (a) => 2 * a.length, Ap = (a, l, h) => {
    var f = "";
    a >>>= 2;
    for (var _ = 0;!(_ >= l / 4); _++) {
      var C = (v(), W)[a + _ >>> 0];
      if (!C && !h)
        break;
      f += String.fromCodePoint(C);
    }
    return f;
  }, Ep = (a, l, h) => {
    if (l >>>= 0, h ??= 2147483647, 4 > h)
      return 0;
    var f = l;
    h = f + h - 4;
    for (var _ = 0;_ < a.length; ++_) {
      var C = a.codePointAt(_);
      if (65535 < C && _++, (v(), D)[l >>> 2 >>> 0] = C, (l += 4) + 4 > h)
        break;
    }
    return (v(), D)[l >>> 2 >>> 0] = 0, l - f;
  }, kp = (a) => {
    for (var l = 0, h = 0;h < a.length; ++h)
      65535 < a.codePointAt(h) && h++, l += 4;
    return l;
  };
  function Pp(a, l, h) {
    if (a >>>= 0, l >>>= 0, h = Je(h >>>= 0), l === 2)
      var f = Tp, _ = Ip, C = Cp;
    else
      f = Ap, _ = Ep, C = kp;
    lt(a, { name: h, Qc: (P) => {
      var B = (v(), W)[P >>> 2 >>> 0];
      return B = f(P + 4, B * l, true), tt(P), B;
    }, Xc: (P, B) => {
      if (typeof B != "string")
        throw new Nt(`Cannot pass non-string to C++ string type ${h}`);
      var G = C(B), H = Zt(4 + G + l);
      return (v(), W)[H >>> 2 >>> 0] = G / l, _(B, H + 4, G + l), P !== null && P.push(tt, H), H;
    }, Wc: Tn, Yc(P) {
      tt(P);
    } });
  }
  function Op(a, l) {
    lt(a >>>= 0, { Cd: true, name: l = Je(l >>> 0), Qc: () => {}, Xc: () => {} });
  }
  function zp(a) {
    Dn(a >>> 0, !n, 1, !r, 131072, false), Go();
  }
  var mr = (a) => {
    if (!A)
      try {
        if (a(), !(0 < Ue))
          try {
            o ? _r() && Bn(y) : wn(y);
          } catch (l) {
            l instanceof Be || l == "unwind" || c(0, l);
          }
      } catch (l) {
        l instanceof Be || l == "unwind" || c(0, l);
      }
  }, Dp = !Atomics.waitAsync || globalThis.navigator?.userAgent && 91 > Number((navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./) || [])[2]);
  function In(a) {
    a >>>= 0, Dp || (Atomics.waitAsync((v(), D), a >>> 2, a).value.then(fr), a += 128, Atomics.store((v(), D), a >>> 2, 1));
  }
  var fr = () => mr(() => {
    var a = _r();
    a && (In(a), Li());
  });
  function Bp(a, l) {
    (a >>>= 0) == l >>> 0 ? setTimeout(fr) : o ? postMessage({ ad: a, Uc: "checkMailbox" }) : (a = It[a]) && a.postMessage({ Uc: "checkMailbox" });
  }
  var Cn = [];
  function Mp(a, l, h, f, _) {
    for (l >>>= 0, _ >>>= 0, Cn.length = 0, h = _ >>> 3, f = _ + f >>> 3;h < f; ) {
      var C;
      C = (v(), Z)[h++ >>> 0] ? (v(), Z)[h++ >>> 0] : (v(), Y)[h++ >>> 0], Cn.push(C);
    }
    return (l ? Nn[l] : Cm[a])(...Cn);
  }
  var Rp = () => {
    Ue = 0;
  };
  function Up(a) {
    a >>>= 0, o ? postMessage({ Uc: "cleanupThread", Qd: a }) : Wo(It[a]);
  }
  function Np(a) {}
  var hr = (a) => {
    try {
      a();
    } catch (l) {
      U(l);
    }
  };
  function Vp(a) {
    var l = (...h) => {
      gr.push(a);
      try {
        return a(...h);
      } finally {
        A || (gr.pop(), et && yt === 1 && gr.length === 0 && (yt = 0, Ue += 1, hr(ka), typeof Fibers < "u" && Fibers.ce()));
      }
    };
    return yi.set(a, l), l;
  }
  var yt = 0, et = null, hi = 0, gr = [], An = new Map, gi = new Map, yi = new Map, Lp = 0, En = null, Wp = [], bi = (a) => function(l) {
    if (!A) {
      if (yt === 0) {
        var h = false, f = false;
        l((_ = 0) => {
          if (!A && (hi = _, h = true, f)) {
            yt = 2, hr(() => Pa(et)), typeof MainLoop < "u" && MainLoop.yd && MainLoop.resume(), _ = false;
            try {
              var C = function() {
                var G = (v(), D)[et + 8 >>> 2 >>> 0];
                return G = gi.get(G), G = yi.get(G), --Ue, G();
              }();
            } catch (G) {
              C = G, _ = true;
            }
            var P = false;
            if (!et) {
              var B = En;
              B && (En = null, (_ ? B.reject : B.resolve)(C), P = true);
            }
            if (_ && !P)
              throw C;
          }
        }), f = true, h || (yt = 1, et = function() {
          var _ = Zt(65548), C = _ + 12;
          if ((v(), W)[_ >>> 2 >>> 0] = C, (v(), W)[_ + 4 >>> 2 >>> 0] = C + 65536, C = gr[0], !An.has(C)) {
            var P = Lp++;
            An.set(C, P), gi.set(P, C);
          }
          return C = An.get(C), (v(), D)[_ + 8 >>> 2 >>> 0] = C, _;
        }(), typeof MainLoop < "u" && MainLoop.yd && MainLoop.pause(), hr(() => Ea(et)));
      } else
        yt === 2 ? (yt = 0, hr(Oa), tt(et), et = null, Wp.forEach(mr)) : U(`invalid state: ${yt}`);
      return hi;
    }
  }((l) => {
    a().then(l);
  });
  function Gp(a) {
    return a >>>= 0, bi(async () => {
      var l = await Ge(a);
      return qe(l);
    });
  }
  var kn = [], Hp = (a) => {
    var l = kn.length;
    return kn.push(a), l;
  }, Fp = (a, l) => {
    for (var h = Array(a), f = 0;f < a; ++f) {
      var _ = f, C = (v(), W)[l + 4 * f >>> 2 >>> 0], P = xn[C];
      if (P === undefined)
        throw a = `parameter ${f}`, C = Bi(C), l = Je(C), tt(C), new Nt(`${a} has unknown type ${l}`);
      h[_] = P;
    }
    return h;
  }, qp = (a, l, h) => {
    var f = [];
    return a = a(f, h), f.length && ((v(), W)[l >>> 2 >>> 0] = qe(f)), a;
  }, Kp = {}, yr = (a) => {
    var l = Kp[a];
    return l === undefined ? Je(a) : l;
  };
  function jp(a, l, h) {
    var [f, ..._] = Fp(a, l >>> 0);
    l = f.Xc.bind(f);
    var C = _.map((G) => G.Wc.bind(G));
    a--;
    var P = { toValue: Ge };
    switch (a = C.map((G, H) => {
      var ue = `argFromPtr${H}`;
      return P[ue] = G, `${ue}(args${H ? "+" + 8 * H : ""})`;
    }), h) {
      case 0:
        var B = "toValue(handle)";
        break;
      case 2:
        B = "new (toValue(handle))";
        break;
      case 3:
        B = "";
        break;
      case 1:
        P.getStringOrSymbol = yr, B = "toValue(handle)[getStringOrSymbol(methodName)]";
    }
    return B += `(${a})`, f.Cd || (P.toReturnWire = l, P.emval_returnValue = qp, B = `return emval_returnValue(toReturnWire, destructorsRef, ${B})`), B = `return function (handle, methodName, destructorsRef, args) {
  ${B}
  }`, h = new Function(Object.keys(P), B)(...Object.values(P)), B = `methodCaller<(${_.map((G) => G.name)}) => ${f.name}>`, Hp(Object.defineProperty(h, "name", { value: B }));
  }
  function Zp(a, l) {
    return l >>>= 0, (a = Ge(a >>> 0)) == Ge(l);
  }
  function Qp(a) {
    return (a >>>= 0) ? (a = yr(a), qe(globalThis[a])) : qe(globalThis);
  }
  function Yp(a) {
    return a = yr(a >>> 0), qe(e[a]);
  }
  function Xp(a, l) {
    return l >>>= 0, a = Ge(a >>> 0), l = Ge(l), qe(a[l]);
  }
  function Jp(a) {
    9 < (a >>>= 0) && (Ct[a + 1] += 1);
  }
  function wi(a, l, h, f, _) {
    return kn[a >>> 0](l >>> 0, h >>> 0, f >>> 0, _ >>> 0);
  }
  function em(a, l, h, f, _) {
    return wi(a >>> 0, l >>> 0, h >>> 0, f >>> 0, _ >>> 0);
  }
  function tm() {
    return qe([]);
  }
  function rm(a) {
    a = Ge(a >>> 0);
    for (var l = Array(a.length), h = 0;h < a.length; h++)
      l[h] = a[h];
    return qe(l);
  }
  function nm(a) {
    return qe(yr(a >>> 0));
  }
  function om() {
    return qe({});
  }
  function im(a) {
    for (var l = Ge(a >>>= 0);l.length; ) {
      var h = l.pop();
      l.pop()(h);
    }
    Sn(a);
  }
  function am(a, l, h) {
    l >>>= 0, h >>>= 0, a = Ge(a >>> 0), l = Ge(l), h = Ge(h), a[l] = h;
  }
  function sm(a, l) {
    a = -9007199254740992 > a || 9007199254740992 < a ? NaN : Number(a), l >>>= 0, a = new Date(1000 * a), (v(), D)[l >>> 2 >>> 0] = a.getUTCSeconds(), (v(), D)[l + 4 >>> 2 >>> 0] = a.getUTCMinutes(), (v(), D)[l + 8 >>> 2 >>> 0] = a.getUTCHours(), (v(), D)[l + 12 >>> 2 >>> 0] = a.getUTCDate(), (v(), D)[l + 16 >>> 2 >>> 0] = a.getUTCMonth(), (v(), D)[l + 20 >>> 2 >>> 0] = a.getUTCFullYear() - 1900, (v(), D)[l + 24 >>> 2 >>> 0] = a.getUTCDay(), a = (a.getTime() - Date.UTC(a.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 86400000 | 0, (v(), D)[l + 28 >>> 2 >>> 0] = a;
  }
  var _i = (a) => a % 4 == 0 && (a % 100 != 0 || a % 400 == 0), vi = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], $i = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  function um(a, l) {
    a = -9007199254740992 > a || 9007199254740992 < a ? NaN : Number(a), l >>>= 0, a = new Date(1000 * a), (v(), D)[l >>> 2 >>> 0] = a.getSeconds(), (v(), D)[l + 4 >>> 2 >>> 0] = a.getMinutes(), (v(), D)[l + 8 >>> 2 >>> 0] = a.getHours(), (v(), D)[l + 12 >>> 2 >>> 0] = a.getDate(), (v(), D)[l + 16 >>> 2 >>> 0] = a.getMonth(), (v(), D)[l + 20 >>> 2 >>> 0] = a.getFullYear() - 1900, (v(), D)[l + 24 >>> 2 >>> 0] = a.getDay();
    var h = (_i(a.getFullYear()) ? vi : $i)[a.getMonth()] + a.getDate() - 1 | 0;
    (v(), D)[l + 28 >>> 2 >>> 0] = h, (v(), D)[l + 36 >>> 2 >>> 0] = -60 * a.getTimezoneOffset(), h = new Date(a.getFullYear(), 6, 1).getTimezoneOffset();
    var f = new Date(a.getFullYear(), 0, 1).getTimezoneOffset();
    a = 0 | (h != f && a.getTimezoneOffset() == Math.min(f, h)), (v(), D)[l + 32 >>> 2 >>> 0] = a;
  }
  function dm(a) {
    a >>>= 0;
    var l = new Date((v(), D)[a + 20 >>> 2 >>> 0] + 1900, (v(), D)[a + 16 >>> 2 >>> 0], (v(), D)[a + 12 >>> 2 >>> 0], (v(), D)[a + 8 >>> 2 >>> 0], (v(), D)[a + 4 >>> 2 >>> 0], (v(), D)[a >>> 2 >>> 0], 0), h = (v(), D)[a + 32 >>> 2 >>> 0], f = l.getTimezoneOffset(), _ = new Date(l.getFullYear(), 6, 1).getTimezoneOffset(), C = new Date(l.getFullYear(), 0, 1).getTimezoneOffset(), P = Math.min(C, _);
    return 0 > h ? (v(), D)[a + 32 >>> 2 >>> 0] = +(_ != C && P == f) : 0 < h != (P == f) && (_ = Math.max(C, _), l.setTime(l.getTime() + 60000 * ((0 < h ? P : _) - f))), (v(), D)[a + 24 >>> 2 >>> 0] = l.getDay(), h = (_i(l.getFullYear()) ? vi : $i)[l.getMonth()] + l.getDate() - 1 | 0, (v(), D)[a + 28 >>> 2 >>> 0] = h, (v(), D)[a >>> 2 >>> 0] = l.getSeconds(), (v(), D)[a + 4 >>> 2 >>> 0] = l.getMinutes(), (v(), D)[a + 8 >>> 2 >>> 0] = l.getHours(), (v(), D)[a + 12 >>> 2 >>> 0] = l.getDate(), (v(), D)[a + 16 >>> 2 >>> 0] = l.getMonth(), (v(), D)[a + 20 >>> 2 >>> 0] = l.getYear(), a = l.getTime(), BigInt(isNaN(a) ? -1 : a / 1000);
  }
  function xi(a, l, h, f, _, C, P) {
    return o ? ve(16, 1, a, l, h, f, _, C, P) : -52;
  }
  function Si(a, l, h, f, _, C) {
    if (o)
      return ve(17, 1, a, l, h, f, _, C);
  }
  var jt = {}, lm = () => performance.timeOrigin + performance.now();
  function Ti(a, l) {
    if (o)
      return ve(18, 1, a, l);
    if (jt[a] && (clearTimeout(jt[a].id), delete jt[a]), !l)
      return 0;
    var h = setTimeout(() => {
      delete jt[a], mr(() => Vi(a, performance.timeOrigin + performance.now()));
    }, l);
    return jt[a] = { id: h, be: l }, 0;
  }
  function cm(a, l, h, f) {
    a >>>= 0, l >>>= 0, h >>>= 0, f >>>= 0;
    var _ = new Date().getFullYear(), C = new Date(_, 0, 1).getTimezoneOffset();
    _ = new Date(_, 6, 1).getTimezoneOffset();
    var P = Math.max(C, _);
    (v(), W)[a >>> 2 >>> 0] = 60 * P, (v(), D)[l >>> 2 >>> 0] = +(C != _), a = (l = (B) => {
      var G = Math.abs(B);
      return `UTC${0 <= B ? "-" : "+"}${String(Math.floor(G / 60)).padStart(2, "0")}${String(G % 60).padStart(2, "0")}`;
    })(C), l = l(_), _ < C ? (gt(a, h, 17), gt(l, f, 17)) : (gt(a, f, 17), gt(l, h, 17));
  }
  var pm = () => Date.now(), mm = 1;
  function fm(a, l, h) {
    if (h >>>= 0, !(0 <= a && 3 >= a))
      return 28;
    if (a === 0)
      a = Date.now();
    else {
      if (!mm)
        return 52;
      a = performance.timeOrigin + performance.now();
    }
    return a = Math.round(1e6 * a), (v(), Z)[h >>> 3 >>> 0] = BigInt(a), 0;
  }
  var Pn = [], Ii = (a, l) => {
    Pn.length = 0;
    for (var h;h = (v(), K)[a++ >>> 0]; ) {
      var f = h != 105;
      l += (f &= h != 112) && l % 8 ? 4 : 0, Pn.push(h == 112 ? (v(), W)[l >>> 2 >>> 0] : h == 106 ? (v(), Z)[l >>> 3 >>> 0] : h == 105 ? (v(), D)[l >>> 2 >>> 0] : (v(), Y)[l >>> 3 >>> 0]), l += f ? 8 : 4;
    }
    return Pn;
  };
  function hm(a, l, h) {
    return a >>>= 0, l = Ii(l >>> 0, h >>> 0), Nn[a](...l);
  }
  function gm(a, l, h) {
    return a >>>= 0, l = Ii(l >>> 0, h >>> 0), Nn[a](...l);
  }
  var ym = () => {};
  function bm(a, l) {
    return E(Ae(a >>> 0, l >>> 0));
  }
  var wm = () => {
    throw Ue += 1, "unwind";
  };
  function _m() {
    return 4294901760;
  }
  var vm = () => navigator.hardwareConcurrency, At = {}, br = (a) => {
    var l;
    return (l = /\bwasm-function\[\d+\]:(0x[0-9a-f]+)/.exec(a)) ? +l[1] : (l = /:(\d+):\d+(?:\)|$)/.exec(a)) ? 2147483648 | +l[1] : 0;
  }, Ci = (a) => {
    for (var l of a)
      (a = br(l)) && (At[a] = l);
  };
  function $m() {
    var a = Error().stack.toString().split(`
`);
    return a[0] == "Error" && a.shift(), Ci(a), At.sd = br(a[3]), At.Md = a, At.sd;
  }
  function wr(a) {
    if (!(a = At[a >>> 0]))
      return 0;
    var l;
    if (l = /^\s+at .*\.wasm\.(.*) \(.*\)$/.exec(a))
      a = l[1];
    else if (l = /^\s+at (.*) \(.*\)$/.exec(a))
      a = l[1];
    else {
      if (!(l = /^(.+?)@/.exec(a)))
        return 0;
      a = l[1];
    }
    tt(wr.td ?? 0), l = pr(a) + 1;
    var h = Zt(l);
    return h && gt(a, h, l), wr.td = h, wr.td;
  }
  function xm(a) {
    a >>>= 0;
    var l = (v(), K).length;
    if (a <= l || 4294901760 < a)
      return false;
    for (var h = 1;4 >= h; h *= 2) {
      var f = l * (1 + 0.2 / h);
      f = Math.min(f, a + 100663296);
      e: {
        f = (Math.min(4294901760, 65536 * Math.ceil(Math.max(a, f) / 65536)) - ht.buffer.byteLength + 65535) / 65536 | 0;
        try {
          ht.grow(f), Te();
          var _ = 1;
          break e;
        } catch {}
        _ = undefined;
      }
      if (_)
        return true;
    }
    return false;
  }
  function Sm(a, l, h) {
    if (a >>>= 0, l >>>= 0, At.sd == a)
      var f = At.Md;
    else
      (f = Error().stack.toString().split(`
`))[0] == "Error" && f.shift(), Ci(f);
    for (var _ = 3;f[_] && br(f[_]) != a; )
      ++_;
    for (a = 0;a < h && f[a + _]; ++a)
      (v(), D)[l + 4 * a >>> 2 >>> 0] = br(f[a + _]);
    return a;
  }
  var On, zn = {}, Ai = () => {
    if (!On) {
      var a, l = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (globalThis.navigator?.language ?? "C").replace("-", "_") + ".UTF-8", _: "./this.program" };
      for (a in zn)
        zn[a] === undefined ? delete l[a] : l[a] = zn[a];
      var h = [];
      for (a in l)
        h.push(`${a}=${l[a]}`);
      On = h;
    }
    return On;
  };
  function Ei(a, l) {
    if (o)
      return ve(19, 1, a, l);
    a >>>= 0, l >>>= 0;
    var h, f = 0, _ = 0;
    for (h of Ai()) {
      var C = l + f;
      (v(), W)[a + _ >>> 2 >>> 0] = C, f += gt(h, C, 1 / 0) + 1, _ += 4;
    }
    return 0;
  }
  function ki(a, l) {
    if (o)
      return ve(20, 1, a, l);
    a >>>= 0, l >>>= 0;
    var h = Ai();
    for (var f of ((v(), W)[a >>> 2 >>> 0] = h.length, a = 0, h))
      a += pr(f) + 1;
    return (v(), W)[l >>> 2 >>> 0] = a, 0;
  }
  function Pi(a) {
    return o ? ve(21, 1, a) : 52;
  }
  function Oi(a, l, h, f) {
    return o ? ve(22, 1, a, l, h, f) : 52;
  }
  function zi(a, l, h, f) {
    return o ? ve(23, 1, a, l, h, f) : 70;
  }
  var Tm = [null, [], []];
  function Di(a, l, h, f) {
    if (o)
      return ve(24, 1, a, l, h, f);
    l >>>= 0, h >>>= 0, f >>>= 0;
    for (var _ = 0, C = 0;C < h; C++) {
      var P = (v(), W)[l >>> 2 >>> 0], B = (v(), W)[l + 4 >>> 2 >>> 0];
      l += 8;
      for (var G = 0;G < B; G++) {
        var H = a, ue = (v(), K)[P + G >>> 0], pe = Tm[H];
        ue === 0 || ue === 10 ? ((H === 1 ? I : E)(Xo(pe)), pe.length = 0) : pe.push(ue);
      }
      _ += B;
    }
    return (v(), W)[f >>> 2 >>> 0] = _, 0;
  }
  function Im(a) {
    return a >>> 0;
  }
  o || function() {
    for (var a = e.numThreads - 1;a--; )
      Fo();
    Xe.push(async () => {
      var l = async function() {
        if (!o)
          return Promise.all(ft.map(Ho));
      }();
      Ce++, await l, --Ce == 0 && $e && (l = $e, $e = null, l());
    });
  }(), o || (ht = new WebAssembly.Memory({ initial: 256, maximum: 65536, shared: true }), Te()), e.wasmBinary && (g = e.wasmBinary), e.stackSave = () => le(), e.stackRestore = (a) => de(a), e.stackAlloc = (a) => Mn(a), e.setValue = function(a, l, h = "i8") {
    switch (h.endsWith("*") && (h = "*"), h) {
      case "i1":
      case "i8":
        (v(), N)[a >>> 0] = l;
        break;
      case "i16":
        (v(), q)[a >>> 1 >>> 0] = l;
        break;
      case "i32":
        (v(), D)[a >>> 2 >>> 0] = l;
        break;
      case "i64":
        (v(), Z)[a >>> 3 >>> 0] = BigInt(l);
        break;
      case "float":
        (v(), j)[a >>> 2 >>> 0] = l;
        break;
      case "double":
        (v(), Y)[a >>> 3 >>> 0] = l;
        break;
      case "*":
        (v(), W)[a >>> 2 >>> 0] = l;
        break;
      default:
        U(`invalid type for setValue: ${h}`);
    }
  }, e.getValue = function(a, l = "i8") {
    switch (l.endsWith("*") && (l = "*"), l) {
      case "i1":
      case "i8":
        return (v(), N)[a >>> 0];
      case "i16":
        return (v(), q)[a >>> 1 >>> 0];
      case "i32":
        return (v(), D)[a >>> 2 >>> 0];
      case "i64":
        return (v(), Z)[a >>> 3 >>> 0];
      case "float":
        return (v(), j)[a >>> 2 >>> 0];
      case "double":
        return (v(), Y)[a >>> 3 >>> 0];
      case "*":
        return (v(), W)[a >>> 2 >>> 0];
      default:
        U(`invalid type for getValue: ${l}`);
    }
  }, e.UTF8ToString = Ae, e.stringToUTF8 = gt, e.lengthBytesUTF8 = pr;
  var Bi, Mi, _r, tt, Zt, Dn, Ri, Ui, Ni, Bn, Vi, Li, ce, Qt, Wi, de, Mn, le, Gi, Rn, Hi, Fi, qi, Un, Ki, ji, Zi, Qi, Yi, Xi, Ji, ea, ta, ra, na, oa, ia, aa, sa, ua, da, la, ca, pa, ma, fa, ha, ga, ya, ba, wa, _a, va, $a, xa, Sa, Ta, Ia, Ca, Aa, Ea, ka, Pa, Oa, ct, Cm = [dr, Vo, jo, Jo, ei, ti, ri, ni, oi, ii, ai, si, ui, di, li, ci, xi, Si, Ti, Ei, ki, Pi, Oi, zi, Di], Nn = { 927244: (a, l, h, f, _) => {
    if (e === undefined || !e.Zc)
      return 1;
    if ((a = Ae(Number(a >>> 0))).startsWith("./") && (a = a.substring(2)), !(a = e.Zc.get(a)))
      return 2;
    if (l = Number(l >>> 0), h = Number(h >>> 0), f = Number(f >>> 0), l + h > a.byteLength)
      return 3;
    try {
      let C = a.subarray(l, l + h);
      switch (_) {
        case 0:
          (v(), K).set(C, f >>> 0);
          break;
        case 1:
          e.Xd ? e.Xd(f, C) : e.Ld(f, C);
          break;
        default:
          return 4;
      }
      return 0;
    } catch {
      return 4;
    }
  }, 928068: (a, l, h) => {
    e.xd(a, (v(), K).subarray(l >>> 0, l + h >>> 0));
  }, 928132: () => e.Zd(), 928174: (a) => {
    e.vd(a);
  }, 928211: () => {
    e.Ed();
  }, 928242: () => {
    e.Fd();
  }, 928271: () => {
    e.Jd();
  }, 928296: (a) => e.Dd(a), 928329: (a) => e.Hd(a), 928361: (a, l, h) => {
    e.jd(Number(a), Number(l), Number(h), true);
  }, 928424: (a, l, h) => {
    e.jd(Number(a), Number(l), Number(h));
  }, 928481: () => typeof wasmOffsetConverter < "u", 928538: (a) => {
    e.ac("Abs", a, undefined);
  }, 928589: (a) => {
    e.ac("Neg", a, undefined);
  }, 928640: (a) => {
    e.ac("Floor", a, undefined);
  }, 928693: (a) => {
    e.ac("Ceil", a, undefined);
  }, 928745: (a) => {
    e.ac("Reciprocal", a, undefined);
  }, 928803: (a) => {
    e.ac("Sqrt", a, undefined);
  }, 928855: (a) => {
    e.ac("Exp", a, undefined);
  }, 928906: (a) => {
    e.ac("Erf", a, undefined);
  }, 928957: (a) => {
    e.ac("Sigmoid", a, undefined);
  }, 929012: (a, l, h) => {
    e.ac("HardSigmoid", a, { alpha: l, beta: h });
  }, 929091: (a) => {
    e.ac("Log", a, undefined);
  }, 929142: (a) => {
    e.ac("Sin", a, undefined);
  }, 929193: (a) => {
    e.ac("Cos", a, undefined);
  }, 929244: (a) => {
    e.ac("Tan", a, undefined);
  }, 929295: (a) => {
    e.ac("Asin", a, undefined);
  }, 929347: (a) => {
    e.ac("Acos", a, undefined);
  }, 929399: (a) => {
    e.ac("Atan", a, undefined);
  }, 929451: (a) => {
    e.ac("Sinh", a, undefined);
  }, 929503: (a) => {
    e.ac("Cosh", a, undefined);
  }, 929555: (a) => {
    e.ac("Asinh", a, undefined);
  }, 929608: (a) => {
    e.ac("Acosh", a, undefined);
  }, 929661: (a) => {
    e.ac("Atanh", a, undefined);
  }, 929714: (a) => {
    e.ac("Tanh", a, undefined);
  }, 929766: (a) => {
    e.ac("Not", a, undefined);
  }, 929817: (a, l, h) => {
    e.ac("Clip", a, { min: l, max: h });
  }, 929886: (a) => {
    e.ac("Clip", a, undefined);
  }, 929938: (a, l) => {
    e.ac("Elu", a, { alpha: l });
  }, 929996: (a) => {
    e.ac("Gelu", a, undefined);
  }, 930048: (a) => {
    e.ac("Relu", a, undefined);
  }, 930100: (a, l) => {
    e.ac("LeakyRelu", a, { alpha: l });
  }, 930164: (a, l) => {
    e.ac("ThresholdedRelu", a, { alpha: l });
  }, 930234: (a, l) => {
    e.ac("Cast", a, { to: l });
  }, 930292: (a) => {
    e.ac("Add", a, undefined);
  }, 930343: (a) => {
    e.ac("Sub", a, undefined);
  }, 930394: (a) => {
    e.ac("Mul", a, undefined);
  }, 930445: (a) => {
    e.ac("Div", a, undefined);
  }, 930496: (a) => {
    e.ac("Pow", a, undefined);
  }, 930547: (a) => {
    e.ac("Equal", a, undefined);
  }, 930600: (a) => {
    e.ac("Greater", a, undefined);
  }, 930655: (a) => {
    e.ac("GreaterOrEqual", a, undefined);
  }, 930717: (a) => {
    e.ac("Less", a, undefined);
  }, 930769: (a) => {
    e.ac("LessOrEqual", a, undefined);
  }, 930828: (a, l, h, f, _) => {
    e.ac("ReduceMean", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 931003: (a, l, h, f, _) => {
    e.ac("ReduceMax", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 931177: (a, l, h, f, _) => {
    e.ac("ReduceMin", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 931351: (a, l, h, f, _) => {
    e.ac("ReduceProd", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 931526: (a, l, h, f, _) => {
    e.ac("ReduceSum", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 931700: (a, l, h, f, _) => {
    e.ac("ReduceL1", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 931873: (a, l, h, f, _) => {
    e.ac("ReduceL2", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 932046: (a, l, h, f, _) => {
    e.ac("ReduceLogSum", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 932223: (a, l, h, f, _) => {
    e.ac("ReduceSumSquare", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 932403: (a, l, h, f, _) => {
    e.ac("ReduceLogSumExp", a, { keepDims: !!l, noopWithEmptyAxes: !!h, axes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 932583: (a) => {
    e.ac("Where", a, undefined);
  }, 932636: (a, l, h) => {
    e.ac("Transpose", a, { perm: l ? Array.from((v(), D).subarray(Number(l) >>> 0, Number(h) >>> 0)) : [] });
  }, 932760: (a, l, h, f) => {
    e.ac("DepthToSpace", a, { blocksize: l, mode: Ae(h), format: f ? "NHWC" : "NCHW" });
  }, 932893: (a, l, h, f) => {
    e.ac("DepthToSpace", a, { blocksize: l, mode: Ae(h), format: f ? "NHWC" : "NCHW" });
  }, 933026: (a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe, bt) => {
    e.ac("ConvTranspose", a, { format: G ? "NHWC" : "NCHW", autoPad: l, dilations: [h], group: f, kernelShape: [_], pads: [C, P], strides: [B], wIsConst: () => !!(v(), N)[H >>> 0], outputPadding: ue ? Array.from((v(), D).subarray(Number(ue) >>> 0, Number(pe) >>> 0)) : [], outputShape: _e ? Array.from((v(), D).subarray(Number(_e) >>> 0, Number(xe) >>> 0)) : [], activation: Ae(bt) });
  }, 933459: (a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe) => {
    e.ac("ConvTranspose", a, { format: B ? "NHWC" : "NCHW", autoPad: l, dilations: Array.from((v(), D).subarray(Number(h) >>> 0, 2 + (Number(h) >>> 0) >>> 0)), group: f, kernelShape: Array.from((v(), D).subarray(Number(_) >>> 0, 2 + (Number(_) >>> 0) >>> 0)), pads: Array.from((v(), D).subarray(Number(C) >>> 0, 4 + (Number(C) >>> 0) >>> 0)), strides: Array.from((v(), D).subarray(Number(P) >>> 0, 2 + (Number(P) >>> 0) >>> 0)), wIsConst: () => !!(v(), N)[G >>> 0], outputPadding: H ? Array.from((v(), D).subarray(Number(H) >>> 0, Number(ue) >>> 0)) : [], outputShape: pe ? Array.from((v(), D).subarray(Number(pe) >>> 0, Number(_e) >>> 0)) : [], activation: Ae(xe) });
  }, 934120: (a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe, bt) => {
    e.ac("ConvTranspose", a, { format: G ? "NHWC" : "NCHW", autoPad: l, dilations: [h], group: f, kernelShape: [_], pads: [C, P], strides: [B], wIsConst: () => !!(v(), N)[H >>> 0], outputPadding: ue ? Array.from((v(), D).subarray(Number(ue) >>> 0, Number(pe) >>> 0)) : [], outputShape: _e ? Array.from((v(), D).subarray(Number(_e) >>> 0, Number(xe) >>> 0)) : [], activation: Ae(bt) });
  }, 934553: (a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe) => {
    e.ac("ConvTranspose", a, { format: B ? "NHWC" : "NCHW", autoPad: l, dilations: Array.from((v(), D).subarray(Number(h) >>> 0, 2 + (Number(h) >>> 0) >>> 0)), group: f, kernelShape: Array.from((v(), D).subarray(Number(_) >>> 0, 2 + (Number(_) >>> 0) >>> 0)), pads: Array.from((v(), D).subarray(Number(C) >>> 0, 4 + (Number(C) >>> 0) >>> 0)), strides: Array.from((v(), D).subarray(Number(P) >>> 0, 2 + (Number(P) >>> 0) >>> 0)), wIsConst: () => !!(v(), N)[G >>> 0], outputPadding: H ? Array.from((v(), D).subarray(Number(H) >>> 0, Number(ue) >>> 0)) : [], outputShape: pe ? Array.from((v(), D).subarray(Number(pe) >>> 0, Number(_e) >>> 0)) : [], activation: Ae(xe) });
  }, 935214: (a, l) => {
    e.ac("GlobalAveragePool", a, { format: l ? "NHWC" : "NCHW" });
  }, 935305: (a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe) => {
    e.ac("AveragePool", a, { format: xe ? "NHWC" : "NCHW", auto_pad: l, ceil_mode: h, count_include_pad: f, storage_order: _, dilations: C ? Array.from((v(), D).subarray(Number(C) >>> 0, Number(P) >>> 0)) : [], kernel_shape: B ? Array.from((v(), D).subarray(Number(B) >>> 0, Number(G) >>> 0)) : [], pads: H ? Array.from((v(), D).subarray(Number(H) >>> 0, Number(ue) >>> 0)) : [], strides: pe ? Array.from((v(), D).subarray(Number(pe) >>> 0, Number(_e) >>> 0)) : [] });
  }, 935784: (a, l) => {
    e.ac("GlobalAveragePool", a, { format: l ? "NHWC" : "NCHW" });
  }, 935875: (a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe) => {
    e.ac("AveragePool", a, { format: xe ? "NHWC" : "NCHW", auto_pad: l, ceil_mode: h, count_include_pad: f, storage_order: _, dilations: C ? Array.from((v(), D).subarray(Number(C) >>> 0, Number(P) >>> 0)) : [], kernel_shape: B ? Array.from((v(), D).subarray(Number(B) >>> 0, Number(G) >>> 0)) : [], pads: H ? Array.from((v(), D).subarray(Number(H) >>> 0, Number(ue) >>> 0)) : [], strides: pe ? Array.from((v(), D).subarray(Number(pe) >>> 0, Number(_e) >>> 0)) : [] });
  }, 936354: (a, l) => {
    e.ac("GlobalMaxPool", a, { format: l ? "NHWC" : "NCHW" });
  }, 936441: (a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe) => {
    e.ac("MaxPool", a, { format: xe ? "NHWC" : "NCHW", auto_pad: l, ceil_mode: h, count_include_pad: f, storage_order: _, dilations: C ? Array.from((v(), D).subarray(Number(C) >>> 0, Number(P) >>> 0)) : [], kernel_shape: B ? Array.from((v(), D).subarray(Number(B) >>> 0, Number(G) >>> 0)) : [], pads: H ? Array.from((v(), D).subarray(Number(H) >>> 0, Number(ue) >>> 0)) : [], strides: pe ? Array.from((v(), D).subarray(Number(pe) >>> 0, Number(_e) >>> 0)) : [] });
  }, 936916: (a, l) => {
    e.ac("GlobalMaxPool", a, { format: l ? "NHWC" : "NCHW" });
  }, 937003: (a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe) => {
    e.ac("MaxPool", a, { format: xe ? "NHWC" : "NCHW", auto_pad: l, ceil_mode: h, count_include_pad: f, storage_order: _, dilations: C ? Array.from((v(), D).subarray(Number(C) >>> 0, Number(P) >>> 0)) : [], kernel_shape: B ? Array.from((v(), D).subarray(Number(B) >>> 0, Number(G) >>> 0)) : [], pads: H ? Array.from((v(), D).subarray(Number(H) >>> 0, Number(ue) >>> 0)) : [], strides: pe ? Array.from((v(), D).subarray(Number(pe) >>> 0, Number(_e) >>> 0)) : [] });
  }, 937478: (a, l, h, f, _) => {
    e.ac("Gemm", a, { alpha: l, beta: h, transA: f, transB: _ });
  }, 937582: (a) => {
    e.ac("MatMul", a, undefined);
  }, 937636: (a, l, h, f) => {
    e.ac("ArgMax", a, { keepDims: !!l, selectLastIndex: !!h, axis: f });
  }, 937744: (a, l, h, f) => {
    e.ac("ArgMin", a, { keepDims: !!l, selectLastIndex: !!h, axis: f });
  }, 937852: (a, l) => {
    e.ac("Softmax", a, { axis: l });
  }, 937915: (a, l) => {
    e.ac("Concat", a, { axis: l });
  }, 937975: (a, l, h, f, _) => {
    e.ac("Split", a, { axis: l, numOutputs: h, splitSizes: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 938131: (a) => {
    e.ac("Expand", a, undefined);
  }, 938185: (a, l) => {
    e.ac("Gather", a, { axis: Number(l) });
  }, 938256: (a, l) => {
    e.ac("GatherElements", a, { axis: Number(l) });
  }, 938335: (a, l) => {
    e.ac("GatherND", a, { batch_dims: Number(l) });
  }, 938414: (a, l, h, f, _, C, P, B, G, H, ue) => {
    e.ac("Resize", a, { antialias: l, axes: h ? Array.from((v(), D).subarray(Number(h) >>> 0, Number(f) >>> 0)) : [], coordinateTransformMode: Ae(_), cubicCoeffA: C, excludeOutside: P, extrapolationValue: B, keepAspectRatioPolicy: Ae(G), mode: Ae(H), nearestMode: Ae(ue) });
  }, 938776: (a, l, h, f, _, C, P) => {
    e.ac("Slice", a, { starts: l ? Array.from((v(), D).subarray(Number(l) >>> 0, Number(h) >>> 0)) : [], ends: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [], axes: C ? Array.from((v(), D).subarray(Number(C) >>> 0, Number(P) >>> 0)) : [] });
  }, 939040: (a) => {
    e.ac("Tile", a, undefined);
  }, 939092: (a, l, h) => {
    e.ac("InstanceNormalization", a, { epsilon: l, format: h ? "NHWC" : "NCHW" });
  }, 939206: (a, l, h) => {
    e.ac("InstanceNormalization", a, { epsilon: l, format: h ? "NHWC" : "NCHW" });
  }, 939320: (a) => {
    e.ac("Range", a, undefined);
  }, 939373: (a, l) => {
    e.ac("Einsum", a, { equation: Ae(l) });
  }, 939454: (a, l, h, f, _) => {
    e.ac("Pad", a, { mode: l, value: h, pads: f ? Array.from((v(), D).subarray(Number(f) >>> 0, Number(_) >>> 0)) : [] });
  }, 939597: (a, l, h, f, _, C) => {
    e.ac("BatchNormalization", a, { epsilon: l, momentum: h, spatial: !!_, trainingMode: !!f, format: C ? "NHWC" : "NCHW" });
  }, 939766: (a, l, h, f, _, C) => {
    e.ac("BatchNormalization", a, { epsilon: l, momentum: h, spatial: !!_, trainingMode: !!f, format: C ? "NHWC" : "NCHW" });
  }, 939935: (a, l, h) => {
    e.ac("CumSum", a, { exclusive: Number(l), reverse: Number(h) });
  }, 940032: (a, l, h) => {
    e.ac("DequantizeLinear", a, { axis: l, blockSize: h });
  }, 940122: (a, l, h, f, _) => {
    e.ac("GridSample", a, { align_corners: l, mode: Ae(h), padding_mode: Ae(f), format: _ ? "NHWC" : "NCHW" });
  }, 940292: (a, l, h, f, _) => {
    e.ac("GridSample", a, { align_corners: l, mode: Ae(h), padding_mode: Ae(f), format: _ ? "NHWC" : "NCHW" });
  }, 940462: (a, l) => {
    e.ac("ScatterND", a, { reduction: Ae(l) });
  }, 940547: (a, l, h, f, _, C, P, B, G) => {
    e.ac("Attention", a, { numHeads: l, isUnidirectional: h, maskFilterValue: f, scale: _, doRotary: C, qkvHiddenSizes: P ? Array.from((v(), D).subarray(Number(B) >>> 0, Number(B) + P >>> 0)) : [], pastPresentShareBuffer: !!G });
  }, 940819: (a) => {
    e.ac("BiasAdd", a, undefined);
  }, 940874: (a) => {
    e.ac("BiasSplitGelu", a, undefined);
  }, 940935: (a) => {
    e.ac("FastGelu", a, undefined);
  }, 940991: (a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe, bt, Vn) => {
    e.ac("Conv", a, { format: pe ? "NHWC" : "NCHW", auto_pad: l, dilations: h ? Array.from((v(), D).subarray(Number(h) >>> 0, Number(f) >>> 0)) : [], group: _, kernel_shape: C ? Array.from((v(), D).subarray(Number(C) >>> 0, Number(P) >>> 0)) : [], pads: B ? Array.from((v(), D).subarray(Number(B) >>> 0, Number(G) >>> 0)) : [], strides: H ? Array.from((v(), D).subarray(Number(H) >>> 0, Number(ue) >>> 0)) : [], w_is_const: () => !!(v(), N)[Number(_e) >>> 0], activation: Ae(xe), activation_params: bt ? Array.from((v(), j).subarray(Number(bt) >>> 0, Number(Vn) >>> 0)) : [] });
  }, 941575: (a) => {
    e.ac("Gelu", a, undefined);
  }, 941627: (a, l, h, f, _, C, P, B, G) => {
    e.ac("GroupQueryAttention", a, { numHeads: l, kvNumHeads: h, scale: f, softcap: _, doRotary: C, rotaryInterleaved: P, smoothSoftmax: B, localWindowSize: G });
  }, 941844: (a, l, h, f) => {
    e.ac("LayerNormalization", a, { axis: l, epsilon: h, simplified: !!f });
  }, 941955: (a, l, h, f) => {
    e.ac("LayerNormalization", a, { axis: l, epsilon: h, simplified: !!f });
  }, 942066: (a, l, h, f, _, C) => {
    e.ac("MatMulNBits", a, { k: l, n: h, accuracyLevel: f, bits: _, blockSize: C });
  }, 942193: (a, l, h, f, _, C) => {
    e.ac("MultiHeadAttention", a, { numHeads: l, isUnidirectional: h, maskFilterValue: f, scale: _, doRotary: C });
  }, 942352: (a, l) => {
    e.ac("QuickGelu", a, { alpha: l });
  }, 942416: (a, l, h, f, _) => {
    e.ac("RotaryEmbedding", a, { interleaved: !!l, numHeads: h, rotaryEmbeddingDim: f, scale: _ });
  }, 942555: (a, l, h) => {
    e.ac("SkipLayerNormalization", a, { epsilon: l, simplified: !!h });
  }, 942657: (a, l, h) => {
    e.ac("SkipLayerNormalization", a, { epsilon: l, simplified: !!h });
  }, 942759: (a, l, h, f) => {
    e.ac("GatherBlockQuantized", a, { gatherAxis: l, quantizeAxis: h, blockSize: f });
  }, 942880: (a) => {
    e.Id(a);
  }, 942914: (a, l) => e.Kd(Number(a), Number(l), e.$c.Nd, e.$c.errors) };
  function Am(a, l, h) {
    return bi(async () => {
      await e.Gd(Number(a), Number(l), Number(h));
    });
  }
  function Em() {
    return typeof wasmOffsetConverter < "u";
  }
  function km(a, l, h, f) {
    var _ = le();
    try {
      return ea(a, l, h, f);
    } catch (C) {
      if (de(_), C !== C + 0)
        throw C;
      ce(1, 0);
    }
  }
  function Pm(a, l, h) {
    var f = le();
    try {
      return Qi(a, l, h);
    } catch (_) {
      if (de(f), _ !== _ + 0)
        throw _;
      ce(1, 0);
    }
  }
  function Om(a, l, h) {
    var f = le();
    try {
      qi(a, l, h);
    } catch (_) {
      if (de(f), _ !== _ + 0)
        throw _;
      ce(1, 0);
    }
  }
  function zm(a, l) {
    var h = le();
    try {
      return Un(a, l);
    } catch (f) {
      if (de(h), f !== f + 0)
        throw f;
      ce(1, 0);
    }
  }
  function Dm(a) {
    var l = le();
    try {
      Ki(a);
    } catch (h) {
      if (de(l), h !== h + 0)
        throw h;
      ce(1, 0);
    }
  }
  function Bm(a, l, h, f, _, C, P) {
    var B = le();
    try {
      return Xi(a, l, h, f, _, C, P);
    } catch (G) {
      if (de(B), G !== G + 0)
        throw G;
      ce(1, 0);
    }
  }
  function Mm(a, l) {
    var h = le();
    try {
      ta(a, l);
    } catch (f) {
      if (de(h), f !== f + 0)
        throw f;
      ce(1, 0);
    }
  }
  function Rm(a, l, h, f, _, C) {
    var P = le();
    try {
      ji(a, l, h, f, _, C);
    } catch (B) {
      if (de(P), B !== B + 0)
        throw B;
      ce(1, 0);
    }
  }
  function Um(a, l, h, f) {
    var _ = le();
    try {
      Ji(a, l, h, f);
    } catch (C) {
      if (de(_), C !== C + 0)
        throw C;
      ce(1, 0);
    }
  }
  function Nm(a, l, h, f, _) {
    var C = le();
    try {
      Zi(a, l, h, f, _);
    } catch (P) {
      if (de(C), P !== P + 0)
        throw P;
      ce(1, 0);
    }
  }
  function Vm(a, l, h, f, _, C, P) {
    var B = le();
    try {
      na(a, l, h, f, _, C, P);
    } catch (G) {
      if (de(B), G !== G + 0)
        throw G;
      ce(1, 0);
    }
  }
  function Lm(a, l, h, f, _, C, P) {
    var B = le();
    try {
      oa(a, l, h, f, _, C, P);
    } catch (G) {
      if (de(B), G !== G + 0)
        throw G;
      ce(1, 0);
    }
  }
  function Wm(a, l, h, f, _, C, P, B) {
    var G = le();
    try {
      ua(a, l, h, f, _, C, P, B);
    } catch (H) {
      if (de(G), H !== H + 0)
        throw H;
      ce(1, 0);
    }
  }
  function Gm(a, l, h, f, _) {
    var C = le();
    try {
      return ra(a, l, h, f, _);
    } catch (P) {
      if (de(C), P !== P + 0)
        throw P;
      ce(1, 0);
    }
  }
  function Hm(a, l, h, f, _, C, P, B) {
    var G = le();
    try {
      da(a, l, h, f, _, C, P, B);
    } catch (H) {
      if (de(G), H !== H + 0)
        throw H;
      ce(1, 0);
    }
  }
  function Fm(a, l, h, f, _, C, P, B, G, H, ue, pe) {
    var _e = le();
    try {
      ia(a, l, h, f, _, C, P, B, G, H, ue, pe);
    } catch (xe) {
      if (de(_e), xe !== xe + 0)
        throw xe;
      ce(1, 0);
    }
  }
  function qm(a, l, h, f, _, C) {
    var P = le();
    try {
      return aa(a, l, h, f, _, C);
    } catch (B) {
      if (de(P), B !== B + 0)
        throw B;
      ce(1, 0);
    }
  }
  function Km(a, l, h) {
    var f = le();
    try {
      return la(a, l, h);
    } catch (_) {
      if (de(f), _ !== _ + 0)
        throw _;
      return ce(1, 0), 0n;
    }
  }
  function jm(a, l, h, f, _, C, P, B, G) {
    var H = le();
    try {
      Yi(a, l, h, f, _, C, P, B, G);
    } catch (ue) {
      if (de(H), ue !== ue + 0)
        throw ue;
      ce(1, 0);
    }
  }
  function Zm(a) {
    var l = le();
    try {
      return ca(a);
    } catch (h) {
      if (de(l), h !== h + 0)
        throw h;
      ce(1, 0);
    }
  }
  function Qm(a, l, h) {
    var f = le();
    try {
      return pa(a, l, h);
    } catch (_) {
      if (de(f), _ !== _ + 0)
        throw _;
      ce(1, 0);
    }
  }
  function Ym(a, l) {
    var h = le();
    try {
      return Aa(a, l);
    } catch (f) {
      if (de(h), f !== f + 0)
        throw f;
      return ce(1, 0), 0n;
    }
  }
  function Xm(a, l, h, f, _) {
    var C = le();
    try {
      ma(a, l, h, f, _);
    } catch (P) {
      if (de(C), P !== P + 0)
        throw P;
      ce(1, 0);
    }
  }
  function Jm(a) {
    var l = le();
    try {
      return fa(a);
    } catch (h) {
      if (de(l), h !== h + 0)
        throw h;
      return ce(1, 0), 0n;
    }
  }
  function ef(a, l, h, f, _, C) {
    var P = le();
    try {
      return _a(a, l, h, f, _, C);
    } catch (B) {
      if (de(P), B !== B + 0)
        throw B;
      ce(1, 0);
    }
  }
  function tf(a, l, h, f, _, C) {
    var P = le();
    try {
      return va(a, l, h, f, _, C);
    } catch (B) {
      if (de(P), B !== B + 0)
        throw B;
      ce(1, 0);
    }
  }
  function rf(a, l, h, f, _, C, P, B) {
    var G = le();
    try {
      return sa(a, l, h, f, _, C, P, B);
    } catch (H) {
      if (de(G), H !== H + 0)
        throw H;
      ce(1, 0);
    }
  }
  function nf(a, l, h, f, _) {
    var C = le();
    try {
      return $a(a, l, h, f, _);
    } catch (P) {
      if (de(C), P !== P + 0)
        throw P;
      return ce(1, 0), 0n;
    }
  }
  function of(a, l, h, f) {
    var _ = le();
    try {
      return xa(a, l, h, f);
    } catch (C) {
      if (de(_), C !== C + 0)
        throw C;
      ce(1, 0);
    }
  }
  function af(a, l, h, f) {
    var _ = le();
    try {
      return Sa(a, l, h, f);
    } catch (C) {
      if (de(_), C !== C + 0)
        throw C;
      ce(1, 0);
    }
  }
  function sf(a, l, h, f, _, C, P, B, G, H, ue, pe) {
    var _e = le();
    try {
      return Ta(a, l, h, f, _, C, P, B, G, H, ue, pe);
    } catch (xe) {
      if (de(_e), xe !== xe + 0)
        throw xe;
      ce(1, 0);
    }
  }
  function uf(a, l, h, f, _, C, P, B, G, H, ue) {
    var pe = le();
    try {
      ba(a, l, h, f, _, C, P, B, G, H, ue);
    } catch (_e) {
      if (de(pe), _e !== _e + 0)
        throw _e;
      ce(1, 0);
    }
  }
  function df(a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe, bt, Vn) {
    var hf = le();
    try {
      wa(a, l, h, f, _, C, P, B, G, H, ue, pe, _e, xe, bt, Vn);
    } catch (Ln) {
      if (de(hf), Ln !== Ln + 0)
        throw Ln;
      ce(1, 0);
    }
  }
  function lf(a, l, h, f) {
    var _ = le();
    try {
      return Ia(a, l, h, f);
    } catch (C) {
      if (de(_), C !== C + 0)
        throw C;
      ce(1, 0);
    }
  }
  function cf(a, l, h, f, _) {
    var C = le();
    try {
      return Ca(a, l, h, f, _);
    } catch (P) {
      if (de(C), P !== P + 0)
        throw P;
      ce(1, 0);
    }
  }
  function pf(a, l, h) {
    var f = le();
    try {
      return ha(a, l, h);
    } catch (_) {
      if (de(f), _ !== _ + 0)
        throw _;
      ce(1, 0);
    }
  }
  function mf(a, l, h) {
    var f = le();
    try {
      return ga(a, l, h);
    } catch (_) {
      if (de(f), _ !== _ + 0)
        throw _;
      ce(1, 0);
    }
  }
  function ff(a, l, h, f) {
    var _ = le();
    try {
      ya(a, l, h, f);
    } catch (C) {
      if (de(_), C !== C + 0)
        throw C;
      ce(1, 0);
    }
  }
  function vr() {
    if (0 < Ce)
      $e = vr;
    else if (o)
      w?.(e), re();
    else {
      for (var a = Xe;0 < a.length; )
        a.shift()(e);
      0 < Ce ? $e = vr : (e.calledRun = true, A || (re(), w?.(e)));
    }
  }
  return o || (ct = await Se(), vr()), e.PTR_SIZE = 4, we ? e : new Promise((a, l) => {
    w = a, S = l;
  });
}
var xf;
var Sf;
var fs = V(() => {
  xf = ps, Sf = globalThis.self?.name?.startsWith("em-pthread");
  Sf && ps();
});
var ys;
var Xn;
var Tf;
var Le;
var bs;
var Yn;
var If;
var Cf;
var ws;
var Af;
var hs;
var _s;
var gs;
var vs;
var Cr = V(() => {
  Ir();
  ys = typeof location > "u" ? undefined : location.origin, Xn = import.meta.url > "file:" && import.meta.url < "file;", Tf = () => {
    if (true) {
      if (Xn) {
        let t = URL;
        return new URL(new t("ort.bundle.min.mjs", import.meta.url).href, ys).href;
      }
      return import.meta.url;
    }
  }, Le = Tf(), bs = () => {
    if (Le && !Le.startsWith("blob:"))
      return Le.substring(0, Le.lastIndexOf("/") + 1);
  }, Yn = (t, e) => {
    try {
      let r = e ?? Le;
      return (r ? new URL(t, r) : new URL(t)).origin === ys;
    } catch {
      return false;
    }
  }, If = (t, e) => {
    let r = e ?? Le;
    try {
      return (r ? new URL(t, r) : new URL(t)).href;
    } catch {
      return;
    }
  }, Cf = (t, e) => `${e ?? "./"}${t}`, ws = async (t) => {
    let r = await (await fetch(t, { credentials: "same-origin" })).blob();
    return URL.createObjectURL(r);
  }, Af = async (t) => (await import(t)).default, hs = (cs(), Yt(ls)).default, _s = async () => {
    if (!Le)
      throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
    if (Yn(Le))
      return [undefined, hs()];
    let t = await ws(Le);
    return [t, hs(t)];
  }, gs = (fs(), Yt(ms)).default, vs = async (t, e, r, n) => {
    let o = gs && !(t || e);
    if (o)
      if (Le)
        o = Yn(Le);
      else if (n && !r)
        o = true;
      else
        throw new Error("cannot determine the script source URL.");
    if (o)
      return [undefined, gs];
    {
      let i = "ort-wasm-simd-threaded.jsep.mjs", s = t ?? If(i, e), u = r && s && !Yn(s, e), d = u ? await ws(s) : s ?? Cf(i, e);
      return [u ? d : undefined, await Af(d)];
    }
  };
});
var Jn;
var eo;
var Mr;
var $s;
var Ef;
var kf;
var Pf;
var Ar;
var ge;
var vt = V(() => {
  Cr();
  eo = false, Mr = false, $s = false, Ef = () => {
    if (typeof SharedArrayBuffer > "u")
      return false;
    try {
      return typeof MessageChannel < "u" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));
    } catch {
      return false;
    }
  }, kf = () => {
    try {
      return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
    } catch {
      return false;
    }
  }, Pf = () => {
    try {
      return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 19, 1, 17, 0, 65, 1, 253, 15, 65, 2, 253, 15, 65, 3, 253, 15, 253, 147, 2, 11]));
    } catch {
      return false;
    }
  }, Ar = async (t) => {
    if (eo)
      return Promise.resolve();
    if (Mr)
      throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
    if ($s)
      throw new Error("previous call to 'initializeWebAssembly()' failed.");
    Mr = true;
    let { initTimeout: e, numThreads: r } = t;
    if (t.simd !== false) {
      if (t.simd === "relaxed") {
        if (!Pf())
          throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.");
      } else if (!kf())
        throw new Error("WebAssembly SIMD is not supported in the current environment.");
    }
    let n = Ef();
    r > 1 && !n && (typeof self < "u" && !self.crossOriginIsolated && console.warn("env.wasm.numThreads is set to " + r + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."), console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."), t.numThreads = r = 1);
    let o = t.wasmPaths, i = typeof o == "string" ? o : undefined, s = o?.mjs, u = s?.href ?? s, d = o?.wasm, c = d?.href ?? d, p = t.wasmBinary, [m, g] = await vs(u, i, r > 1, !!p || !!c), b = false, y = [];
    if (e > 0 && y.push(new Promise((w) => {
      setTimeout(() => {
        b = true, w();
      }, e);
    })), y.push(new Promise((w, S) => {
      let x = { numThreads: r };
      if (p)
        x.wasmBinary = p;
      else if (c || i)
        x.locateFile = ($) => c ?? i + $;
      else if (u && u.indexOf("blob:") !== 0)
        x.locateFile = ($) => new URL($, u).href;
      else if (m) {
        let $ = bs();
        $ && (x.locateFile = (T) => $ + T);
      }
      g(x).then(($) => {
        Mr = false, eo = true, Jn = $, w(), m && URL.revokeObjectURL(m);
      }, ($) => {
        Mr = false, $s = true, S($);
      });
    })), await Promise.race(y), b)
      throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`);
  }, ge = () => {
    if (eo && Jn)
      return Jn;
    throw new Error("WebAssembly is not initialized yet.");
  };
});
var We;
var er;
var me;
var Rr = V(() => {
  vt();
  We = (t, e) => {
    let r = ge(), n = r.lengthBytesUTF8(t) + 1, o = r._malloc(n);
    return r.stringToUTF8(t, o, n), e.push(o), o;
  }, er = (t, e, r, n) => {
    if (typeof t == "object" && t !== null) {
      if (r.has(t))
        throw new Error("Circular reference in options");
      r.add(t);
    }
    Object.entries(t).forEach(([o, i]) => {
      let s = e ? e + o : o;
      if (typeof i == "object")
        er(i, s + ".", r, n);
      else if (typeof i == "string" || typeof i == "number")
        n(s, i.toString());
      else if (typeof i == "boolean")
        n(s, i ? "1" : "0");
      else
        throw new Error(`Can't handle extra config type: ${typeof i}`);
    });
  }, me = (t) => {
    let e = ge(), r = e.stackSave();
    try {
      let n = e.PTR_SIZE, o = e.stackAlloc(2 * n);
      e._OrtGetLastError(o, o + n);
      let i = Number(e.getValue(o, n === 4 ? "i32" : "i64")), s = e.getValue(o + n, "*"), u = s ? e.UTF8ToString(s) : "";
      throw new Error(`${t} ERROR_CODE: ${i}, ERROR_MESSAGE: ${u}`);
    } finally {
      e.stackRestore(r);
    }
  };
});
var xs;
var Ss = V(() => {
  vt();
  Rr();
  xs = (t) => {
    let e = ge(), r = 0, n = [], o = t || {};
    try {
      if (t?.logSeverityLevel === undefined)
        o.logSeverityLevel = 2;
      else if (typeof t.logSeverityLevel != "number" || !Number.isInteger(t.logSeverityLevel) || t.logSeverityLevel < 0 || t.logSeverityLevel > 4)
        throw new Error(`log severity level is not valid: ${t.logSeverityLevel}`);
      if (t?.logVerbosityLevel === undefined)
        o.logVerbosityLevel = 0;
      else if (typeof t.logVerbosityLevel != "number" || !Number.isInteger(t.logVerbosityLevel))
        throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);
      t?.terminate === undefined && (o.terminate = false);
      let i = 0;
      return t?.tag !== undefined && (i = We(t.tag, n)), r = e._OrtCreateRunOptions(o.logSeverityLevel, o.logVerbosityLevel, !!o.terminate, i), r === 0 && me("Can't create run options."), t?.extra !== undefined && er(t.extra, "", new WeakSet, (s, u) => {
        let d = We(s, n), c = We(u, n);
        e._OrtAddRunConfigEntry(r, d, c) !== 0 && me(`Can't set a run config entry: ${s} - ${u}.`);
      }), [r, n];
    } catch (i) {
      throw r !== 0 && e._OrtReleaseRunOptions(r), n.forEach((s) => e._free(s)), i;
    }
  };
});
var Of;
var zf;
var Df;
var Ur;
var Bf;
var Ts;
var Is = V(() => {
  vt();
  Rr();
  Of = (t) => {
    switch (t) {
      case "disabled":
        return 0;
      case "basic":
        return 1;
      case "extended":
        return 2;
      case "layout":
        return 3;
      case "all":
        return 99;
      default:
        throw new Error(`unsupported graph optimization level: ${t}`);
    }
  }, zf = (t) => {
    switch (t) {
      case "sequential":
        return 0;
      case "parallel":
        return 1;
      default:
        throw new Error(`unsupported execution mode: ${t}`);
    }
  }, Df = (t) => {
    t.extra || (t.extra = {}), t.extra.session || (t.extra.session = {});
    let e = t.extra.session;
    e.use_ort_model_bytes_directly || (e.use_ort_model_bytes_directly = "1"), t.executionProviders && t.executionProviders.some((r) => (typeof r == "string" ? r : r.name) === "webgpu") && (t.enableMemPattern = false);
  }, Ur = (t, e, r, n) => {
    let o = We(e, n), i = We(r, n);
    ge()._OrtAddSessionConfigEntry(t, o, i) !== 0 && me(`Can't set a session config entry: ${e} - ${r}.`);
  }, Bf = async (t, e, r) => {
    let n = e.executionProviders;
    for (let o of n) {
      let i = typeof o == "string" ? o : o.name, s = [];
      switch (i) {
        case "webnn":
          if (i = "WEBNN", typeof o != "string") {
            let g = o?.deviceType;
            g && Ur(t, "deviceType", g, r);
          }
          break;
        case "webgpu":
          if (i = "JS", typeof o != "string") {
            let m = o;
            if (m?.preferredLayout) {
              if (m.preferredLayout !== "NCHW" && m.preferredLayout !== "NHWC")
                throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${m.preferredLayout}`);
              Ur(t, "preferredLayout", m.preferredLayout, r);
            }
          }
          break;
        case "wasm":
        case "cpu":
          continue;
        default:
          throw new Error(`not supported execution provider: ${i}`);
      }
      let u = We(i, r), d = s.length, c = 0, p = 0;
      if (d > 0) {
        c = ge()._malloc(d * ge().PTR_SIZE), r.push(c), p = ge()._malloc(d * ge().PTR_SIZE), r.push(p);
        for (let m = 0;m < d; m++)
          ge().setValue(c + m * ge().PTR_SIZE, s[m][0], "*"), ge().setValue(p + m * ge().PTR_SIZE, s[m][1], "*");
      }
      await ge()._OrtAppendExecutionProvider(t, u, c, p, d) !== 0 && me(`Can't append execution provider: ${i}.`);
    }
  }, Ts = async (t) => {
    let e = ge(), r = 0, n = [], o = t || {};
    Df(o);
    try {
      let i = Of(o.graphOptimizationLevel ?? "all"), s = zf(o.executionMode ?? "sequential"), u = typeof o.logId == "string" ? We(o.logId, n) : 0, d = o.logSeverityLevel ?? 2;
      if (!Number.isInteger(d) || d < 0 || d > 4)
        throw new Error(`log severity level is not valid: ${d}`);
      let c = o.logVerbosityLevel ?? 0;
      if (!Number.isInteger(c) || c < 0 || c > 4)
        throw new Error(`log verbosity level is not valid: ${c}`);
      let p = typeof o.optimizedModelFilePath == "string" ? We(o.optimizedModelFilePath, n) : 0;
      if (r = e._OrtCreateSessionOptions(i, !!o.enableCpuMemArena, !!o.enableMemPattern, s, !!o.enableProfiling, 0, u, d, c, p), r === 0 && me("Can't create session options."), o.executionProviders && await Bf(r, o, n), o.enableGraphCapture !== undefined) {
        if (typeof o.enableGraphCapture != "boolean")
          throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);
        Ur(r, "enableGraphCapture", o.enableGraphCapture.toString(), n);
      }
      if (o.freeDimensionOverrides)
        for (let [m, g] of Object.entries(o.freeDimensionOverrides)) {
          if (typeof m != "string")
            throw new Error(`free dimension override name must be a string: ${m}`);
          if (typeof g != "number" || !Number.isInteger(g) || g < 0)
            throw new Error(`free dimension override value must be a non-negative integer: ${g}`);
          let b = We(m, n);
          e._OrtAddFreeDimensionOverride(r, b, g) !== 0 && me(`Can't set a free dimension override: ${m} - ${g}.`);
        }
      return o.extra !== undefined && er(o.extra, "", new WeakSet, (m, g) => {
        Ur(r, m, g, n);
      }), [r, n];
    } catch (i) {
      throw r !== 0 && e._OrtReleaseSessionOptions(r) !== 0 && me("Can't release session options."), n.forEach((s) => e._free(s)), i;
    }
  };
});
var $t;
var rt;
var xt;
var Lt;
var tr;
var Nr;
var Vr;
var to;
var J = V(() => {
  $t = (t) => {
    switch (t) {
      case "int8":
        return 3;
      case "uint8":
        return 2;
      case "bool":
        return 9;
      case "int16":
        return 5;
      case "uint16":
        return 4;
      case "int32":
        return 6;
      case "uint32":
        return 12;
      case "float16":
        return 10;
      case "float32":
        return 1;
      case "float64":
        return 11;
      case "string":
        return 8;
      case "int64":
        return 7;
      case "uint64":
        return 13;
      case "int4":
        return 22;
      case "uint4":
        return 21;
      default:
        throw new Error(`unsupported data type: ${t}`);
    }
  }, rt = (t) => {
    switch (t) {
      case 3:
        return "int8";
      case 2:
        return "uint8";
      case 9:
        return "bool";
      case 5:
        return "int16";
      case 4:
        return "uint16";
      case 6:
        return "int32";
      case 12:
        return "uint32";
      case 10:
        return "float16";
      case 1:
        return "float32";
      case 11:
        return "float64";
      case 8:
        return "string";
      case 7:
        return "int64";
      case 13:
        return "uint64";
      case 22:
        return "int4";
      case 21:
        return "uint4";
      default:
        throw new Error(`unsupported data type: ${t}`);
    }
  }, xt = (t, e) => {
    let r = [-1, 4, 1, 1, 2, 2, 4, 8, -1, 1, 2, 8, 4, 8, -1, -1, -1, -1, -1, -1, -1, 0.5, 0.5][t], n = typeof e == "number" ? e : e.reduce((o, i) => o * i, 1);
    return r > 0 ? Math.ceil(n * r) : undefined;
  }, Lt = (t) => {
    switch (t) {
      case "float16":
        return typeof Float16Array < "u" && Float16Array.from ? Float16Array : Uint16Array;
      case "float32":
        return Float32Array;
      case "uint8":
        return Uint8Array;
      case "int8":
        return Int8Array;
      case "uint16":
        return Uint16Array;
      case "int16":
        return Int16Array;
      case "int32":
        return Int32Array;
      case "bool":
        return Uint8Array;
      case "float64":
        return Float64Array;
      case "uint32":
        return Uint32Array;
      case "int64":
        return BigInt64Array;
      case "uint64":
        return BigUint64Array;
      default:
        throw new Error(`unsupported type: ${t}`);
    }
  }, tr = (t) => {
    switch (t) {
      case "verbose":
        return 0;
      case "info":
        return 1;
      case "warning":
        return 2;
      case "error":
        return 3;
      case "fatal":
        return 4;
      default:
        throw new Error(`unsupported logging level: ${t}`);
    }
  }, Nr = (t) => t === "float32" || t === "float16" || t === "int32" || t === "int64" || t === "uint32" || t === "uint8" || t === "bool" || t === "uint4" || t === "int4", Vr = (t) => t === "float32" || t === "float16" || t === "int32" || t === "int64" || t === "uint32" || t === "uint64" || t === "int8" || t === "uint8" || t === "bool" || t === "uint4" || t === "int4", to = (t) => {
    switch (t) {
      case "none":
        return 0;
      case "cpu":
        return 1;
      case "cpu-pinned":
        return 2;
      case "texture":
        return 3;
      case "gpu-buffer":
        return 4;
      case "ml-tensor":
        return 5;
      default:
        throw new Error(`unsupported data location: ${t}`);
    }
  };
});
var rr;
var ro = V(() => {
  Ir();
  rr = async (t) => {
    if (typeof t == "string")
      if (false)
        ;
      else {
        let e = await fetch(t);
        if (!e.ok)
          throw new Error(`failed to load external data file: ${t}`);
        let r = e.headers.get("Content-Length"), n = r ? parseInt(r, 10) : 0;
        if (n < 1073741824)
          return new Uint8Array(await e.arrayBuffer());
        {
          if (!e.body)
            throw new Error(`failed to load external data file: ${t}, no response body.`);
          let o = e.body.getReader(), i;
          try {
            i = new ArrayBuffer(n);
          } catch (u) {
            if (u instanceof RangeError) {
              let d = Math.ceil(n / 65536);
              i = new WebAssembly.Memory({ initial: d, maximum: d }).buffer;
            } else
              throw u;
          }
          let s = 0;
          for (;; ) {
            let { done: u, value: d } = await o.read();
            if (u)
              break;
            let c = d.byteLength;
            new Uint8Array(i, s, c).set(d), s += c;
          }
          return new Uint8Array(i, 0, n);
        }
      }
    else
      return t instanceof Blob ? new Uint8Array(await t.arrayBuffer()) : t instanceof Uint8Array ? t : new Uint8Array(t);
  };
});
var Mf;
var Rf;
var Cs;
var As;
var Lr;
var Uf;
var se;
var nt = V(() => {
  J();
  Mf = ["V", "I", "W", "E", "F"], Rf = (t, e) => {
    console.log(`[${Mf[t]},${new Date().toISOString()}]${e}`);
  }, Lr = (t, e) => {
    Cs = t, As = e;
  }, Uf = (t, e) => {
    let r = tr(t), n = tr(Cs);
    r >= n && Rf(r, typeof e == "function" ? e() : e);
  }, se = (...t) => {
    As && Uf(...t);
  };
});
var no;
var ot;
var k;
var zt;
var Wr;
var Es;
var ks;
var ne = V(() => {
  no = class {
    static calcMatMulShape(e, r) {
      return e[1] !== r[0] ? undefined : [e[0], r[1]];
    }
  }, ot = class {
    static calcShape(e, r, n = false) {
      let o = e.length, i = r.length;
      if (o === 0)
        return r;
      if (i === 0)
        return e;
      let s = Math.max(e.length, r.length), u = new Array(s);
      if (n) {
        if (o < 2 || i < 2)
          return;
        let d = no.calcMatMulShape([e[o - 2], e[o - 1]], [r[i - 2], r[i - 1]]);
        if (d === undefined)
          return;
        [u[s - 2], u[s - 1]] = d;
      }
      for (let d = n ? 3 : 1;d <= s; d++) {
        let c = o - d < 0 ? 1 : e[o - d], p = i - d < 0 ? 1 : r[i - d];
        if (c !== p && c > 1 && p > 1)
          return;
        let m = Math.max(c, p);
        if (c && p)
          u[s - d] = Math.max(c, p);
        else {
          if (m > 1)
            return;
          u[s - d] = 0;
        }
      }
      return u;
    }
    static isValidBroadcast(e, r) {
      let n = e.length, o = r.length;
      if (n > o)
        return false;
      for (let i = 1;i <= n; i++)
        if (e[n - i] !== 1 && e[n - i] !== r[o - i])
          return false;
      return true;
    }
  }, k = class t {
    static size(e) {
      return t.getSizeFromDimensionRange(e, 0, e.length);
    }
    static convertShape(e, r = 4) {
      let n = e.length;
      if (n === 0)
        return [];
      let o = new Array(n), i = n - 1;
      for (;i >= 0; ) {
        if (e[i] % r === 0) {
          o[i] = e[i] / r;
          break;
        }
        if (r % e[i] !== 0)
          throw new Error("cannot convert shape");
        o[i] = 1, r /= e[i], i--;
      }
      for (i--;i >= 0; i--)
        o[i] = e[i];
      return o;
    }
    static sizeFromDimension(e, r) {
      if (r < 0 || r > e.length)
        throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${e.length} dimensions.`);
      return t.getSizeFromDimensionRange(e, r, e.length);
    }
    static sizeToDimension(e, r) {
      if (r < 0 || r > e.length)
        throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${e.length} dimensions.`);
      return t.getSizeFromDimensionRange(e, 0, r);
    }
    static getSizeFromDimensionRange(e, r, n) {
      let o = 1;
      for (let i = r;i < n; i++) {
        if (e[i] < 0)
          throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");
        o *= Number(e[i]);
      }
      return o;
    }
    static computeStrides(e) {
      let r = e.length;
      if (r === 0)
        return [];
      if (r === 1)
        return [1];
      let n = new Array(r);
      n[r - 1] = 1, n[r - 2] = e[r - 1];
      for (let o = r - 3;o >= 0; --o)
        n[o] = n[o + 1] * e[o + 1];
      return n;
    }
    static normalizeAxis(e, r) {
      if (e < -r && e >= r)
        throw new Error("unsupported axis for this operation.");
      return e < 0 ? e + r : e;
    }
    static normalizeAxes(e, r) {
      return e.map((n) => this.normalizeAxis(n, r ?? e.length));
    }
    static sortBasedOnPerm(e, r) {
      return r ? r.map((n) => e[n]) : e.slice().reverse();
    }
    static padShape(e, r) {
      let n = e.length;
      return e.map((o, i) => o + r[i] + r[i + n]);
    }
    static areEqual(e, r) {
      return e.length !== r.length ? false : e.every((n, o) => n === r[o]);
    }
  }, zt = class t {
    static adjustPoolAttributes(e, r, n, o, i, s) {
      if (!e && n.length !== r.length - 2)
        throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
      if (e)
        for (let u = 0;u < r.length - 2; u++)
          u >= n.length ? n.push(r[u + 2]) : n[u] = r[u + 2];
      for (let u = 0;u < n.length; u++)
        if (u < o.length) {
          if (o[u] < 0)
            throw new Error("strides should be greater than or equal to 1");
        } else
          o.push(1);
      for (let u = 0;u < n.length; u++)
        if (u < i.length) {
          if (i[u] < 0)
            throw new Error("dilations should be greater than or equal to 1");
        } else
          i.push(1);
      for (let u = 0;u < n.length * 2; u++)
        if (u < s.length) {
          if (s[u] < 0)
            throw new Error("pad should be greater than or equal to 1");
        } else
          s.push(0);
      for (let u = 0;u < n.length; u++) {
        if (n[u] <= 0)
          throw new Error("kernel shapes need to be greater than 0");
        if (s[u] >= n[u] || s[u + n.length] >= n[u])
          throw new Error("pads should be smaller than kernel");
      }
    }
    static adjustPadsBasedOnAutoPad(e, r, n, o, i, s, u) {
      if (u) {
        if (i.length !== 2 * (e.length - 2))
          throw new Error("length of pads should be twice the length of data dimensions");
        if (r.length !== e.length - 2)
          throw new Error("length of strides should be the length of data dimensions");
        if (o.length !== e.length - 2)
          throw new Error("length of kernel shapes should be the length of data dimensions");
        for (let d = 0;d < e.length - 2; d++)
          t.adjustPadAndReturnShape(e[d + (s ? 1 : 2)], r[d], n[d], o[d], i, d, d + e.length - 2, u);
      }
    }
    static computePoolOutputShape(e, r, n, o, i, s, u) {
      if (r.length <= 0)
        throw new Error("input shape must be of size greater than 0");
      let d = [r[0], r[1]];
      return t.computeShapeHelper(e, r, d, n, o, i, s, u), d;
    }
    static computeConvOutputShape(e, r, n, o, i, s, u) {
      if (e.length <= 0 || r.length <= 0)
        throw new Error("invalid input tensor dims or invalid filter tensor dims");
      let d = [e[0], r[0]];
      return t.computeShapeHelper(false, e, d, n, o, i, s, u), d;
    }
    static computeShapeHelper(e, r, n, o, i, s, u, d) {
      if (e)
        for (let c = 0;c < r.length - 2; c++)
          n.push(1);
      else
        for (let c = 0;c < r.length - 2; c++)
          n.push(t.adjustPadAndReturnShape(r[c + 2], o[c], i[c], s[c], u, c, c + r.length - 2, d));
    }
    static adjustPadAndReturnShape(e, r, n, o, i, s, u, d) {
      let c = n * (o - 1) + 1;
      if (d && d !== "NOTSET")
        switch (d) {
          case "VALID":
            return i[s] = 0, i[u] = 0, Math.floor((e - c) / r + 1);
          case "SAME_LOWER":
          case "SAME_UPPER":
            if (n !== 1)
              throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
            {
              let m = ((e + r - 1) / r - 1) * r + o - e;
              return i[s] = Math.floor(d === "SAME_LOWER" ? (m + 1) / 2 : m / 2), i[u] = m - i[s], Math.floor((e + m - o) / r + 1);
            }
          default:
            throw new Error("Unsupported AutoPad type");
        }
      else
        return Math.floor((e + i[s] + i[u] - c) / r + 1);
    }
  }, Wr = class {
    static getShapeOfGemmResult(e, r, n, o, i) {
      if (e.length !== 2 || n.length !== 2)
        throw new Error("shape need to be of size 2");
      let s, u, d;
      r ? (s = e[1], u = e[0]) : (s = e[0], u = e[1]);
      let c = -1;
      if (o ? (d = n[0], c = 1) : (d = n[1], c = 0), n[c] !== u)
        throw new Error("dimension mismatch");
      if (s <= 0 || d <= 0 || u <= 0)
        throw new Error("invalid shape specified");
      if (i && !ot.isValidBroadcast(i, [s, d]))
        throw new Error("gemm: invalid bias shape for broadcast");
      return [s, d, u];
    }
  }, Es = -340282346638528860000000000000000000000, ks = 340282346638528860000000000000000000000;
});
var Gr;
var oo = V(() => {
  J();
  Gr = (t, e) => new (Lt(e))(t);
});
var Os;
var ao;
var zs;
var Nf;
var Ps;
var Vf;
var Ds;
var Hr;
var Fr;
var io;
var Bs;
var Ms = V(() => {
  J();
  nt();
  Os = new Map([["float32", 32], ["float16", 16], ["int32", 32], ["uint32", 32], ["int64", 64], ["uint64", 64], ["int8", 8], ["uint8", 8], ["int4", 4], ["uint4", 4]]), ao = (t, e) => {
    if (e === "int32")
      return t;
    let r = Os.get(e);
    if (!r)
      throw new Error(`WebNN backend does not support data type: ${e}`);
    let n = r / 8;
    if (t.byteLength % n !== 0)
      throw new Error(`Invalid Uint8Array length - must be a multiple of ${n}.`);
    let o = t.byteLength / n, i = new (Lt(e))(t.buffer, t.byteOffset, o);
    switch (e) {
      case "int64":
      case "uint64": {
        let s = new Int32Array(o);
        for (let u = 0;u < o; u++) {
          let d = i[u];
          if (d > 2147483647n || d < -2147483648n)
            throw new Error("Can not convert int64 data to int32 - value out of range.");
          s[u] = Number(d);
        }
        return new Uint8Array(s.buffer);
      }
      case "int8":
      case "uint8":
      case "uint32": {
        if (e === "uint32" && i.some((u) => u > 2147483647))
          throw new Error("Can not convert uint32 data to int32 - value out of range.");
        let s = Int32Array.from(i, Number);
        return new Uint8Array(s.buffer);
      }
      default:
        throw new Error(`Unsupported data conversion from ${e} to 'int32'`);
    }
  }, zs = (t, e) => {
    if (e === "int32")
      return t;
    if (t.byteLength % 4 !== 0)
      throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");
    let r = t.byteLength / 4, n = new Int32Array(t.buffer, t.byteOffset, r);
    switch (e) {
      case "int64": {
        let o = BigInt64Array.from(n, BigInt);
        return new Uint8Array(o.buffer);
      }
      case "uint64": {
        if (n.some((i) => i < 0))
          throw new Error("Can not convert int32 data to uin64 - negative value found.");
        let o = BigUint64Array.from(n, BigInt);
        return new Uint8Array(o.buffer);
      }
      case "int8": {
        if (n.some((i) => i < -128 || i > 127))
          throw new Error("Can not convert int32 data to int8 - value out of range.");
        let o = Int8Array.from(n, Number);
        return new Uint8Array(o.buffer);
      }
      case "uint8": {
        if (n.some((o) => o < 0 || o > 255))
          throw new Error("Can not convert int32 data to uint8 - value out of range.");
        return Uint8Array.from(n, Number);
      }
      case "uint32": {
        if (n.some((i) => i < 0))
          throw new Error("Can not convert int32 data to uint32 - negative value found.");
        let o = Uint32Array.from(n, Number);
        return new Uint8Array(o.buffer);
      }
      default:
        throw new Error(`Unsupported data conversion from 'int32' to ${e}`);
    }
  }, Nf = 1, Ps = () => Nf++, Vf = new Map([["int8", "int32"], ["uint8", "int32"], ["uint32", "int32"], ["int64", "int32"]]), Ds = (t, e) => {
    let r = Os.get(t);
    if (!r)
      throw new Error(`WebNN backend does not support data type: ${t}`);
    return e.length > 0 ? Math.ceil(e.reduce((n, o) => n * o) * r / 8) : 0;
  }, Hr = class {
    constructor(e) {
      this.isDataConverted = false;
      let { sessionId: r, context: n, tensor: o, dataType: i, shape: s, fallbackDataType: u } = e;
      this.sessionId = r, this.mlContext = n, this.mlTensor = o, this.dataType = i, this.tensorShape = s, this.fallbackDataType = u;
    }
    get tensor() {
      return this.mlTensor;
    }
    get type() {
      return this.dataType;
    }
    get fallbackType() {
      return this.fallbackDataType;
    }
    get shape() {
      return this.tensorShape;
    }
    get byteLength() {
      return Ds(this.dataType, this.tensorShape);
    }
    destroy() {
      se("verbose", () => "[WebNN] TensorWrapper.destroy"), this.mlTensor.destroy();
    }
    write(e) {
      this.mlContext.writeTensor(this.mlTensor, e);
    }
    async read(e) {
      if (this.fallbackDataType) {
        let r = await this.mlContext.readTensor(this.mlTensor), n = zs(new Uint8Array(r), this.dataType);
        if (e) {
          (e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength)).set(n);
          return;
        } else
          return n.buffer;
      } else
        return e ? this.mlContext.readTensor(this.mlTensor, e) : this.mlContext.readTensor(this.mlTensor);
    }
    canReuseTensor(e, r, n) {
      return this.mlContext === e && this.dataType === r && this.tensorShape.length === n.length && this.tensorShape.every((o, i) => o === n[i]);
    }
    setIsDataConverted(e) {
      this.isDataConverted = e;
    }
  }, Fr = class {
    constructor(e, r) {
      this.tensorManager = e;
      this.wrapper = r;
    }
    get tensorWrapper() {
      return this.wrapper;
    }
    releaseTensor() {
      this.tensorWrapper && (this.tensorManager.releaseTensor(this.tensorWrapper), this.wrapper = undefined);
    }
    async ensureTensor(e, r, n, o) {
      let i = this.tensorManager.getMLContext(e), s = this.tensorManager.getMLOpSupportLimits(e), u;
      if (!s?.input.dataTypes.includes(r)) {
        if (u = Vf.get(r), !u || s?.input.dataTypes.includes(u))
          throw new Error(`WebNN backend does not support data type: ${r}`);
        se("verbose", () => `[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${r} to ${u}`);
      }
      if (this.wrapper) {
        if (this.wrapper.canReuseTensor(i, r, n))
          return this.wrapper.tensor;
        if (o) {
          if (this.wrapper.byteLength !== Ds(r, n))
            throw new Error("Unable to copy data to tensor with different size.");
          this.activeUpload = new Uint8Array(await this.wrapper.read());
        }
        this.tensorManager.releaseTensor(this.wrapper);
      }
      let d = typeof MLTensorUsage > "u" ? undefined : MLTensorUsage.READ | MLTensorUsage.WRITE;
      return this.wrapper = await this.tensorManager.getCachedTensor(e, r, n, d, true, true, u), o && this.activeUpload && (this.wrapper.write(this.activeUpload), this.activeUpload = undefined), this.wrapper.tensor;
    }
    upload(e) {
      let r = e;
      if (this.wrapper) {
        if (this.wrapper.fallbackType)
          if (this.wrapper.fallbackType === "int32")
            r = ao(e, this.wrapper.type), this.wrapper.setIsDataConverted(true);
          else
            throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);
        if (e.byteLength === this.wrapper.byteLength) {
          this.wrapper.write(r);
          return;
        } else
          se("verbose", () => "Data size does not match tensor size. Releasing tensor."), this.releaseTensor();
      }
      this.activeUpload ? this.activeUpload.set(r) : this.activeUpload = new Uint8Array(r);
    }
    async download(e) {
      if (this.activeUpload) {
        let r = this.wrapper?.isDataConverted ? zs(this.activeUpload, this.wrapper?.type) : this.activeUpload;
        if (e) {
          e instanceof ArrayBuffer ? new Uint8Array(e).set(r) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength).set(r);
          return;
        } else
          return r.buffer;
      }
      if (!this.wrapper)
        throw new Error("Tensor has not been created.");
      return e ? this.wrapper.read(e) : this.wrapper.read();
    }
  }, io = class {
    constructor(e) {
      this.backend = e;
      this.tensorTrackersById = new Map;
      this.freeTensors = [];
      this.externalTensors = new Set;
    }
    getMLContext(e) {
      let r = this.backend.getMLContext(e);
      if (!r)
        throw new Error("MLContext not found for session.");
      return r;
    }
    getMLOpSupportLimits(e) {
      return this.backend.getMLOpSupportLimits(e);
    }
    reserveTensorId() {
      let e = Ps();
      return this.tensorTrackersById.set(e, new Fr(this)), e;
    }
    releaseTensorId(e) {
      let r = this.tensorTrackersById.get(e);
      r && (this.tensorTrackersById.delete(e), r.tensorWrapper && this.releaseTensor(r.tensorWrapper));
    }
    async ensureTensor(e, r, n, o, i) {
      se("verbose", () => `[WebNN] TensorManager.ensureTensor {tensorId: ${r}, dataType: ${n}, shape: ${o}, copyOld: ${i}}`);
      let s = this.tensorTrackersById.get(r);
      if (!s)
        throw new Error("Tensor not found.");
      return s.ensureTensor(e, n, o, i);
    }
    upload(e, r) {
      let n = this.tensorTrackersById.get(e);
      if (!n)
        throw new Error("Tensor not found.");
      n.upload(r);
    }
    async download(e, r) {
      se("verbose", () => `[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${r?.byteLength}}`);
      let n = this.tensorTrackersById.get(e);
      if (!n)
        throw new Error("Tensor not found.");
      return n.download(r);
    }
    releaseTensorsForSession(e) {
      for (let r of this.freeTensors)
        r.sessionId === e && r.destroy();
      this.freeTensors = this.freeTensors.filter((r) => r.sessionId !== e);
    }
    registerTensor(e, r, n, o) {
      let i = this.getMLContext(e), s = Ps(), u = new Hr({ sessionId: e, context: i, tensor: r, dataType: n, shape: o });
      return this.tensorTrackersById.set(s, new Fr(this, u)), this.externalTensors.add(u), s;
    }
    async getCachedTensor(e, r, n, o, i, s, u) {
      let d = this.getMLContext(e);
      for (let [p, m] of this.freeTensors.entries())
        if (m.canReuseTensor(d, r, n)) {
          se("verbose", () => `[WebNN] Reusing tensor {dataType: ${r}, ${u ? `fallbackDataType: ${u},` : ""} shape: ${n}`);
          let g = this.freeTensors.splice(p, 1)[0];
          return g.sessionId = e, g;
        }
      se("verbose", () => `[WebNN] MLContext.createTensor {dataType: ${r}, ${u ? `fallbackDataType: ${u},` : ""} shape: ${n}}`);
      let c = await d.createTensor({ dataType: u ?? r, shape: n, dimensions: n, usage: o, writable: i, readable: s });
      return new Hr({ sessionId: e, context: d, tensor: c, dataType: r, shape: n, fallbackDataType: u });
    }
    releaseTensor(e) {
      this.externalTensors.has(e) && this.externalTensors.delete(e), this.freeTensors.push(e);
    }
  }, Bs = (...t) => new io(...t);
});
var qr;
var Lf;
var Kr;
var Rs = V(() => {
  J();
  vt();
  oo();
  Ms();
  nt();
  qr = new Map([[1, "float32"], [10, "float16"], [6, "int32"], [12, "uint32"], [7, "int64"], [13, "uint64"], [22, "int4"], [21, "uint4"], [3, "int8"], [2, "uint8"], [9, "uint8"]]), Lf = (t, e) => {
    if (t === e)
      return true;
    if (t === undefined || e === undefined)
      return false;
    let r = Object.keys(t).sort(), n = Object.keys(e).sort();
    return r.length === n.length && r.every((o, i) => o === n[i] && t[o] === e[o]);
  }, Kr = class {
    constructor(e) {
      this.tensorManager = Bs(this);
      this.mlContextBySessionId = new Map;
      this.sessionIdsByMLContext = new Map;
      this.mlContextCache = [];
      this.sessionGraphInputs = new Map;
      this.sessionGraphOutputs = new Map;
      this.temporaryGraphInputs = [];
      this.temporaryGraphOutputs = [];
      this.temporarySessionTensorIds = new Map;
      this.mlOpSupportLimitsBySessionId = new Map;
      Lr(e.logLevel, !!e.debug);
    }
    get currentSessionId() {
      if (this.activeSessionId === undefined)
        throw new Error("No active session");
      return this.activeSessionId;
    }
    onRunStart(e) {
      se("verbose", () => `[WebNN] onRunStart {sessionId: ${e}}`), this.activeSessionId = e;
    }
    onRunEnd(e) {
      se("verbose", () => `[WebNN] onRunEnd {sessionId: ${e}}`);
      let r = this.temporarySessionTensorIds.get(e);
      if (r) {
        for (let n of r)
          se("verbose", () => `[WebNN] releasing temporary tensor {tensorId: ${n}}`), this.tensorManager.releaseTensorId(n);
        this.temporarySessionTensorIds.delete(e), this.activeSessionId = undefined;
      }
    }
    async createMLContext(e) {
      if (e instanceof GPUDevice) {
        let n = this.mlContextCache.findIndex((o) => o.gpuDevice === e);
        if (n !== -1)
          return this.mlContextCache[n].mlContext;
        {
          let o = await navigator.ml.createContext(e);
          return this.mlContextCache.push({ gpuDevice: e, mlContext: o }), o;
        }
      } else if (e === undefined) {
        let n = this.mlContextCache.findIndex((o) => o.options === undefined && o.gpuDevice === undefined);
        if (n !== -1)
          return this.mlContextCache[n].mlContext;
        {
          let o = await navigator.ml.createContext();
          return this.mlContextCache.push({ mlContext: o }), o;
        }
      }
      let r = this.mlContextCache.findIndex((n) => Lf(n.options, e));
      if (r !== -1)
        return this.mlContextCache[r].mlContext;
      {
        let n = await navigator.ml.createContext(e);
        return this.mlContextCache.push({ options: e, mlContext: n }), n;
      }
    }
    registerMLContext(e, r) {
      this.mlContextBySessionId.set(e, r);
      let n = this.sessionIdsByMLContext.get(r);
      n || (n = new Set, this.sessionIdsByMLContext.set(r, n)), n.add(e), this.mlOpSupportLimitsBySessionId.has(e) || this.mlOpSupportLimitsBySessionId.set(e, r.opSupportLimits()), this.temporaryGraphInputs.length > 0 && (this.sessionGraphInputs.set(e, this.temporaryGraphInputs), this.temporaryGraphInputs = []), this.temporaryGraphOutputs.length > 0 && (this.sessionGraphOutputs.set(e, this.temporaryGraphOutputs), this.temporaryGraphOutputs = []);
    }
    onReleaseSession(e) {
      this.sessionGraphInputs.delete(e), this.sessionGraphOutputs.delete(e);
      let r = this.mlContextBySessionId.get(e);
      if (!r)
        return;
      this.tensorManager.releaseTensorsForSession(e), this.mlContextBySessionId.delete(e), this.mlOpSupportLimitsBySessionId.delete(e);
      let n = this.sessionIdsByMLContext.get(r);
      if (n.delete(e), n.size === 0) {
        this.sessionIdsByMLContext.delete(r);
        let o = this.mlContextCache.findIndex((i) => i.mlContext === r);
        o !== -1 && this.mlContextCache.splice(o, 1);
      }
    }
    getMLContext(e) {
      return this.mlContextBySessionId.get(e);
    }
    getMLOpSupportLimits(e) {
      return this.mlOpSupportLimitsBySessionId.get(e);
    }
    reserveTensorId() {
      return this.tensorManager.reserveTensorId();
    }
    releaseTensorId(e) {
      se("verbose", () => `[WebNN] releaseTensorId {tensorId: ${e}}`), this.tensorManager.releaseTensorId(e);
    }
    async ensureTensor(e, r, n, o, i) {
      let s = qr.get(n);
      if (!s)
        throw new Error(`Unsupported ONNX data type: ${n}`);
      return this.tensorManager.ensureTensor(e ?? this.currentSessionId, r, s, o, i);
    }
    async createTemporaryTensor(e, r, n) {
      se("verbose", () => `[WebNN] createTemporaryTensor {onnxDataType: ${r}, shape: ${n}}`);
      let o = qr.get(r);
      if (!o)
        throw new Error(`Unsupported ONNX data type: ${r}`);
      let i = this.tensorManager.reserveTensorId();
      await this.tensorManager.ensureTensor(e, i, o, n, false);
      let s = this.temporarySessionTensorIds.get(e);
      return s ? s.push(i) : this.temporarySessionTensorIds.set(e, [i]), i;
    }
    uploadTensor(e, r) {
      if (!ge().shouldTransferToMLTensor)
        throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");
      se("verbose", () => `[WebNN] uploadTensor {tensorId: ${e}, data: ${r.byteLength}}`), this.tensorManager.upload(e, r);
    }
    async downloadTensor(e, r) {
      return this.tensorManager.download(e, r);
    }
    createMLTensorDownloader(e, r) {
      return async () => {
        let n = await this.tensorManager.download(e);
        return Gr(n, r);
      };
    }
    registerMLTensor(e, r, n, o) {
      let i = qr.get(n);
      if (!i)
        throw new Error(`Unsupported ONNX data type: ${n}`);
      let s = this.tensorManager.registerTensor(e, r, i, o);
      return se("verbose", () => `[WebNN] registerMLTensor {tensor: ${r}, dataType: ${i}, dimensions: ${o}} -> {tensorId: ${s}}`), s;
    }
    registerMLConstant(e, r, n, o, i, s, u = false) {
      if (!s)
        throw new Error("External mounted files are not available.");
      let d = e;
      e.startsWith("./") && (d = e.substring(2));
      let c = s.get(d);
      if (!c)
        throw new Error(`File with name ${d} not found in preloaded files.`);
      if (r + n > c.byteLength)
        throw new Error("Out of bounds: data offset and length exceed the external file data size.");
      let p = c.slice(r, r + n).buffer, m;
      switch (i.dataType) {
        case "float32":
          m = new Float32Array(p);
          break;
        case "float16":
          m = typeof Float16Array < "u" && Float16Array.from ? new Float16Array(p) : new Uint16Array(p);
          break;
        case "int32":
          m = new Int32Array(p);
          break;
        case "uint32":
          m = new Uint32Array(p);
          break;
        case "int64":
          if (u) {
            let g = ao(new Uint8Array(p), "int64");
            m = new Int32Array(g.buffer), i.dataType = "int32";
          } else
            m = new BigInt64Array(p);
          break;
        case "uint64":
          m = new BigUint64Array(p);
          break;
        case "int8":
          m = new Int8Array(p);
          break;
        case "int4":
        case "uint4":
        case "uint8":
          m = new Uint8Array(p);
          break;
        default:
          throw new Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`);
      }
      return se("verbose", () => `[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}} ${u ? "(Note: it was int64 data type and registered to int32 as workaround)" : ""}`), o.constant(i, m);
    }
    registerGraphInput(e) {
      this.temporaryGraphInputs.push(e);
    }
    registerGraphOutput(e) {
      this.temporaryGraphOutputs.push(e);
    }
    isGraphInput(e, r) {
      let n = this.sessionGraphInputs.get(e);
      return n ? n.includes(r) : false;
    }
    isGraphOutput(e, r) {
      let n = this.sessionGraphOutputs.get(e);
      return n ? n.includes(r) : false;
    }
    isGraphInputOutputTypeSupported(e, r, n = true) {
      let o = qr.get($t(r)), i = this.mlOpSupportLimitsBySessionId.get(e);
      return typeof o > "u" ? false : n ? !!i?.input.dataTypes.includes(o) : !!i?.output.dataTypes.includes(o);
    }
    flush() {}
  };
});
var jr = V(() => {});
var Us;
var so;
var uo;
var Wf;
var Gf;
var Ns;
var co;
var lo;
var Ls;
var Ws = V(() => {
  nt();
  jr();
  Us = new Map([[64, 250], [128, 200], [256, 200], [512, 200], [2048, 230], [4096, 200], [8192, 50], [16384, 50], [32768, 50], [65536, 50], [131072, 50], [262144, 50], [524288, 50], [1048576, 50], [2097152, 30], [4194304, 20], [8388608, 10], [12582912, 10], [16777216, 10], [26214400, 15], [33554432, 22], [44236800, 2], [58982400, 6], [67108864, 6], [134217728, 6], [167772160, 6]]), so = [], uo = (t) => Math.ceil(Number(t) / 16) * 16, Wf = (t) => {
    for (let e = 0;e < so.length; e++) {
      let r = so[e];
      if (t <= r)
        return r;
    }
    return Math.ceil(t / 16) * 16;
  }, Gf = 1, Ns = () => Gf++, co = async (t, e, r, n) => {
    let o = uo(r), i = t.device.createBuffer({ size: o, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });
    try {
      let s = t.getCommandEncoder();
      t.endComputePass(), s.copyBufferToBuffer(e, 0, i, 0, o), t.flush(), await i.mapAsync(GPUMapMode.READ);
      let u = i.getMappedRange();
      if (n) {
        let d = n();
        return d.set(new Uint8Array(u, 0, r)), d;
      } else
        return new Uint8Array(u.slice(0, r));
    } finally {
      i.destroy();
    }
  }, lo = class {
    constructor(e) {
      this.backend = e;
      this.storageCache = new Map, this.freeBuffers = new Map, this.freeUniformBuffers = new Map, this.buffersPending = [], this.capturedPendingBuffers = new Map;
      for (let [r] of Us)
        so.push(r), this.freeBuffers.set(r, []), this.freeUniformBuffers.set(r, []);
      this.sessionCount = 0;
    }
    upload(e, r) {
      let { buffer: n, byteOffset: o, byteLength: i } = r, s = uo(i), u = this.storageCache.get(e);
      if (!u)
        throw new Error("gpu data for uploading does not exist");
      if (Number(u.originalSize) !== i)
        throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${i}`);
      let d = this.backend.device.createBuffer({ mappedAtCreation: true, size: s, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }), c = d.getMappedRange();
      new Uint8Array(c).set(new Uint8Array(n, o, i)), d.unmap();
      let p = this.backend.device.createCommandEncoder();
      p.copyBufferToBuffer(d, 0, u.gpuData.buffer, 0, s), this.backend.device.queue.submit([p.finish()]), d.destroy(), se("verbose", () => `[WebGPU] GpuDataManager.upload(id=${e})`);
    }
    memcpy(e, r) {
      let n = this.storageCache.get(e);
      if (!n)
        throw new Error("source gpu data for memcpy does not exist");
      let o = this.storageCache.get(r);
      if (!o)
        throw new Error("destination gpu data for memcpy does not exist");
      if (n.originalSize !== o.originalSize)
        throw new Error("inconsistent source and destination gpu data size");
      let i = uo(n.originalSize), s = this.backend.getCommandEncoder();
      this.backend.endComputePass(), s.copyBufferToBuffer(n.gpuData.buffer, 0, o.gpuData.buffer, 0, i);
    }
    registerExternalBuffer(e, r, n) {
      let o;
      if (n) {
        if (o = n[0], e === n[1])
          return se("verbose", () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`), o;
        if (this.backend.capturedCommandList.has(this.backend.currentSessionId))
          throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
      } else
        o = Ns();
      return this.storageCache.set(o, { gpuData: { id: o, type: 0, buffer: e }, originalSize: r }), se("verbose", () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`), o;
    }
    unregisterExternalBuffer(e) {
      e !== undefined && (this.storageCache.delete(e), se("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`));
    }
    create(e, r = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
      let n = Wf(e), o, i = (r & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE, s = (r & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
      if (i || s) {
        let c = (i ? this.freeBuffers : this.freeUniformBuffers).get(n);
        c ? c.length > 0 ? o = c.pop() : o = this.backend.device.createBuffer({ size: n, usage: r }) : o = this.backend.device.createBuffer({ size: n, usage: r });
      } else
        o = this.backend.device.createBuffer({ size: n, usage: r });
      let u = { id: Ns(), type: 0, buffer: o };
      return this.storageCache.set(u.id, { gpuData: u, originalSize: Number(e) }), se("verbose", () => `[WebGPU] GpuDataManager.create(size=${e}) => id=${u.id}`), u;
    }
    get(e) {
      return this.storageCache.get(e)?.gpuData;
    }
    release(e) {
      let r = typeof e == "bigint" ? Number(e) : e, n = this.storageCache.get(r);
      if (!n) {
        if (this.storageCache.size === 0)
          return 0;
        throw new Error("releasing data does not exist");
      }
      return se("verbose", () => `[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${n.gpuData.id}`), this.storageCache.delete(r), this.buffersPending.push(n.gpuData.buffer), n.originalSize;
    }
    async download(e, r) {
      let n = this.storageCache.get(Number(e));
      if (!n)
        throw new Error("data does not exist");
      await co(this.backend, n.gpuData.buffer, n.originalSize, r);
    }
    refreshPendingBuffers() {
      if (this.buffersPending.length !== 0)
        if (this.backend.sessionStatus === "default") {
          for (let e of this.buffersPending) {
            let r = Us.get(e.size);
            if ((e.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
              let n = this.freeBuffers.get(e.size) || [];
              r === undefined || n.length >= r ? e.destroy() : n.push(e);
            } else if ((e.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
              let n = this.freeUniformBuffers.get(e.size) || [];
              r === undefined || n.length >= r ? e.destroy() : n.push(e);
            } else
              e.destroy();
          }
          this.buffersPending = [];
        } else {
          let e = this.capturedPendingBuffers.get(this.backend.currentSessionId);
          e || (e = [], this.capturedPendingBuffers.set(this.backend.currentSessionId, e));
          for (let r of this.buffersPending)
            e.push(r);
          this.buffersPending = [];
        }
    }
    dispose() {
      this.freeBuffers.forEach((e) => {
        e.forEach((r) => {
          r.destroy();
        });
      }), this.freeUniformBuffers.forEach((e) => {
        e.forEach((r) => {
          r.destroy();
        });
      }), this.storageCache.forEach((e) => {
        e.gpuData.buffer.destroy();
      }), this.capturedPendingBuffers.forEach((e) => {
        e.forEach((r) => {
          r.destroy();
        });
      }), this.storageCache = new Map, this.freeBuffers = new Map, this.freeUniformBuffers = new Map, this.capturedPendingBuffers = new Map;
    }
    onCreateSession() {
      this.sessionCount += 1;
    }
    onReleaseSession(e) {
      let r = this.capturedPendingBuffers.get(e);
      r && (r.forEach((n) => {
        n.destroy();
      }), this.capturedPendingBuffers.delete(e)), this.sessionCount -= 1, this.sessionCount === 0 && (se("warning", () => "[WebGPU] Clearing webgpu buffer cache"), this.storageCache.forEach((n) => {
        n.gpuData.buffer.destroy();
      }), this.storageCache = new Map);
    }
  }, Ls = (...t) => new lo(...t);
});
var po;
var ee;
var Ie = V(() => {
  po = class {
    constructor(e) {
      Object.assign(this, e);
    }
    get cacheKey() {
      return this.key || (this.key = Object.getOwnPropertyNames(this).sort().map((e) => `${this[e]}`).join(";")), this.key;
    }
  }, ee = (t) => new po(t);
});
var Dt;
var fo;
var be;
var Pe;
var L;
var fe;
var ho;
var Bt;
var je;
var F;
var Zr;
var O;
var R;
var Gs;
var Qr;
var mo;
var Hs;
var ae = V(() => {
  J();
  ne();
  Dt = 64, fo = (t, e) => {
    if (e === 3)
      throw new Error("vec3 has same alignment as vec4, use vec4 instead");
    switch (Number(t)) {
      case 10:
        return e > 1 ? `vec${e}<f16>` : "f16";
      case 1:
        return e > 1 ? `vec${e}<f32>` : "f32";
      case 6:
        return e > 1 ? `vec${e}<i32>` : "i32";
      case 12:
        return e > 1 ? `vec${e}<u32>` : "u32";
      case 7:
        if (e > 1)
          throw new Error("currently not supported vecX of uint64 yet");
        return ["vec2<u32>", "i32"];
      case 13:
        if (e > 1)
          throw new Error("currently not supported vecX of uint64 yet");
        return ["vec2<u32>", "u32"];
      case 9:
        if (e !== 4)
          throw new Error("bool must be vec4");
        return ["u32", "vec4<bool>"];
      case 22:
        return "i32";
      case 21:
        return "u32";
      default:
        throw new Error(`Unknown data type: ${t}`);
    }
  }, be = (t, e = 1) => {
    let r = fo(t, e);
    return typeof r == "string" ? r : r[0];
  }, Pe = (t, e = 1) => {
    let r = fo(t, e);
    return typeof r == "string" ? r : r[1];
  }, L = (...t) => {
    let e = [];
    return t.forEach((r) => {
      r.length !== 0 && e.push({ type: 12, data: r }, { type: 12, data: k.computeStrides(r) });
    }), e;
  }, fe = (t) => t % 4 === 0 ? 4 : t % 2 === 0 ? 2 : 1, ho = (t = "f32", e, r = "0") => !e || e === 1 ? `${t}(${r})` : `vec${e}<${t}>(${r})`, Bt = (t, e, r) => t === "f32" ? r : e === 1 ? `f32(${r})` : `vec${e}<f32>(${r})`, je = (t, e) => e === 4 ? `(${t}.x + ${t}.y + ${t}.z + ${t}.w)` : e === 2 ? `(${t}.x + ${t}.y)` : e === 3 ? `(${t}.x + ${t}.y + ${t}.z)` : t, F = (t, e, r, n) => t.startsWith("uniforms.") && r > 4 ? typeof e == "string" ? n === "f16" ? `${t}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]` : `${t}[(${e}) / 4][(${e}) % 4]` : n === "f16" ? `${t}[${Math.floor(e / 8)}][${Math.floor(e % 8 / 4)}][${e % 8 % 4}]` : `${t}[${Math.floor(e / 4)}][${e % 4}]` : r > 1 ? `${t}[${e}]` : t, Zr = (t, e, r, n, o) => {
    let i = typeof r == "number", s = i ? r : r.length, u = [...new Array(s).keys()], d = s < 2 ? "u32" : s <= 4 ? `vec${s}<u32>` : `array<u32, ${s}>`, c = fo(e, o), p = typeof c == "string" ? c : c[1], m = typeof c == "string" ? c : c[0], g = { indices: d, value: p, storage: m, tensor: e }, b = (U) => typeof U == "string" ? U : `${U}u`, y = { offsetToIndices: false, indicesToOffset: false, broadcastedIndicesToOffset: false, set: false, setByIndices: false, get: false, getByIndices: false }, w = i ? "uniforms." : "", S = `${w}${t}_shape`, x = `${w}${t}_strides`, $ = "";
    for (let U = 0;U < s - 1; U++)
      $ += `
    let dim${U} = current / ${F(x, U, s)};
    let rest${U} = current % ${F(x, U, s)};
    indices[${U}] = dim${U};
    current = rest${U};
    `;
    $ += `indices[${s - 1}] = current;`;
    let T = s < 2 ? "" : `
  fn o2i_${t}(offset: u32) -> ${g.indices} {
    var indices: ${g.indices};
    var current = offset;
    ${$}
    return indices;
  }`, I = (U) => (y.offsetToIndices = true, s < 2 ? U : `o2i_${t}(${U})`), E = [];
    if (s >= 2)
      for (let U = s - 1;U >= 0; U--)
        E.push(`${F(x, U, s)} * (indices[${U}])`);
    let A = s < 2 ? "" : `
  fn i2o_${t}(indices: ${g.indices}) -> u32 {
    return ${E.join("+")};
  }`, z = (U) => (y.indicesToOffset = true, s < 2 ? U : `i2o_${t}(${U})`), v = (...U) => s === 0 ? "0u" : `${g.indices}(${U.map(b).join(",")})`, M = (U, X) => s < 2 ? `${U}` : `${F(U, X, s)}`, N = (U, X, Se) => s < 2 ? `${U}=${Se};` : `${F(U, X, s)}=${Se};`, K = {}, q = (U, X) => {
      y.broadcastedIndicesToOffset = true;
      let Se = `${X.name}broadcastedIndicesTo${t}Offset`;
      if (Se in K)
        return `${Se}(${U})`;
      let Be = [];
      for (let ze = s - 1;ze >= 0; ze--) {
        let Xe = X.indicesGet("outputIndices", ze + X.rank - s);
        Be.push(`${M(x, ze)} * (${Xe} % ${M(S, ze)})`);
      }
      return K[Se] = `fn ${Se}(outputIndices: ${X.type.indices}) -> u32 {
             return ${Be.length > 0 ? Be.join("+") : "0u"};
           }`, `${Se}(${U})`;
    }, Q = (U, X) => (() => {
      if (g.storage === g.value)
        return `${t}[${U}]=${X};`;
      if (g.storage === "vec2<u32>" && g.value === "i32")
        return `${t}[${U}]=vec2<u32>(u32(${X}), select(0u, 0xFFFFFFFFu, ${X} < 0));`;
      if (g.storage === "vec2<u32>" && g.value === "u32")
        return `${t}[${U}]=vec2<u32>(u32(${X}), 0u);`;
      if (g.storage === "u32" && g.value === "vec4<bool>")
        return `${t}[${U}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${X}));`;
      throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`);
    })(), D = (U) => (() => {
      if (g.storage === g.value)
        return `${t}[${U}]`;
      if (g.storage === "vec2<u32>" && g.value === "i32")
        return `i32(${t}[${U}].x)`;
      if (g.storage === "vec2<u32>" && g.value === "u32")
        return `u32(${t}[${U}].x)`;
      if (g.storage === "u32" && g.value === "vec4<bool>")
        return `vec4<bool>(bool(${t}[${U}] & 0xFFu), bool(${t}[${U}] & 0xFF00u), bool(${t}[${U}] & 0xFF0000u), bool(${t}[${U}] & 0xFF000000u))`;
      throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`);
    })(), W = s < 2 ? "" : `
  fn get_${t}ByIndices(indices: ${g.indices}) -> ${p} {
    return ${D(`i2o_${t}(indices)`)};
  }`, j = s < 2 ? "" : (() => {
      let U = u.map((Se) => `d${Se}: u32`).join(", "), X = u.map((Se) => `d${Se}`).join(", ");
      return `
  fn get_${t}(${U}) -> ${p} {
    return get_${t}ByIndices(${v(X)});
  }`;
    })(), Y = (...U) => {
      if (U.length !== s)
        throw new Error(`indices length must be ${s}`);
      let X = U.map(b).join(",");
      return s === 0 ? D("0u") : s === 1 ? D(X[0]) : (y.get = true, y.getByIndices = true, y.indicesToOffset = true, `get_${t}(${X})`);
    }, Z = (U) => s < 2 ? D(U) : (y.getByIndices = true, y.indicesToOffset = true, `get_${t}ByIndices(${U})`), te = s < 2 ? "" : `
  fn set_${t}ByIndices(indices: ${g.indices}, value: ${p}) {
    ${Q(`i2o_${t}(indices)`, "value")}
  }`, ie = s < 2 ? "" : (() => {
      let U = u.map((Se) => `d${Se}: u32`).join(", "), X = u.map((Se) => `d${Se}`).join(", ");
      return `
  fn set_${t}(${U}, value: ${p}) {
    set_${t}ByIndices(${v(X)}, value);
  }`;
    })();
    return { impl: () => {
      let U = [], X = false;
      return y.offsetToIndices && (U.push(T), X = true), y.indicesToOffset && (U.push(A), X = true), y.broadcastedIndicesToOffset && (Object.values(K).forEach((Se) => U.push(Se)), X = true), y.set && (U.push(ie), X = true), y.setByIndices && (U.push(te), X = true), y.get && (U.push(j), X = true), y.getByIndices && (U.push(W), X = true), !i && X && U.unshift(`const ${S} = ${g.indices}(${r.join(",")});`, `const ${x} = ${g.indices}(${k.computeStrides(r).join(",")});`), U.join(`
`);
    }, type: g, offsetToIndices: I, indicesToOffset: z, broadcastedIndicesToOffset: q, indices: v, indicesGet: M, indicesSet: N, set: (...U) => {
      if (U.length !== s + 1)
        throw new Error(`indices length must be ${s}`);
      let X = U[s];
      if (typeof X != "string")
        throw new Error("value must be string");
      let Se = U.slice(0, s).map(b).join(",");
      return s === 0 ? Q("0u", X) : s === 1 ? Q(Se[0], X) : (y.set = true, y.setByIndices = true, y.indicesToOffset = true, `set_${t}(${Se}, ${X})`);
    }, setByOffset: Q, setByIndices: (U, X) => s < 2 ? Q(U, X) : (y.setByIndices = true, y.indicesToOffset = true, `set_${t}ByIndices(${U}, ${X});`), get: Y, getByOffset: D, getByIndices: Z, usage: n, name: t, strides: x, shape: S, rank: s };
  }, O = (t, e, r, n = 1) => Zr(t, e, r, "input", n), R = (t, e, r, n = 1) => Zr(t, e, r, "output", n), Gs = (t, e, r) => Zr(t, e, r, "atomicOutput", 1), Qr = (t, e, r, n = 1) => Zr(t, e, r, "internal", n), mo = class {
    constructor(e, r) {
      this.normalizedDispatchGroup = e;
      this.limits = r;
      this.internalVariables = [];
      this.variables = [];
      this.uniforms = [];
      this.variableIndex = 0;
    }
    guardAgainstOutOfBoundsWorkgroupSizes(e) {
      return `if (global_idx >= ${typeof e == "number" ? `${e}u` : e}) { return; }`;
    }
    mainStart(e = Dt) {
      let r = typeof e == "number" ? e : e[0], n = typeof e == "number" ? 1 : e[1], o = typeof e == "number" ? 1 : e[2];
      if (r > this.limits.maxComputeWorkgroupSizeX || n > this.limits.maxComputeWorkgroupSizeY || o > this.limits.maxComputeWorkgroupSizeZ)
        throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);
      if (r * n * o > this.limits.maxComputeInvocationsPerWorkgroup)
        throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);
      let i = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1, s = i ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`, u = i ? `let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;` : `let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${r * n * o}u + local_idx;`;
      return `@compute @workgroup_size(${r}, ${n}, ${o})
  fn main(${s}) {
    ${u}
  `;
    }
    appendVariableUniforms(e) {
      e.rank !== 0 && (e.shape.startsWith("uniforms.") && this.uniforms.push({ name: e.shape.replace("uniforms.", ""), type: "u32", length: e.rank }), e.strides.startsWith("uniforms.") && this.uniforms.push({ name: e.strides.replace("uniforms.", ""), type: "u32", length: e.rank }));
    }
    declareVariable(e, r) {
      if (e.usage === "internal")
        throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
      this.variables.push(e), this.appendVariableUniforms(e);
      let n = e.usage === "input" ? "read" : "read_write", o = e.usage === "atomicOutput" ? "atomic<i32>" : e.type.storage;
      return `@group(0) @binding(${r}) var<storage, ${n}> ${e.name}: array<${o}>;`;
    }
    declareVariables(...e) {
      return e.map((r) => this.declareVariable(r, this.variableIndex++)).join(`
`);
    }
    registerInternalVariable(e) {
      if (e.usage !== "internal")
        throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");
      this.internalVariables.push(e), this.appendVariableUniforms(e);
    }
    registerInternalVariables(...e) {
      return e.forEach((r) => this.registerInternalVariable(r)), this;
    }
    registerUniform(e, r, n = 1) {
      return this.uniforms.push({ name: e, type: r, length: n }), this;
    }
    registerUniforms(e) {
      return this.uniforms = this.uniforms.concat(e), this;
    }
    uniformDeclaration() {
      if (this.uniforms.length === 0)
        return "";
      let e = [];
      for (let { name: r, type: n, length: o } of this.uniforms)
        if (o && o > 4)
          n === "f16" ? e.push(`@align(16) ${r}:array<mat2x4<${n}>, ${Math.ceil(o / 8)}>`) : e.push(`${r}:array<vec4<${n}>, ${Math.ceil(o / 4)}>`);
        else {
          let i = o == null || o === 1 ? n : `vec${o}<${n}>`;
          e.push(`${r}:${i}`);
        }
      return `
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
    }
    get additionalImplementations() {
      return this.uniformDeclaration() + this.variables.map((e) => e.impl()).join(`
`) + this.internalVariables.map((e) => e.impl()).join(`
`);
    }
    get variablesInfo() {
      if (this.uniforms.length === 0)
        return;
      let e = (r) => [12, 10, 1, 6][["u32", "f16", "f32", "i32"].indexOf(r)];
      return this.uniforms.map((r) => [e(r.type), r.length ?? 1]);
    }
  }, Hs = (t, e) => new mo(t, e);
});
var Hf;
var Fs;
var Ff;
var qf;
var Kf;
var jf;
var Oe;
var qs;
var Ks;
var pt = V(() => {
  J();
  ne();
  Ie();
  ae();
  Hf = (t, e) => {
    if (!t || t.length !== 1)
      throw new Error("Transpose requires 1 input.");
    if (e.length !== 0 && e.length !== t[0].dims.length)
      throw new Error(`perm size ${e.length} does not match input rank ${t[0].dims.length}`);
  }, Fs = (t, e) => e.length !== 0 ? e : [...new Array(t).keys()].reverse(), Ff = (t, e) => k.sortBasedOnPerm(t, Fs(t.length, e)), qf = (t, e, r, n) => {
    let o = `fn perm(i: ${n.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`;
    for (let i = 0;i < e; ++i)
      o += `a[${t[i]}]=i[${i}];`;
    return o += "return a;}";
  }, Kf = (t, e) => {
    let r = [], n = [];
    for (let o = 0;o < t.length; ++o)
      t[o] !== 1 && r.push(t[o]), t[e[o]] !== 1 && n.push(e[o]);
    return { newShape: r, newPerm: n };
  }, jf = (t, e) => {
    let r = 0;
    for (let n = 0;n < t.length; ++n)
      if (e[t[n]] !== 1) {
        if (t[n] < r)
          return false;
        r = t[n];
      }
    return true;
  }, Oe = (t, e) => {
    let r = t.dataType, n = t.dims.length, o = Fs(n, e), i = Ff(t.dims, o), s = t.dims, u = i, d = n < 2 || jf(o, t.dims), c;
    if (d)
      return c = (w) => {
        let S = O("input", r, s, 4), x = R("output", r, u, 4);
        return `
  ${w.registerUniform("output_size", "u32").declareVariables(S, x)}
  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`;
      }, { name: "TransposeCopy", shaderCache: { inputDependencies: ["type"] }, getRunData: () => {
        let w = k.size(i);
        return { outputs: [{ dims: i, dataType: t.dataType }], dispatchGroup: { x: Math.ceil(w / 64 / 4) }, programUniforms: [{ type: 12, data: Math.ceil(w / 4) }] };
      }, getShaderSource: c };
    let { newShape: p, newPerm: m } = Kf(t.dims, o), g = k.areEqual(m, [2, 3, 1]), b = k.areEqual(m, [3, 1, 2]);
    if (p.length === 2 || g || b) {
      s = g ? [p[0], p[1] * p[2]] : b ? [p[0] * p[1], p[2]] : p, u = [s[1], s[0]];
      let w = 16;
      return c = (S) => {
        let x = O("a", r, s.length), $ = R("output", r, u.length);
        return `
  ${S.registerUniform("output_size", "u32").declareVariables(x, $)}
  var<workgroup> tile : array<array<${$.type.value}, ${w + 1}>, ${w}>;
  ${S.mainStart([w, w, 1])}
    let stride = (uniforms.output_shape[1] - 1) / ${w} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${w}u + local_id.x;
    let input_row = workgroup_id_x * ${w}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${x.getByIndices(`${x.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${w}u + local_id.x;
    let output_row = workgroup_id_y * ${w}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${$.setByIndices(`${$.type.indices}(output_row, output_col)`, "tile[local_id.x][local_id.y]")}
    }
  }`;
      }, { name: "TransposeShared", shaderCache: { inputDependencies: ["type"] }, getRunData: () => {
        let S = k.size(i);
        return { outputs: [{ dims: i, dataType: t.dataType }], dispatchGroup: { x: Math.ceil(u[1] / w), y: Math.ceil(u[0] / w) }, programUniforms: [{ type: 12, data: S }, ...L(s, u)] };
      }, getShaderSource: c };
    }
    return c = (w) => {
      let S = O("a", r, s.length), x = R("output", r, u.length);
      return `
  ${w.registerUniform("output_size", "u32").declareVariables(S, x)}

  ${qf(o, n, S, x)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${x.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${x.setByOffset("global_idx", S.getByIndices("aIndices"))}
  }`;
    }, { name: "Transpose", shaderCache: { hint: `${e}`, inputDependencies: ["rank"] }, getRunData: () => {
      let w = k.size(i);
      return { outputs: [{ dims: i, dataType: t.dataType }], dispatchGroup: { x: Math.ceil(w / 64) }, programUniforms: [{ type: 12, data: w }, ...L(s, u)] };
    }, getShaderSource: c };
  }, qs = (t, e) => {
    Hf(t.inputs, e.perm), t.compute(Oe(t.inputs[0], e.perm));
  }, Ks = (t) => ee({ perm: t.perm });
});
var Zf;
var Qf;
var Yf;
var Xf;
var Jf;
var eh;
var th;
var rh;
var nh;
var oh;
var it;
var js;
var Zs;
var Qs;
var Ys;
var Xs;
var Js;
var eu;
var tu;
var ru;
var nu;
var ou = V(() => {
  J();
  ne();
  ae();
  Yr();
  pt();
  Zf = { max: "select(bestValue, candidate, candidate > bestValue)", min: "select(bestValue, candidate, candidate < bestValue)", mean: "bestValue + candidate", sum: "bestValue + candidate", prod: "bestValue * candidate", sumSquare: "bestValue + candidate * candidate", logSumExp: "bestValue + exp(candidate)", l1: "bestValue + abs(candidate)", l2: "bestValue + candidate * candidate", logSum: "bestValue + candidate" }, Qf = { max: "select(bestValue, candidate, candidate > bestValue)", min: "select(bestValue, candidate, candidate < bestValue)", mean: "bestValue + candidate", sum: "bestValue + candidate", prod: "bestValue * candidate", sumSquare: "bestValue + candidate", logSumExp: "bestValue + candidate", l1: "bestValue + candidate", l2: "bestValue + candidate", logSum: "bestValue + candidate" }, Yf = { max: "_A[offset]", min: "_A[offset]", mean: "0", sum: "0", prod: "1", sumSquare: "0", logSumExp: "0", l1: "0", l2: "0", logSum: "0" }, Xf = { max: "bestValue", min: "bestValue", sum: "bestValue", prod: "bestValue", sumSquare: "bestValue", logSumExp: "log(bestValue)", l1: "bestValue", l2: "sqrt(bestValue)", logSum: "log(bestValue)" }, Jf = (t, e) => {
    let r = [];
    for (let n = e - t;n < e; ++n)
      r.push(n);
    return r;
  }, eh = (t, e) => {
    let r = [], n = t.length;
    for (let i = 0;i < n; i++)
      e.indexOf(i) === -1 && r.push(t[i]);
    let o = e.map((i) => t[i]);
    return [r, o];
  }, th = (t, e) => {
    let r = t.length + e.length, n = [], o = 0;
    for (let i = 0;i < r; i++)
      e.indexOf(i) === -1 ? n.push(t[o++]) : n.push(1);
    return n;
  }, rh = (t, e) => {
    for (let r = 0;r < t.length; ++r)
      if (t[t.length - r - 1] !== e - 1 - r)
        return false;
    return true;
  }, nh = (t, e) => {
    let r = [];
    if (!rh(t, e)) {
      for (let n = 0;n < e; ++n)
        t.indexOf(n) === -1 && r.push(n);
      t.forEach((n) => r.push(n));
    }
    return r;
  }, oh = (t, e, r, n, o, i, s) => {
    let u = r[0].dims, d = k.size(i), c = k.size(s), p = O("_A", r[0].dataType, u), m = R("output", o, i), g = 64;
    d === 1 && (g = 256);
    let b = `
          var<workgroup> aBestValues : array<f32, ${g}>;
       `, y = (w) => `
        ${w.registerUniform("reduceSize", "u32").declareVariables(p, m)}
        ${b}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${w.mainStart(g)}

          let outputIndex = global_idx / ${g};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Yf[n]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${g}) {
           let candidate = f32(${p.getByOffset("offset + k")});
           bestValue = ${Zf[n]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${g}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Qf[n]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${m.setByOffset("outputIndex", `${n === "mean" ? `${m.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${m.type.storage}(${Xf[n]})`}`)};
         }
        }`;
    return { name: t, shaderCache: { hint: `${e};${g}`, inputDependencies: ["type"] }, getShaderSource: y, getRunData: () => ({ outputs: [{ dims: i, dataType: o }], dispatchGroup: { x: d }, programUniforms: [{ type: 12, data: c }] }) };
  }, it = (t, e, r, n) => {
    let o = t.inputs.length === 1 ? r : go(t.inputs, r), i = o.axes;
    i.length === 0 && !o.noopWithEmptyAxes && (i = t.inputs[0].dims.map((b, y) => y));
    let s = k.normalizeAxes(i, t.inputs[0].dims.length), u = s, d = t.inputs[0], c = nh(u, t.inputs[0].dims.length);
    c.length > 0 && (d = t.compute(Oe(t.inputs[0], c), { inputs: [0], outputs: [-1] })[0], u = Jf(u.length, d.dims.length));
    let [p, m] = eh(d.dims, u), g = p;
    o.keepDims && (g = th(p, s)), t.compute(oh(e, o.cacheKey, [d], n, t.inputs[0].dataType, g, m), { inputs: [d] });
  }, js = (t, e) => {
    it(t, "ReduceMeanShared", e, "mean");
  }, Zs = (t, e) => {
    it(t, "ReduceL1Shared", e, "l1");
  }, Qs = (t, e) => {
    it(t, "ReduceL2Shared", e, "l2");
  }, Ys = (t, e) => {
    it(t, "ReduceLogSumExpShared", e, "logSumExp");
  }, Xs = (t, e) => {
    it(t, "ReduceMaxShared", e, "max");
  }, Js = (t, e) => {
    it(t, "ReduceMinShared", e, "min");
  }, eu = (t, e) => {
    it(t, "ReduceProdShared", e, "prod");
  }, tu = (t, e) => {
    it(t, "ReduceSumShared", e, "sum");
  }, ru = (t, e) => {
    it(t, "ReduceSumSquareShared", e, "sumSquare");
  }, nu = (t, e) => {
    it(t, "ReduceLogSumShared", e, "logSum");
  };
});
var at;
var ih;
var Xr;
var go;
var st;
var ah;
var sh;
var uh;
var dh;
var lh;
var ch;
var ph;
var mh;
var fh;
var hh;
var ut;
var iu;
var au;
var su;
var uu;
var du;
var lu;
var cu;
var pu;
var mu;
var fu;
var Yr = V(() => {
  J();
  ne();
  Ie();
  ae();
  ou();
  at = (t) => {
    if (!t || t.length === 0 || t.length > 2)
      throw new Error("Reduce op requires 1 or 2 inputs.");
    if (t.length === 2 && t[1].dims.length !== 1)
      throw new Error("Invalid axes input dims.");
  }, ih = (t) => ["", "", `var value = ${t.getByIndices("input_indices")};`, ""], Xr = (t, e, r, n, o, i, s = false, u = false) => {
    let d = [], c = r[0].dims, p = c.length, m = k.normalizeAxes(o, p), g = !u && m.length === 0;
    c.forEach((S, x) => {
      g || m.indexOf(x) >= 0 ? s && d.push(1) : d.push(S);
    });
    let b = d.length, y = k.size(d);
    return { name: t, shaderCache: e, getShaderSource: (S) => {
      let x = [], $ = O("_A", r[0].dataType, p), T = R("output", i, b), I = n($, T, m), E = I[2];
      for (let A = 0, z = 0;A < p; A++)
        g || m.indexOf(A) >= 0 ? (s && z++, E = `for(var j${A}: u32 = 0; j${A} < ${c[A]}; j${A}++) {
                  ${I[2].includes("last_index") ? `let last_index = j${A};` : ""}
                  ${$.indicesSet("input_indices", A, `j${A}`)}
                  ${E}
                }`) : (x.push(`${$.indicesSet("input_indices", A, T.indicesGet("output_indices", z))};`), z++);
      return `

        ${S.registerUniform("output_size", "u32").declareVariables($, T)}

        ${S.mainStart()}
          ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${$.type.indices};
          let output_indices = ${T.offsetToIndices("global_idx")};

          ${x.join(`
`)}
          ${I[0]}       // init ops for reduce max/min
          ${I[1]}
          ${E}
          ${I[3]}
          ${I.length === 4 ? T.setByOffset("global_idx", "value") : I.slice(4).join(`
`)}
        }`;
    }, getRunData: () => ({ outputs: [{ dims: d, dataType: i }], dispatchGroup: { x: Math.ceil(y / 64) }, programUniforms: [{ type: 12, data: y }, ...L(c, d)] }) };
  }, go = (t, e) => {
    let r = [];
    return t[1].dims[0] > 0 && t[1].getBigInt64Array().forEach((n) => r.push(Number(n))), ee({ axes: r, keepDims: e.keepDims, noopWithEmptyAxes: e.noopWithEmptyAxes });
  }, st = (t, e, r, n) => {
    let o = t.inputs, i = o.length === 1 ? r : go(o, r);
    t.compute(Xr(e, { hint: i.cacheKey, inputDependencies: ["rank"] }, [o[0]], i.noopWithEmptyAxes && i.axes.length === 0 ? ih : n, i.axes, o[0].dataType, i.keepDims, i.noopWithEmptyAxes), { inputs: [0] });
  }, ah = (t, e) => {
    at(t.inputs), st(t, "ReduceLogSum", e, (n, o) => [`var value = ${o.type.storage}(0);`, "", `value += ${n.getByIndices("input_indices")};`, "value = log(value);"]);
  }, sh = (t, e) => {
    at(t.inputs), st(t, "ReduceL1", e, (n, o) => [`var value = ${o.type.storage}(0);`, "", `value += abs(${n.getByIndices("input_indices")});`, ""]);
  }, uh = (t, e) => {
    at(t.inputs), st(t, "ReduceL2", e, (n, o) => [`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`, "", `t = ${n.getByIndices("input_indices")}; value += (t * t);`, "value = sqrt(value);"]);
  }, dh = (t, e) => {
    at(t.inputs), st(t, "ReduceLogSumExp", e, (n, o) => [`var value = ${o.type.storage}(0);`, "", `value += exp(${n.getByIndices("input_indices")});`, "value = log(value);"]);
  }, lh = (t, e) => {
    at(t.inputs), st(t, "ReduceMax", e, (n, o, i) => {
      let s = [];
      for (let u = 0;u < n.rank; u++)
        (i.indexOf(u) >= 0 || i.length === 0) && s.push(n.indicesSet("input_indices", u, 0));
      return [`${s.join(`
`)}`, `var value = ${n.getByIndices("input_indices")};`, `value = max(value, ${n.getByIndices("input_indices")});`, ""];
    });
  }, ch = (t, e) => {
    at(t.inputs), st(t, "ReduceMean", e, (n, o, i) => {
      let s = 1;
      for (let u = 0;u < n.rank; u++)
        (i.indexOf(u) >= 0 || i.length === 0) && (s *= t.inputs[0].dims[u]);
      return ["var sum = f32(0);", "", `sum += f32(${n.getByIndices("input_indices")});`, `let value = ${o.type.value}(sum / ${s});`];
    });
  }, ph = (t, e) => {
    at(t.inputs), st(t, "ReduceMin", e, (n, o, i) => {
      let s = [];
      for (let u = 0;u < n.rank; u++)
        (i.indexOf(u) >= 0 || i.length === 0) && s.push(`input_indices[${u}] = 0;`);
      return [`${s.join(`
`)}`, `var value = ${n.getByIndices("input_indices")};`, `value = min(value, ${n.getByIndices("input_indices")});`, ""];
    });
  }, mh = (t, e) => {
    at(t.inputs), st(t, "ReduceProd", e, (n, o) => [`var value = ${o.type.storage}(1);`, "", `value *= ${n.getByIndices("input_indices")};`, ""]);
  }, fh = (t, e) => {
    at(t.inputs), st(t, "ReduceSum", e, (n, o) => [`var value = ${o.type.storage}(0);`, "", `value += ${n.getByIndices("input_indices")};`, ""]);
  }, hh = (t, e) => {
    at(t.inputs), st(t, "ReduceSumSquare", e, (n, o) => [`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`, "", `t = ${n.getByIndices("input_indices")}; value += t * t;`, ""]);
  }, ut = (t, e, r) => {
    if (e.length === 0)
      return r;
    let n = 1, o = 1;
    for (let i = 0;i < e.length; i++)
      e.indexOf(i) === -1 ? n *= t[i] : o *= t[i];
    return o < 32 && n > 1024;
  }, iu = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? ch(t, e) : js(t, e);
  }, au = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? sh(t, e) : Zs(t, e);
  }, su = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? uh(t, e) : Qs(t, e);
  }, uu = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? dh(t, e) : Ys(t, e);
  }, du = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? lh(t, e) : Xs(t, e);
  }, lu = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? ph(t, e) : Js(t, e);
  }, cu = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? mh(t, e) : eu(t, e);
  }, pu = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? fh(t, e) : tu(t, e);
  }, mu = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? hh(t, e) : ru(t, e);
  }, fu = (t, e) => {
    ut(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? ah(t, e) : nu(t, e);
  };
});
var hu;
var gu;
var yu;
var yo;
var bu = V(() => {
  J();
  Ie();
  Yr();
  hu = (t) => {
    if (!t || t.length === 0 || t.length > 2)
      throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
    if (t[0].dataType !== 1)
      throw new Error("Invalid input type.");
  }, gu = (t, e) => {
    hu(t.inputs);
    let r = (n, o, i) => {
      let s = [];
      for (let u = 0;u < n.rank; u++)
        (i.indexOf(u) >= 0 || i.length === 0) && s.push(`input_indices[${u}] = 0;`);
      return [`${s.join(`
`)}`, `var value = ${n.getByIndices("input_indices")};
var best_index : i32 = 0;`, `if (${n.getByIndices("input_indices")} ${e.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${n.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`, "", o.setByOffset("global_idx", "best_index")];
    };
    t.compute(Xr("ArgMin", { hint: e.cacheKey, inputDependencies: ["rank"] }, [t.inputs[0]], r, [e.axis], 7, e.keepDims), { inputs: [0] });
  }, yu = (t, e) => {
    hu(t.inputs);
    let r = (n, o, i) => {
      let s = [];
      for (let u = 0;u < n.rank; u++)
        (i.indexOf(u) >= 0 || i.length === 0) && s.push(`input_indices[${u}] = 0;`);
      return [`${s.join(`
`)}`, `var value = ${n.getByIndices("input_indices")};
var best_index : i32 = 0;`, `if (${n.getByIndices("input_indices")} ${e.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${n.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`, "", o.setByOffset("global_idx", "best_index")];
    };
    t.compute(Xr("argMax", { hint: e.cacheKey, inputDependencies: ["rank"] }, [t.inputs[0]], r, [e.axis], 7, e.keepDims), { inputs: [0] });
  }, yo = (t) => ee(t);
});
var gh;
var bo;
var yh;
var bh;
var wh;
var Wt;
var _h;
var wu;
var Jr = V(() => {
  J();
  ne();
  jr();
  ae();
  gh = (t, e) => {
    let r = t[0], n = t[1], o = t[2], i = t[3], s = t[4], u = t[5];
    if (s && u)
      throw new Error("Attention cannot have both past and attention_bias");
    if (r.dims.length !== 3)
      throw new Error('Input "input" must have 3 dimensions');
    let d = r.dims[0], c = r.dims[1], p = r.dims[2];
    if (o.dims.length !== 1)
      throw new Error('Input "bias" is expected to have 1 dimensions');
    if (n.dims.length !== 2)
      throw new Error('Input "weights" is expected to have 2 dimensions');
    if (n.dims[0] !== p)
      throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
    if (o.dims[0] !== n.dims[1])
      throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
    let m = o.dims[0] / 3, g = m, b = g;
    if (e.qkvHiddenSizes.length > 0) {
      if (e.qkvHiddenSizes.length !== 3)
        throw new Error("qkv_hidden_sizes attribute should have 3 elements");
      for (let T of e.qkvHiddenSizes)
        if (T % e.numHeads !== 0)
          throw new Error("qkv_hidden_sizes should be divisible by num_heads");
      m = e.qkvHiddenSizes[0], g = e.qkvHiddenSizes[1], b = e.qkvHiddenSizes[2];
    }
    let y = c;
    if (m !== g)
      throw new Error("qkv_hidden_sizes first element should be same as the second");
    if (o.dims[0] !== m + g + b)
      throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
    let w = 0;
    if (s) {
      if (g !== b)
        throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
      if (s.dims.length !== 5)
        throw new Error('Input "past" must have 5 dimensions');
      if (s.dims[0] !== 2)
        throw new Error('Input "past" first dimension must be 2');
      if (s.dims[1] !== d)
        throw new Error('Input "past" second dimension must be batch_size');
      if (s.dims[2] !== e.numHeads)
        throw new Error('Input "past" third dimension must be num_heads');
      if (s.dims[4] !== g / e.numHeads)
        throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
      e.pastPresentShareBuffer || (w = s.dims[3]);
    }
    let S = y + w, x = -1, $ = 0;
    if (i)
      throw new Error("Mask not supported");
    if (s)
      throw new Error("past is not supported");
    if (u) {
      if (u.dims.length !== 4)
        throw new Error('Input "attention_bias" must have 4 dimensions');
      if (u.dims[0] !== d || u.dims[1] !== e.numHeads || u.dims[2] !== c || u.dims[3] !== S)
        throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
    }
    return { batchSize: d, sequenceLength: c, pastSequenceLength: w, kvSequenceLength: y, totalSequenceLength: S, maxSequenceLength: x, inputHiddenSize: p, hiddenSize: m, vHiddenSize: b, headSize: Math.floor(m / e.numHeads), vHeadSize: Math.floor(b / e.numHeads), numHeads: e.numHeads, isUnidirectional: false, pastPresentShareBuffer: false, maskFilterValue: e.maskFilterValue, maskType: $, scale: e.scale, broadcastResPosBias: false, passPastInKv: false, qkvFormat: 1 };
  }, bo = (t, e, r) => e && t ? `
      let total_sequence_length_input = u32(${e.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${t?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       ` : `
    ${r ? "let past_sequence_length = uniforms.past_sequence_length" : ""};
    let present_sequence_length = total_sequence_length;
    `, yh = (t, e, r, n, o, i, s, u) => {
    let d = fe(s ? 1 : i), c = 64, p = i / d;
    p < c && (c = 32);
    let m = Math.ceil(i / d / c), g = [{ type: 12, data: e }, { type: 12, data: r }, { type: 12, data: n }, { type: 12, data: o }, { type: 12, data: p }, { type: 12, data: m }], b = be(t.dataType, d), y = Pe(1, d), w = ["type"];
    s && w.push("type"), u && w.push("type");
    let S = (x) => {
      let $ = R("x", t.dataType, t.dims, d), T = [$], I = s ? O("seq_lens", s.dataType, s.dims) : undefined;
      I && T.push(I);
      let E = u ? O("total_sequence_length_input", u.dataType, u.dims) : undefined;
      E && T.push(E);
      let A = Pe(t.dataType), z = [{ name: "batch_size", type: "u32" }, { name: "num_heads", type: "u32" }, { name: "past_sequence_length", type: "u32" }, { name: "sequence_length", type: "u32" }, { name: "total_sequence_length", type: "u32" }, { name: "elements_per_thread", type: "u32" }];
      return `
  var<workgroup> thread_max: array<f32, ${c}>;
  var<workgroup> thread_sum: array<f32, ${c}>;
  ${x.registerUniforms(z).declareVariables(...T)}
  ${x.mainStart([c, 1, 1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${bo(I, E, false)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${c}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${s ? "u32(past_sequence_length + workgroup_id.y + 1)" : "total_sequence_length"};
    var thread_max_vector = ${y}(-3.4028234663852886e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${y}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
        switch (d) {
          case 1:
            return "thread_max_vector";
          case 2:
            return "max(thread_max_vector.x, thread_max_vector.y)";
          case 4:
            return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
          default:
            throw new Error(`Unsupported components: ${d}`);
        }
      })()};
    workgroupBarrier();

    var max_value =  f32(-3.4028234663852886e+38f);
    for (var i = 0u; i < ${c}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${y}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${y}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
        switch (d) {
          case 1:
            return "sum_vector";
          case 2:
            return "sum_vector.x + sum_vector.y";
          case 4:
            return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
          default:
            throw new Error(`Unsupported components: ${d}`);
        }
      })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${c}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${$.type.value}(${A}(1.0) / ${A}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${y}(x[offset + i]);
        x[offset + i] = ${$.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${s ? `
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${$.type.value}(${A}(0));
        }` : ""};
  }`;
    };
    return { name: "AttentionProbsSoftmax", shaderCache: { hint: `${c};${b};${d}`, inputDependencies: w }, getShaderSource: S, getRunData: () => ({ outputs: [], dispatchGroup: { x: 1, y: o, z: e * r }, programUniforms: g }) };
  }, bh = (t, e, r, n, o, i, s, u, d) => {
    let c = s + i.kvSequenceLength, p = [i.batchSize, i.numHeads, i.sequenceLength, c], m = t > 1 && n, g = i.kvNumHeads ? i.kvNumHeads : i.numHeads, b = m ? [i.batchSize, g, c, i.headSize] : undefined, y = i.nReps ? i.nReps : 1, w = i.scale === 0 ? 1 / Math.sqrt(i.headSize) : i.scale, S = fe(i.headSize), x = i.headSize / S, $ = 12, T = { x: Math.ceil(c / $), y: Math.ceil(i.sequenceLength / $), z: i.batchSize * i.numHeads }, I = [{ type: 12, data: i.sequenceLength }, { type: 12, data: x }, { type: 12, data: c }, { type: 12, data: i.numHeads }, { type: 12, data: i.headSize }, { type: 1, data: w }, { type: 12, data: s }, { type: 12, data: i.kvSequenceLength }, { type: 12, data: y }], E = m && n && k.size(n.dims) > 0, A = ["type", "type"];
    E && A.push("type"), o && A.push("type"), u && A.push("type"), d && A.push("type");
    let z = [{ dims: p, dataType: e.dataType, gpuDataType: 0 }];
    m && z.push({ dims: b, dataType: e.dataType, gpuDataType: 0 });
    let v = (M) => {
      let N = O("q", e.dataType, e.dims, S), K = O("key", r.dataType, r.dims, S), q = [N, K];
      if (E) {
        let te = O("past_key", n.dataType, n.dims, S);
        q.push(te);
      }
      o && q.push(O("attention_bias", o.dataType, o.dims));
      let Q = u ? O("seq_lens", u.dataType, u.dims) : undefined;
      Q && q.push(Q);
      let D = d ? O("total_sequence_length_input", d.dataType, d.dims) : undefined;
      D && q.push(D);
      let W = R("output", e.dataType, p), j = [W];
      m && j.push(R("present_key", e.dataType, b, S));
      let Y = Pe(1, S), Z = [{ name: "M", type: "u32" }, { name: "K", type: "u32" }, { name: "N", type: "u32" }, { name: "num_heads", type: "u32" }, { name: "head_size", type: "u32" }, { name: "alpha", type: "f32" }, { name: "past_sequence_length", type: "u32" }, { name: "kv_sequence_length", type: "u32" }, { name: "n_reps", type: "u32" }];
      return `
  const TILE_SIZE = ${$}u;

  var<workgroup> tileQ: array<${N.type.storage}, ${$ * $}>;
  var<workgroup> tileK: array<${N.type.storage}, ${$ * $}>;
  ${M.registerUniforms(Z).declareVariables(...q, ...j)}
  ${M.mainStart([$, $, 1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${y === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
    let kv_num_heads = ${y === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${bo(Q, D, true)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${E && m ? "let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;" : ""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${m ? "let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${Y}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${E && m ? `
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }` : `
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${m ? `if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }` : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${Y}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
        switch (S) {
          case 1:
            return "value";
          case 2:
            return "value.x + value.y";
          case 4:
            return "value.x + value.y + value.z + value.w";
          default:
            throw new Error(`Unsupported components: ${S}`);
        }
      })()};
        output[outputIdx] = ${W.type.value} (sum * uniforms.alpha) + ${o ? "attention_bias[outputIdx]" : "0.0"};
    }
  }`;
    };
    return { name: "AttentionProbs", shaderCache: { hint: `${S};${o !== undefined};${n !== undefined};${t}`, inputDependencies: A }, getRunData: () => ({ outputs: z, dispatchGroup: T, programUniforms: I }), getShaderSource: v };
  }, wh = (t, e, r, n, o, i, s = undefined, u = undefined) => {
    let d = i + o.kvSequenceLength, c = o.nReps ? o.nReps : 1, p = o.vHiddenSize * c, m = t > 1 && n, g = o.kvNumHeads ? o.kvNumHeads : o.numHeads, b = m ? [o.batchSize, g, d, o.headSize] : undefined, y = [o.batchSize, o.sequenceLength, p], w = 12, S = { x: Math.ceil(o.vHeadSize / w), y: Math.ceil(o.sequenceLength / w), z: o.batchSize * o.numHeads }, x = [{ type: 12, data: o.sequenceLength }, { type: 12, data: d }, { type: 12, data: o.vHeadSize }, { type: 12, data: o.numHeads }, { type: 12, data: o.headSize }, { type: 12, data: p }, { type: 12, data: i }, { type: 12, data: o.kvSequenceLength }, { type: 12, data: c }], $ = m && n && k.size(n.dims) > 0, T = ["type", "type"];
    $ && T.push("type"), s && T.push("type"), u && T.push("type");
    let I = [{ dims: y, dataType: e.dataType, gpuDataType: 0 }];
    m && I.push({ dims: b, dataType: e.dataType, gpuDataType: 0 });
    let E = (A) => {
      let z = O("probs", e.dataType, e.dims), v = O("v", r.dataType, r.dims), M = [z, v];
      $ && M.push(O("past_value", n.dataType, n.dims));
      let N = s ? O("seq_lens", s.dataType, s.dims) : undefined;
      s && M.push(N);
      let K = u ? O("total_sequence_length_input", u.dataType, u.dims) : undefined;
      u && M.push(K);
      let Q = [R("output", e.dataType, y)];
      m && Q.push(R("present_value", e.dataType, b));
      let D = [{ name: "M", type: "u32" }, { name: "K", type: "u32" }, { name: "N", type: "u32" }, { name: "num_heads", type: "u32" }, { name: "head_size", type: "u32" }, { name: "v_hidden_size", type: "u32" }, { name: "past_sequence_length", type: "u32" }, { name: "kv_sequence_length", type: "u32" }, { name: "n_reps", type: "u32" }];
      return `
  const TILE_SIZE = ${w}u;
  var<workgroup> tileQ: array<${z.type.value}, ${w * w}>;
  var<workgroup> tileV: array<${z.type.value}, ${w * w}>;
  ${A.registerUniforms(D).declareVariables(...M, ...Q)}
  ${A.mainStart([w, w, 1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${c === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
   let kv_num_heads = ${c === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${bo(N, K, true)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${$ && m ? "let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;" : ""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${m ? "let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${z.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${$ && m ? `
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      ` : `
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${m ? `
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }` : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
    };
    return { name: "AttentionScore", shaderCache: { hint: `${n !== undefined};${t}`, inputDependencies: T }, getRunData: () => ({ outputs: I, dispatchGroup: S, programUniforms: x }), getShaderSource: E };
  }, Wt = (t, e, r, n, o, i, s, u, d, c, p = undefined, m = undefined) => {
    let g = Math.min(t.outputCount, 1 + (s ? 1 : 0) + (u ? 1 : 0)), b = g > 1 ? c.pastSequenceLength : 0, y = b + c.kvSequenceLength, w = d && k.size(d.dims) > 0 ? d : undefined, S = [e, r];
    g > 1 && s && k.size(s.dims) > 0 && S.push(s), w && S.push(w), p && S.push(p), m && S.push(m);
    let x = t.compute(bh(g, e, r, s, w, c, b, p, m), { inputs: S, outputs: g > 1 ? [-1, 1] : [-1] })[0];
    t.compute(yh(x, c.batchSize, c.numHeads, b, c.sequenceLength, y, p, m), { inputs: p && m ? [x, p, m] : [x], outputs: [] });
    let $ = [x, n];
    g > 1 && u && k.size(u.dims) > 0 && $.push(u), p && $.push(p), m && $.push(m), t.compute(wh(g, x, n, u, c, b, p, m), { inputs: $, outputs: g > 1 ? [0, 2] : [0] });
  }, _h = (t, e) => {
    let r = [e.batchSize, e.numHeads, e.sequenceLength, e.headSize], n = e.sequenceLength, o = e.inputHiddenSize, i = e.headSize, s = 12, u = { x: Math.ceil(e.headSize / s), y: Math.ceil(e.sequenceLength / s), z: e.batchSize * e.numHeads }, d = [t.inputs[0], t.inputs[1], t.inputs[2]], c = [{ type: 12, data: n }, { type: 12, data: o }, { type: 12, data: i }, { type: 12, data: e.numHeads }, { type: 12, data: e.headSize }, { type: 12, data: e.hiddenSize }, { type: 12, data: e.hiddenSize + e.hiddenSize + e.vHiddenSize }], p = (m) => {
      let g = R("output_q", d[0].dataType, r), b = R("output_k", d[0].dataType, r), y = R("output_v", d[0].dataType, r), w = O("input", d[0].dataType, d[0].dims), S = O("weight", d[1].dataType, d[1].dims), x = O("bias", d[2].dataType, d[2].dims), $ = w.type.storage, T = [{ name: "M", type: "u32" }, { name: "K", type: "u32" }, { name: "N", type: "u32" }, { name: "num_heads", type: "u32" }, { name: "head_size", type: "u32" }, { name: "hidden_size", type: "u32" }, { name: "ldb", type: "u32" }];
      return `
  const TILE_SIZE = ${s}u;
  var<workgroup> tileInput: array<${$}, ${s * s}>;
  var<workgroup> tileWeightQ: array<${$}, ${s * s}>;
  var<workgroup> tileWeightK: array<${$}, ${s * s}>;
  var<workgroup> tileWeightV: array<${$}, ${s * s}>;
  ${m.registerUniforms(T).declareVariables(w, S, x, g, b, y)}
  ${m.mainStart([s, s, 1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${$}(0);
    var valueK = ${$}(0);
    var valueV = ${$}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
    };
    return t.compute({ name: "AttentionPrepare", shaderCache: { inputDependencies: ["type", "type", "type"] }, getRunData: () => ({ outputs: [{ dims: r, dataType: t.inputs[0].dataType, gpuDataType: 0 }, { dims: r, dataType: t.inputs[0].dataType, gpuDataType: 0 }, { dims: r, dataType: t.inputs[0].dataType, gpuDataType: 0 }], dispatchGroup: u, programUniforms: c }), getShaderSource: p }, { inputs: d, outputs: [-1, -1, -1] });
  }, wu = (t, e) => {
    let r = gh(t.inputs, e), [n, o, i] = _h(t, r);
    return Wt(t, n, o, i, t.inputs[4], undefined, undefined, undefined, t.inputs[5], r);
  };
});
var vh;
var $h;
var xh;
var _u;
var vu = V(() => {
  Ve();
  J();
  ne();
  Ie();
  ae();
  vh = (t, e) => {
    if (!t || t.length !== 5)
      throw new Error("BatchNormalization requires 5 inputs");
    let r = (n, o, i) => {
      let s = o.length;
      if (s !== n.length)
        throw new Error(`${i}: num dimensions != ${s}`);
      o.forEach((u, d) => {
        if (u !== n[d])
          throw new Error(`${i}: dim[${d}] do not match`);
      });
    };
    if (t[0].dims.length > 1) {
      let n = e.format === "NHWC" ? e.spatial ? t[0].dims.slice(-1) : t[0].dims.slice(-1).concat(t[0].dims.slice(1, t[0].dims.length - 1)) : t[0].dims.slice(1, e.spatial ? 2 : undefined);
      r(t[1].dims, n, "Invalid input scale"), r(t[2].dims, n, "Invalid input B"), r(t[3].dims, n, "Invalid input mean"), r(t[4].dims, n, "Invalid input var");
    } else
      r(t[1].dims, [1], "Invalid input scale"), r(t[2].dims, [1], "Invalid input B"), r(t[3].dims, [1], "Invalid input mean"), r(t[4].dims, [1], "Invalid input var");
  }, $h = (t, e) => {
    let { epsilon: r, spatial: n, format: o } = e, i = t[0].dims, s = n ? fe(i[i.length - 1]) : 1, u = o === "NHWC" && i.length > 1 ? s : 1, d = k.size(i) / s, c = n, p = c ? i.length : i, m = O("x", t[0].dataType, t[0].dims, s), g = O("scale", t[1].dataType, t[1].dims, u), b = O("bias", t[2].dataType, t[2].dims, u), y = O("inputMean", t[3].dataType, t[3].dims, u), w = O("inputVar", t[4].dataType, t[4].dims, u), S = R("y", t[0].dataType, p, s), x = () => {
      let T = "";
      if (n)
        T = `let cOffset = ${i.length === 1 ? "0u" : o === "NHWC" ? `outputIndices[${i.length - 1}] / ${s}` : "outputIndices[1]"};`;
      else if (o === "NCHW")
        T = `
            ${S.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${S.indicesToOffset("outputIndices")};`;
      else {
        T = `var cIndices = ${g.type.indices}(0);
                       cIndices[0] = outputIndices[${i.length - 1}];`;
        for (let I = 1;I < g.rank; I++)
          T += `cIndices[${I}] = outputIndices[${I}];`;
        T += `let cOffset = ${g.indicesToOffset("cIndices")};`;
      }
      return T;
    }, $ = (T) => `
  const epsilon = ${r};
  ${T.registerUniform("outputSize", "u32").declareVariables(m, g, b, y, w, S)}
  ${T.mainStart()}
  ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${S.offsetToIndices(`global_idx * ${s}`)};
    ${x()}
    let scale = ${g.getByOffset("cOffset")};
    let bias = ${b.getByOffset("cOffset")};
    let inputMean = ${y.getByOffset("cOffset")};
    let inputVar = ${w.getByOffset("cOffset")};
    let x = ${m.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${S.setByOffset("global_idx", "value")}
  }`;
    return { name: "BatchNormalization", shaderCache: { hint: `${e.epsilon}_${e.format}_${n}_${s}`, inputDependencies: c ? ["rank", "type", "type", "type", "type"] : undefined }, getShaderSource: $, getRunData: () => ({ outputs: [{ dims: t[0].dims, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(d / 64) }, programUniforms: c ? [{ type: 12, data: d }, ...L(i)] : [{ type: 12, data: d }] }) };
  }, xh = (t) => ee(t), _u = (t, e) => {
    let { inputs: r, outputCount: n } = t, o = xh({ ...e, outputCount: n });
    if (ye.webgpu.validateInputContent && vh(r, o), e.trainingMode)
      throw new Error("BatchNormalization trainingMode is not supported yet.");
    t.compute($h(r, o));
  };
});
var Sh;
var Th;
var $u;
var xu = V(() => {
  ne();
  ae();
  Sh = (t) => {
    if (t[0].dims.length !== 3)
      throw new Error("input should have 3 dimensions");
    if (![320, 640, 1280].includes(t[0].dims[2]))
      throw new Error("number of channels should be 320, 640 or 1280");
    if (t[1].dims.length !== 1)
      throw new Error("bias is expected to have 1 dimensions");
    if (t[0].dims[2] !== t[1].dims[0])
      throw new Error("last dimension of input and bias are not the same");
  }, Th = (t) => {
    let e = t[0].dims, r = t[0].dims[2], n = k.size(e) / 4, o = t[0].dataType, i = O("input", o, e, 4), s = O("bias", o, [r], 4), u = O("residual", o, e, 4), d = R("output", o, e, 4);
    return { name: "BiasAdd", getRunData: () => ({ outputs: [{ dims: e, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(n / 64) } }), getShaderSource: (p) => `
  const channels = ${r}u / 4;
  ${p.declareVariables(i, s, u, d)}

  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes(n)}
    let value = ${i.getByOffset("global_idx")}
      + ${s.getByOffset("global_idx % channels")} + ${u.getByOffset("global_idx")};
    ${d.setByOffset("global_idx", "value")}
  }` };
  }, $u = (t) => {
    Sh(t.inputs), t.compute(Th(t.inputs));
  };
});
var Ih;
var he;
var Su;
var Tu;
var Iu;
var Cu;
var Au;
var Eu;
var ku;
var Pu;
var Ou;
var Ch;
var zu;
var Du;
var Bu;
var Mu;
var nr;
var Ru;
var en;
var Uu;
var Nu;
var Vu;
var Lu;
var Wu;
var Gu;
var Hu;
var Fu;
var qu;
var Ku;
var ju;
var Zu;
var Qu;
var Yu;
var Xu;
var Ju;
var ed;
var td;
var wo;
var _o;
var rd;
var nd;
var od;
var Ah;
var Eh;
var id;
var tn = V(() => {
  J();
  ne();
  Ie();
  ae();
  Ih = (t, e, r, n, o, i, s) => {
    let u = Math.ceil(e / 4), d = "";
    typeof o == "string" ? d = `${o}(a)` : d = o("a");
    let c = O("inputData", r, [u], 4), p = R("outputData", n, [u], 4), m = [{ name: "vec_size", type: "u32" }];
    return s && m.push(...s), `
      ${t.registerUniforms(m).declareVariables(c, p)}

  ${i ?? ""}

  ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${c.getByOffset("global_idx")};
    ${p.setByOffset("global_idx", d)}
  }`;
  }, he = (t, e, r, n, o, i = t.dataType, s, u) => {
    let d = [{ type: 12, data: Math.ceil(k.size(t.dims) / 4) }];
    return s && d.push(...s), { name: e, shaderCache: { hint: o, inputDependencies: ["type"] }, getShaderSource: (c) => Ih(c, k.size(t.dims), t.dataType, i, r, n, u), getRunData: (c) => ({ outputs: [{ dims: t.dims, dataType: i }], dispatchGroup: { x: Math.ceil(k.size(c[0].dims) / 64 / 4) }, programUniforms: d }) };
  }, Su = (t) => {
    t.compute(he(t.inputs[0], "Abs", "abs"));
  }, Tu = (t) => {
    t.compute(he(t.inputs[0], "Acos", "acos"));
  }, Iu = (t) => {
    t.compute(he(t.inputs[0], "Acosh", "acosh"));
  }, Cu = (t) => {
    t.compute(he(t.inputs[0], "Asin", "asin"));
  }, Au = (t) => {
    t.compute(he(t.inputs[0], "Asinh", "asinh"));
  }, Eu = (t) => {
    t.compute(he(t.inputs[0], "Atan", "atan"));
  }, ku = (t) => {
    t.compute(he(t.inputs[0], "Atanh", "atanh"));
  }, Pu = (t) => ee(t), Ou = (t, e) => {
    let r;
    switch (e.to) {
      case 10:
        r = "vec4<f16>";
        break;
      case 1:
        r = "vec4<f32>";
        break;
      case 12:
        r = "vec4<u32>";
        break;
      case 6:
        r = "vec4<i32>";
        break;
      case 9:
        r = "vec4<bool>";
        break;
      default:
        throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`);
    }
    t.compute(he(t.inputs[0], "Cast", r, undefined, e.cacheKey, e.to));
  }, Ch = (t) => {
    let e, r, n = t.length >= 2 && t[1].data !== 0, o = t.length >= 3 && t[2].data !== 0;
    switch (t[0].dataType) {
      case 1:
        e = n ? t[1].getFloat32Array()[0] : -340282346638528860000000000000000000000, r = o ? t[2].getFloat32Array()[0] : 340282346638528860000000000000000000000;
        break;
      case 10:
        e = n ? t[1].getUint16Array()[0] : 64511, r = o ? t[2].getUint16Array()[0] : 31743;
        break;
      default:
        throw new Error("Unsupport data type");
    }
    return ee({ min: e, max: r });
  }, zu = (t, e) => {
    let r = e || Ch(t.inputs), n = Pe(t.inputs[0].dataType);
    t.compute(he(t.inputs[0], "Clip", (o) => `clamp(${o}, vec4<${n}>(uniforms.min), vec4<${n}>(uniforms.max))`, undefined, r.cacheKey, undefined, [{ type: t.inputs[0].dataType, data: r.min }, { type: t.inputs[0].dataType, data: r.max }], [{ name: "min", type: n }, { name: "max", type: n }]), { inputs: [0] });
  }, Du = (t) => {
    t.compute(he(t.inputs[0], "Ceil", "ceil"));
  }, Bu = (t) => {
    t.compute(he(t.inputs[0], "Cos", "cos"));
  }, Mu = (t) => {
    t.compute(he(t.inputs[0], "Cosh", "cosh"));
  }, nr = (t) => ee(t), Ru = (t, e) => {
    let r = Pe(t.inputs[0].dataType);
    t.compute(he(t.inputs[0], "Elu", (n) => `elu_vf32(${n})`, `
  const elu_alpha_ = ${r}(${e.alpha});

  fn elu_f32(a: ${r}) -> ${r} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`, e.cacheKey));
  }, en = (t = "f32") => `
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: vec4<${t}>) -> vec4<${t}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`, Uu = (t) => {
    let e = Pe(t.inputs[0].dataType);
    t.compute(he(t.inputs[0], "Erf", (r) => `erf_vf32(${r})`, en(e)));
  }, Nu = (t) => {
    t.compute(he(t.inputs[0], "Exp", "exp"));
  }, Vu = (t) => {
    t.compute(he(t.inputs[0], "Floor", "floor"));
  }, Lu = (t) => {
    let e = Pe(t.inputs[0].dataType);
    t.compute(he(t.inputs[0], "Gelu", (r) => `0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`, en(e)));
  }, Wu = (t, e) => {
    let r = Pe(t.inputs[0].dataType);
    t.compute(he(t.inputs[0], "LeakyRelu", (n) => `select(leaky_relu_alpha_ * ${n}, ${n}, ${n} >= vec4<${r}>(0.0))`, `const leaky_relu_alpha_ = ${r}(${e.alpha});`, e.cacheKey));
  }, Gu = (t) => {
    t.compute(he(t.inputs[0], "Not", (e) => `!${e}`));
  }, Hu = (t) => {
    t.compute(he(t.inputs[0], "Neg", (e) => `-${e}`));
  }, Fu = (t) => {
    t.compute(he(t.inputs[0], "Reciprocal", (e) => `1.0/${e}`));
  }, qu = (t) => {
    let e = Pe(t.inputs[0].dataType);
    t.compute(he(t.inputs[0], "Relu", (r) => `select(vec4<${e}>(0.0), ${r}, ${r} > vec4<${e}>(0.0))`));
  }, Ku = (t) => {
    t.compute(he(t.inputs[0], "Sigmoid", (e) => `(1.0 / (1.0 + exp(-${e})))`));
  }, ju = (t) => ee(t), Zu = (t, e) => {
    let r = Pe(t.inputs[0].dataType);
    t.compute(he(t.inputs[0], "HardSigmoid", (n) => `max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${e.alpha} * ${n} + vec4<${r}>(${e.beta})))`, undefined, e.cacheKey));
  }, Qu = (t) => {
    t.compute(he(t.inputs[0], "Sin", "sin"));
  }, Yu = (t) => {
    t.compute(he(t.inputs[0], "Sinh", "sinh"));
  }, Xu = (t) => {
    t.compute(he(t.inputs[0], "Sqrt", "sqrt"));
  }, Ju = (t) => {
    t.compute(he(t.inputs[0], "Tan", "tan"));
  }, ed = (t) => `sign(${t}) * (1 - exp(-2 * abs(${t}))) / (1 + exp(-2 * abs(${t})))`, td = (t) => {
    t.compute(he(t.inputs[0], "Tanh", ed));
  }, wo = (t = "f32") => `
const fast_gelu_a: ${t} = 0.5;
const fast_gelu_b: ${t} = 0.7978845608028654;
const fast_gelu_c: ${t} = 0.035677408136300125;

fn tanh_v(v: vec4<${t}>) -> vec4<${t}> {
  return ${ed("v")};
}
`, _o = (t) => `(fast_gelu_a + fast_gelu_a * tanh_v(${t} * (fast_gelu_c * ${t} * ${t} + fast_gelu_b))) * ${t}`, rd = (t) => {
    let e = Pe(t.inputs[0].dataType);
    t.compute(he(t.inputs[0], "FastGelu", _o, wo(e), undefined, t.inputs[0].dataType));
  }, nd = (t, e) => {
    let r = Pe(t.inputs[0].dataType);
    return t.compute(he(t.inputs[0], "ThresholdedRelu", (n) => `select(vec4<${r}>(0.0), ${n}, ${n} > thresholded_relu_alpha_)`, `const thresholded_relu_alpha_ = vec4<${r}>(${e.alpha});`, e.cacheKey)), 0;
  }, od = (t) => {
    t.compute(he(t.inputs[0], "Log", "log"));
  }, Ah = (t, e) => `
const alpha = vec4<${t}>(${e});
const one = ${t}(1.0);
const zero = ${t}(0.0);

fn quick_gelu_impl(x: vec4<${t}>) -> vec4<${t}> {
  let v = x *alpha;
  var x1 : vec4<${t}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`, Eh = (t) => `quick_gelu_impl(${t})`, id = (t, e) => {
    let r = Pe(t.inputs[0].dataType);
    t.compute(he(t.inputs[0], "QuickGelu", Eh, Ah(r, e.alpha), e.cacheKey, t.inputs[0].dataType));
  };
});
var kh;
var Ph;
var sd;
var ud = V(() => {
  ne();
  ae();
  tn();
  kh = (t) => {
    if (t[0].dims.length !== 3)
      throw new Error("input should have 3 dimensions");
    if (![2560, 5120, 10240].includes(t[0].dims[2]))
      throw new Error("hidden state should be 2560, 5120 or 10240");
    if (t[1].dims.length !== 1)
      throw new Error("bias is expected to have 1 dimensions");
    if (t[0].dims[2] !== t[1].dims[0])
      throw new Error("last dimension of input and bias are not the same");
  }, Ph = (t) => {
    let e = t[0].dims.slice();
    e[2] = e[2] / 2;
    let r = O("input", t[0].dataType, t[0].dims, 4), n = O("bias", t[0].dataType, [t[0].dims[2]], 4), o = R("output", t[0].dataType, e, 4), i = k.size(e) / 4, s = be(t[0].dataType);
    return { name: "BiasSplitGelu", getRunData: () => ({ outputs: [{ dims: e, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(i / 64) } }), getShaderSource: (d) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${t[0].dims[2] / 4 / 2}u;

  ${d.declareVariables(r, n, o)}

  ${en(s)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${o.setByOffset("global_idx", "valueLeft * geluRight")}
  }` };
  }, sd = (t) => {
    kh(t.inputs), t.compute(Ph(t.inputs));
  };
});
var Oh;
var zh;
var dt;
var dd;
var ld;
var cd;
var pd;
var md;
var fd;
var hd;
var gd;
var yd;
var bd;
var wd = V(() => {
  J();
  ne();
  ae();
  Oh = (t, e, r, n, o, i, s, u, d, c, p, m) => {
    let g, b;
    typeof u == "string" ? g = b = ($, T) => `${u}((${$}),(${T}))` : typeof u == "function" ? g = b = u : (g = u.scalar, b = u.vector);
    let y = R("outputData", p, n.length, 4), w = O("aData", d, e.length, 4), S = O("bData", c, r.length, 4), x;
    if (o)
      if (i) {
        let $ = k.size(e) === 1, T = k.size(r) === 1, I = e.length > 0 && e[e.length - 1] % 4 === 0, E = r.length > 0 && r[r.length - 1] % 4 === 0;
        $ || T ? x = y.setByOffset("global_idx", b($ ? `${w.type.value}(${w.getByOffset("0")}.x)` : w.getByOffset("global_idx"), T ? `${S.type.value}(${S.getByOffset("0")}.x)` : S.getByOffset("global_idx"))) : x = `
            let outputIndices = ${y.offsetToIndices("global_idx * 4u")};
            let offsetA = ${w.broadcastedIndicesToOffset("outputIndices", y)};
            let offsetB = ${S.broadcastedIndicesToOffset("outputIndices", y)};
            ${y.setByOffset("global_idx", b(s || I ? w.getByOffset("offsetA / 4u") : `${w.type.value}(${w.getByOffset("offsetA / 4u")}[offsetA % 4u])`, s || E ? S.getByOffset("offsetB / 4u") : `${S.type.value}(${S.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `;
      } else
        x = y.setByOffset("global_idx", b(w.getByOffset("global_idx"), S.getByOffset("global_idx")));
    else {
      if (!i)
        throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
      let $ = (T, I, E = "") => {
        let A = `aData[indexA${I}][componentA${I}]`, z = `bData[indexB${I}][componentB${I}]`;
        return `
            let outputIndices${I} = ${y.offsetToIndices(`global_idx * 4u + ${I}u`)};
            let offsetA${I} = ${w.broadcastedIndicesToOffset(`outputIndices${I}`, y)};
            let offsetB${I} = ${S.broadcastedIndicesToOffset(`outputIndices${I}`, y)};
            let indexA${I} = offsetA${I} / 4u;
            let indexB${I} = offsetB${I} / 4u;
            let componentA${I} = offsetA${I} % 4u;
            let componentB${I} = offsetB${I} % 4u;
            ${T}[${I}] = ${E}(${g(A, z)});
          `;
      };
      p === 9 ? x = `
            var data = vec4<u32>(0);
            ${$("data", 0, "u32")}
            ${$("data", 1, "u32")}
            ${$("data", 2, "u32")}
            ${$("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));` : x = `
            ${$("outputData[global_idx]", 0)}
            ${$("outputData[global_idx]", 1)}
            ${$("outputData[global_idx]", 2)}
            ${$("outputData[global_idx]", 3)}
          `;
    }
    return `
        ${t.registerUniform("vec_size", "u32").declareVariables(w, S, y)}

        ${m ?? ""}

        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${x}
      }`;
  }, zh = (t, e, r, n, o, i, s = r.dataType) => {
    let u = r.dims.map(Number), d = n.dims.map(Number), c = !k.areEqual(u, d), p = u, m = k.size(u), g = false, b = false, y = [c];
    if (c) {
      let w = ot.calcShape(u, d, false);
      if (!w)
        throw new Error("Can't perform binary op on the given tensors");
      p = w.slice(), m = k.size(p);
      let S = k.size(u) === 1, x = k.size(d) === 1, $ = u.length > 0 && u[u.length - 1] % 4 === 0, T = d.length > 0 && d[d.length - 1] % 4 === 0;
      y.push(S), y.push(x), y.push($), y.push(T);
      let I = 1;
      for (let E = 1;E < p.length; E++) {
        let A = u[u.length - E], z = d[d.length - E];
        if (A === z)
          I *= A;
        else
          break;
      }
      I % 4 === 0 ? (b = true, g = true) : (S || x || $ || T) && (g = true);
    } else
      g = true;
    return y.push(g), { name: t, shaderCache: { hint: e + y.map((w) => w.toString()).join("_"), inputDependencies: ["rank", "rank"] }, getShaderSource: (w) => Oh(w, u, d, p, g, c, b, o, r.dataType, n.dataType, s, i), getRunData: () => ({ outputs: [{ dims: p, dataType: s }], dispatchGroup: { x: Math.ceil(m / 64 / 4) }, programUniforms: [{ type: 12, data: Math.ceil(k.size(p) / 4) }, ...L(u, d, p)] }) };
  }, dt = (t, e, r, n, o, i) => {
    t.compute(zh(e, o ?? "", t.inputs[0], t.inputs[1], r, n, i));
  }, dd = (t) => {
    dt(t, "Add", (e, r) => `${e}+${r}`);
  }, ld = (t) => {
    dt(t, "Div", (e, r) => `${e}/${r}`);
  }, cd = (t) => {
    dt(t, "Equal", { scalar: (e, r) => `u32(${e}==${r})`, vector: (e, r) => `vec4<u32>(${e}==${r})` }, undefined, undefined, 9);
  }, pd = (t) => {
    dt(t, "Mul", (e, r) => `${e}*${r}`);
  }, md = (t) => {
    let e = O("input", t.inputs[0].dataType, t.inputs[0].dims).type.value;
    dt(t, "Pow", { scalar: (n, o) => `pow_custom(${n},${o})`, vector: (n, o) => `pow_vector_custom(${n},${o})` }, `
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e === "i32" ? "round" : ""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `);
  }, fd = (t) => {
    dt(t, "Sub", (e, r) => `${e}-${r}`);
  }, hd = (t) => {
    dt(t, "Greater", { scalar: (e, r) => `u32(${e}>${r})`, vector: (e, r) => `vec4<u32>(${e}>${r})` }, undefined, undefined, 9);
  }, gd = (t) => {
    dt(t, "Less", { scalar: (e, r) => `u32(${e}<${r})`, vector: (e, r) => `vec4<u32>(${e}<${r})` }, undefined, undefined, 9);
  }, yd = (t) => {
    dt(t, "GreaterOrEqual", { scalar: (e, r) => `u32(${e}>=${r})`, vector: (e, r) => `vec4<u32>(${e}>=${r})` }, undefined, undefined, 9);
  }, bd = (t) => {
    dt(t, "LessOrEqual", { scalar: (e, r) => `u32(${e}<=${r})`, vector: (e, r) => `vec4<u32>(${e}<=${r})` }, undefined, undefined, 9);
  };
});
var Bh;
var Mh;
var Rh;
var Uh;
var _d;
var vd;
var $d = V(() => {
  J();
  ne();
  Ie();
  ae();
  Bh = (t, e) => {
    if (!t || t.length < 1)
      throw new Error("too few inputs");
    let r = 0, n = t[r], o = n.dataType, i = n.dims.length;
    t.forEach((s, u) => {
      if (u !== r) {
        if (s.dataType !== o)
          throw new Error("input tensors should be one type");
        if (s.dims.length !== i)
          throw new Error("input tensors should have the same shape");
        s.dims.forEach((d, c) => {
          if (c !== e && d !== n.dims[c])
            throw new Error("non concat dimensions must match");
        });
      }
    });
  }, Mh = (t, e) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${t}u>(${e});
    for (var i: u32 = 0u; i < ${t}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${t}u;
  }`, Rh = (t, e) => {
    let r = t.length, n = [];
    for (let o = 0;o < r; ++o) {
      let i = e.setByOffset("global_idx", t[o].getByIndices("indices"));
      r === 1 ? n.push(i) : o === 0 ? n.push(`if (inputIndex == ${o}u) { ${i} }`) : o === r - 1 ? n.push(`else { ${i} }`) : n.push(`else if (inputIndex == ${o}) { ${i} }`);
    }
    return n.join(`
`);
  }, Uh = (t, e, r, n) => {
    let o = k.size(r), i = new Array(t.length), s = new Array(t.length), u = 0, d = [], c = [], p = [{ type: 12, data: o }];
    for (let w = 0;w < t.length; ++w)
      u += t[w].dims[e], i[w] = u, c.push(t[w].dims.length), s[w] = O(`input${w}`, n, c[w]), d.push("rank"), p.push({ type: 12, data: i[w] });
    for (let w = 0;w < t.length; ++w)
      p.push(...L(t[w].dims));
    p.push(...L(r));
    let m = R("output", n, r.length), g = m.indicesGet("indices", e), b = Array.from(Array(i.length).keys()).map((w) => `uniforms.sizeInConcatAxis${w}`).join(","), y = (w) => `

  ${(() => {
      w.registerUniform("outputSize", "u32");
      for (let S = 0;S < t.length; S++)
        w.registerUniform(`sizeInConcatAxis${S}`, "u32");
      return w.declareVariables(...s, m);
    })()}

  ${Mh(i.length, b)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${m.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${g});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${i.length}u>(${b});
      ${g} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Rh(s, m)}
  }`;
    return { name: "Concat", shaderCache: { hint: `${e}`, inputDependencies: d }, getRunData: () => ({ outputs: [{ dims: r, dataType: n }], dispatchGroup: { x: Math.ceil(o / 64) }, programUniforms: p }), getShaderSource: y };
  }, _d = (t, e) => {
    let r = t.inputs, n = r[0].dims, o = k.normalizeAxis(e.axis, n.length);
    Bh(r, o);
    let i = n.slice();
    i[o] = r.reduce((u, d) => u + (d.dims.length > o ? d.dims[o] : 0), 0);
    let s = r.filter((u) => k.size(u.dims) > 0);
    t.compute(Uh(s, o, i, r[0].dataType), { inputs: s });
  }, vd = (t) => ee({ axis: t.axis });
});
var Ze;
var Qe;
var Ye;
var rn;
var St = V(() => {
  J();
  ne();
  Ze = (t, e, r = "f32") => {
    switch (t.activation) {
      case "Relu":
        return `value = max(value, ${e}(0.0));`;
      case "Sigmoid":
        return `value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;
      case "Clip":
        return `value = clamp(value, ${e}(${r}(uniforms.clip_min)), ${e}(${r}(uniforms.clip_max)));`;
      case "HardSigmoid":
        return `value = max(${e}(0.0), min(${e}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;
      case "LeakyRelu":
        return `value = select(${r}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;
      case "Tanh":
        return `let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;
      case "":
        return "";
      default:
        throw new Error(`Unsupported activation ${t.activation}`);
    }
  }, Qe = (t, e) => {
    t.activation === "Clip" ? e.push({ type: 1, data: t.clipMax }, { type: 1, data: t.clipMin }) : t.activation === "HardSigmoid" ? e.push({ type: 1, data: t.alpha }, { type: 1, data: t.beta }) : t.activation === "LeakyRelu" && e.push({ type: 1, data: t.alpha });
  }, Ye = (t, e) => {
    t.activation === "Clip" ? e.push({ name: "clip_max", type: "f32" }, { name: "clip_min", type: "f32" }) : t.activation === "HardSigmoid" ? e.push({ name: "alpha", type: "f32" }, { name: "beta", type: "f32" }) : t.activation === "LeakyRelu" && e.push({ name: "alpha", type: "f32" });
  }, rn = (t) => {
    let e = t?.activation || "";
    if (e === "HardSigmoid") {
      let [r, n] = t?.activation_params || [0.2, 0.5];
      return { activation: e, alpha: r, beta: n };
    } else if (e === "Clip") {
      let [r, n] = t?.activation_params || [Es, ks];
      return { activation: e, clipMax: n, clipMin: r };
    } else if (e === "LeakyRelu") {
      let [r] = t?.activation_params || [0.01];
      return { activation: e, alpha: r };
    }
    return { activation: e };
  };
});
var Ee;
var xd;
var nn = V(() => {
  Ee = (t, e) => {
    switch (t) {
      case 1:
        return e;
      case 2:
        return `vec2<${e}>`;
      case 3:
        return `vec3<${e}>`;
      case 4:
        return `vec4<${e}>`;
      default:
        throw new Error(`${t}-component is not supported.`);
    }
  }, xd = (t) => `
      ${t ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
});
var Sd;
var Td = V(() => {
  Sd = (t) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${t}.x), i32(${t}.y), i32(${t}.z), 1));
}
`;
});
var or;
var on;
var an = V(() => {
  J();
  ne();
  ae();
  St();
  or = (t, e, r, n, o) => {
    let i = n - r;
    return `
      ${Array.from({ length: r }).map((s, u) => `
      if (${F(e.shape, u, e.rank)} != 1) {
        ${e.indicesSet(t, u, F(o, u + i, n))}
      } else {
        ${e.indicesSet(t, u, 0)}
      }`).join("")}
`;
  }, on = (t, e, r, n, o = false, i) => {
    let s = t[0].dims, u = t[1].dims, d = s[s.length - 2], c = u[u.length - 1], p = s[s.length - 1], m = fe(c), g = fe(p), b = fe(d), y = k.size(r) / m / b, w = t.length > 2, S = n ? n.slice(0, -2) : r.slice(0, -2), $ = [k.size(S), d, c], T = [{ type: 12, data: y }, { type: 12, data: d }, { type: 12, data: c }, { type: 12, data: p }];
    Qe(e, T), T.push(...L(S, s, u)), w && T.push(...L(t[2].dims)), T.push(...L($));
    let I = (E) => {
      let A = Qr("batch_dims", t[0].dataType, S.length), z = O("a", t[0].dataType, s.length, g), v = O("b", t[1].dataType, u.length, m), M = R("output", t[0].dataType, $.length, m), N = be(M.type.tensor), K = Ze(e, M.type.value, N), q = [z, v], Q = "";
      if (w) {
        let j = o ? m : 1;
        q.push(O("bias", t[2].dataType, t[2].dims.length, j)), Q = `${o ? `value += bias[col / ${j}];` : `value += ${M.type.value}(bias[row + i]);`}`;
      }
      let D = [{ name: "output_size", type: "u32" }, { name: "M", type: "u32" }, { name: "N", type: "u32" }, { name: "K", type: "u32" }];
      Ye(e, D);
      let W = () => {
        let j = `var a_data: ${z.type.value};`;
        for (let Y = 0;Y < g; Y++)
          j += `
              let b_data${Y} = b[(b_offset + (k + ${Y}) * uniforms.N + col) / ${m}];`;
        for (let Y = 0;Y < b; Y++) {
          j += `a_data = a[(a_offset + (row + ${Y}) * uniforms.K + k) / ${g}];`;
          for (let Z = 0;Z < g; Z++)
            j += `
            values[${Y}] = fma(${v.type.value}(a_data${g === 1 ? "" : `[${Z}]`}), b_data${Z}, values[${Y}]);
`;
        }
        return j;
      };
      return `
  ${E.registerUniforms(D).registerInternalVariables(A).declareVariables(...q, M)}
  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${m})) * ${m};
    var index1 = global_idx / (uniforms.N / ${m});
    let stride1 = uniforms.M / ${b};
    let row = (index1 % stride1) * ${b};
    let batch = index1 / stride1;

    ${r.length === 2 ? "" : `let batch_indices = ${A.offsetToIndices("batch")};`}

    var a_indices: ${z.type.indices};
    ${or("a_indices", z, z.rank - 2, A.rank, "batch_indices")}
    ${z.indicesSet("a_indices", z.rank - 2, 0)}
    ${z.indicesSet("a_indices", z.rank - 1, 0)}
    let a_offset = ${z.indicesToOffset("a_indices")};

    var b_indices: ${v.type.indices};
    ${or("b_indices", v, v.rank - 2, A.rank, "batch_indices")}
    ${v.indicesSet("b_indices", v.rank - 2, 0)}
    ${v.indicesSet("b_indices", v.rank - 1, 0)}
    let b_offset = ${v.indicesToOffset("b_indices")};
    var values: array<${M.type.value}, ${b}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${g}) {
      ${W()}
    }
    for (var i = 0u; i < ${b}u; i++) {
      var value = values[i];
      ${Q}
      ${K}
      let cur_indices = ${M.type.indices}(batch, row + i, col);
      let offset = ${M.indicesToOffset("cur_indices")};
      ${M.setByOffset(`offset / ${m}`, "value")};
    }
  }
  `;
    };
    return { name: "MatMulNaive", shaderCache: { hint: `${e.activation};${m};${g};${b};${o}`, inputDependencies: w ? ["rank", "rank", "rank"] : ["rank", "rank"] }, getRunData: () => ({ outputs: [{ dims: i ? i(r) : r, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(y / 64) }, programUniforms: T }), getShaderSource: I };
  };
});
var Nh;
var Vh;
var vo;
var Id;
var Lh;
var $o;
var Wh;
var ir;
var sn = V(() => {
  J();
  ne();
  ae();
  St();
  an();
  nn();
  Nh = (t, e) => t ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e ? ", batchIndices" : ""});
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e ? ", batchIndices" : ""});
        `, Vh = (t, e) => t ? `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }` : `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`, vo = (t, e, r = "f32", n, o = false, i = 32, s = false, u = 32) => {
    let d = e[1] * t[1], c = e[0] * t[0], p = o ? d : i, m = o ? i : d, g = p / e[0], b = i / e[1];
    if (!((o && g === 4 && t[1] === 4 || !o && (g === 3 || g === 4)) && p % e[0] === 0 && i % e[1] === 0 && t[0] === 4))
      throw new Error(`If transposeA ${o} is true, innerElementSize ${g} and workPerThread[1] ${t[1]} must be 4.
      Otherwise, innerElementSize ${g} must be 3 or 4.
  tileAWidth ${p} must be divisible by workgroupSize[0]${e[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`);
    return `
var<workgroup> mm_Asub: array<array<vec${g}<${r}>, ${p / g}>, ${m}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${c / t[0]}>, ${i}>;

const rowPerThread = ${t[1]};
const colPerThread = ${t[0]};
const innerElementSize = ${g};
const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${s ? "0" : "i32(globalId.z)"};
  ${n ? `let batchIndices = ${n.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${d};

  let num_tiles = ${s ? `${Math.ceil(u / i)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${s ? `i32(globalId.z) * ${u}` : "0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${b};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${Nh(o, n)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${n ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${g === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Vh(o, g)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
  }, Id = (t, e) => t ? `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e ? ", batchIndices" : ""});
            ` : `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e ? ", batchIndices" : ""});
            `, Lh = (t) => t ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];", $o = (t, e, r = "f32", n, o = false, i = 32, s = false, u = 32, d = false) => {
    let c = t[1] * e[1], p = t[0] * e[0], m = o ? c : i, g = o ? i : c;
    if (!(g % e[1] === 0 && m % e[0] === 0 && i % e[1] === 0))
      throw new Error(`tileAHight ${g} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${m} must be divisible by workgroupSize[0]${e[0]}, tileInner ${i} must be divisible by workgroupSize[1]${e[1]}`);
    let b = g / e[1], y = m / e[0], w = i / e[1], S = d ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${c};
    let globalColStart = i32(workgroupId.x) * ${p};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${g}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${m}; inputCol = inputCol + ${e[0]}) {
          ${Id(o, n)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${n ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${o ? `mm_Asub[k][localRow + innerRow * ${e[1]}];` : `mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${c};

let tileRowA = i32(localId.y) * ${b};
let tileColA = i32(localId.x) * ${y};
let tileRowB = i32(localId.y) * ${w};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Id(o, n)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${n ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Lh(o)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
    return `
  var<workgroup> mm_Asub : array<array<${r}, ${m}>, ${g}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${p}>, ${i}>;
  const rowPerThread = ${t[1]};
  const colPerThread = ${t[0]};
  const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${s ? "0" : "i32(globalId.z)"};
    ${n ? `let batchIndices = ${n.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${s ? `${Math.ceil(u / i)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${s ? `i32(globalId.z) * ${u}` : "0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;
    ${S}
  }
`;
  }, Wh = (t, e, r, n, o = false) => {
    let [i, s, u, d] = n, c = be(n[0].type.tensor);
    return `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ee(t, c)} {
      var value = ${Ee(t, c)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${s.type.indices};
        ${or("aIndices", s, s.rank - 2, i.rank, "batchIndices")}
        ${s.indicesSet("aIndices", s.rank - 2, "u32(row)")}
        ${s.indicesSet("aIndices", s.rank - 1, "u32(colIn)")}
        value = ${s.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ee(t, c)} {
      var value = ${Ee(t, c)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${u.type.indices};
        ${or("bIndices", u, u.rank - 2, i.rank, "batchIndices")}
        ${u.indicesSet("bIndices", u.rank - 2, "u32(row)")}
        ${u.indicesSet("bIndices", u.rank - 1, "u32(colIn)")}
        value = ${u.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ee(t, c)}) {
      let col = colIn * ${t};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e ? `value = value + ${o ? "bias[colIn]" : `${Ee(t, c)}(bias[row])`};` : ""}
        ${r}
        ${d.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
  }, ir = (t, e, r, n, o = false, i) => {
    let s = t[0].dims, u = t[1].dims, d = s.slice(0, -2), c = u.slice(0, -2), p = n ? n.slice(0, -2) : r.slice(0, -2), m = k.size(p), g = s[s.length - 2], b = s[s.length - 1], y = u[u.length - 1], w = b % 4 === 0 && y % 4 === 0, S = g <= 8 ? [4, 1, 1] : [4, 4, 1], x = [8, 8, 1], $ = [Math.ceil(y / x[0] / S[0]), Math.ceil(g / x[1] / S[1]), Math.ceil(m / x[2] / S[2])], T = w ? 4 : 1, I = [...d, g, b / T], E = I.length, A = [...c, b, y / T], z = A.length, v = [m, g, y / T], M = [{ type: 6, data: g }, { type: 6, data: y }, { type: 6, data: b }];
    Qe(e, M), M.push(...L(p, I, A));
    let N = ["rank", "rank"], K = t.length > 2;
    K && (M.push(...L(t[2].dims)), N.push("rank")), M.push(...L(v));
    let q = (Q) => {
      let D = p.length, W = Qr("batchDims", t[0].dataType, D, 1), j = be(t[0].dataType), Y = O("a", t[0].dataType, E, T), Z = O("b", t[1].dataType, z, T), te = R("result", t[0].dataType, v.length, T), ie = [Y, Z];
      if (K) {
        let X = o ? T : 1;
        ie.push(O("bias", t[2].dataType, t[2].dims.length, X));
      }
      let we = [{ name: "dim_a_outer", type: "i32" }, { name: "dim_b_outer", type: "i32" }, { name: "dim_inner", type: "i32" }];
      Ye(e, we);
      let Te = be(te.type.tensor), re = Ze(e, te.type.value, Te), U = Wh(T, K, re, [W, Y, Z, te], o);
      return `
  ${Q.registerUniforms(we).registerInternalVariables(W).declareVariables(...ie, te)}
  ${U}
  ${w ? vo(S, x, j, W) : $o(S, x, j, W)}
                   `;
    };
    return { name: "MatMul", shaderCache: { hint: `${S};${e.activation};${w};${o}`, inputDependencies: N }, getRunData: () => ({ outputs: [{ dims: i ? i(r) : r, dataType: t[0].dataType }], dispatchGroup: { x: $[0], y: $[1], z: $[2] }, programUniforms: M }), getShaderSource: q };
  };
});
var Gh;
var Cd;
var Ad = V(() => {
  J();
  nt();
  ae();
  St();
  nn();
  Td();
  sn();
  Gh = (t, e, r, n, o = false, i, s = 4, u = 4, d = 4, c = "f32") => {
    let p = (N) => {
      switch (N) {
        case 1:
          return "resData = x[xIndex];";
        case 3:
          return `resData = vec3<${c}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
        case 4:
          return "resData = x[xIndex / 4];";
        default:
          throw new Error(`innerElementSize ${N} is not supported.`);
      }
    }, m = (N) => {
      switch (N) {
        case 1:
          return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
        case 4:
          return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
        default:
          throw new Error(`innerElementSize ${N} is not supported.`);
      }
    }, g = t ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `, b = t ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `, y = t ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])", w = t ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])", S = t ? "row" : "col", x = t ? "col" : "row", $ = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${t ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${S} / outWidth;
    let outCol = ${S} % outWidth;

    let WRow = ${x} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${x} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${x} % inChannels;
    var resData = ${Ee(s, c)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${w}) {
      ${g}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${p(s)}
    }
    return resData;`, T = t ? e && n ? `
    let col = colIn * ${s};
    ${$}` : `
    let col = colIn * ${s};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${$}
    }
    return ${Ee(s, c)}(0.0);` : n && r ? `
    let col = colIn * ${s};
    ${$}` : `
    let col = colIn * ${s};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${$}
    }
    return ${Ee(s, c)}(0.0);`, I = t ? n && r ? m(u) : `
    let col = colIn * ${u};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${m(u)}
    }
    return ${Ee(u, c)}(0.0);` : `
    let col = colIn * ${u};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${m(u)}
    }
    return ${Ee(u, c)}(0.0);`, E = Ee(d, c), A = t ? Ee(s, c) : Ee(u, c), z = t ? Ee(u, c) : Ee(s, c), v = Ze(i, E, c);
    return `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${A} {
      ${t ? T : I}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${z} {
      ${t ? I : T}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${E}) {
      let col = colIn * ${d};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${t ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${b}
      ${xd(o)}
      ${v}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
  }, Cd = (t, e, r, n, o, i, s, u, d) => {
    let c = e.format === "NHWC", p = c ? t[0].dims[3] : t[0].dims[1], m = r[0], g = c ? r[2] : r[3], b = c ? r[1] : r[2], y = c ? r[3] : r[1], w = c && (p % 4 === 0 || p % 3 === 0) && y % 4 === 0, S = c ? y : g * b, x = c ? g * b : y, $ = [8, 8, 1], T = n <= 8 ? [4, 1, 1] : [4, 4, 1], I = [Math.ceil(S / $[0] / T[0]), Math.ceil(x / $[1] / T[1]), Math.ceil(m / $[2] / T[2])];
    se("verbose", () => `[conv2d_mm_webgpu] dispatch = ${I}`);
    let E = w ? c && p % 4 !== 0 ? 3 : 4 : 1, A = $[1] * T[1], z = $[0] * T[0], v = Math.max($[0] * E, $[1]), M = n % A === 0, N = o % z === 0, K = i % v === 0, q = w ? [E, 4, 4] : [1, 1, 1], Q = [{ type: 6, data: n }, { type: 6, data: o }, { type: 6, data: i }, { type: 6, data: [e.pads[0], e.pads[1]] }, { type: 6, data: e.strides }, { type: 6, data: e.dilations }];
    Qe(e, Q), Q.push(...L(t[0].dims, t[1].dims));
    let D = ["rank", "rank"];
    s && (Q.push(...L(t[2].dims)), D.push("rank")), Q.push(...L(r));
    let W = (j) => {
      let Y = [{ name: "dim_a_outer", type: "i32" }, { name: "dim_b_outer", type: "i32" }, { name: "dim_inner", type: "i32" }, { name: "pad", type: "i32", length: 2 }, { name: "stride", type: "i32", length: 2 }, { name: "dilation", type: "i32", length: 2 }];
      Ye(e, Y);
      let Z = w ? 4 : 1, te = be(t[0].dataType), ie = `
      fn setOutputAtIndex(flatIndex : i32, value : ${w ? `vec4<${te}>` : te}) {
        result[flatIndex] = ${w ? `vec4<${te}>` : te}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${w ? `vec4<${te}>` : te}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${w ? "/ 4" : ""}, value);
      }`, we = O("x", t[0].dataType, t[0].dims.length, E === 3 ? 1 : E), Te = O("w", t[1].dataType, t[1].dims.length, Z), re = [we, Te], U = R("result", t[0].dataType, r.length, Z);
      if (s) {
        let X = O("bias", t[2].dataType, t[2].dims.length, Z);
        re.push(X), ie += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${w ? `vec4<${te}>` : te} {
          return bias[coords.${c ? "w" : "y"}${w ? "/ 4" : ""}];
        }`;
      }
      return `
        ${Sd("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${j.registerUniforms(Y).declareVariables(...re, U)}
        ${ie}
        ${Gh(c, M, N, K, s, e, q[0], q[1], q[2], te)}
        ${w ? vo(T, $, te, undefined, !c, v) : $o(T, $, te, undefined, !c, v, false, undefined, u)}`;
    };
    return { name: "Conv2DMatMul", shaderCache: { hint: `${e.cacheKey};${E};${w};${M};${N};${K};${A};${z};${v}`, inputDependencies: D }, getRunData: () => ({ outputs: [{ dims: d ? d(r) : r, dataType: t[0].dataType }], dispatchGroup: { x: I[0], y: I[1], z: I[2] }, programUniforms: Q }), getShaderSource: W };
  };
});
var Hh;
var Ed;
var un;
var Fh;
var kd;
var qh;
var Pd;
var Od;
var zd = V(() => {
  J();
  nt();
  ne();
  ae();
  St();
  nn();
  Hh = (t) => {
    let e = 1;
    for (let r = 0;r < t.length; r++)
      e *= t[r];
    return e;
  }, Ed = (t) => typeof t == "number" ? [t, t, t] : t, un = (t, e) => e <= 1 ? t : t + (t - 1) * (e - 1), Fh = (t, e, r, n = 1) => {
    let o = un(e, n);
    return Math.floor((t[0] * (r - 1) - r + o) / 2);
  }, kd = (t, e, r, n, o) => {
    o == null && (o = Fh(t, e[0], n[0]));
    let i = [0, 0, 0, r];
    for (let s = 0;s < 3; s++)
      t[s] + 2 * o >= e[s] && (i[s] = Math.trunc((t[s] - e[s] + 2 * o) / n[s] + 1));
    return i;
  }, qh = (t, e, r, n, o, i, s, u, d, c) => {
    let p, m, g, b;
    if (t === "VALID" && (t = 0), typeof t == "number") {
      p = { top: t, bottom: t, left: t, right: t, front: t, back: t };
      let y = kd([e, r, n, 1], [u, d, c], 1, [o, i, s], t);
      m = y[0], g = y[1], b = y[2];
    } else if (Array.isArray(t)) {
      if (!t.every((w, S, x) => w === x[0]))
        throw Error(`Unsupported padding parameter: ${t}`);
      p = { top: t[0], bottom: t[1], left: t[2], right: t[3], front: t[4], back: t[5] };
      let y = kd([e, r, n, 1], [u, d, c], 1, [o, i, s], t[0]);
      m = y[0], g = y[1], b = y[2];
    } else if (t === "SAME_UPPER") {
      m = Math.ceil(e / o), g = Math.ceil(r / i), b = Math.ceil(n / s);
      let y = (m - 1) * o + u - e, w = (g - 1) * i + d - r, S = (b - 1) * s + c - n, x = Math.floor(y / 2), $ = y - x, T = Math.floor(w / 2), I = w - T, E = Math.floor(S / 2), A = S - E;
      p = { top: T, bottom: I, left: E, right: A, front: x, back: $ };
    } else
      throw Error(`Unknown padding parameter: ${t}`);
    return { padInfo: p, outDepth: m, outHeight: g, outWidth: b };
  }, Pd = (t, e, r, n, o, i = false, s = "channelsLast") => {
    let u, d, c, p, m;
    if (s === "channelsLast")
      [u, d, c, p, m] = t;
    else if (s === "channelsFirst")
      [u, m, d, c, p] = t;
    else
      throw new Error(`Unknown dataFormat ${s}`);
    let [g, , b, y, w] = e, [S, x, $] = Ed(r), [T, I, E] = Ed(n), A = un(b, T), z = un(y, I), v = un(w, E), { padInfo: M, outDepth: N, outHeight: K, outWidth: q } = qh(o, d, c, p, S, x, $, A, z, v), Q = i ? g * m : g, D = [0, 0, 0, 0, 0];
    return s === "channelsFirst" ? D = [u, Q, N, K, q] : s === "channelsLast" && (D = [u, N, K, q, Q]), { batchSize: u, dataFormat: s, inDepth: d, inHeight: c, inWidth: p, inChannels: m, outDepth: N, outHeight: K, outWidth: q, outChannels: Q, padInfo: M, strideDepth: S, strideHeight: x, strideWidth: $, filterDepth: b, filterHeight: y, filterWidth: w, effectiveFilterDepth: A, effectiveFilterHeight: z, effectiveFilterWidth: v, dilationDepth: T, dilationHeight: I, dilationWidth: E, inShape: t, outShape: D, filterShape: e };
  }, Od = (t, e, r, n, o, i) => {
    let s = i === "channelsLast", u = s ? t[0].dims[3] : t[0].dims[1], d = false, c = [64, 1, 1], p = { x: r.map(($, T) => T) }, m = [Math.ceil(Hh(p.x.map(($) => r[$])) / c[0]), 1, 1];
    se("verbose", () => `[conv3d_naive_webgpu] dispatch = ${m}`);
    let g = d ? s && u % 4 !== 0 ? 3 : 4 : 1, b = k.size(r), y = [{ type: 12, data: b }, { type: 12, data: n }, { type: 12, data: o }, { type: 12, data: e.strides }, { type: 12, data: e.dilations }];
    Qe(e, y), y.push(...L(t[0].dims, t[1].dims));
    let w = ["rank", "rank"], S = t.length === 3;
    S && (y.push(...L(t[2].dims)), w.push("rank")), y.push(...L(r));
    let x = ($) => {
      let T = [{ name: "output_size", type: "u32" }, { name: "filter_dims", type: "u32", length: n.length }, { name: "pads", type: "u32", length: o.length }, { name: "strides", type: "u32", length: e.strides.length }, { name: "dilations", type: "u32", length: e.dilations.length }];
      Ye(e, T);
      let I = d ? 4 : 1, E = be(t[0].dataType), A = O("x", t[0].dataType, t[0].dims.length, g === 3 ? 1 : g), z = O("W", t[1].dataType, t[1].dims.length, I), v = [A, z], M = R("result", t[0].dataType, r.length, I), N = "";
      if (S) {
        let Q = O("bias", t[2].dataType, t[2].dims.length, I);
        v.push(Q), N += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${d ? `vec4<${E}>` : E} {
          return bias[${s ? F("coords", 4, 5) : F("coords", 1, 5)}${d ? "/ 4" : ""}];
        }`;
      }
      let K = Ee(g, E), q = Ze(e, K, E);
      return `
            ${N}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${A.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${z.getByIndices("aIndices")};
            }
          ${$.registerUniforms(T).declareVariables(...v, M)}
          ${$.mainStart()}
          ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${M.offsetToIndices("global_idx")};
              let batch = ${F("coords", 0, A.rank)};
              let d2 = ${s ? F("coords", A.rank - 1, A.rank) : F("coords", 1, A.rank)};
              let xFRCCorner = vec3<u32>(${s ? F("coords", 1, A.rank) : F("coords", 2, A.rank)},
              ${s ? F("coords", 2, A.rank) : F("coords", 3, A.rank)},
              ${s ? F("coords", 3, A.rank) : F("coords", 4, A.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${s ? F("uniforms.x_shape", 1, A.rank) : F("uniforms.x_shape", 2, A.rank)};
              let xShapeZ = ${s ? F("uniforms.x_shape", 2, A.rank) : F("uniforms.x_shape", 3, A.rank)};
              let xShapeW = ${s ? F("uniforms.x_shape", 3, A.rank) : F("uniforms.x_shape", 4, A.rank)};
              let xShapeU = ${s ? F("uniforms.x_shape", 4, A.rank) : F("uniforms.x_shape", 1, A.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${s ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            ` : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${s ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${s ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      ` : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${s ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      ` : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${S ? "value = value + getBiasByOutputCoords(coords)" : ""};
              ${q}
              result[global_idx] = f32(value);
          }`;
    };
    return { name: "Conv3DNaive", shaderCache: { hint: `${e.cacheKey};${s};${g};${S}`, inputDependencies: w }, getRunData: () => ({ outputs: [{ dims: r, dataType: t[0].dataType }], dispatchGroup: { x: m[0], y: m[1], z: m[2] }, programUniforms: y }), getShaderSource: x };
  };
});
var Dd;
var Bd;
var Md = V(() => {
  J();
  ne();
  ae();
  St();
  Dd = (t, e, r, n) => {
    let o = t.length > 2, i = o ? "value += b[output_channel];" : "", s = t[0].dims, u = t[1].dims, d = e.format === "NHWC", c = d ? r[3] : r[1], p = c / e.group, m = d && p >= 4 ? fe(c) : 1, g = k.size(r) / m, b = [{ type: 12, data: g }, { type: 12, data: e.dilations }, { type: 12, data: [e.strides[0], e.strides[1]] }, { type: 12, data: [e.pads[0], e.pads[1]] }, { type: 12, data: p }];
    Qe(e, b), b.push(...L(s, [u[0], u[1], u[2], u[3] / m]));
    let y = o ? ["rank", "rank", "rank"] : ["rank", "rank"];
    b.push(...L([r[0], r[1], r[2], r[3] / m]));
    let w = (S) => {
      let x = R("output", t[0].dataType, r.length, m), $ = be(x.type.tensor), T = Ze(e, x.type.value, $), I = O("x", t[0].dataType, s.length), E = O("w", t[1].dataType, u.length, m), A = [I, E];
      o && A.push(O("b", t[2].dataType, t[2].dims, m));
      let z = [{ name: "output_size", type: "u32" }, { name: "dilations", type: "u32", length: e.dilations.length }, { name: "strides", type: "u32", length: 2 }, { name: "pads", type: "u32", length: 2 }, { name: "output_channels_per_group", type: "u32" }];
      Ye(e, z);
      let v = d ? `
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${I.get("batch", "xHeight", "xWidth", "input_channel")};
            let wVal = ${E.get("wHeight", "wWidth", "wInChannel", "output_channel")};
            value += xVal * wVal;
          }
        }
      }
      ` : `
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${I.get("batch", "input_channel", "xHeight", "xWidth")};
            let wVal = ${E.get("output_channel", "wInChannel", "wHeight", "wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;
      return `
  ${S.registerUniforms(z).declareVariables(...A, x)}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${x.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${d ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${d ? 1 : 2}], outputIndices[${d ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${m} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${d ? 2 : 1}];

    var value: ${x.type.value} = ${x.type.value}(0);
    ${v}
    ${i}
    ${T}
    ${x.setByOffset("global_idx", "value")}
  }`;
    };
    return { name: "GroupedConv", shaderCache: { hint: `${e.cacheKey}_${m}`, inputDependencies: y }, getRunData: () => ({ outputs: [{ dims: n ? n(r) : r, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(g / 64) }, programUniforms: b }), getShaderSource: w };
  }, Bd = (t, e, r, n) => {
    let o = t.length > 2, i = fe(r[3]), s = fe(r[2]), u = k.size(r) / i / s, d = [t[0].dims[0], t[0].dims[1], t[0].dims[2], t[0].dims[3] / i], c = [t[1].dims[0], t[1].dims[1], t[1].dims[2], t[1].dims[3] / i], p = [r[0], r[1], r[2], r[3] / i], m = [{ type: 12, data: u }, { type: 6, data: [e.strides[0], e.strides[1]] }, { type: 6, data: [e.pads[0], e.pads[1]] }];
    Qe(e, m), m.push(...L(d, c, p));
    let g = (s - 1) * e.strides[1] + c[1], b = (y) => {
      let w = R("output", t[0].dataType, p.length, i), S = be(w.type.tensor), x = Ze(e, w.type.value, S), $ = O("x", t[0].dataType, d.length, i), T = O("w", t[1].dataType, c.length, i), I = [$, T];
      o && I.push(O("b", t[2].dataType, t[2].dims, i));
      let E = o ? "value += b[output_channel];" : "", A = [{ name: "output_size", type: "u32" }, { name: "strides", type: "i32", length: 2 }, { name: "pads", type: "i32", length: 2 }];
      return Ye(e, A), `
  ${y.registerUniforms(A).declareVariables(...I, w)}
  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${s}u;
    let col = (index1 % width1) * ${s}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${$.type.value}, ${g}>;
    var values: array<${w.type.value}, ${s}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${c[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${g}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${$.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${$.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${c[1]}; w_width++) {
          let w_val = ${T.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${s}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${s}u; i++) {
      var value = values[i];
      ${E}
      ${x}
      ${w.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
    };
    return { name: "GroupedConv-Vectorize", shaderCache: { hint: `${e.cacheKey};${i};${s};${g};${c[0]};${c[1]}`, inputDependencies: o ? ["rank", "rank", "type"] : ["rank", "rank"] }, getRunData: () => ({ outputs: [{ dims: n ? n(r) : r, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(u / 64) }, programUniforms: m }), getShaderSource: b };
  };
});
var Kh;
var xo;
var jh;
var So;
var To;
var Rd;
var Zh;
var Qh;
var Io;
var Ud = V(() => {
  ne();
  Ad();
  zd();
  sn();
  Md();
  St();
  an();
  pt();
  Kh = (t, e, r, n, o, i) => {
    let s = t[0], u = t.slice(i ? 1 : 2, i ? 3 : 4), d = u.length, c = e[0], m = e.slice(2).map((y, w) => y + (y - 1) * (r[w] - 1)), b = u.map((y, w) => y + n[w] + n[w + d]).map((y, w) => Math.floor((y - m[w] + o[w]) / o[w]));
    return b.splice(0, 0, s), b.splice(i ? 3 : 1, 0, c), b;
  }, xo = [2, 3, 1, 0], jh = (t, e) => {
    if (!t || t.length !== 2 && t.length !== 3)
      throw new Error("Conv requires 2 or 3 inputs");
    if (t[0].dims.length > 5)
      throw new Error("greater than 5D is not supported");
    if (t[0].dims.length !== t[1].dims.length)
      throw new Error("filter does not have same dimension as input");
    let r = t[0].dims[e.format === "NHWC" ? t[0].dims.length - 1 : 1], n = t[1].dims[1] * e.group;
    if (r !== n)
      throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
    if (t.length === 3 && (t[2].dims.length !== 1 || t[1].dims[0] !== t[2].dims[0]))
      throw new Error("invalid bias");
    let o = t[0].dims.length - 2;
    if (e.dilations.length !== o)
      throw new Error(`dilations should be ${o}D`);
    if (e.strides.length !== o)
      throw new Error(`strides should be ${o}D`);
    if (e.pads.length !== o * 2)
      throw new Error(`pads should be ${o * 2}D`);
    if (e.kernelShape.length !== 0 && e.kernelShape.length !== t[1].dims.length - 2)
      throw new Error("invalid kernel shape");
  }, So = (t, e) => {
    let r = t.kernelShape.slice();
    r.length < e[1].dims.length - 2 && r.push(...Array(e[1].dims.length - 2 - r.length).fill(0));
    for (let i = 2;i < e[1].dims.length; ++i)
      r[i - 2] === 0 && (r[i - 2] = e[1].dims[i]);
    let n = t.pads.slice();
    zt.adjustPadsBasedOnAutoPad(e[0].dims, t.strides, t.dilations, r, n, t.format === "NHWC", t.autoPad);
    let o = Object.assign({}, t);
    return Object.assign(o, { kernelShape: r, pads: n }), o;
  }, To = (t) => {
    let e = rn(t), r = t.format, n = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][t.auto_pad], o = t.dilations, i = t.group, s = t.kernel_shape, u = t.pads, d = t.strides, c = t.w_is_const();
    return { autoPad: n, format: r, dilations: o, group: i, kernelShape: s, pads: u, strides: d, wIsConst: c, ...e, cacheKey: `${t.format};${e.activation};` };
  }, Rd = (t, e, r, n) => {
    let o = r.format === "NHWC", i = Kh(e[0].dims, e[1].dims, r.dilations, r.pads, r.strides, o);
    if (r.group !== 1) {
      let A = [e[0]];
      if (o) {
        let v = t.kernelCustomData.wT ?? t.compute(Oe(e[1], xo), { inputs: [1], outputs: [r.wIsConst ? -2 : -1] })[0];
        r.wIsConst && !t.kernelCustomData.wT && (t.kernelCustomData.wT = v), A.push(v);
      } else
        A.push(e[1]);
      e.length === 3 && A.push(e[2]), !t.adapterInfo.isArchitecture("ampere") && o && e[1].dims[0] === r.group && e[1].dims[1] === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 ? t.compute(Bd(A, r, i, n), { inputs: A }) : t.compute(Dd(A, r, i, n), { inputs: A });
      return;
    }
    let s = e.length === 3, u = e[0].dims[o ? 1 : 2], d = e[0].dims[o ? 2 : 3], c = e[0].dims[o ? 3 : 1], p = e[1].dims[2], m = e[1].dims[3], g = i[o ? 1 : 2], b = i[o ? 2 : 3], y = i[o ? 3 : 1], w = o && p === u && m === d && r.pads[0] === 0 && r.pads[1] === 0;
    if (w || p === 1 && m === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 && r.strides[0] === 1 && r.strides[1] === 1 && r.pads[0] === 0 && r.pads[1] === 0) {
      let A = i[0], z, v, M, N = [];
      if (o) {
        let Q = t.kernelCustomData.wT ?? t.compute(Oe(e[1], xo), { inputs: [1], outputs: [r.wIsConst ? -2 : -1] })[0];
        if (r.wIsConst && !t.kernelCustomData.wT && (t.kernelCustomData.wT = Q), w) {
          let D = u * d * c;
          z = e[0].reshape([1, A, D]), v = Q.reshape([1, D, y]), M = [1, A, y];
        } else
          z = e[0].reshape([A, u * d, c]), v = Q.reshape([1, c, y]), M = [A, g * b, y];
        N.push(z), N.push(v);
      } else
        z = e[0].reshape([A, c, u * d]), v = e[1].reshape([1, y, c]), M = [A, y, g * b], N.push(v), N.push(z);
      s && N.push(e[2]);
      let K = M[2], q = N[0].dims[N[0].dims.length - 1];
      K < 8 && q < 8 ? t.compute(on(N, r, i, M, o, n), { inputs: N }) : t.compute(ir(N, r, i, M, o, n), { inputs: N });
      return;
    }
    let S = true, x = t.kernelCustomData.wT ?? t.compute(Oe(e[1], xo), { inputs: [1], outputs: [r.wIsConst ? -2 : -1] })[0];
    r.wIsConst && !t.kernelCustomData.wT && (t.kernelCustomData.wT = x);
    let $ = [e[0], x];
    s && $.push(e[2]);
    let T = o ? g * b : y, I = o ? y : g * b, E = p * m * c;
    t.compute(Cd($, r, i, T, I, E, s, S, n), { inputs: $ });
  }, Zh = (t, e) => {
    let r = e.format === "NHWC", n = [t.inputs[0].reshape(r ? [t.inputs[0].dims[0], 1, t.inputs[0].dims[1], t.inputs[0].dims[2]] : [t.inputs[0].dims[0], t.inputs[0].dims[1], 1, t.inputs[0].dims[2]]), t.inputs[1].reshape([t.inputs[1].dims[0], t.inputs[1].dims[1], 1, t.inputs[1].dims[2]])];
    t.inputs.length === 3 && n.push(t.inputs[2]);
    let o = [0, e.pads[0], 0, e.pads[1]], i = [1].concat(e.strides), s = [1].concat(e.dilations), u = [1].concat(e.kernelShape), d = So({ ...e, pads: o, strides: i, dilations: s, kernelShape: u }, n);
    Rd(t, n, d, (c) => r ? [c[0], c[2], c[3]] : [c[0], c[1], c[3]]);
  }, Qh = (t, e, r) => {
    let n = r.format === "NHWC" ? "channelsLast" : "channelsFirst", o = So(r, e), i = r.autoPad === "NOTSET" ? r.pads : r.autoPad, s = Pd(e[0].dims, e[1].dims, r.strides, r.dilations, i, false, n);
    t.compute(Od(e, o, s.outShape, [s.filterDepth, s.filterHeight, s.filterWidth], [s.padInfo.front, s.padInfo.top, s.padInfo.left], n));
  }, Io = (t, e) => {
    if (jh(t.inputs, e), t.inputs[0].dims.length === 3)
      Zh(t, e);
    else if (t.inputs[0].dims.length === 5)
      Qh(t, t.inputs, e);
    else {
      let r = So(e, t.inputs);
      Rd(t, t.inputs, r);
    }
  };
});
var Nd;
var Vd = V(() => {
  J();
  nt();
  ne();
  ae();
  Nd = (t, e, r) => {
    let n = t.length > 2, o = e.outputShape, i = e.format === "NHWC", s = e.group, u = t[1].dims, d = u[2] / s, c = u[3], p = i ? fe(d) : 1, m = i && c === 1 && d >= 4, g = m ? Math.floor(d / 4) * 4 : Math.floor(d / p) * p, b = d - g, y = i ? fe(c) : 1, w = i ? c === 1 ? p : y : 1, S = k.size(o) / y, x = [Math.ceil(S / 64), 1, 1];
    se("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${x}`);
    let $ = ["rank", "rank"], T = [e.strides[0], e.strides[1]], I = [e.kernelShape[i ? 1 : 2], e.kernelShape[i ? 2 : 3]], E = [e.dilations[0], e.dilations[1]], A = [I[0] + (e.dilations[0] <= 1 ? 0 : (e.kernelShape[i ? 1 : 2] - 1) * (e.dilations[0] - 1)), I[1] + (e.dilations[1] <= 1 ? 0 : (e.kernelShape[i ? 2 : 3] - 1) * (e.dilations[1] - 1))], z = [A[0] - 1 - Math.floor((e.pads[0] + e.pads[2]) / 2), A[1] - 1 - Math.floor((e.pads[1] + e.pads[3]) / 2)], v = [{ type: 12, data: S }, { type: 12, data: T }, { type: 12, data: I }, { type: 12, data: E }, { type: 12, data: A }, { type: 6, data: z }, { type: 12, data: g }, { type: 12, data: d }, { type: 12, data: c }, ...L(t[0].dims, t[1].dims)];
    n && (v.push(...L(t[2].dims)), $.push("rank")), v.push(...L(o));
    let M = (N) => {
      let K = [{ name: "output_size", type: "u32" }, { name: "strides", type: "u32", length: T.length }, { name: "filter_dims", type: "u32", length: I.length }, { name: "dilations", type: "u32", length: I.length }, { name: "effective_filter_dims", type: "u32", length: A.length }, { name: "pads", type: "i32", length: z.length }, { name: "input_channels_per_group_int", type: "u32" }, { name: "input_channels_per_group", type: "u32" }, { name: "output_channels_per_group", type: "u32" }], q = be(t[0].dataType), Q = i ? 1 : 2, D = i ? 2 : 3, W = i ? 3 : 1, j = O("W", t[1].dataType, t[1].dims.length, w), Y = O("Dy", t[0].dataType, t[0].dims.length, p), Z = [Y, j];
      n && Z.push(O("bias", t[2].dataType, [o[W]].length, y));
      let te = R("result", t[0].dataType, o.length, y), ie = () => {
        let re = "";
        if (m)
          p === 4 ? re += `
        let xValue = ${Y.getByOffset("x_offset")};
        let wValue = ${j.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;` : p === 2 ? re += `
          dotProd = dotProd + dot(vec4<${q}>(${Y.getByOffset("x_offset")}, ${Y.getByOffset("x_offset + 1u")}), vec4<${q}>(${j.getByOffset("w_offset")}, ${j.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;` : p === 1 && (re += `
          dotProd = dotProd + dot(vec4<${q}>(${Y.getByOffset("x_offset")}, ${Y.getByOffset("x_offset + 1u")}, ${Y.getByOffset("x_offset + 2u")}, ${Y.getByOffset("x_offset + 3u")}), vec4<${q}>(${j.getByOffset("w_offset")}, ${j.getByOffset("w_offset + 1u")}, ${j.getByOffset("w_offset + 2u")}, ${j.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);
        else if (re += `
                  let xValue = ${i ? Y.getByOffset(`${Y.indicesToOffset(`${Y.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${p}`) : Y.get("batch", "inputChannel", "idyR", "idyC")};
        `, p === 1)
          re += `
          let w_offset = ${j.indicesToOffset(`${j.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${j.getByOffset(`w_offset / ${w}`)};
          dotProd = dotProd + xValue * wValue;`;
        else
          for (let U = 0;U < p; U++)
            re += `
            let wValue${U} = ${j.getByOffset(`${j.indicesToOffset(`${j.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${U}, wOutChannel)`)} / ${w}`)};
            dotProd = dotProd + xValue[${U}] * wValue${U};`;
        return re;
      }, we = () => {
        if (b === 0)
          return "";
        if (!m)
          throw new Error(`packInputAs4 ${m} is not true.`);
        let re = "";
        if (p === 1) {
          re += "dotProd = dotProd";
          for (let U = 0;U < b; U++)
            re += `
            + ${Y.getByOffset(`x_offset + ${U}`)} * ${j.getByOffset(`w_offset + ${U}`)}`;
          re += ";";
        } else if (p === 2) {
          if (b !== 2)
            throw new Error(`Invalid inputChannelsRemainder ${b}.`);
          re += `
          let xValue = ${Y.getByOffset("x_offset")};
          let wValue = ${j.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`;
        }
        return re;
      }, Te = `
            let outputIndices = ${te.offsetToIndices(`global_idx * ${y}`)};
            let batch = ${te.indicesGet("outputIndices", 0)};
            let d1 = ${te.indicesGet("outputIndices", W)};
            let r = ${te.indicesGet("outputIndices", Q)};
            let c = ${te.indicesGet("outputIndices", D)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${te.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${q}(dyRCorner) + ${q}(wR)) / ${q}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${q}(uniforms.Dy_shape[${Q}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${q}(dyCCorner) + ${q}(wC)) / ${q}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${q}(uniforms.Dy_shape[${D}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${m ? `
                var x_offset = ${Y.indicesToOffset(`${Y.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${p};
                var w_offset = ${j.indicesToOffset(`${j.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${w};
                  ` : ""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${m ? 4 : p}) {
                  ${ie()}
                  inputChannel = inputChannel + ${m ? 4 : p};
                }
                ${we()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${n ? ` + bias[d1 / ${y}]` : ""};
            ${te.setByOffset("global_idx", "value")};
          `;
      return `
    ${N.registerUniforms(K).declareVariables(...Z, te)}
      ${N.mainStart()}
      ${N.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${Te}}`;
    };
    return { name: "ConvTranspose2D", shaderCache: { hint: `${e.cacheKey};${p}${w}${y}${m}${b}`, inputDependencies: $ }, getRunData: () => ({ dispatchGroup: { x: x[0], y: x[1], z: x[2] }, outputs: [{ dims: r ? r(o) : o, dataType: t[0].dataType }], programUniforms: v }), getShaderSource: M };
  };
});
var Yh;
var Xh;
var Jh;
var Ld;
var Wd;
var eg;
var Gd;
var tg;
var Hd;
var Fd = V(() => {
  Vd();
  St();
  pt();
  Yh = (t, e, r, n, o, i) => (t - 1) * e + r + (n - 1) * o + 1 - i, Xh = (t, e, r, n, o) => {
    let i = Math.floor(t / 2);
    e === "SAME_UPPER" ? (r[n] = i, r[o] = t - i) : e === "SAME_LOWER" && (r[n] = t - i, r[o] = i);
  }, Jh = (t, e, r, n, o, i, s, u, d, c) => {
    let p = t.length - 2, m = c.length === 0;
    d.length < p && d.push(...Array(p - d.length).fill(0));
    let g = t[0], b = e[u ? 3 : 1] * o;
    for (let y = 0, w = t.length - p - (u ? 1 : 0);y < p; ++y, ++w) {
      let S = t[w], x = m ? S * s[y] : c[y], $ = Yh(S, s[y], i[y], e[w], r[y], x);
      Xh($, n, i, y, y + p), m && c.push(s[y] * (S - 1) + d[y] + (e[w] - 1) * r[y] + 1 - i[y] - i[y + p]);
    }
    c.splice(0, 0, g), c.splice(u ? 3 : 1, 0, b);
  }, Ld = (t, e) => {
    let r = t.kernelShape.slice();
    if (t.kernelShape.length === 0 || t.kernelShape.reduce((m, g) => m * g, 1) === 0) {
      r.length = 0;
      for (let m = 2;m < e[1].dims.length; ++m)
        r.push(e[1].dims[m]);
    }
    let n = t.format === "NHWC";
    r.splice(0, 0, e[1].dims[0]), r.splice(n ? 3 : 1, 0, e[1].dims[1]);
    let o = t.pads.slice(), i = t.outputShape.slice(), s = t.outputPadding.slice(), u = e[0].dims, d = t.dilations.slice();
    if (d.reduce((m, g) => m + g, 0) === 0) {
      let m = e[0].dims.length - 2;
      d = new Array(m).fill(1);
    }
    let c = t.strides.slice();
    if (c.reduce((m, g) => m + g, 0) === 0) {
      let m = e[0].dims.length - 2;
      c = new Array(m).fill(1);
    }
    Jh(u, r, d, t.autoPad, t.group, o, c, n, s, i);
    let p = Object.assign({}, t);
    return Object.assign(p, { kernelShape: r, pads: o, outputPadding: s, outputShape: i, dilations: d, strides: c }), p;
  }, Wd = (t) => {
    let e = rn(t), r = t.format, n = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][typeof t.autoPad > "u" ? 0 : t.autoPad], o = t.dilations, i = t.group, s = t.kernelShape, u = t.pads, d = t.strides, c = t.wIsConst(), p = t.outputPadding, m = t.outputShape;
    return { autoPad: n, format: r, dilations: o, group: i, kernelShape: s, outputPadding: p, outputShape: m, pads: u, strides: d, wIsConst: c, ...e, cacheKey: `${t.format};${e.activation};` };
  }, eg = (t, e) => {
    if (!t || t.length !== 2 && t.length !== 3)
      throw new Error("Conv requires 2 or 3 inputs");
    if (t[0].dims.length !== 4 && t[0].dims.length !== 3)
      throw new Error("currently only support 2-dimensional conv");
    if (t[0].dims.length !== t[1].dims.length)
      throw new Error("filter does not have same dimension as input");
    let r = t[0].dims[e.format === "NHWC" ? t[0].dims.length - 1 : 1], n = t[1].dims[0];
    if (r !== n)
      throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
    let o = t[1].dims[1] * e.group;
    if (t.length === 3 && (t[2].dims.length !== 1 || t[2].dims[0] !== o))
      throw new Error("invalid bias");
    let i = t[0].dims.length - 2;
    if (e.dilations.reduce((p, m) => p + m, 0) > 0 && e.dilations.length !== i)
      throw new Error(`dilations should be ${i}D`);
    if (e.strides.reduce((p, m) => p + m, 0) > 0 && e.strides.length !== i)
      throw new Error(`strides should be ${i}D`);
    if (e.pads.reduce((p, m) => p + m, 0) > 0 && e.pads.length !== i * 2)
      throw new Error(`pads should be ${i * 2}D`);
    if (e.outputPadding.length !== i && e.outputPadding.length !== 0)
      throw new Error(`output_padding should be ${i}D`);
    if (e.kernelShape.reduce((p, m) => p + m, 0) > 0 && e.kernelShape.length !== 0 && e.kernelShape.length !== t[1].dims.length - 2)
      throw new Error("invalid kernel shape");
    if (e.outputShape.length !== 0 && e.outputShape.length !== t[0].dims.length - 2)
      throw new Error("invalid output shape");
  }, Gd = (t, e, r, n) => {
    let o = t.kernelCustomData.wT ?? t.compute(Oe(e[1], [2, 3, 0, 1]), { inputs: [1], outputs: [r.wIsConst ? -2 : -1] })[0];
    r.wIsConst && !t.kernelCustomData.wT && (t.kernelCustomData.wT = o);
    let i = [e[0], o];
    e.length === 3 && i.push(e[2]), t.compute(Nd(i, r, n), { inputs: i });
  }, tg = (t, e) => {
    let r = e.format === "NHWC", n = [t.inputs[0].reshape(r ? [t.inputs[0].dims[0], 1, t.inputs[0].dims[1], t.inputs[0].dims[2]] : [t.inputs[0].dims[0], t.inputs[0].dims[1], 1, t.inputs[0].dims[2]]), t.inputs[1].reshape([t.inputs[1].dims[0], t.inputs[1].dims[1], 1, t.inputs[1].dims[2]])];
    t.inputs.length === 3 && n.push(t.inputs[2]);
    let o = e.kernelShape;
    (o.length === 0 || o[0] === 0) && (o = [t.inputs[1].dims[2]]);
    let i = e.dilations;
    (i.length === 0 || i[0] === 0) && (i = [1]);
    let s = e.strides;
    (s.length === 0 || s[0] === 0) && (s = [1]);
    let u = e.pads;
    u.length === 0 && (u = [0, 0]), u = [0, u[0], 0, u[1]], s = [1].concat(s), i = [1].concat(i), o = [1].concat(o);
    let d = e.outputPadding;
    d = [0].concat(d);
    let c = Ld({ ...e, pads: u, strides: s, dilations: i, kernelShape: o, outputPadding: d }, n);
    Gd(t, n, c, (p) => r ? [p[0], p[2], p[3]] : [p[0], p[1], p[3]]);
  }, Hd = (t, e) => {
    if (eg(t.inputs, e), t.inputs[0].dims.length === 3)
      tg(t, e);
    else {
      let r = Ld(e, t.inputs);
      Gd(t, t.inputs, r);
    }
  };
});
var rg;
var qd;
var Kd;
var jd = V(() => {
  J();
  ne();
  Ie();
  ae();
  rg = (t, e, r, n) => {
    let o = k.size(e), i = e.length, s = O("input", t, i), u = R("output", t, i), d = r.dataType === 6 ? r.getInt32Array()[0] : Number(r.getBigInt64Array()[0]), c = k.normalizeAxis(d, i), p = (m) => {
      let g = ` i32(${s.indicesGet("inputIndices", "uniforms.axis")}) `, b = F("uniforms.input_shape", "uniforms.axis", i), y = n.reverse ? g + (n.exclusive ? " + 1" : "") : "0", w = n.reverse ? b : g + (n.exclusive ? "" : " + 1");
      return `
                ${m.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(s, u)}
                ${m.mainStart()}
                  ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${u.offsetToIndices("global_idx")};
                  var sum = ${u.type.value}(0);
                  let first : i32 = ${y};
                  let last : i32 = ${w};
                  for (var i : i32 = first; i < last; i++) {
                    ${s.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${s.getByIndices("inputIndices")};
                  }
                  ${u.setByOffset("global_idx", "sum")};
                }`;
    };
    return { name: "CumSum", shaderCache: { hint: n.cacheKey, inputDependencies: ["rank"] }, getRunData: () => ({ outputs: [{ dims: e, dataType: t }], dispatchGroup: { x: Math.ceil(o / 64) }, programUniforms: [{ type: 12, data: o }, { type: 12, data: c }, ...L(e, e)] }), getShaderSource: p };
  }, qd = (t, e) => {
    let r = t.inputs[0].dims, n = t.inputs[0].dataType, o = t.inputs[1];
    t.compute(rg(n, r, o, e), { inputs: [0] });
  }, Kd = (t) => {
    let e = t.exclusive === 1, r = t.reverse === 1;
    return ee({ exclusive: e, reverse: r });
  };
});
var ng;
var og;
var ig;
var Zd;
var Qd;
var Yd = V(() => {
  J();
  ne();
  Ie();
  ae();
  ng = (t) => {
    if (!t || t.length !== 1)
      throw new Error("DepthToSpace requires 1 input.");
    if (t[0].dims.length !== 4)
      throw new Error("DepthToSpace requires 4D input.");
  }, og = (t, e, r, n) => {
    let o = [];
    o.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);
    for (let i = 0;i < e; ++i)
      o.push(r.indicesSet("a", t[i], `i[${i}]`));
    return o.push("return a;}"), o.join(`
`);
  }, ig = (t, e) => {
    let r, n, o, i, s, u, d = e.format === "NHWC", c = e.blocksize, p = e.mode === "DCR";
    d ? ([r, n, o, i] = t.dims, s = p ? [r, n, o, c, c, i / c ** 2] : [r, n, o, i / c ** 2, c, c], u = p ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3]) : ([r, n, o, i] = [t.dims[0], t.dims[2], t.dims[3], t.dims[1]], s = p ? [r, c, c, i / c ** 2, n, o] : [r, i / c ** 2, c, c, n, o], u = p ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3]);
    let m = t.reshape(s), g = m.dims.length, b = t.dataType, y = O("a", b, g), w = R("output", b, g), S = (x) => `
  ${x.registerUniform("output_size", "u32").declareVariables(y, w)}

  ${og(u, g, y, w)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${w.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${w.setByOffset("global_idx", y.getByIndices("aIndices"))}
  }`;
    return { name: "DepthToSpace", shaderCache: { hint: `${t.dims};${e.blocksize};${e.mode}`, inputDependencies: ["rank"] }, getRunData: (x) => {
      let $ = d ? [r, n * c, o * c, i / c ** 2] : [r, i / c ** 2, n * c, o * c], T = k.size($), I = m.dims, E = k.sortBasedOnPerm(I, u);
      return { outputs: [{ dims: $, dataType: x[0].dataType }], dispatchGroup: { x: Math.ceil(T / 64) }, programUniforms: [{ type: 12, data: T }, ...L(I, E)] };
    }, getShaderSource: S };
  }, Zd = (t, e) => {
    ng(t.inputs), t.compute(ig(t.inputs[0], e));
  }, Qd = (t) => ee({ blocksize: t.blocksize, mode: t.mode, format: t.format });
});
var Co;
var dn;
var Xd;
var ag;
var sg;
var Ao;
var Eo;
var Jd;
var ug;
var el;
var tl;
var rl = V(() => {
  J();
  ne();
  Ie();
  ae();
  Co = "[a-zA-Z]|\\.\\.\\.", dn = "(" + Co + ")+", Xd = "^" + dn + "$", ag = "(" + dn + ",)*" + dn, sg = "^" + ag + "$", Ao = class {
    constructor(e = -1) {
      this.symbolToIndices = new Map, this.inputIndex = e;
    }
    addSymbol(e, r) {
      let n = this.symbolToIndices.get(e);
      n === undefined ? n = [r] : n.push(r), this.symbolToIndices.set(e, n);
    }
  }, Eo = class {
    constructor(e, r) {
      this.equation = r;
      this.hasEllipsis = false, this.symbolToInfo = new Map, this.lhs = new Array, this.outputDims = [];
      let [n, o] = r.includes("->") ? r.split("->", 2) : [r, ""];
      if (!n.match(RegExp(sg)))
        throw new Error("Invalid LHS term");
      if (n.split(",").forEach((u, d) => {
        let c = e[d].dims.slice();
        if (!u.match(RegExp(Xd)))
          throw new Error("Invalid LHS term");
        let p = this.processTerm(u, true, c, d);
        this.lhs.push(p);
      }), o === "")
        o += [...this.symbolToInfo.entries()].filter(([u, d]) => d.count === 1 || u === "...").map(([u]) => u).join("");
      else if (!o.match(RegExp(dn)))
        throw new Error("Invalid RHS");
      o.match(RegExp(Co, "g"))?.forEach((u) => {
        if (u === "...")
          this.outputDims = this.outputDims.concat(this.ellipsisDims);
        else {
          let d = this.symbolToInfo.get(u);
          if (d === undefined)
            throw new Error("Invalid RHS symbol");
          this.outputDims.push(d.dimValue);
        }
      }), this.rhs = this.processTerm(o, false, this.outputDims);
    }
    addSymbol(e, r, n) {
      let o = this.symbolToInfo.get(e);
      if (o !== undefined) {
        if (o.dimValue !== r && o.count !== 1)
          throw new Error("Dimension mismatch");
        o.count++, o.inputIndices.push(n);
      } else
        o = { count: 1, dimValue: r, inputIndices: [n] };
      this.symbolToInfo.set(e, o);
    }
    processTerm(e, r, n, o = -1) {
      let i = n.length, s = false, u = [], d = 0;
      if (!e.match(RegExp(Xd)) && !r && e !== "")
        throw new Error("Invalid LHS term");
      let c = e.match(RegExp(Co, "g")), p = new Ao(o);
      return c?.forEach((m, g) => {
        if (m === "...") {
          if (s)
            throw new Error("Only one ellipsis is allowed per input term");
          s = true;
          let b = i - c.length + 1;
          if (b < 0)
            throw new Error("Ellipsis out of bounds");
          if (u = n.slice(d, d + b), this.hasEllipsis) {
            if (this.ellipsisDims.length !== u.length || this.ellipsisDims.toString() !== u.toString())
              throw new Error("Ellipsis dimensions mismatch");
          } else if (r)
            this.hasEllipsis = true, this.ellipsisDims = u;
          else
            throw new Error("Ellipsis must be specified in the LHS");
          for (let y = 0;y < u.length; y++) {
            let w = String.fromCharCode(48 + y);
            p.addSymbol(w, g + y), this.addSymbol(w, n[d++], o);
          }
        } else
          p.addSymbol(m, g + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0)), this.addSymbol(m, n[d++], o);
      }), p;
    }
  }, Jd = (t) => t + "_max", ug = (t, e, r, n) => {
    let i = t.map((p) => p.length).map((p, m) => O(`input${m}`, e, p)), s = k.size(n), u = R("output", e, n.length), d = [...r.symbolToInfo.keys()].filter((p) => !r.rhs.symbolToIndices.has(p)), c = (p) => {
      let m = [], g = "var prod = 1.0;", b = "var sum = 0.0;", y = "sum += prod;", w = [], S = [], x = [], $ = [], T = r.symbolToInfo.size === r.rhs.symbolToIndices.size;
      r.symbolToInfo.forEach((E, A) => {
        if (r.rhs.symbolToIndices.has(A)) {
          let z = r.rhs.symbolToIndices.get(A)?.[0];
          z !== undefined && r.lhs.forEach((v, M) => {
            if (E.inputIndices.includes(M)) {
              let N = v.symbolToIndices.get(A);
              if (N === undefined)
                throw new Error("Invalid symbol error");
              N.forEach((K) => {
                m.push(`${i[M].indicesSet(`input${M}Indices`, K, u.indicesGet("outputIndices", z))}`);
              });
            }
          });
        } else
          r.lhs.forEach((z, v) => {
            if (E.inputIndices.includes(v)) {
              let M = z.symbolToIndices.get(A);
              if (M === undefined)
                throw new Error("Invalid symbol error");
              M.forEach((N) => {
                w.push(`${i[v].indicesSet(`input${v}Indices`, N, `${A}`)}`);
              }), $.push(`prod *= ${i[v].getByIndices(`input${v}Indices`)};`);
            }
          }), S.push(`for(var ${A}: u32 = 0; ${A} < uniforms.${Jd(A)}; ${A}++) {`), x.push("}");
      });
      let I = T ? [...m, `let sum = ${i.map((E, A) => E.getByIndices(`input${A}Indices`)).join(" * ")};`] : [...m, b, ...S, ...w, g, ...$, y, ...x];
      return `
            ${p.registerUniforms(d.map((E) => ({ name: `${Jd(E)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...i, u)}

            ${p.mainStart()}
            ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${u.offsetToIndices("global_idx")};
            ${i.map((E, A) => `var input${A}Indices: ${i[A].type.indices};`).join(`
`)}
            ${I.join(`
`)};
            ${u.setByOffset("global_idx", "sum")};
          }`;
    };
    return { name: "Einsum", shaderCache: { hint: r.equation, inputDependencies: t.map(() => "rank") }, getRunData: () => {
      let p = d.filter((g) => r.symbolToInfo.has(g)).map((g) => ({ type: 12, data: r.symbolToInfo.get(g)?.dimValue || 0 }));
      p.push({ type: 12, data: s });
      let m = t.map((g, b) => [...L(g)]).reduce((g, b) => g.concat(b), p);
      return m.push(...L(n)), { outputs: [{ dims: n, dataType: e }], dispatchGroup: { x: Math.ceil(s / 64) }, programUniforms: m };
    }, getShaderSource: c };
  }, el = (t, e) => {
    let r = new Eo(t.inputs, e.equation), n = r.outputDims, o = t.inputs.map((i, s) => i.dims);
    t.compute(ug(o, t.inputs[0].dataType, r, n));
  }, tl = (t) => {
    let e = t.equation.replace(/\s+/g, "");
    return ee({ equation: e });
  };
});
var dg;
var nl;
var lg;
var cg;
var ol;
var il = V(() => {
  J();
  ne();
  ae();
  dg = (t) => {
    if (!t || t.length !== 2)
      throw new Error("Expand requires 2 input.");
    let e = t[0].dims, r = Array.from(t[1].getBigInt64Array(), Number), n = r.length < e.length ? 0 : r.length - e.length, o = e.length < r.length ? 0 : e.length - r.length;
    for (;n < r.length && o < e.length; ++n, ++o)
      if (r[n] !== e[o] && r[n] !== 1 && e[o] !== 1)
        throw new Error("Expand requires shape to be broadcastable to input");
  }, nl = (t, e) => {
    let r = t.length - e.length, n = [];
    for (let o = 0;o < r; ++o)
      n.push(t[o]);
    for (let o = 0;o < e.length; ++o)
      n.push(e[o] === 1 ? t[o + r] : e[o]);
    return n;
  }, lg = (t, e) => t.length > e.length ? nl(t, e) : nl(e, t), cg = (t) => {
    let e = t[0].dims, r = Array.from(t[1].getBigInt64Array(), Number), n = lg(e, r), o = t[0].dataType, i = o === 9 || k.size(e) === 1, s = o === 9 || e.length > 0 && e[e.length - 1] % 4 === 0 ? 4 : 1, u = i || n.length > 0 && n[n.length - 1] % 4 === 0 ? 4 : 1, d = Math.ceil(k.size(n) / u), c = (m) => {
      let g = O("input", o, e.length, s), b = R("output", o, n.length, u), y;
      if (o === 9) {
        let w = (S, x, $ = "") => `
          let outputIndices${x} = ${b.offsetToIndices(`outputOffset + ${x}u`)};
          let offset${x} = ${g.broadcastedIndicesToOffset(`outputIndices${x}`, b)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${S}[${x}] = ${$}(${g.getByOffset(`index${x}`)}[component${x}]);
        `;
        y = `
        let outputOffset = global_idx * ${u};
        var data = vec4<u32>(0);
        ${w("data", 0, "u32")}
        ${w("data", 1, "u32")}
        ${w("data", 2, "u32")}
        ${w("data", 3, "u32")}
        ${b.setByOffset("global_idx", "data")}
      }`;
      } else
        y = `
        let outputIndices = ${b.offsetToIndices(`global_idx * ${u}`)};
        let inputOffset = ${g.broadcastedIndicesToOffset("outputIndices", b)};
        let data = ${b.type.value}(${g.getByOffset(`inputOffset / ${s}`)});
        ${b.setByOffset("global_idx", "data")}
      }`;
      return `
    ${m.registerUniform("vec_size", "u32").declareVariables(g, b)}
    ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${y}`;
    }, p = [{ type: 12, data: d }, ...L(e, n)];
    return { name: "Expand", shaderCache: { hint: `${n.length};${s}${u}`, inputDependencies: ["rank"] }, getShaderSource: c, getRunData: () => ({ outputs: [{ dims: n, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(d / 64) }, programUniforms: p }) };
  }, ol = (t) => {
    dg(t.inputs), t.compute(cg(t.inputs), { inputs: [0] });
  };
});
var pg;
var al;
var sl = V(() => {
  J();
  ne();
  ae();
  tn();
  pg = (t) => {
    let e = t[0].dataType, r = k.size(t[0].dims), n = k.size(t[1].dims), o = n % 4 === 0, i = (s) => {
      let u = O("x", e, [1], 4), d = O("bias", e, [1], 4), c = R("y", e, [1], 4), p = [{ name: "output_vec_size", type: "u32" }, { name: "bias_size", type: "u32" }], m = (b) => `
      let bias${b}_offset: u32 = (global_idx * 4 + ${b}) % uniforms.bias_size;
      let bias${b} = ${d.getByOffset(`bias${b}_offset / 4`)}[bias${b}_offset % 4];`, g = o ? `
      let bias = ${d.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${m(0)}${m(1)}${m(2)}${m(3)}
      let bias = ${u.type.value}(bias0, bias1, bias2, bias3);`;
      return `${s.registerUniforms(p).declareVariables(u, d, c)}

    ${wo(Pe(e))}

    ${s.mainStart(Dt)}
      ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${u.getByOffset("global_idx")};
      ${g}
      let x_in = x + bias;
      ${c.setByOffset("global_idx", _o("x_in"))}
    }`;
    };
    return { name: "FastGeluWithBias", shaderCache: { hint: `${o}`, inputDependencies: ["type", "type"] }, getShaderSource: i, getRunData: (s) => ({ outputs: [{ dims: s[0].dims, dataType: s[0].dataType }], programUniforms: [{ type: 12, data: Math.ceil(r / 4) }, { type: 12, data: n }], dispatchGroup: { x: Math.ceil(r / Dt / 4) } }) };
  }, al = (t) => {
    t.inputs.length < 2 || k.size(t.inputs[1].dims) === 0 ? rd(t) : t.compute(pg(t.inputs));
  };
});
var mg;
var fg;
var ul;
var dl;
var ll = V(() => {
  J();
  ne();
  Ie();
  ae();
  mg = (t) => {
    if (!t || t.length !== 2)
      throw new Error("Gather requires 2 inputs.");
  }, fg = (t, e) => {
    let r = t[0].dims, n = t[1].dims, o = r.length, i = k.normalizeAxis(e.axis, o), s = r.slice(0);
    s.splice(i, 1, ...n);
    let u = r[i], d = t[0].dataType === 9 ? 4 : 1, c = Math.ceil(k.size(s) / d), p = [{ type: 12, data: c }, { type: 6, data: u }, { type: 12, data: i }, ...L(t[0].dims, t[1].dims, s)], m = (g) => {
      let b = O("data", t[0].dataType, t[0].dims.length, d), y = O("inputIndices", t[1].dataType, t[1].dims.length), w = R("output", t[0].dataType, s.length, d), S = ($) => {
        let T = n.length, I = `var indicesIndices${$}  = ${y.type.indices}(0);`;
        for (let E = 0;E < T; E++)
          I += `${T > 1 ? `indicesIndices${$}[${E}]` : `indicesIndices${$}`} = ${s.length > 1 ? `outputIndices${$}[uniforms.axis + ${E}]` : `outputIndices${$}`};`;
        I += `
          var idx${$} = ${y.getByIndices(`indicesIndices${$}`)};
          if (idx${$} < 0) {
            idx${$} = idx${$} + uniforms.axisDimLimit;
          }
          var dataIndices${$} : ${b.type.indices};
        `;
        for (let E = 0, A = 0;E < o; E++)
          E === i ? (I += `${o > 1 ? `dataIndices${$}[${E}]` : `dataIndices${$}`} = u32(idx${$});`, A += T) : (I += `${o > 1 ? `dataIndices${$}[${E}]` : `dataIndices${$}`} = ${s.length > 1 ? `outputIndices${$}[${A}]` : `outputIndices${$}`};`, A++);
        return I;
      }, x;
      if (t[0].dataType === 9) {
        let $ = (T, I, E = "") => `
          let outputIndices${I} = ${w.offsetToIndices(`outputOffset + ${I}u`)};
          ${S(I)};
          let offset${I} = ${b.indicesToOffset(`dataIndices${I}`)};
          let index${I} = offset${I} / 4u;
          let component${I} = offset${I} % 4u;
          ${T}[${I}] = ${E}(${b.getByOffset(`index${I}`)}[component${I}]);
        `;
        x = `
        let outputOffset = global_idx * ${d};
        var value = vec4<u32>(0);
        ${$("value", 0, "u32")}
        ${$("value", 1, "u32")}
        ${$("value", 2, "u32")}
        ${$("value", 3, "u32")}
        ${w.setByOffset("global_idx", "value")}
      `;
      } else
        x = `
      let outputIndices = ${w.offsetToIndices("global_idx")};
      ${S("")};
      let value = ${b.getByIndices("dataIndices")};
      ${w.setByOffset("global_idx", "value")};
      `;
      return `
      ${g.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(b, y, w)}
      ${g.mainStart()}
        ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${x}
      }`;
    };
    return { name: "Gather", shaderCache: { hint: e.cacheKey, inputDependencies: ["rank", "rank"] }, getRunData: () => ({ outputs: [{ dims: s, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(c / 64) }, programUniforms: p }), getShaderSource: m };
  }, ul = (t) => ee({ axis: t.axis }), dl = (t, e) => {
    let r = t.inputs;
    mg(r), t.compute(fg(t.inputs, e));
  };
});
var hg;
var cl;
var pl;
var ml = V(() => {
  J();
  ne();
  ae();
  hg = (t, e, r, n, o, i, s, u, d) => {
    let c = [{ type: 12, data: i }, { type: 12, data: n }, { type: 12, data: o }, { type: 12, data: r }, { type: 12, data: s }, { type: 12, data: u }, { type: 12, data: d }], p = [i];
    c.push(...L(e.dims, p));
    let m = (g) => {
      let b = O("indices_data", e.dataType, e.dims.length), y = R("input_slice_offsets_data", 12, 1, 1), w = [b, y], S = [{ name: "output_size", type: "u32" }, { name: "batch_dims", type: "u32" }, { name: "input_dims", type: "u32", length: o.length }, { name: "sizes_from_slice_dims_data", type: "u32", length: r.length }, { name: "num_slices_per_batch", type: "u32" }, { name: "input_batch_stride", type: "u32" }, { name: "num_slice_dims", type: "u32" }];
      return `
  ${g.registerUniforms(S).declareVariables(...w)}
  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${o.length === 1 ? "index += i32(uniforms.input_dims);" : "index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${r.length === 1 ? "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);" : "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`;
    };
    return t.compute({ name: "computeSliceOffsets", shaderCache: { hint: `${o.length}_${r.length}`, inputDependencies: ["rank"] }, getRunData: () => ({ outputs: [{ dims: p, dataType: t.inputs[1].dataType }], dispatchGroup: { x: Math.ceil(i / 64) }, programUniforms: c }), getShaderSource: m }, { inputs: [e], outputs: [-1] })[0];
  }, cl = (t, e) => {
    let r = t.inputs, n = r[0].dims, o = r[0].dataType, i = r[1].dims, s = i[i.length - 1], u = k.sizeToDimension(i, i.length - 1), d = k.sizeFromDimension(n, e.batchDims + s), c = k.sizeToDimension(n, e.batchDims), p = k.sizeFromDimension(n, e.batchDims), m = u / c, g = new Array(s), b = d;
    for (let I = 0;I < s; ++I)
      g[s - 1 - I] = b, b *= n[e.batchDims + s - 1 - I];
    let y = hg(t, r[1], g, e.batchDims, n, u, m, p, s), w = e.batchDims + s;
    if (w > n.length)
      throw new Error("last dimension of indices must not be larger than rank of input tensor");
    let S = i.slice(0, -1).concat(n.slice(w)), x = k.size(S), $ = [{ type: 12, data: x }, { type: 12, data: d }, ...L(r[0].dims, y.dims, S)], T = (I) => {
      let E = O("data", r[0].dataType, r[0].dims.length), A = O("slice_offsets", 12, y.dims.length), z = R("output", r[0].dataType, S.length);
      return `
          ${I.registerUniform("output_size", "u32").registerUniform("slice_size", "u32").declareVariables(E, A, z)}
            ${I.mainStart()}
            ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`;
    };
    t.compute({ name: "GatherND", shaderCache: { hint: e.cacheKey, inputDependencies: ["rank", "rank"] }, getRunData: () => ({ outputs: [{ dims: S, dataType: o }], dispatchGroup: { x: Math.ceil(x / 64) }, programUniforms: $ }), getShaderSource: T }, { inputs: [r[0], y] });
  }, pl = (t) => ({ batchDims: t.batch_dims, cacheKey: "" });
});
var gg;
var yg;
var fl;
var hl;
var gl = V(() => {
  J();
  ne();
  Ie();
  ae();
  gg = (t, e) => {
    if (t.length < 3 || t.length > 4)
      throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");
    let r = k.normalizeAxis(e.quantizeAxis, t[0].dims.length), n = e.blockSize, o = t[0], i = t[2], s = t.length === 4 ? t[3] : undefined;
    if (i.dims.length !== o.dims.length || !o.dims.map((u, d) => d === r ? Math.ceil(u / n) === i.dims[d] : u === i.dims[d]).reduce((u, d) => u && d, true))
      throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");
    if (s) {
      if (s.dataType !== o.dataType)
        throw new Error("Zero point must have the same data type as the input tensor.");
      if (s.dims.length !== i.dims.length || !s.dims.map((u, d) => u === i.dims[d]).reduce((u, d) => u && d, true))
        throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.");
    }
  }, yg = (t, e) => {
    let r = t[0].dims, n = t[1].dims, o = r.length, i = k.normalizeAxis(e.gatherAxis, o), s = k.normalizeAxis(e.quantizeAxis, o), u = r.slice(0);
    u.splice(i, 1, ...n);
    let d = k.size(u), c = t[2].dataType, m = t[0].dataType === 22, g = [{ type: 12, data: d }, { type: 12, data: s }, { type: 12, data: i }, { type: 12, data: e.blockSize }, ...L(...t.map((y, w) => y.dims), u)], b = (y) => {
      let w = O("data", t[0].dataType, t[0].dims.length), S = O("inputIndices", t[1].dataType, t[1].dims.length), x = O("scales", t[2].dataType, t[2].dims.length), $ = t.length > 3 ? O("zeroPoint", t[3].dataType, t[3].dims.length) : undefined, T = R("output", c, u.length), I = [w, S, x];
      $ && I.push($);
      let E = [{ name: "output_size", type: "u32" }, { name: "quantize_axis", type: "u32" }, { name: "gather_axis", type: "u32" }, { name: "block_size", type: "u32" }];
      return `
        ${y.registerUniforms(E).declareVariables(...I, T)}
        ${y.mainStart()}
        let output_indices = ${T.offsetToIndices("global_idx")};
        var indices_indices = ${S.type.indices}(0);
        ${n.length > 1 ? `
          for (var i: u32 = 0; i < ${n.length}; i++) {
            let index = ${T.indicesGet("output_indices", "uniforms.gather_axis + i")};
            ${S.indicesSet("indices_indices", "i", "index")};
          }` : `indices_indices = ${T.indicesGet("output_indices", "uniforms.gather_axis")};`};
        var data_indices = ${w.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${T.indicesGet("output_indices", "i")};
          ${w.indicesSet("data_indices", "i", "index")};
        }
        var index_from_indices = ${S.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${r[i]};
        }
        ${w.indicesSet("data_indices", "uniforms.gather_axis", "u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${u.length}; i++) {
          let index = ${T.indicesGet("output_indices", `i + ${n.length} - 1`)};
          ${w.indicesSet("data_indices", "i", "index")};
        }
        let data_offset = ${w.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${w.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${m ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${x.indicesGet("data_indices", "uniforms.quantize_axis")} / uniforms.block_size;
        ${x.indicesSet("scale_indices", "uniforms.quantize_axis", "quantize_axis_index")};
        var scale = ${x.getByIndices("scale_indices")};
        ${$ ? `
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${$.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${$.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${m ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];` : "var zero_point = 0"};
        let dequantized_data = ${Pe(c)}(quantized_data - zero_point) * scale;
        ${T.setByOffset("global_idx", "dequantized_data")};
    }`;
    };
    return { name: "GatherBlockQuantized", shaderCache: { hint: `${e.cacheKey};${t.filter((y, w) => w !== 1).map((y) => y.dims.join("_")).join(";")}`, inputDependencies: Array.from({ length: t.length }, (y, w) => "rank") }, getRunData: () => ({ outputs: [{ dims: u, dataType: c }], dispatchGroup: { x: Math.ceil(d / 64) }, programUniforms: g }), getShaderSource: b };
  }, fl = (t, e) => {
    let r = t.inputs;
    gg(r, e), t.compute(yg(t.inputs, e));
  }, hl = (t) => ee({ blockSize: t.blockSize, gatherAxis: t.gatherAxis, quantizeAxis: t.quantizeAxis });
});
var bg;
var wg;
var yl;
var bl;
var wl = V(() => {
  J();
  ne();
  Ie();
  ae();
  bg = (t) => {
    if (!t || t.length !== 2)
      throw new Error("GatherElements requires 2 inputs.");
    if (t[0].dims.length < 1)
      throw new Error("GatherElements requires that the data input be rank >= 1.");
    if (t[0].dims.length !== t[1].dims.length)
      throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
  }, wg = (t, e) => {
    let r = t[0].dims, n = t[0].dataType, o = r.length, i = t[1].dims, s = t[1].dataType, u = k.normalizeAxis(e.axis, o), d = r[u], c = i.slice(0), p = k.size(c), m = O("input", n, o), g = O("indicesInput", s, i.length), b = R("output", n, c.length), y = [{ type: 12, data: p }, { type: 6, data: d }, { type: 12, data: u }];
    return y.push(...L(r, i, c)), { name: "GatherElements", shaderCache: { inputDependencies: ["rank", "rank"] }, getRunData: () => ({ outputs: [{ dims: c, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(p / 64) }, programUniforms: y }), getShaderSource: (x) => `
      ${x.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(m, g, b)}
      ${x.mainStart()}
      ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${b.offsetToIndices("global_idx")};

      var idx = ${g.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${m.type.indices}(outputIndices);
      ${m.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${m.getByIndices("inputIndices")};

      ${b.setByOffset("global_idx", "value")};
  }` };
  }, yl = (t) => ee({ axis: t.axis }), bl = (t, e) => {
    let r = t.inputs;
    bg(r), t.compute(wg(t.inputs, e));
  };
});
var _g;
var vg;
var _l;
var vl;
var $l = V(() => {
  J();
  ne();
  ae();
  _g = (t) => {
    if (!t)
      throw new Error("Input is missing");
    if (t.length < 2 || t.length > 3)
      throw new Error("Invaid input number.");
    if (t.length === 3 && t[2].dims.length > 2)
      throw new Error("Invalid input shape of C");
    if (t[0].dataType !== t[1].dataType || t.length === 3 && t[0].dataType !== t[2].dataType)
      throw new Error("Input types are mismatched");
  }, vg = (t, e) => {
    let r = t[0].dims.slice(), n = t[1].dims.slice(), [o, i, s] = Wr.getShapeOfGemmResult(r, e.transA, n, e.transB, t.length === 3 ? t[2].dims : undefined), u = [o, i];
    if (!u)
      throw new Error("Can't use gemm on the given tensors");
    let d = 16, c = Math.ceil(i / d), p = Math.ceil(o / d), m = true, g = k.size(u), b = [{ type: 12, data: m ? c : g }, { type: 12, data: o }, { type: 12, data: i }, { type: 12, data: s }, { type: 1, data: e.alpha }, { type: 1, data: e.beta }], y = ["type", "type"];
    t.length === 3 && (b.push(...L(t[2].dims)), y.push("rank")), b.push(...L(u));
    let w = (x) => {
      let $ = "";
      e.transA && e.transB ? $ = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];" : e.transA && !e.transB ? $ = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];" : !e.transA && e.transB ? $ = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];" : !e.transA && !e.transB && ($ = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");
      let T = e.alpha === 1 ? "" : "value *= uniforms.alpha;", I = O("a", t[0].dataType, t[0].dims), E = O("b", t[1].dataType, t[1].dims), A = I.type.value, z = null, v = [I, E];
      t.length === 3 && (z = O("c", t[2].dataType, t[2].dims.length), v.push(z));
      let M = R("output", t[0].dataType, u.length);
      v.push(M);
      let N = [{ name: "output_size", type: "u32" }, { name: "M", type: "u32" }, { name: "N", type: "u32" }, { name: "K", type: "u32" }, { name: "alpha", type: "f32" }, { name: "beta", type: "f32" }];
      return `
  ${x.registerUniforms(N).declareVariables(...v)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${A}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${$}
    }

    ${T}
    ${z != null ? `let cOffset = ${z.broadcastedIndicesToOffset("vec2(m, n)", M)}; value += ${A}(uniforms.beta) * ${z.getByOffset("cOffset")};` : ""}
    output[global_idx] = value;
  }`;
    }, S = (x) => {
      let $ = O("a", t[0].dataType, t[0].dims), T = O("b", t[1].dataType, t[1].dims), I = null, E = [$, T];
      t.length === 3 && (I = O("c", t[2].dataType, t[2].dims.length), E.push(I));
      let A = R("output", t[0].dataType, u.length);
      E.push(A);
      let z = [{ name: "num_tile_n", type: "u32" }, { name: "M", type: "u32" }, { name: "N", type: "u32" }, { name: "K", type: "u32" }, { name: "alpha", type: "f32" }, { name: "beta", type: "f32" }], v = "", M = "";
      e.transA && e.transB ? (M = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${$.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `, v = "value += tile_a[k][local_id.y] * tile_b[local_id.x][k];") : e.transA && !e.transB ? (M = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${$.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `, v = "value += tile_a[k][local_id.y] * tile_b[k][local_id.x];") : !e.transA && e.transB ? (M = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${$.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `, v = "value += tile_a[local_id.y][k] * tile_b[local_id.x][k];") : !e.transA && !e.transB && (M = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${$.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);
      }
      `, v = "value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");
      let N = e.alpha === 1 ? "" : "value *= uniforms.alpha;";
      return `
  ${x.registerUniforms(z).declareVariables(...E)}
  var<workgroup> tile_a: array<array<${$.type.storage}, ${d}>, ${d}>;
  var<workgroup> tile_b: array<array<${T.type.storage}, ${d}>, ${d}>;
  ${x.mainStart([d, d, 1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${d};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${d};
    let num_tiles = (uniforms.K - 1) / ${d} + 1;
    var k_start = 0u;
    var value = ${A.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${M}
      k_start = k_start + ${d};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${d}; k++) {
        ${v}
      }
      workgroupBarrier();
    }

    ${N}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${I != null ? `let cOffset = ${I.broadcastedIndicesToOffset("vec2(m, n)", A)}; value += ${A.type.value}(uniforms.beta) * ${I.getByOffset("cOffset")};` : ""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`;
    };
    return m ? { name: "GemmShared", shaderCache: { hint: `${e.cacheKey}`, inputDependencies: y }, getRunData: () => ({ outputs: [{ dims: u, dataType: t[0].dataType }], dispatchGroup: { x: c * p }, programUniforms: b }), getShaderSource: S } : { name: "Gemm", shaderCache: { hint: `${e.cacheKey}`, inputDependencies: y }, getRunData: () => ({ outputs: [{ dims: u, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(g / 64) }, programUniforms: b }), getShaderSource: w };
  }, _l = (t) => {
    let { transA: e, transB: r, alpha: n, beta: o } = t;
    return { transA: e, transB: r, alpha: n, beta: o, cacheKey: `${t.transA};${t.transB};${t.alpha === 1}` };
  }, vl = (t, e) => {
    _g(t.inputs), t.compute(vg(t.inputs, e));
  };
});
var mt;
var Tt;
var Gt;
var Ht;
var $g;
var xg;
var Sg;
var Tg;
var Ig;
var Cg;
var Ag;
var Eg;
var xl;
var Sl;
var Tl = V(() => {
  J();
  ne();
  Ie();
  ae();
  [mt, Tt, Gt, Ht] = [0, 1, 2, 3], $g = (t) => {
    if (t[0].dims.length !== 4)
      throw new Error("only 4-D tensor is supported.");
    if (t[0].dims.length !== t[1].dims.length)
      throw new Error("input dimensions must be equal to grid dimensions");
    if (t[0].dims.length - 2 !== t[1].dims[t[1].dims.length - 1])
      throw new Error(`last dimension of grid must be equal to ${t[0].dims.length - 2}`);
    if (t[0].dims[0] !== t[1].dims[0])
      throw new Error("grid batch size must match input batch size");
  }, xg = `
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`, Sg = (t) => `
  fn gs_bicubic_interpolate(p: mat4x4<${t}>, x: f32, y: f32) -> ${t} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${t}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`, Tg = (t) => `
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${t.alignCorners === 0 ? `
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    ` : `
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`, Ig = (t) => `
  ${t.paddingMode === "reflection" ? `
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }` : ""}
`, Cg = (t, e, r) => `
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${e} {
     var pixel = ${e}(0);
     var indices = vec4<u32>(0);
     indices[${mt}] = batch;
     indices[${Tt}] = channel;` + (() => {
    switch (r.paddingMode) {
      case "zeros":
        return `
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${Gt}] = u32(r);
            indices[${Ht}] = u32(c);
          } else {
            return ${e}(0);
          }
        `;
      case "border":
        return `
          indices[${Gt}] = u32(clamp(r, 0, H - 1));
          indices[${Ht}] = u32(clamp(c, 0, W - 1));
        `;
      case "reflection":
        return `
          indices[${Gt}] = gs_reflect(r, border[1], border[3]);
          indices[${Ht}] = gs_reflect(c, border[0], border[2]);
        `;
      default:
        throw new Error(`padding mode ${r.paddingMode} is not supported`);
    }
  })() + `
    return ${t.getByIndices("indices")};
  }
`, Ag = (t, e, r) => (() => {
    switch (r.mode) {
      case "nearest":
        return `
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${mt}], indices[${Tt}], border);
        `;
      case "bilinear":
        return `
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${mt}], indices[${Tt}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${mt}], indices[${Tt}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${mt}], indices[${Tt}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${mt}], indices[${Tt}], border);

          let dx2 = ${e}(f32(x2) - x);
          let dx1 = ${e}(x - f32(x1));
          let dy2 = ${e}(f32(y2) - y);
          let dy1 = ${e}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;
      case "bicubic":
        return `
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${e}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${mt}], indices[${Tt}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;
      default:
        throw new Error(`mode ${r.mode} is not supported`);
    }
  })() + `${t.setByOffset("global_idx", "result")}`, Eg = (t, e) => {
    let r = O("x", t[0].dataType, t[0].dims.length), n = [t[1].dims[0], t[1].dims[1], t[1].dims[2]], o = O("grid", t[1].dataType, n.length, 2), i = [t[0].dims[0], t[0].dims[1], t[1].dims[1], t[1].dims[2]];
    e.format === "NHWC" && (i = [t[0].dims[0], t[1].dims[1], t[1].dims[2], t[0].dims[3]], [mt, Tt, Gt, Ht] = [0, 3, 1, 2]);
    let s = R("output", t[0].dataType, i.length), u = r.type.value, d = k.size(i), c = [{ type: 12, data: d }, ...L(t[0].dims, n, i)], p = (m) => `
  ${m.registerUniform("output_size", "u32").declareVariables(r, o, s)}
  ${xg}
  ${Sg(u)}
  ${Tg(e)}
  ${Ig(e)}
  ${Cg(r, u, e)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${Gt}]);
      let W_in = i32(uniforms.x_shape[${Ht}]);

      ${e.alignCorners === 0 ? `
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      ` : `
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${s.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${mt}], indices[${Gt}], indices[${Ht}]);
      let nxy = ${o.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${Ag(s, u, e)}
  }`;
    return { name: "GridSample", shaderCache: { hint: `${e.cacheKey}`, inputDependencies: ["type", "type"] }, getRunData: (m) => {
      let g = k.size(i);
      return { outputs: [{ dims: i, dataType: m[0].dataType }], dispatchGroup: { x: Math.ceil(g / 64) }, programUniforms: c };
    }, getShaderSource: p };
  }, xl = (t, e) => {
    $g(t.inputs), t.compute(Eg(t.inputs, e));
  }, Sl = (t) => ee({ alignCorners: t.align_corners, mode: t.mode, paddingMode: t.padding_mode, format: t.format });
});
var Re;
var Og;
var Cl;
var Il;
var zg;
var ar;
var Al;
var ko = V(() => {
  J();
  ne();
  Ie();
  jr();
  Jr();
  ae();
  pt();
  Re = (t, e) => t.length > e && t[e].dims.length > 0 ? t[e] : undefined, Og = (t, e) => {
    let r = t[0], n = Re(t, 1), o = Re(t, 2), i = Re(t, 3), s = Re(t, 4), u = Re(t, 5), d = Re(t, 6), c = Re(t, 7);
    if (r.dims.length !== 3 && r.dims.length !== 5)
      throw new Error("Input query is expected to have 3 or 5 dimensions");
    let p = r.dims[0], m = r.dims[1], g = r.dims.length === 3 ? r.dims[2] : e.numHeads * r.dims[4], b = m, y = 0, w = 0, S = Math.floor(g / e.numHeads);
    if (d && c && k.size(d.dims) && k.size(c.dims)) {
      if (d.dims.length !== 4)
        throw new Error('Input "past_key" is expected to have 4 dimensions');
      if (d.dims[0] !== p || d.dims[1] !== e.numHeads || d.dims[3] !== S)
        throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
      if (c.dims[0] !== p || c.dims[1] !== e.numHeads || c.dims[3] !== S)
        throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
      if (d.dims[2] !== c.dims[2])
        throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
      if (c.dims.length !== 4)
        throw new Error('Input "past_value" is expected to have 4 dimensions');
      y = d.dims[2], w = d.dims[2];
    } else if (d && k.size(d.dims) || c && k.size(c.dims))
      throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
    let x;
    if (n && k.size(n.dims) > 0) {
      if (r.dims.length !== 3)
        throw new Error('Input "query" is expected to have 3 dimensions when key is given');
      if (n.dims.length < 3 || n.dims.length > 5)
        throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
      if (r.dims[0] !== n.dims[0])
        throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
      if (n.dims.length === 3) {
        if (n.dims[2] !== r.dims[2])
          throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
        x = 2, b = n.dims[1];
      } else if (n.dims.length === 5) {
        if (n.dims[2] !== e.numHeads || n.dims[3] !== 2 || n.dims[4] !== S)
          throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
        if (o)
          throw new Error('Expect "value" be none when "key" has packed kv format.');
        x = 5, b = n.dims[1];
      } else {
        if (n.dims[1] !== e.numHeads || n.dims[3] !== S)
          throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
        x = 0, b = n.dims[2];
      }
    } else {
      if (r.dims.length !== 5)
        throw new Error('Input "query" is expected to have 5 dimensions when key is empty');
      if (r.dims[2] !== e.numHeads || r.dims[3] !== 3)
        throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
      x = 3;
    }
    if (i && k.size(i.dims) > 0) {
      if (i.dims.length !== 1)
        throw new Error('Input "bias" is expected to have 1 dimension');
      if (n && n.dims.length === 5 && n.dims[3] === 2)
        throw new Error("bias is not allowed for packed kv.");
    }
    let $ = y + b, T = 0;
    if (s && k.size(s.dims) > 0) {
      T = 8;
      let z = s.dims;
      throw z.length === 1 ? z[0] === p ? T = 1 : z[0] === 3 * p + 2 && (T = 3) : z.length === 2 && z[0] === p && z[1] === $ && (T = 5), T === 8 ? new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)') : new Error("Mask not supported");
    }
    let I = false, E = g;
    if (o && k.size(o.dims) > 0) {
      if (o.dims.length !== 3 && o.dims.length !== 4)
        throw new Error('Input "value" is expected to have 3 or 4 dimensions');
      if (r.dims[0] !== o.dims[0])
        throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
      if (o.dims.length === 3) {
        if (b !== o.dims[1])
          throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
        E = o.dims[2];
      } else {
        if (b !== o.dims[2])
          throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');
        E = o.dims[1] * o.dims[3], I = true;
      }
    }
    let A = false;
    if (s && k.size(s.dims) > 0)
      throw new Error("Key padding mask is not supported");
    if (u && k.size(u.dims) > 0) {
      if (u.dims.length !== 4)
        throw new Error('Input "attention_bias" is expected to have 4 dimensions');
      if (u.dims[0] !== p || u.dims[1] !== e.numHeads || u.dims[2] !== m || u.dims[3] !== $)
        throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
    }
    return { batchSize: p, sequenceLength: m, pastSequenceLength: y, kvSequenceLength: b, totalSequenceLength: $, maxSequenceLength: w, inputHiddenSize: 0, hiddenSize: g, vHiddenSize: E, headSize: S, vHeadSize: Math.floor(E / e.numHeads), numHeads: e.numHeads, isUnidirectional: false, pastPresentShareBuffer: false, maskFilterValue: e.maskFilterValue, maskType: T, scale: e.scale, broadcastResPosBias: A, passPastInKv: I, qkvFormat: x };
  }, Cl = (t) => ee({ ...t }), Il = ee({ perm: [0, 2, 1, 3] }), zg = (t, e, r, n, o, i, s) => {
    let u = [n, o, i], d = k.size(u), c = [{ type: 12, data: d }, { type: 12, data: s }, { type: 12, data: i }], p = (m) => {
      let g = R("qkv_with_bias", e.dataType, u), b = O("qkv", e.dataType, u), y = O("bias", r.dataType, u), w = [{ name: "output_size", type: "u32" }, { name: "bias_offset", type: "u32" }, { name: "hidden_size", type: "u32" }];
      return `
  ${m.registerUniforms(w).declareVariables(b, y, g)}
  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
    };
    return t.compute({ name: "MultiHeadAttentionAddBias", shaderCache: { inputDependencies: ["type", "type"] }, getRunData: () => ({ outputs: [{ dims: u, dataType: e.dataType, gpuDataType: 0 }], dispatchGroup: { x: Math.ceil(d / 64) }, programUniforms: c }), getShaderSource: p }, { inputs: [e, r], outputs: [-1] })[0];
  }, ar = (t, e, r, n, o, i, s, u) => {
    let d = i;
    if (s && k.size(s.dims) > 0) {
      if (n === 1)
        throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
      return d = zg(t, i, s, e, n, r * o, u), d = d.reshape([e, n, r, o]), r === 1 || n === 1 ? d : t.compute(Oe(d, Il.perm), { inputs: [d], outputs: [-1] })[0];
    } else
      return i.dims.length === 3 && (d = i.reshape([e, n, r, o])), r === 1 || n === 1 ? d : t.compute(Oe(d, Il.perm), { inputs: [d], outputs: [-1] })[0];
  }, Al = (t, e) => {
    let r = Og(t.inputs, e), n = t.inputs[0], o = Re(t.inputs, 1), i = Re(t.inputs, 2), s = Re(t.inputs, 3), u = Re(t.inputs, 4), d = Re(t.inputs, 5), c = Re(t.inputs, 6), p = Re(t.inputs, 7);
    if (n.dims.length === 5)
      throw new Error("Packed QKV is not implemented");
    if (o?.dims.length === 5)
      throw new Error("Packed KV is not implemented");
    let m = o && i && o.dims.length === 4 && i.dims.length === 4, g = ar(t, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, n, s, 0);
    if (m)
      return Wt(t, g, o, i, u, undefined, c, p, d, r);
    if (!o || !i)
      throw new Error("key and value must be provided");
    let b = ar(t, r.batchSize, r.numHeads, r.kvSequenceLength, r.headSize, o, s, r.hiddenSize), y = ar(t, r.batchSize, r.numHeads, r.kvSequenceLength, r.vHeadSize, i, s, 2 * r.hiddenSize);
    Wt(t, g, b, y, u, undefined, c, p, d, r);
  };
});
var Dg;
var Bg;
var Mg;
var Rg;
var Po;
var El;
var kl;
var Oo = V(() => {
  J();
  ne();
  Ie();
  ae();
  Dg = (t) => {
    if (!t || t.length < 1)
      throw new Error("too few inputs");
  }, Bg = (t, e) => {
    let r = [], n = e.numOutputs;
    return t[1].dims[0] > 0 && (t[1].getBigInt64Array().forEach((o) => r.push(Number(o))), n = r.length), ee({ numOutputs: n, axis: e.axis, splitSizes: r });
  }, Mg = (t) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {
    if (index < ${F("uniforms.size_in_split_axis", "i", t)}) {
        return i;
    }
    }
    return ${t}u;
}`, Rg = (t) => {
    let e = t.length, r = [];
    for (let n = 0;n < e; ++n) {
      let o = t[n].setByIndices("indices", "input[global_idx]");
      e === 1 ? r.push(o) : n === 0 ? r.push(`if (output_number == ${n}u) { ${o} }`) : n === e - 1 ? r.push(`else { ${o} }`) : r.push(`else if (output_number == ${n}) { ${o} }`);
    }
    return `
      fn writeBufferData(output_number: u32, indices: ${t[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`;
  }, Po = (t, e) => {
    let r = t[0].dims, n = k.size(r), o = t[0].dataType, i = k.normalizeAxis(e.axis, r.length), s = new Array(e.numOutputs), u = O("input", o, r.length), d = new Array(e.numOutputs), c = [], p = [], m = 0, g = [{ type: 12, data: n }];
    for (let y = 0;y < e.numOutputs; y++) {
      m += e.splitSizes[y], d[y] = m;
      let w = r.slice();
      w[i] = e.splitSizes[y], p.push(w), s[y] = R(`output${y}`, o, w.length), c.push({ dims: p[y], dataType: t[0].dataType });
    }
    g.push({ type: 12, data: d }, ...L(r, ...p));
    let b = (y) => `
  ${y.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", d.length).declareVariables(u, ...s)}
  ${Mg(d.length)}
  ${Rg(s)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${u.offsetToIndices("global_idx")};
    var index = ${u.indicesGet("indices", i)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${F("uniforms.size_in_split_axis", "output_number - 1u", d.length)};
      ${u.indicesSet("indices", i, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
    return { name: "Split", shaderCache: { hint: e.cacheKey, inputDependencies: ["rank"] }, getShaderSource: b, getRunData: () => ({ outputs: c, dispatchGroup: { x: Math.ceil(n / 64) }, programUniforms: g }) };
  }, El = (t, e) => {
    Dg(t.inputs);
    let r = t.inputs.length === 1 ? e : Bg(t.inputs, e);
    t.compute(Po(t.inputs, r), { inputs: [0] });
  }, kl = (t) => {
    let { axis: e, splitSizes: r } = t, n = t.numOutputs < 0 ? r.length : t.numOutputs;
    if (n !== r.length)
      throw new Error("numOutputs and splitSizes length must be equal");
    return ee({ axis: e, numOutputs: n, splitSizes: r });
  };
});
var Ug;
var ln;
var Pl;
var zo = V(() => {
  J();
  ne();
  Ie();
  ae();
  Ug = (t, e) => {
    let [r, n, o, i] = t, { numHeads: s, rotaryEmbeddingDim: u } = e;
    if (r.dims.length !== 3 && r.dims.length !== 4)
      throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);
    if (!k.areEqual(n.dims, []) && !k.areEqual(n.dims, [1]) && n.dims.length !== 2)
      throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${n.dims.length}`);
    if (o.dims.length !== 2)
      throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${o.dims.length}`);
    if (i.dims.length !== 2)
      throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${i.dims.length}`);
    if (!k.areEqual(o.dims, i.dims))
      throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
    if (u > 0 && s === 0)
      throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
    let d = r.dims[0], c = r.dims[r.dims.length - 2], p = o.dims[0], m = k.sizeFromDimension(r.dims, 1) / c, g = u === 0 ? o.dims[1] * 2 : m / s;
    if (u > g)
      throw new Error("rotary_embedding_dim must be less than or equal to head_size");
    if (n.dims.length === 2) {
      if (d !== n.dims[0])
        throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${n.dims[0]}`);
      if (c !== n.dims[1])
        throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${n.dims[1]}`);
    }
    if (g / 2 !== o.dims[1] && u / 2 !== o.dims[1])
      throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${o.dims[1]}`);
    if (c > p)
      throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
  }, ln = (t, e) => {
    let { interleaved: r, numHeads: n, rotaryEmbeddingDim: o, scale: i } = e, s = t[0].dims[0], u = k.sizeFromDimension(t[0].dims, 1), d = t[0].dims[t[0].dims.length - 2], c = u / d, p = t[2].dims[1], m = o === 0 ? p * 2 : c / n, g = new Array(s, d, c / m, m - p), b = k.computeStrides(g), y = [{ type: 1, data: i }, { type: 12, data: g }, { type: 12, data: b }, ...t[0].dims.length === 3 ? new Array({ type: 12, data: [u, c, m, 1] }) : [], ...t[0].dims.length === 4 ? new Array({ type: 12, data: [u, m, d * m, 1] }) : [], ...L(t[0].dims, t[1].dims, t[2].dims, t[3].dims, t[0].dims)], w = (S) => {
      let x = O("input", t[0].dataType, t[0].dims.length), $ = O("position_ids", t[1].dataType, t[1].dims.length), T = O("cos_cache", t[2].dataType, t[2].dims.length), I = O("sin_cache", t[3].dataType, t[3].dims.length), E = R("output", t[0].dataType, t[0].dims.length);
      return S.registerUniforms([{ name: "scale", type: "f32" }, { name: "global_shape", type: "u32", length: g.length }, { name: "global_strides", type: "u32", length: b.length }, { name: "input_output_strides", type: "u32", length: b.length }]), `
        ${S.declareVariables(x, $, T, I, E)}

        ${S.mainStart(Dt)}
          let half_rotary_emb_dim = uniforms.${T.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${S.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${$.broadcastedIndicesToOffset("bsnh.xy", R("", $.type.tensor, 2))};
            let position_id =
                u32(${$.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});
            let j = i + select(half_rotary_emb_dim, 1, ${r});
            let re = ${x.getByOffset("i")} * ${T.get("position_id", "bsnh[3]")} -
                ${x.getByOffset("j")} * ${I.get("position_id", "bsnh[3]")};
            ${E.setByOffset("i", "re")}
            let im = ${x.getByOffset("i")} * ${I.get("position_id", "bsnh[3]")} +
                ${x.getByOffset("j")} * ${T.get("position_id", "bsnh[3]")};
            ${E.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${E.setByOffset("k", x.getByOffset("k"))}
          }
        }`;
    };
    return { name: "RotaryEmbedding", shaderCache: { hint: ee({ interleaved: r }).cacheKey, inputDependencies: ["rank", "rank", "rank", "rank"] }, getShaderSource: w, getRunData: () => ({ outputs: [{ dims: t[0].dims, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(k.size(g) / Dt) }, programUniforms: y }) };
  }, Pl = (t, e) => {
    Ug(t.inputs, e), t.compute(ln(t.inputs, e));
  };
});
var Ng;
var Vg;
var Ol;
var Lg;
var zl;
var Dl = V(() => {
  Ie();
  J();
  Jr();
  ko();
  Oo();
  pt();
  zo();
  ae();
  Ng = (t, e) => {
    if (e.doRotary && t.length <= 7)
      throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");
    let r = t[0], n = t[1], o = t[2], i = t[3], s = t[4];
    if (e.doRotary !== 0 && t.length <= 7)
      throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");
    if (e.localWindowSize !== -1)
      throw new Error("Local attention is not supported");
    if (e.softcap !== 0)
      throw new Error("Softcap is not supported");
    if (e.rotaryInterleaved !== 0)
      throw new Error("Rotary interleaved is not supported");
    if (e.smoothSoftmax)
      throw new Error("Smooth softmax is not supported");
    if (r.dims.length !== 3 && r.dims.length !== 5)
      throw new Error("Input query is expected to have 3 or 5 dimensions");
    let u = false, d = r.dims[0], c = r.dims[1], p = r.dims.length === 3 ? u ? r.dims[2] / 3 : r.dims[2] : e.numHeads * r.dims[4], m = c, g = 0, b = !n || n.dims.length === 0, y = Math.floor(b ? p / (e.numHeads + 2 * e.kvNumHeads) : p / e.numHeads);
    b && (p = y * e.numHeads);
    let w = i && i.dims.length !== 0, S = s && s.dims.length !== 0;
    if (w && i.dims.length === 4 && i.dims[0] === d && i.dims[1] !== e.kvNumHeads && i.dims[2] === e.kvNumHeads && i.dims[3] === y)
      throw new Error("BSNH pastKey/pastValue is not supported");
    if (w && S) {
      if (i.dims.length !== 4)
        throw new Error('Input "past_key" is expected to have 4 dimensions');
      if (s.dims.length !== 4)
        throw new Error('Input "past_value" is expected to have 4 dimensions');
      g = i.dims[2];
    } else if (w || S)
      throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
    let $ = 1;
    if (n && n.dims.length > 0) {
      if (r.dims.length !== 3)
        throw new Error('Input "query" is expected to have 3 dimensions when key is given');
      if (n.dims.length < 3 || n.dims.length > 5)
        throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
      if (r.dims[0] !== n.dims[0])
        throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
      if (n.dims.length === 3) {
        if (r.dims[2] % n.dims[2] !== 0)
          throw new Error('Dimension 2 of "query" should be a multiple of "key"');
        m = n.dims[1];
      } else if (n.dims.length === 5) {
        if (n.dims[2] !== e.numHeads || n.dims[3] !== 2 || n.dims[4] !== y)
          throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
        if (o)
          throw new Error('Expect "value" be none when "key" has packed kv format.');
        m = n.dims[1];
      } else {
        if (n.dims[1] !== e.numHeads || n.dims[3] !== y)
          throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
        m = n.dims[2];
      }
    } else {
      if (r.dims.length !== 3 && r.dims.length !== 5)
        throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
      if (r.dims.length === 5 && (r.dims[2] !== e.numHeads || r.dims[3] !== 3))
        throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
      $ = 3;
    }
    let T = 0, I = false, E = e.kvNumHeads ? y * e.kvNumHeads : p;
    if (o && o.dims.length > 0) {
      if (o.dims.length !== 3 && o.dims.length !== 4)
        throw new Error('Input "value" is expected to have 3 or 4 dimensions');
      if (r.dims[0] !== o.dims[0])
        throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
      if (o.dims.length === 3) {
        if (m !== o.dims[1])
          throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
        E = o.dims[2];
      } else {
        if (m !== o.dims[2])
          throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
        E = o.dims[1] * o.dims[3], I = true;
      }
    }
    let A = t.length > 4 ? t[5] : undefined;
    if (A && A.dims.length !== 1 && A.dims[0] !== d)
      throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');
    return { batchSize: d, sequenceLength: c, pastSequenceLength: g, kvSequenceLength: m, totalSequenceLength: -1, maxSequenceLength: -1, inputHiddenSize: 0, hiddenSize: p, vHiddenSize: E, headSize: y, vHeadSize: Math.floor(E / e.kvNumHeads), numHeads: e.numHeads, kvNumHeads: e.kvNumHeads, nReps: e.numHeads / e.kvNumHeads, pastPresentShareBuffer: false, maskType: T, scale: e.scale, broadcastResPosBias: false, passPastInKv: I, qkvFormat: $ };
  }, Vg = ee({ perm: [0, 2, 1, 3] }), Ol = (t, e, r) => {
    let n = e, o = r.kvNumHeads;
    return e.dims.length === 3 && r.kvSequenceLength !== 0 && (n = e.reshape([r.batchSize, r.kvSequenceLength, o, r.headSize]), n = t.compute(Oe(n, Vg.perm), { inputs: [n], outputs: [-1] })[0]), n;
  }, Lg = (t, e, r, n) => {
    let o = 7, i = ["type", "type"], s = [t * e], u = t * e, d = [{ type: 12, data: u }, { type: 12, data: e }, { type: 12, data: t }], c = (p) => {
      let m = O("seq_lens", r.dataType, r.dims), g = O("total_seq_lens", n.dataType, n.dims), b = R("pos_ids", o, s), y = [{ name: "output_size", type: "u32" }, { name: "sequence_length", type: "u32" }, { name: "batch_size", type: "u32" }];
      return `
  ${p.registerUniforms(y).declareVariables(m, g, b)}
  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${g.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${m.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${b.setByOffset("global_idx", "pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${b.setByOffset("global_idx", "pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${b.setByOffset("global_idx", "seqlen")}
    };
  }
  `;
    };
    return { name: "GeneratePositionIds", shaderCache: { hint: `${t};${e}`, inputDependencies: i }, getRunData: () => ({ outputs: [{ dims: s, dataType: o }], dispatchGroup: { x: Math.ceil(u / 64) }, programUniforms: d }), getShaderSource: c };
  }, zl = (t, e) => {
    let r = Ng(t.inputs, e);
    if (t.inputs[0].dims.length === 5)
      throw new Error("Packed QKV is not implemented");
    if (t.inputs[1]?.dims.length === 5)
      throw new Error("Packed KV is not implemented");
    let n = t.inputs[0], o = t.inputs[1] && t.inputs[1].dims.length > 0 ? t.inputs[1] : undefined, i = t.inputs[2] && t.inputs[2].dims.length > 0 ? t.inputs[2] : undefined, s = t.inputs[3] && t.inputs[3].dims.length !== 0 ? t.inputs[3] : undefined, u = t.inputs[4] && t.inputs[4].dims.length !== 0 ? t.inputs[4] : undefined, d = t.inputs.length > 4 ? t.inputs[5] : undefined, c = t.inputs.length > 5 ? t.inputs[6] : undefined, p = r.kvNumHeads ? r.kvNumHeads : r.numHeads, m = ee({ axis: 2, numOutputs: 3, splitSizes: [r.numHeads * r.headSize, p * r.headSize, p * r.headSize] }), [g, b, y] = !o && !i ? t.compute(Po([n], m), { inputs: [n], outputs: [-1, -1, -1] }) : [n, o, i], w, S;
    if (e.doRotary) {
      let I = t.compute(Lg(r.batchSize, r.sequenceLength, d, c), { inputs: [d, c], outputs: [-1] })[0], E = t.inputs[7], A = t.inputs[8], z = ee({ interleaved: e.rotaryInterleaved !== 0, numHeads: r.numHeads, rotaryEmbeddingDim: 0, scale: e.scale }), v = [g, I, E, A], M = [-1];
      w = t.compute(ln(v, z), { inputs: v, outputs: M })[0], v.splice(0, 1, b);
      let N = ee({ interleaved: e.rotaryInterleaved !== 0, numHeads: r.kvNumHeads, rotaryEmbeddingDim: 0, scale: e.scale });
      S = t.compute(ln(v, N), { inputs: v, outputs: M })[0];
    }
    let x = ar(t, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, e.doRotary ? w : g, undefined, 0), $ = Ol(t, e.doRotary ? S : b, r), T = Ol(t, y, r);
    Wt(t, x, $, T, undefined, undefined, s, u, undefined, r, d, c);
  };
});
var Bl;
var Wg;
var Gg;
var Ml;
var Rl = V(() => {
  J();
  ne();
  pt();
  ae();
  Bl = (t, e, r, n, o, i, s, u) => {
    let d = fe(i), c = d === 1 ? "f32" : `vec${d}f`, p = d === 1 ? "vec2f" : `mat2x${d}f`, m = o * s, g = 64;
    m === 1 && (g = 256);
    let b = [o, s, i / d], y = [o, s, 2], w = ["rank", "type", "type"], S = [];
    S.push(...L(b, y));
    let x = ($) => {
      let T = O("x", e.dataType, 3, d), I = O("scale", r.dataType, r.dims), E = O("bias", n.dataType, n.dims), A = R("output", 1, 3, 2), z = [T, I, E, A];
      return `
  var<workgroup> workgroup_shared : array<${p}, ${g}>;
  const workgroup_size = ${g}u;
  ${$.declareVariables(...z)}
  ${$.mainStart(g)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${c}(0);
    var squared_sum = ${c}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${c}(${T.get("batch", "channel", "h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${p}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${je("workgroup_shared[0][0]", d)} / f32(hight * ${d});
      let squared_sum_final = ${je("workgroup_shared[0][1]", d)} / f32(hight * ${d});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${u}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`;
    };
    return t.compute({ name: "InstanceNormComputeChannelScaleShift", shaderCache: { hint: `${d};${u};${g}`, inputDependencies: w }, getRunData: () => ({ outputs: [{ dims: y, dataType: 1 }], dispatchGroup: { x: m }, programUniforms: S }), getShaderSource: x }, { inputs: [e, r, n], outputs: [-1] })[0];
  }, Wg = (t, e, r) => {
    let n = e[0].dims, o = n, i = 2, s = n[0], u = n[1], d = k.sizeFromDimension(n, i), c = fe(d), p = k.size(o) / c, m = Bl(t, e[0], e[1], e[2], s, d, u, r.epsilon), g = [s, u, d / c], b = [s, u], y = ["type", "none"], w = (S) => {
      let x = O("x", e[0].dataType, g.length, c), $ = O("scale_shift", 1, b.length, 2), T = R("output", e[0].dataType, g.length, c), I = [x, $, T];
      return `
  ${S.registerUniform("output_size", "u32").declareVariables(...I)}
  ${S.mainStart()}
  ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${T.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${$.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${x.getByOffset("global_idx")} * ${T.type.value}(scale_shift.x) + ${T.type.value}(scale_shift.y);
      ${T.setByOffset("global_idx", "value")};
  }`;
    };
    t.compute({ name: "InstanceNormalization", shaderCache: { hint: `${c}`, inputDependencies: y }, getRunData: () => ({ outputs: [{ dims: o, dataType: e[0].dataType }], dispatchGroup: { x: Math.ceil(p / 64) }, programUniforms: [{ type: 12, data: p }, ...L(g, b, g)] }), getShaderSource: w }, { inputs: [e[0], m] });
  }, Gg = (t, e, r) => {
    let n = e[0].dims, o = n, i = n[0], s = n[n.length - 1], u = k.sizeFromDimension(n, 1) / s, d = fe(s), c = k.size(o) / d, p = [{ type: 12, data: u }, { type: 12, data: Math.floor(s / d) }], m = ["type", "type"], g = false, b = [0, n.length - 1];
    for (let x = 0;x < n.length - 2; x++)
      g = g || n[x + 1] !== 1, b.push(x + 1);
    g = g && n[n.length - 1] !== 1;
    let y = g ? t.compute(Oe(t.inputs[0], b), { inputs: [t.inputs[0]], outputs: [-1] })[0] : t.inputs[0].reshape(Array.from({ length: n.length }, (x, $) => n[b[$]])), w = Bl(t, y, e[1], e[2], i, u, s, r.epsilon), S = (x) => {
      let $ = be(e[0].dataType), T = d === 1 ? "vec2f" : `mat${d}x2f`, I = (z) => {
        let v = z === 0 ? "x" : "y", M = d === 1 ? "f32" : `vec${d}f`;
        switch (d) {
          case 1:
            return `${$}(${M}(scale.${v}))`;
          case 2:
            return `vec2<${$}>(${M}(scale[0].${v}, scale[1].${v}))`;
          case 4:
            return `vec4<${$}>(${M}(scale[0].${v}, scale[1].${v}, scale[2].${v}, scale[3].${v}))`;
          default:
            throw new Error(`Not supported compoents ${d}`);
        }
      }, E = O("input", e[0].dataType, e[0].dims, d), A = R("output", e[0].dataType, o, d);
      return `
  @group(0) @binding(0) var<storage, read> input : array<${E.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${T}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${A.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${x.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${I(0)}, ${I(1)});
  }`;
    };
    t.compute({ name: "InstanceNormalizationNHWC", shaderCache: { hint: `${d}`, inputDependencies: m }, getRunData: () => ({ outputs: [{ dims: o, dataType: e[0].dataType }], dispatchGroup: { x: Math.ceil(c / 64) }, programUniforms: p }), getShaderSource: S }, { inputs: [e[0], w] });
  }, Ml = (t, e) => {
    e.format === "NHWC" ? Gg(t, t.inputs, e) : Wg(t, t.inputs, e);
  };
});
var Hg;
var Fg;
var Ul;
var Nl = V(() => {
  J();
  ne();
  ae();
  Hg = (t) => {
    if (!t || t.length < 2)
      throw new Error("layerNorm requires at least 2 inputs.");
  }, Fg = (t, e, r) => {
    let n = e.simplified, o = t[0].dims, i = t[1], s = !n && t[2], u = o, d = k.normalizeAxis(e.axis, o.length), c = k.sizeToDimension(o, d), p = k.sizeFromDimension(o, d), m = k.size(i.dims), g = s ? k.size(s.dims) : 0;
    if (m !== p || s && g !== p)
      throw new Error(`Size of X.shape()[axis:] == ${p}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${m} and bias size of ${g}`);
    let b = [];
    for (let E = 0;E < o.length; ++E)
      E < d ? b.push(o[E]) : b.push(1);
    let y = fe(p), w = ["type", "type"], S = [{ type: 12, data: c }, { type: 1, data: p }, { type: 12, data: Math.floor(p / y) }, { type: 1, data: e.epsilon }];
    s && w.push("type");
    let x = r > 1, $ = r > 2, T = (E) => {
      let A = be(t[0].dataType), z = [O("x", t[0].dataType, t[0].dims, y), O("scale", i.dataType, i.dims, y)];
      s && z.push(O("bias", s.dataType, s.dims, y)), z.push(R("output", t[0].dataType, u, y)), x && z.push(R("mean_data_output", 1, b)), $ && z.push(R("inv_std_output", 1, b));
      let v = [{ name: "norm_count", type: "u32" }, { name: "norm_size", type: "f32" }, { name: "norm_size_vectorized", type: "u32" }, { name: "epsilon", type: "f32" }];
      return `
  ${E.registerUniforms(v).declareVariables(...z)}
  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${ho("f32", y)};
    var mean_square_vector = ${ho("f32", y)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Bt(A, y, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${je("mean_vector", y)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${je("mean_square_vector", y)} / uniforms.norm_size ${n ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Bt(A, y, "x[j + offset]")};
      let f32scale = ${Bt(A, y, "scale[j]")};
      output[j + offset] = ${z[0].type.value}((f32input ${n ? "" : "- mean"}) * inv_std_dev * f32scale
        ${s ? `+ ${Bt(A, y, "bias[j]")}` : ""}
      );
    }

    ${x ? "mean_data_output[global_idx] = mean" : ""};
    ${$ ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
    }, I = [{ dims: u, dataType: t[0].dataType }];
    return x && I.push({ dims: b, dataType: 1 }), $ && I.push({ dims: b, dataType: 1 }), { name: "LayerNormalization", shaderCache: { hint: `${y};${r};${n}`, inputDependencies: w }, getRunData: () => ({ outputs: I, dispatchGroup: { x: Math.ceil(c / 64) }, programUniforms: S }), getShaderSource: T };
  }, Ul = (t, e) => {
    Hg(t.inputs), t.compute(Fg(t.inputs, e, t.outputCount));
  };
});
var qg;
var Vl;
var Ll = V(() => {
  ne();
  an();
  sn();
  qg = (t) => {
    if (!t || t.length !== 2)
      throw new Error("MatMul requires 2 inputs.");
    if (t[0].dims[t[0].dims.length - 1] !== t[1].dims[t[1].dims.length - 2])
      throw new Error("shared dimension does not match.");
  }, Vl = (t) => {
    qg(t.inputs);
    let e = ot.calcShape(t.inputs[0].dims, t.inputs[1].dims, true);
    if (!e)
      throw new Error("Can't use matmul on the given tensors");
    let r = e[e.length - 1], n = t.inputs[0].dims[t.inputs[0].dims.length - 1];
    if (r < 8 && n < 8)
      t.compute(on(t.inputs, { activation: "" }, e));
    else {
      let o = e[e.length - 2], i = k.size(t.inputs[0].dims.slice(0, -2)), s = k.size(t.inputs[1].dims.slice(0, -2));
      if (i !== 1 && o === 1 && s === 1) {
        let u = t.inputs[0].reshape([1, i, n]), d = t.inputs[1].reshape([1, n, r]), c = [1, i, r], p = [u, d];
        t.compute(ir(p, { activation: "" }, e, c), { inputs: p });
      } else
        t.compute(ir(t.inputs, { activation: "" }, e));
    }
  };
});
var Kg;
var jg;
var Zg;
var Wl;
var Gl;
var Hl = V(() => {
  J();
  ne();
  Ie();
  ae();
  Kg = (t, e) => {
    if (t.length < 3 || t.length > 4)
      throw new Error("MatMulNBits requires 3 or 4 inputs");
    let r = t[0], n = r.dims.length;
    if (r.dims[n - 1] !== e.k)
      throw new Error("The last dim of input shape does not match the k value");
    let o = Math.floor((e.k + e.blockSize - 1) / e.blockSize), i = e.blockSize / 8 * e.bits, s = t[1];
    if (!k.areEqual(s.dims, [e.n, o, i]))
      throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
    let d = t[2].dims;
    if (k.size(d) !== e.n * o)
      throw new Error("scales input size error.");
    if (t.length === 4) {
      let p = t[3].dims, m = e.n * (e.bits === 8 ? o : Math.floor((o * e.bits + 7) / 8));
      if (k.size(p) !== m)
        throw new Error("zeroPoints input size error.");
    }
  }, jg = (t, e) => {
    let r = t[0].dims, n = r.length, o = r[n - 2], i = e.k, s = e.n, u = r.slice(0, n - 2), d = k.size(u), p = t[1].dims[2] / 4, m = t[0].dataType, g = fe(e.k), b = fe(p), y = fe(s), w = u.concat([o, s]), S = o > 1 && s / y % 2 === 0 ? 2 : 1, x = k.size(w) / y / S, $ = 64, T = [], I = [d, o, i / g], E = k.convertShape(t[1].dims).slice();
    E.splice(-1, 1, p / b), T.push(...L(I)), T.push(...L(E)), T.push(...L(t[2].dims)), t.length === 4 && T.push(...L(k.convertShape(t[3].dims)));
    let A = [d, o, s / y];
    T.push(...L(A));
    let z = (v) => {
      let M = I.length, N = O("a", t[0].dataType, M, g), K = O("b", 12, E.length, b), q = O("scales", t[2].dataType, t[2].dims.length), Q = [N, K, q], D = t.length === 4 ? O("zero_points", 12, t[3].dims.length) : undefined;
      D && Q.push(D);
      let W = A.length, j = R("output", t[0].dataType, W, y), Y = be(t[0].dataType), Z = (() => {
        switch (g) {
          case 1:
            return `array<${Y}, 8>`;
          case 2:
            return `mat4x2<${Y}>`;
          case 4:
            return `mat2x4<${Y}>`;
          default:
            throw new Error(`${g}-component is not supported.`);
        }
      })(), te = () => {
        let Te = `
          // reuse a data
            var input_offset = ${N.indicesToOffset(`${N.type.indices}(batch, row, word_offset)`)};
            var a_data: ${Z};
            for (var j: u32 = 0; j < ${8 / g}; j++) {
              a_data[j] = ${N.getByOffset("input_offset")};
              input_offset++;
            }
          `;
        for (let re = 0;re < y * S; re++)
          Te += `
            b_value = ${b === 1 ? `b${re}_data` : `b${re}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${Z}(${Array.from({ length: 4 }, (U, X) => `${Y}(b_value_lower[${X}]), ${Y}(b_value_upper[${X}])`).join(", ")});
            b_dequantized_values = ${g === 1 ? `${Z}(${Array.from({ length: 8 }, (U, X) => `(b_quantized_values[${X}] - ${D ? `zero_point${re}` : "zero_point"}) * scale${re}`).join(", ")});` : `(b_quantized_values - ${Z}(${Array(8).fill(`${D ? `zero_point${re}` : "zero_point"}`).join(",")})) * scale${re};`};
            workgroup_shared[local_id.x * ${S} + ${Math.floor(re / y)}]${y > 1 ? `[${re % y}]` : ""} += ${Array.from({ length: 8 / g }, (U, X) => `${g === 1 ? `a_data[${X}] * b_dequantized_values[${X}]` : `dot(a_data[${X}], b_dequantized_values[${X}])`}`).join(" + ")};
          `;
        return Te;
      }, ie = () => {
        let Te = `
            var col_index = col * ${y};
            ${D ? `
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Y}(8);`}
            `;
        for (let re = 0;re < y * S; re++)
          Te += `
            let scale${re} = ${q.getByOffset("col_index * nBlocksPerCol + block")};
            ${D ? `
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${D.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${re} = ${Y}((zero_point_word) & 0xFu);` : ""}
            col_index += 1;`;
        return Te;
      }, we = () => {
        let Te = `col_index = col * ${y};`;
        for (let re = 0;re < y * S; re++)
          Te += `
            let b${re}_data = ${K.getByIndices(`${K.type.indices}(col_index, block, word)`)};
            col_index += 1;`;
        return Te += `
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${Z};
            var b_dequantized_values: ${Z};`, Te;
      };
      return `
        var<workgroup> workgroup_shared: array<${j.type.value}, ${S * $}>;
        ${v.declareVariables(...Q, j)}
        ${v.mainStart([$, 1, 1])}
          let output_indices = ${j.offsetToIndices(`(global_idx / ${$}) * ${S}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${$}) {
            //process one block
            var word_offset: u32 = block * ${e.blockSize / g};
            ${ie()}
            for (var word: u32 = 0; word < ${p}; word += ${b}) {
              ${we()}
              for (var i: u32 = 0; i < ${b}; i++) {
                ${te()}
                word_offset += ${8 / g};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${S}) {
            var output_value: ${j.type.value} = ${j.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${$}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${S};
            }
            ${j.setByIndices(`${j.type.indices}(batch, row, col + local_id.x)`, "output_value")};
          }
        }`;
    };
    return { name: "MatMulNBits", shaderCache: { hint: `${e.blockSize};${e.bits};${g};${b};${y};${S};${$}`, inputDependencies: Array(t.length).fill("rank") }, getRunData: () => ({ outputs: [{ dims: w, dataType: m }], dispatchGroup: { x }, programUniforms: T }), getShaderSource: z };
  }, Zg = (t, e) => {
    let r = t[0].dims, n = r.length, o = r[n - 2], i = e.k, s = e.n, u = r.slice(0, n - 2), d = k.size(u), p = t[1].dims[2] / 4, m = t[0].dataType, g = fe(e.k), b = fe(p), y = u.concat([o, s]), w = 128, S = s % 8 === 0 ? 8 : s % 4 === 0 ? 4 : 1, x = w / S, $ = x * b * 8, T = $ / g, I = $ / e.blockSize, E = k.size(y) / S, A = [], z = [d, o, i / g], v = k.convertShape(t[1].dims).slice();
    v.splice(-1, 1, p / b), A.push(...L(z)), A.push(...L(v)), A.push(...L(t[2].dims)), t.length === 4 && A.push(...L(k.convertShape(t[3].dims)));
    let M = [d, o, s];
    A.push(...L(M));
    let N = (K) => {
      let q = z.length, Q = O("a", t[0].dataType, q, g), D = O("b", 12, v.length, b), W = O("scales", t[2].dataType, t[2].dims.length), j = [Q, D, W], Y = t.length === 4 ? O("zero_points", 12, t[3].dims.length) : undefined;
      Y && j.push(Y);
      let Z = M.length, te = R("output", t[0].dataType, Z), ie = be(t[0].dataType), we = () => {
        switch (g) {
          case 1:
            return `
          let a_data0 = vec4<${ie}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${ie}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;
          case 2:
            return `
          let a_data0 = vec4<${ie}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${ie}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;
          case 4:
            return `
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;
          default:
            throw new Error(`${g}-component is not supported.`);
        }
      };
      return `
        var<workgroup> sub_a: array<${Q.type.value}, ${T}>;
        var<workgroup> inter_results: array<array<${te.type.value}, ${x}>, ${S}>;
        ${K.declareVariables(...j, te)}
        ${K.mainStart([x, S, 1])}
          let output_indices = ${te.offsetToIndices(`workgroup_index * ${S}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${I} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${T};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${T}; a_offset += ${w})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${Q.getByIndices(`${Q.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${Q.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${I} + local_id.x;
            ${Y ? `
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${Y.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${ie}((zero_point_word) & 0xFu);` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${ie}(8);`}
            let scale = ${W.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${D.getByIndices(`${D.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${e.blockSize / g};
            for (var i: u32 = 0; i < ${b}; i++) {
              ${we()}
              let b_value = ${b === 1 ? "b_data" : "b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${ie}>(${Array.from({ length: 4 }, (Te, re) => `${ie}(b_value_lower[${re}]), ${ie}(b_value_upper[${re}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${ie}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({ length: 2 }, (Te, re) => `${`dot(a_data${re}, b_dequantized_values[${re}])`}`).join(" + ")};
              word_offset += ${8 / g};
            }
            workgroupBarrier();
          }

          if (local_idx < ${S}) {
            var output_value: ${te.type.value} = ${te.type.value}(0);
            for (var b = 0u; b < ${x}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${te.setByIndices(`${te.type.indices}(batch, row, col + local_idx)`, "output_value")}
            }
          }
        }`;
    };
    return { name: "BlockwiseMatMulNBits32", shaderCache: { hint: `${e.blockSize};${g};${b};${x};${S}`, inputDependencies: Array(t.length).fill("rank") }, getRunData: () => ({ outputs: [{ dims: y, dataType: m }], dispatchGroup: { x: E }, programUniforms: A }), getShaderSource: N };
  }, Wl = (t, e) => {
    Kg(t.inputs, e), e.blockSize === 32 && t.adapterInfo.isVendor("intel") && t.adapterInfo.isArchitecture("gen-12lp") ? t.compute(Zg(t.inputs, e)) : t.compute(jg(t.inputs, e));
  }, Gl = (t) => ee(t);
});
var Qg;
var Yg;
var Xg;
var Jg;
var ey;
var ty;
var ry;
var ny;
var Fl;
var ql = V(() => {
  J();
  ne();
  ae();
  Qg = (t) => {
    if (!t || t.length < 1)
      throw new Error("Too few inputs");
    if (t[0].dataType !== 1 && t[0].dataType !== 10)
      throw new Error("Input type must be float or float16.");
    if (t.length >= 2) {
      let e = t[0].dims.length * 2 === t[1].dims[0];
      if (t.length === 4 && (e = t[3].dims[0] * 2 === t[1].dims[0]), !e)
        throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
    }
  }, Yg = (t, e, r) => {
    let n = "";
    for (let o = e - 1;o >= 0; --o)
      n += `
            k = i32(${t.indicesGet("indices", o)}) - ${F("uniforms.pads", o, r)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${F("uniforms.x_shape", o, e)})) {
              break;
            }
            offset += k * i32(${F("uniforms.x_strides", o, e)});
        `;
    return `
          value = ${t.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${n}
            value = x[offset];
          }
      `;
  }, Xg = (t, e, r) => {
    let n = "";
    for (let o = e - 1;o >= 0; --o)
      n += `
                k = i32(${t.indicesGet("indices", o)}) - ${F("uniforms.pads", o, r)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${F("uniforms.x_shape", o, e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${F("uniforms.x_shape", o, e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${F("uniforms.x_strides", o, e)});
            `;
    return `
              var offset = 0;
              var k = 0;
              ${n}
              value = x[offset];
          `;
  }, Jg = (t, e, r) => {
    let n = "";
    for (let o = e - 1;o >= 0; --o)
      n += `
                k = i32(${t.indicesGet("indices", o)}) - ${F("uniforms.pads", o, r)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${F("uniforms.x_shape", o, e)})) {
                  k = i32(${F("uniforms.x_shape", o, e)}) - 1;
                }
                offset += k * i32(${F("uniforms.x_strides", o, e)});
            `;
    return `
              var offset = 0;
              var k = 0;
              ${n}
              value = x[offset];
          `;
  }, ey = (t, e, r) => {
    let n = "";
    for (let o = e - 1;o >= 0; --o)
      n += `
                k = i32(${t.indicesGet("indices", o)}) - ${F("uniforms.pads", o, r)};
                if (k < 0)  {
                  k += i32(${F("uniforms.x_shape", o, e)}]);
                }
                if (k >= i32(${F("uniforms.x_shape", o, e)})) {
                  k -= i32(${F("uniforms.x_shape", o, e)});
                }
                offset += k * i32(${F("uniforms.x_strides", o, e)});
            `;
    return `
              var offset = 0;
              var k = 0;
              ${n}
              value = x[offset];
          `;
  }, ty = (t, e, r) => {
    switch (r.mode) {
      case 0:
        return Yg(t, e, r.pads.length);
      case 1:
        return Xg(t, e, r.pads.length);
      case 2:
        return Jg(t, e, r.pads.length);
      case 3:
        return ey(t, e, r.pads.length);
      default:
        throw new Error("Invalid mode");
    }
  }, ry = (t, e) => {
    let r = k.padShape(t[0].dims.slice(), e.pads), n = t[0].dims, o = k.size(r), i = [{ type: 12, data: o }, { type: 6, data: e.pads }], s = t.length >= 3 && t[2].data;
    e.mode === 0 && i.push({ type: s ? t[2].dataType : 1, data: e.value }), i.push(...L(t[0].dims, r));
    let u = ["rank"], d = (c) => {
      let p = R("output", t[0].dataType, r.length), m = O("x", t[0].dataType, n.length), g = m.type.value, b = ty(p, n.length, e), y = [{ name: "output_size", type: "u32" }, { name: "pads", type: "i32", length: e.pads.length }];
      return e.mode === 0 && y.push({ name: "constant_value", type: s ? g : "f32" }), `
            ${c.registerUniforms(y).declareVariables(m, p)}
            ${c.mainStart()}
            ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${p.offsetToIndices("global_idx")};

            var value = ${g}(0);
            ${b}
            output[global_idx] = value;
        }`;
    };
    return { name: "Pad", shaderCache: { hint: `${e.mode}${s}`, inputDependencies: u }, getRunData: () => ({ outputs: [{ dims: r, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(k.size(r) / 64) }, programUniforms: i }), getShaderSource: d };
  }, ny = (t, e) => {
    if (t.length > 1) {
      let r = t[1].getBigInt64Array(), n = t.length >= 3 && t[2].data ? t[2].dataType === 10 ? t[2].getUint16Array()[0] : t[2].getFloat32Array()[0] : 0, o = t[0].dims.length, i = new Int32Array(2 * o).fill(0);
      if (t.length >= 4) {
        let u = t[3].getBigInt64Array();
        for (let d = 0;d < u.length; d++)
          i[Number(u[d])] = Number(r[d]), i[Number(u[d]) + o] = Number(r[d + u.length]);
      } else
        r.forEach((u, d) => i[Number(d)] = Number(u));
      let s = [];
      return i.forEach((u) => s.push(u)), { mode: e.mode, value: n, pads: s };
    } else
      return e;
  }, Fl = (t, e) => {
    Qg(t.inputs);
    let r = ny(t.inputs, e);
    t.compute(ry(t.inputs, r), { inputs: [0] });
  };
});
var cn;
var Kl;
var jl;
var Zl;
var Ql;
var oy;
var iy;
var Yl;
var Xl;
var Jl;
var ec;
var tc;
var rc;
var nc;
var oc;
var ic;
var ac;
var sc;
var uc;
var dc = V(() => {
  Ve();
  J();
  ne();
  ae();
  cn = (t) => {
    if (ye.webgpu.validateInputContent && (!t || t.length !== 1))
      throw new Error("Pool ops requires 1 input.");
  }, Kl = (t, e, r) => {
    let n = e.format === "NHWC", o = t.dims.slice();
    n && o.splice(1, 0, o.pop());
    let i = Object.hasOwnProperty.call(e, "dilations"), s = e.kernelShape.slice(), u = e.strides.slice(), d = i ? e.dilations.slice() : [], c = e.pads.slice();
    zt.adjustPoolAttributes(r, o, s, u, d, c);
    let p = zt.computePoolOutputShape(r, o, u, d, s, c, e.autoPad), m = Object.assign({}, e);
    i ? Object.assign(m, { kernelShape: s, strides: u, pads: c, dilations: d, cacheKey: e.cacheKey }) : Object.assign(m, { kernelShape: s, strides: u, pads: c, cacheKey: e.cacheKey });
    let g = p.slice();
    return g.push(g.splice(1, 1)[0]), [m, n ? g : p];
  }, jl = (t, e) => {
    let r = e.format === "NHWC", n = k.size(t), o = k.size(e.kernelShape), i = [{ type: 12, data: n }, { type: 12, data: o }], s = [{ name: "outputSize", type: "u32" }, { name: "kernelSize", type: "u32" }];
    if (e.kernelShape.length <= 2) {
      let u = e.kernelShape[e.kernelShape.length - 1], d = e.strides[e.strides.length - 1], c = e.pads[e.pads.length / 2 - 1], p = e.pads[e.pads.length - 1], m = !!(c + p);
      i.push({ type: 12, data: u }, { type: 12, data: d }, { type: 12, data: c }, { type: 12, data: p }), s.push({ name: "kw", type: "u32" }, { name: "sw", type: "u32" }, { name: "pwStart", type: "u32" }, { name: "pwEnd", type: "u32" });
      let g = false;
      if (e.kernelShape.length === 2) {
        let b = e.kernelShape[e.kernelShape.length - 2], y = e.strides[e.strides.length - 2], w = e.pads[e.pads.length / 2 - 2], S = e.pads[e.pads.length - 2];
        g = !!(w + S), i.push({ type: 12, data: b }, { type: 12, data: y }, { type: 12, data: w }, { type: 12, data: S }), s.push({ name: "kh", type: "u32" }, { name: "sh", type: "u32" }, { name: "phStart", type: "u32" }, { name: "phEnd", type: "u32" });
      }
      return [i, s, true, m, g];
    } else {
      if (r)
        throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
      let u = k.computeStrides(e.kernelShape);
      i.push({ type: 12, data: u }, { type: 12, data: e.pads }, { type: 12, data: e.strides }), s.push({ name: "kernelStrides", type: "u32", length: u.length }, { name: "pads", type: "u32", length: e.pads.length }, { name: "strides", type: "u32", length: e.strides.length });
      let d = e.pads.reduce((c, p) => c + p);
      return [i, s, !!d, false, false];
    }
  }, Zl = (t, e, r, n, o, i, s, u, d, c, p, m) => {
    let g = o.format === "NHWC", b = e.type.value, y = R("output", e.type.tensor, n);
    if (o.kernelShape.length <= 2) {
      let w = "", S = "", x = "", $ = r - (g ? 2 : 1);
      if (p ? w = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${$}] = indices[${$}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${$}] < 0 || xIndices[${$}]
                      >= uniforms.x_shape[${$}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }` : w = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${$}] = indices[${$}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }`, o.kernelShape.length === 2) {
        let I = r - (g ? 3 : 2);
        m ? S = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${I}] = indices[${I}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${I}] < 0 || xIndices[${I}] >= uniforms.x_shape[${I}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              ` : S = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${I}] = indices[${I}] * uniforms.sh - uniforms.phStart + j;
                `, x = `
              }
            `;
      }
      return `
            ${t.registerUniforms(d).declareVariables(e, y)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${y.offsetToIndices("global_idx")};
              var xIndices = ${y.offsetToIndices("global_idx")};

              var value = ${b}(${u});
              var pad = 0;
              ${S}
              ${w}
              ${x}
              ${s}

              output[global_idx] = value;
            }`;
    } else {
      if (g)
        throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
      let w = o.kernelShape.length, S = o.pads.length, x = "";
      return c ? x = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${i}
              }` : x = `
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${i}
            `, `
            ${t.registerUniforms(d).declareVariables(e, y)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${y.offsetToIndices("global_idx")};
              var xIndices = ${y.offsetToIndices("global_idx")};

              var offsets: array<u32, ${w}>;

              var value = ${b}(${u});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${w - 1}u; j++) {
                  offsets[j] = offset / ${F("uniforms.kernelStrides", "j", w)};
                  offset -= offsets[j] * ${F("uniforms.kernelStrides", "j", w)};
                }
                offsets[${w - 1}] = offset;

                isPad = false;
                for (var j = ${r - w}u; j < ${r}u; j++) {
                  xIndices[j] = indices[j] * ${F("uniforms.strides", `j - ${r - w}u`, w)}
                    + offsets[j - ${r - w}u] - ${F("uniforms.pads", "j - 2u", S)};
                  ${x}
              }
              ${s}

              output[global_idx] = value;
            }`;
    }
  }, Ql = (t) => `${t.format};${t.ceilMode};${t.autoPad};${t.kernelShape.length}`, oy = (t) => `${Ql(t)};${t.countIncludePad}`, iy = (t) => `${Ql(t)};${t.storageOrder};${t.dilations}`, Yl = (t) => ({ format: t.format, autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][t.auto_pad], ceilMode: t.ceil_mode, kernelShape: t.kernel_shape, strides: t.strides, pads: t.pads }), Xl = (t, e, r, n) => {
    let [o, i] = Kl(e, n, r), s = O("x", e.dataType, e.dims.length), u = s.type.value, d = "value += x_val;", c = "";
    o.countIncludePad ? c += `value /= ${u}(uniforms.kernelSize);` : c += `value /= ${u}(i32(uniforms.kernelSize) - pad);`;
    let [p, m, g, b, y] = jl(i, o);
    p.push(...L(e.dims, i));
    let w = ["rank"];
    return { name: t, shaderCache: { hint: `${n.cacheKey};${g};${b};${y}`, inputDependencies: w }, getRunData: () => ({ outputs: [{ dims: i, dataType: e.dataType }], dispatchGroup: { x: Math.ceil(k.size(i) / 64) }, programUniforms: p }), getShaderSource: (S) => Zl(S, s, e.dims.length, i.length, o, d, c, 0, m, g, b, y) };
  }, Jl = (t) => {
    let e = t.count_include_pad !== 0, r = Yl(t);
    if (r.ceilMode !== 0)
      throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
    let n = { countIncludePad: e, ...r, cacheKey: "" };
    return { ...n, cacheKey: oy(n) };
  }, ec = (t, e) => {
    cn(t.inputs), t.compute(Xl("AveragePool", t.inputs[0], false, e));
  }, tc = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [] }, rc = (t) => {
    let e = t.format;
    return { format: e, ...tc, cacheKey: e };
  }, nc = (t, e) => {
    cn(t.inputs), t.compute(Xl("GlobalAveragePool", t.inputs[0], true, e));
  }, oc = (t, e, r, n) => {
    let [o, i] = Kl(e, n, r), s = `
      value = max(x_val, value);
    `, u = "", d = O("x", e.dataType, e.dims.length), c = ["rank"], [p, m, g, b, y] = jl(i, o);
    return p.push(...L(e.dims, i)), { name: t, shaderCache: { hint: `${n.cacheKey};${g};${b};${y}`, inputDependencies: c }, getRunData: () => ({ outputs: [{ dims: i, dataType: e.dataType }], dispatchGroup: { x: Math.ceil(k.size(i) / 64) }, programUniforms: p }), getShaderSource: (w) => Zl(w, d, e.dims.length, i.length, o, s, u, e.dataType === 10 ? -65504 : -1e5, m, g, b, y) };
  }, ic = (t, e) => {
    cn(t.inputs), t.compute(oc("MaxPool", t.inputs[0], false, e));
  }, ac = (t) => {
    let { storage_order: e, dilations: r } = t, n = Yl(t);
    if (e !== 0)
      throw new Error("column major storage order is not yet supported for MaxPool");
    if (n.ceilMode !== 0)
      throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
    let o = { storageOrder: e, dilations: r, ...n, cacheKey: "" };
    return { ...o, cacheKey: iy(o) };
  }, sc = (t) => {
    let e = t.format;
    return { format: e, ...tc, cacheKey: e };
  }, uc = (t, e) => {
    cn(t.inputs), t.compute(oc("GlobalMaxPool", t.inputs[0], true, e));
  };
});
var sy;
var uy;
var lc;
var cc;
var pc = V(() => {
  J();
  ne();
  Ie();
  ae();
  sy = (t, e) => {
    if (t.length < 2 || t.length > 3)
      throw new Error("DequantizeLinear requires 2 or 3 inputs.");
    if (t.length === 3 && t[1].dims === t[2].dims)
      throw new Error("x-scale and x-zero-point must have the same shape.");
    if (t.length === 3 && t[0].dataType !== t[2].dataType)
      throw new Error("x and x-zero-point must have the same data type.");
    if (t[0].dataType === 6 && t.length > 2)
      throw new Error("In the case of dequantizing int32 there is no zero point.");
    if (t[1].dims.length !== 0 && t[1].dims.length !== 1 && t[1].dims.length !== t[0].dims.length)
      throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");
    if (t.length > 2) {
      if (t[0].dataType !== t[2].dataType)
        throw new Error("x and x-zero-point must have the same data type.");
      if (t[1].dims.length !== t[2].dims.length)
        throw new Error("scale and zero-point inputs must have the same rank.");
      if (!t[1].dims.map((r, n) => r === t[2].dims[n]).reduce((r, n) => r && n, true))
        throw new Error("scale and zero-point inputs must have the same shape.");
    }
    if (e.blockSize > 0) {
      if (t[1].dims.length === 0 || t[1].dims.length === 1 && t[1].dims[0] === 1)
        throw new Error("blockSize must be set only for block quantization.");
      if (!t[1].dims.map((o, i) => i === e.axis || o === t[0].dims[i]).reduce((o, i) => o && i, true))
        throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");
      if (t[1].dims.length !== t[0].dims.length)
        throw new Error("For block qunatization the scale input rank must be the same as the x rank.");
      let r = t[0].dims[e.axis], n = t[1].dims[e.axis];
      if (e.blockSize < Math.ceil(r / n) || e.blockSize > Math.ceil(r / (n - 1) - 1))
        throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].");
    }
  }, uy = (t, e) => {
    let r = k.normalizeAxis(e.axis, t[0].dims.length), n = t[0].dataType, o = n === 3, i = t[0].dims, s = t[1].dataType, u = k.size(i), d = n === 3 || n === 2, c = d ? [Math.ceil(k.size(t[0].dims) / 4)] : t[0].dims, p = t[1].dims, m = t.length > 2 ? t[2] : undefined, g = m ? d ? [Math.ceil(k.size(m.dims) / 4)] : m.dims : undefined, b = p.length === 0 || p.length === 1 && p[0] === 1, y = b === false && p.length === 1, w = fe(u), S = b && (!d || w === 4), x = S ? w : 1, $ = S && !d ? w : 1, T = O("input", d ? 12 : n, c.length, $), I = O("scale", s, p.length), E = m ? O("zero_point", d ? 12 : n, g.length) : undefined, A = R("output", s, i.length, x), z = [T, I];
    E && z.push(E);
    let v = [c, p];
    m && v.push(g);
    let M = [{ type: 12, data: u / x }, { type: 12, data: r }, { type: 12, data: e.blockSize }, ...L(...v, i)], N = (K) => {
      let q = [{ name: "output_size", type: "u32" }, { name: "axis", type: "u32" }, { name: "block_size", type: "u32" }];
      return `
      ${K.registerUniforms(q).declareVariables(...z, A)}
      ${K.mainStart()}
          ${K.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${A.offsetToIndices("global_idx")};

          // Set input x
          ${d ? `
            let input = ${T.getByOffset("global_idx / 4")};
            let x_vec = ${o ? "unpack4xI8(input)" : "unpack4xU8(input)"};
            let x_value = ${x === 1 ? "x_vec[global_idx % 4]" : "x_vec"};` : `let x_value = ${T.getByOffset("global_idx")};`};

          // Set scale input
          ${b ? `let scale_value= ${I.getByOffset("0")}` : y ? `
            let scale_index = ${A.indicesGet("output_indices", "uniforms.axis")};
            let scale_value= ${I.getByOffset("scale_index")};` : `
            var scale_indices: ${I.type.indices} = output_indices;
            let index = ${I.indicesGet("scale_indices", "uniforms.axis")} / uniforms.block_size;
            ${I.indicesSet("scale_indices", "uniforms.axis", "index")};
            let scale_value= ${I.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${E ? b ? d ? `
                let zero_point_input = ${E.getByOffset("0")};
                let zero_point_vec =  ${o ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]` : `let zero_point_value = ${E.getByOffset("0")}` : y ? d ? `
                let zero_point_index = ${A.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_input = ${E.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${o ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]` : `
                let zero_point_index = ${A.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_value = ${E.getByOffset("zero_point_index")};` : d ? `
                let zero_point_offset = ${I.indicesToOffset("scale_indices")};
                let zero_point_input = ${E.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${o ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];` : `let zero_point_value = ${E.getByIndices("scale_indices")};` : `let zero_point_value = ${d ? o ? "i32" : "u32" : T.type.value}(0);`};
      // Compute and write output
      ${A.setByOffset("global_idx", `${A.type.value}(x_value - zero_point_value) * scale_value`)};
      }`;
    };
    return { name: "DequantizeLinear", shaderCache: { hint: e.cacheKey, inputDependencies: E ? ["rank", "rank", "rank"] : ["rank", "rank"] }, getShaderSource: N, getRunData: () => ({ outputs: [{ dims: i, dataType: s }], dispatchGroup: { x: Math.ceil(u / x / 64), y: 1, z: 1 }, programUniforms: M }) };
  }, lc = (t, e) => {
    sy(t.inputs, e), t.compute(uy(t.inputs, e));
  }, cc = (t) => ee({ axis: t.axis, blockSize: t.blockSize });
});
var dy;
var ly;
var mc;
var fc = V(() => {
  Ve();
  J();
  ae();
  dy = (t, e, r) => {
    let n = t === e, o = t < e && r < 0, i = t > e && r > 0;
    if (n || o || i)
      throw new Error("Range these inputs' contents are invalid.");
  }, ly = (t, e, r, n) => {
    let o = Math.abs(Math.ceil((e - t) / r)), i = [o], s = o, u = [{ type: 12, data: s }, { type: n, data: t }, { type: n, data: r }, ...L(i)], d = (c) => {
      let p = R("output", n, i.length), m = p.type.value, g = [{ name: "outputSize", type: "u32" }, { name: "start", type: m }, { name: "delta", type: m }];
      return `
        ${c.registerUniforms(g).declareVariables(p)}
        ${c.mainStart()}
        ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${m}(global_idx) * uniforms.delta;
      }`;
    };
    return { name: "Range", shaderCache: { hint: `${n}` }, getShaderSource: d, getRunData: () => ({ outputs: [{ dims: i, dataType: n }], dispatchGroup: { x: Math.ceil(s / 64) }, programUniforms: u }) };
  }, mc = (t) => {
    let e = 0, r = 0, n = 0;
    t.inputs[0].dataType === 6 ? (e = t.inputs[0].getInt32Array()[0], r = t.inputs[1].getInt32Array()[0], n = t.inputs[2].getInt32Array()[0]) : t.inputs[0].dataType === 1 && (e = t.inputs[0].getFloat32Array()[0], r = t.inputs[1].getFloat32Array()[0], n = t.inputs[2].getFloat32Array()[0]), ye.webgpu.validateInputContent && dy(e, r, n), t.compute(ly(e, r, n, t.inputs[0].dataType), { inputs: [] });
  };
});
var cy;
var py;
var hc;
var gc;
var yc = V(() => {
  J();
  ne();
  Ie();
  ae();
  cy = (t, e, r, n) => {
    if (t !== "none" && n !== "i32" && n !== "u32" && n !== "f32")
      throw new Error(`Input ${n} is not supported with reduction ${t}.`);
    let o = `{
                var oldValue = 0;
                loop {
                  let newValueF32 =`, i = `;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${e}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;
    switch (t) {
      case "none":
        return `${e}=${r};`;
      case "add":
        return n === "i32" || n === "u32" ? `atomicAdd(&${e}, bitcast<${n}>(${r}));` : `
              ${o}bitcast<${n}>(oldValue) + (${r})${i}`;
      case "max":
        return n === "i32" || n === "u32" ? `atomicMax(&${e}, bitcast<${n}>(${r}));` : `
                ${o}max(bitcast<f32>(oldValue), (${r}))${i}`;
      case "min":
        return n === "i32" || n === "u32" ? `atomicMin(&${e}, bitcast<${n}>(${r}));` : `${o}min(bitcast<${n}>(oldValue), (${r}))${i}`;
      case "mul":
        return `${o}(bitcast<${n}>(oldValue) * (${r}))${i}`;
      default:
        throw new Error(`Reduction ${t} is not supported.`);
    }
  }, py = (t, e) => {
    let r = t[0].dims, n = t[1].dims, o = r, i = 1, s = Math.ceil(k.sizeToDimension(n, n.length - 1) / i), u = n[n.length - 1], d = k.sizeFromDimension(r, u), c = [{ type: 12, data: s }, { type: 12, data: u }, { type: 12, data: d }, ...L(t[1].dims, t[2].dims, o)], p = (m) => {
      let g = O("indices", t[1].dataType, t[1].dims.length), b = O("updates", t[2].dataType, t[2].dims.length, i), y = e.reduction !== "none" && e.reduction !== "" ? Gs("output", t[0].dataType, o.length) : R("output", t[0].dataType, o.length, i);
      return `
      ${m.registerUniform("output_size", "u32").registerUniform("last_index_dimension", "u32").registerUniform("num_updates_elements", "u32").declareVariables(g, b, y)}
      ${m.mainStart()}
        ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var data_offset = 0u;
  let indices_start = uniforms.last_index_dimension * global_idx;
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${t[0].dims.length === 1 ? `
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;` : `
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${cy(e.reduction, "output[data_offset + i]", "value", y.type.value)}
  }

      }`;
    };
    return { name: "ScatterND", shaderCache: { hint: `${e.cacheKey}_${e.reduction}`, inputDependencies: ["rank", "rank"] }, getRunData: () => ({ outputs: [{ dims: o, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(s / 64) }, programUniforms: c }), getShaderSource: p };
  }, hc = (t) => ee({ reduction: t.reduction }), gc = (t, e) => {
    t.compute(py(t.inputs, e), { inputs: [t.inputs[1], t.inputs[2]], outputs: [] });
  };
});
var my;
var fy;
var hy;
var bc;
var gy;
var yy;
var by;
var wy;
var _y;
var vy;
var $y;
var xy;
var wc;
var Sy;
var Ty;
var Iy;
var Cy;
var Ay;
var _c;
var vc;
var $c = V(() => {
  J();
  ne();
  Ie();
  ae();
  my = (t, e) => {
    if (t.every((r) => r > 0 || (() => {
      throw new Error("Resize requires scales input values to be positive");
    })), t.length > 0) {
      if (e.mode === "linear") {
        if (!(t.length === 2 || t.length === 3 || t.length === 4 && t[0] === 1 && t[1] === 1 || t.length === 4 && t[0] === 1 && t[3] === 1 || t.length === 5 && t[0] === 1 && t[1] === 1))
          throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`);
      } else if (e.mode === "cubic" && !(t.length === 2 || t.length === 4 && t[0] === 1 && t[1] === 1 || t.length === 4 && t[0] === 1 && t[3] === 1))
        throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
    }
  }, fy = (t, e, r) => {
    e.every((o) => o >= 0 && o < r || (() => {
      throw new Error("Resize requires axes input values to be positive and less than rank");
    }));
    let n = new Array(r).fill(1);
    return e.forEach((o, i) => n[o] = t[i]), n;
  }, hy = (t, e, r, n, o, i) => {
    let [s, u, d] = r > 10 ? [1, 2, 3] : [-1, t.length > 1 ? 1 : -1, -1], c = t[0].dims.length;
    if (s > 0 && t.length > s && t[s].dims.length > 0)
      t[s].getFloat32Array().forEach((p) => i.push(p));
    else if (e.coordinateTransformMode === "tf_crop_and_resize")
      throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
    if (u > 0 && t.length > u && t[u].dims.length === 1 && t[u].dims[0] > 0) {
      if (t[u].getFloat32Array().forEach((p) => n.push(p)), n.length !== 0 && n.length !== c && r >= 18 && n.length !== e.axes.length)
        throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");
      my(n, e), e.axes.length > 0 && fy(n, e.axes, c).forEach((p, m) => n[m] = p);
    }
    if (d > 0 && t.length > d && t[d].dims.length === 1 && t[d].dims[0] > 0 && (t[d].getBigInt64Array().forEach((p) => o.push(Number(p))), o.length !== 0 && o.length !== c && r >= 18 && o.length !== e.axes.length))
      throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
    if (e.axes.length > 0) {
      if (n.length !== 0 && n.length !== e.axes.length)
        throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
      if (o.length !== 0 && o.length !== e.axes.length)
        throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified');
    }
    if (typeof n < "u" && typeof o < "u" && n.length > 0 && o.length > c)
      throw new Error("Resize requires only of scales or sizes to be specified");
  }, bc = (t, e, r, n) => `
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${t}) * (${e});
  let whole = ${n}(big / (${r}));
  let fract = ${n}(big % (${r})) / ${n}(${r});
  return whole + fract;
`, gy = (t, e) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { ` + (() => {
    switch (t) {
      case "asymmetric":
        return `
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${e}(xResized) / ${e}(xScale);
          } else {
            ${bc("xResized", "lengthOriginal", "lengthResized", e)}
          }
        `;
      case "pytorch_half_pixel":
        return `if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
      case "tf_half_pixel_for_nn":
        return `return (${e}(xResized) + 0.5) / ${e}(xScale);`;
      case "align_corners":
        return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${bc("xResized", "lengthOriginal - 1", "lengthResized - 1", e)}
                  }`;
      case "tf_crop_and_resize":
        return `if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;
      case "half_pixel_symmetric":
        return `const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;
      case "half_pixel":
        return `return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;
      default:
        throw new Error(`Coordinate transform mode ${t} is not supported`);
    }
  })() + "}", yy = (t, e, r) => `fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {` + (() => {
    switch (t) {
      case "round_prefer_ceil":
        return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
      case "floor":
        return "return floor(xOriginal);";
      case "ceil":
        return "return ceil(xOriginal);";
      case "round_prefer_floor":
        return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
      case "simple":
      default:
        if (e < 11)
          return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
        throw new Error(`Nearest mode ${t} is not supported`);
    }
  })() + "}", by = (t, e, r) => {
    let n = new Array(r).fill(0).concat(new Array(r).fill(1)), o = t.length === 0 ? n : t.slice();
    return e.length > 0 ? (e.forEach((i, s) => {
      n[i] = o[s], n[s + r] = o[e.length + s];
    }), n) : o;
  }, wy = (t, e, r, n) => {
    let o = [];
    if (r.length > 0)
      if (n.length > 0) {
        if (t.forEach((i) => o.push(i)), Math.max(...n) > t.length)
          throw new Error("axes is out of bound");
        n.forEach((i, s) => o[i] = r[s]);
      } else
        r.forEach((i) => o.push(i));
    else {
      if (e.length === 0)
        throw new Error("Resize requires either scales or sizes.");
      o = t.map((i, s) => Math.round(i * e[s]));
    }
    return o;
  }, _y = (t, e, r) => {
    let n = (() => {
      switch (r.keepAspectRatioPolicy) {
        case "not_larger":
          return r.axes.length > 0 ? Math.min(...r.axes.map((i) => e[i]), Number.MAX_VALUE) : Math.min(...e, Number.MAX_VALUE);
        case "not_smaller":
          return r.axes.length > 0 ? Math.max(...r.axes.map((i) => e[i]), Number.MIN_VALUE) : Math.max(...e, Number.MIN_VALUE);
        default:
          throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`);
      }
    })();
    e.fill(1, 0, e.length);
    let o = t.slice();
    return r.axes.length > 0 ? (r.axes.forEach((i) => e[i] = n), r.axes.forEach((i) => o[i] = Math.round(t[i] * e[i]))) : (e.fill(n, 0, e.length), o.forEach((i, s) => o[s] = Math.round(i * e[s]))), o;
  }, vy = (t, e, r, n, o) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> array<${t.type.value}, ${r.length}> {
      var original_indices: array<${t.type.value}, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var output_index = ${t.indicesGet("output_indices", "i")};
        var scale = ${F("uniforms.scales", "i", n)};
        var roi_low = ${F("uniforms.roi", "i", o)};
        var roi_hi = ${F("uniforms.roi", `i + ${e.length}`, o)};
        if (scale == 1.0) {
          original_indices[i] = ${t.type.value}(output_index);
        } else {
          var input_shape_i = ${F("uniforms.input_shape", "i", e.length)};
          var output_shape_i = ${F("uniforms.output_shape", "i", r.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`, $y = (t, e, r, n, o, i, s) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
      var input_indices: ${t.type.indices};
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${e.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${F("uniforms.scales", "i", o)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${F("uniforms.roi", "i", i)};
          var roi_hi = ${F("uniforms.roi", `i + ${r.length}`, i)};
          var input_shape_i = ${F("uniforms.input_shape", "i", r.length)};
          var output_shape_i = ${F("uniforms.output_shape", "i", n.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${s} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${t.indicesSet("input_indices", "i", "input_index")}
      }
      return input_indices;
    }`, xy = (t, e) => `
    fn checkInputIndices(input_indices: ${t.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${t.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${F("uniforms.input_shape", "i", e.length)}) {
          return false;
        }
      }
      return true;
    }`, wc = (t, e, r, n) => t.rank > n ? `
    ${t.indicesSet("input_indices", e, "channel")};
    ${t.indicesSet("input_indices", r, "batch")};
` : "", Sy = (t, e, r, n, o) => {
    let [s, u, d, c] = r.length === 2 ? [-1, 0, 1, -1] : [0, 2, 3, 1], p = t.type.value;
    return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${p} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices", u, `max(0, min(row, ${r[u]} - 1))`)};
      ${t.indicesSet("input_indices", d, `max(0, min(col, ${r[d]} - 1))`)};
      ${wc(t, c, s, 2)}
      return ${t.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${p} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${p} = originalIndices[${u}];
      var col:${p} = originalIndices[${d}];
      ${n ? `if (row < 0 || row > (${r[u]} - 1) || col < 0 || col > (${r[d]} - 1)) {
        return ${o};
      }` : ""};
      row = max(0, min(row, ${r[u]} - 1));
      col = max(0, min(col, ${r[d]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${r.length > 2 ? `u32(originalIndices[${c}])` : "0"};
      var batch: u32 =  ${r.length > 2 ? `u32(originalIndices[${s}])` : "0"};
      var x11: ${p} = getInputValue(batch, channel, row1, col1);
      var x12: ${p} = getInputValue(batch, channel, row1, col2);
      var x21: ${p} = getInputValue(batch, channel, row2, col1);
      var x22: ${p} = getInputValue(batch, channel, row2, col2);
      var dx1: ${p} = abs(row - ${p}(row1));
      var dx2: ${p} = abs(${p}(row2) - row);
      var dy1: ${p} = abs(col - ${p}(col1));
      var dy2: ${p} = abs(${p}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
  }, Ty = (t, e, r, n, o, i, s, u, d, c) => {
    let p = r.length === 2, m = true, [g, b] = p ? [0, 1] : m ? [2, 3] : [1, 2], y = t.type.value, w = (S) => {
      let x = S === g ? "row" : "col";
      return `
      fn ${x}CubicInterpolation(input_indices: ${t.type.indices}, output_indices: ${e.type.indices}) -> ${y} {
        var output_index = ${e.indicesGet("output_indices", S)};
        var originalIdx: ${y} = getOriginalCoordinateFromResizedCoordinate(output_index, ${o[S]},
        ${n[S]}, ${r[S]}, ${i[S]}, ${i[S]} + ${r.length});
        var fractOriginalIdx: ${y} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${u} && (originalIdx < 0 || originalIdx > (${r[S]} - 1))) {
          return ${d};
        }
        var data: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${x}: ${y} = originalIdx + ${y}(i);
          if (${x} < 0 || ${x} >= ${r[S]}) {
            ${c ? `coefs[i + 1] = 0.0;
                        continue;` : u ? `return ${d};` : `${x} = max(0, min(${x}, ${r[S]} - 1));`};
          }
        var input_indices_copy: ${t.type.indices} = input_indices;
          ${t.indicesSet("input_indices_copy", S, `u32(${x})`)};
          data[i + 1] = ${S === g ? t.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
    };
    return `
    ${w(g)};
    ${w(b)};
  fn getCubicInterpolationCoefs(s: ${y}) -> array<${y}, 4> {
    var absS = abs(s);
    var coeffs: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${y} = 1.0 - absS;
    var twoMinusAbsS: ${y} = 2.0 - absS;
    var onePlusAbsS: ${y} = 1.0 + absS;
    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};
    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;
    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${y}, 4>, coefs: array<${y}, 4>) -> ${y} {
    var coefsSum: ${y} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${y} {
    var input_indices: ${t.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
  }, Iy = (t, e, r, n, o) => {
    let [s, u, d, c, p] = r.length === 3 ? [-1, 0, 1, 2, -1] : [0, 2, 3, 4, 1], m = t.type.value;
    return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${m} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices", u, `max(0, min(depth, ${r[u]} - 1))`)};
      ${t.indicesSet("input_indices", d, `max(0, min(height, ${r[d]} - 1))`)};
      ${t.indicesSet("input_indices", c, `max(0, min(width, ${r[c]} - 1))`)};
      ${wc(t, p, s, 3)}
      return ${t.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${m} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${m} = originalIndices[${u}];
      var height:${m} = originalIndices[${d}];
      var width:${m} = originalIndices[${c}];
      ${n ? `if (depth < 0 || depth > (${r[u]} - 1) || height < 0 || height > (${r[d]} - 1) || width < 0 || (width > ${r[c]} - 1)) {
      return ${o};
        }` : ""};

    depth = max(0, min(depth, ${r[u]} - 1));
      height = max(0, min(height, ${r[d]} - 1));
      width = max(0, min(width, ${r[c]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${r.length > 3 ? `u32(originalIndices[${p}])` : "0"};
      var batch: u32 =  ${r.length > 3 ? `u32(originalIndices[${s}])` : "0"};

      var x111: ${m} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${m} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${m} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${m} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${m} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${m} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${m} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${m} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${m} = abs(depth - ${m}(depth1));
      var dx2: ${m} = abs(${m}(depth2) - depth);
      var dy1: ${m} = abs(height - ${m}(height1));
      var dy2: ${m} = abs(${m}(height2) - height);
      var dz1: ${m} = abs(width - ${m}(width1));
      var dz2: ${m} = abs(${m}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
  }, Cy = (t, e, r, n, o, i) => {
    let s = t.dims, u = by(i, e.axes, s.length), d = wy(s, n, o, e.axes), c = n.slice();
    n.length === 0 && (c = s.map(($, T) => $ === 0 ? 1 : d[T] / $), e.keepAspectRatioPolicy !== "stretch" && (d = _y(s, c, e)));
    let p = R("output", t.dataType, d.length), m = O("input", t.dataType, s.length), g = k.size(d), b = s.length === d.length && s.every(($, T) => $ === d[T]), y = e.coordinateTransformMode === "tf_crop_and_resize", w = e.extrapolationValue, S = m.type.value, x = ($) => `
      ${b ? "" : `
      ${gy(e.coordinateTransformMode, S)};
      ${(() => {
      switch (e.mode) {
        case "nearest":
          return `
              ${xy(m, s)};
              ${yy(e.nearestMode, r, S)};
              ${$y(m, p, s, d, c.length, u.length, y)};
              `;
        case "linear":
          return `
              ${vy(p, s, d, c.length, u.length)};
              ${(() => {
            if (s.length === 2 || s.length === 4)
              return `${Sy(m, p, s, y, w)}`;
            if (s.length === 3 || s.length === 5)
              return `${Iy(m, p, s, y, w)}`;
            throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
          })()};
            `;
        case "cubic":
          return `
            ${(() => {
            if (s.length === 2 || s.length === 4)
              return `${Ty(m, p, s, d, c, u, e.cubicCoeffA, y, e.extrapolationValue, e.excludeOutside)}`;
            throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
          })()};
            `;
        default:
          throw Error("Invalid resize mode");
      }
    })()};
      `}
      ${$.registerUniform("output_size", "u32").registerUniform("scales", "f32", c.length).registerUniform("roi", "f32", u.length).declareVariables(m, p)}
      ${$.mainStart()}
        ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${b ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${p.offsetToIndices("global_idx")};
        var input_indices: ${m.type.indices};
        ${(() => {
      switch (e.mode) {
        case "nearest":
          return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${m.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;
        case "linear":
          return `output[global_idx] = ${s.length === 2 || s.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
        case "cubic":
          return "output[global_idx] = bicubicInterpolation(output_indices);";
        default:
          throw Error(`Unsupported resize mode: ${e.mode}`);
      }
    })()};
`}
      }`;
    return { name: "Resize", shaderCache: { hint: `${e.cacheKey}|${r}|${c.length > 0 ? e.mode === "cubic" ? c : c.length : ""}|${o.length > 0 ? o : ""}|${u.length > 0 ? u : ""}|${b}|${e.mode === "nearest" ? s.length : s}`, inputDependencies: ["rank"] }, getShaderSource: x, getRunData: () => ({ outputs: [{ dims: d, dataType: t.dataType }], dispatchGroup: { x: Math.ceil(g / 64) }, programUniforms: [{ type: 12, data: g }, { type: 1, data: c }, { type: 1, data: u }, ...L(s, d)] }) };
  }, Ay = (t) => {
    let e = t.customDataBuffer;
    return new Uint32Array(e, e.byteOffset, 1)[0];
  }, _c = (t, e) => {
    let r = [], n = [], o = [], i = Ay(t);
    if (e.antialias !== 0)
      throw Error("Only default value (0) for Antialias attribute is supported");
    hy(t.inputs, e, i, r, n, o), t.compute(Cy(t.inputs[0], e, i, r, n, o), { inputs: [0] });
  }, vc = (t) => {
    let { antialias: e, axes: r, coordinateTransformMode: n, cubicCoeffA: o } = t, i = t.excludeOutside !== 0, s = t.extrapolationValue, u = t.keepAspectRatioPolicy, d = t.mode, c = t.nearestMode === "" ? "simple" : t.nearestMode;
    return ee({ antialias: e, axes: r, coordinateTransformMode: n, cubicCoeffA: o, excludeOutside: i, extrapolationValue: s, keepAspectRatioPolicy: u, mode: d, nearestMode: c });
  };
});
var Ey;
var ky;
var xc;
var Sc = V(() => {
  J();
  ne();
  ae();
  Ey = (t) => {
    if (!t || t.length < 3)
      throw new Error("layerNorm requires at least 3 inputs.");
    let e = t[0], r = t[1], n = t[2];
    if (e.dataType !== r.dataType || e.dataType !== n.dataType)
      throw new Error("All inputs must have the same data type");
    if (e.dims.length !== 3 && e.dims.length !== 2)
      throw new Error("Input must be 2D or 3D");
    if (r.dims.length !== 3 && r.dims.length !== 2)
      throw new Error("Skip must be 2D or 3D");
    let o = e.dims[e.dims.length - 1], i = e.dims[e.dims.length - 2];
    if (r.dims[r.dims.length - 1] !== o)
      throw new Error("Skip must have the same hidden size as input");
    if (r.dims[r.dims.length - 2] !== i)
      throw new Error("Skip must have the same sequence length as input");
    if (n.dims.length !== 1)
      throw new Error("Gamma must be 1D");
    if (n.dims[n.dims.length - 1] !== o)
      throw new Error("Gamma must have the same hidden size as input");
    if (t.length > 3) {
      let s = t[3];
      if (s.dims.length !== 1)
        throw new Error("Beta must be 1D");
      if (s.dims[s.dims.length - 1] !== o)
        throw new Error("Beta must have the same hidden size as input");
    }
    if (t.length > 4) {
      let s = t[4];
      if (s.dims.length !== 1)
        throw new Error("Bias must be 1D");
      if (s.dims[s.dims.length - 1] !== o)
        throw new Error("Bias must have the same hidden size as input");
    }
  }, ky = (t, e, r, n) => {
    let o = e.simplified, i = t[0].dims, s = k.size(i), u = i, d = s, c = i.slice(-1)[0], p = n ? i.slice(0, -1).concat(1) : [], m = !o && t.length > 3, g = t.length > 4, b = n && r > 1, y = n && r > 2, w = r > 3, S = 64, x = fe(c), $ = [{ type: 12, data: d }, { type: 12, data: x }, { type: 12, data: c }, { type: 1, data: e.epsilon }], T = (E) => {
      let A = [{ name: "output_size", type: "u32" }, { name: "components", type: "u32" }, { name: "hidden_size", type: "u32" }, { name: "epsilon", type: "f32" }], z = [O("x", t[0].dataType, t[0].dims, x), O("skip", t[1].dataType, t[1].dims, x), O("gamma", t[2].dataType, t[2].dims, x)];
      m && z.push(O("beta", t[3].dataType, t[3].dims, x)), g && z.push(O("bias", t[4].dataType, t[4].dims, x)), z.push(R("output", t[0].dataType, u, x)), b && z.push(R("mean_output", 1, p)), y && z.push(R("inv_std_output", 1, p)), w && z.push(R("input_skip_bias_sum", t[0].dataType, u, x));
      let v = be(t[0].dataType), M = be(1, x);
      return `

      ${E.registerUniforms(A).declareVariables(...z)}
      var<workgroup> sum_shared : array<${M}, ${S}>;
      var<workgroup> sum_squared_shared : array<${M}, ${S}>;

      ${E.mainStart([S, 1, 1])}
        let ix = local_id.x;
        let iy = global_id.x / ${S};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${S};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${S - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${g ? "bias[offset1d + i]" : v + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${w ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${Bt(v, x, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${S};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${je("sum", x)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${je("square_sum", x)} / f32(uniforms.hidden_size) ${o ? "" : "- mean * mean"} + uniforms.epsilon);
        ${b ? "mean_output[global_idx] = mean;" : ""}
        ${y ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${o ? "" : `- ${v}(mean)`}) *
            ${v}(inv_std_dev) * gamma[offset1d + i]
            ${m ? "+ beta[offset1d + i]" : ""};
        }
      }`;
    }, I = [{ dims: u, dataType: t[0].dataType }];
    return r > 1 && I.push({ dims: p, dataType: 1 }), r > 2 && I.push({ dims: p, dataType: 1 }), r > 3 && I.push({ dims: i, dataType: t[0].dataType }), { name: "SkipLayerNormalization", shaderCache: { hint: `${x};${b};${y};${w}`, inputDependencies: t.map((E, A) => "type") }, getShaderSource: T, getRunData: () => ({ outputs: I, dispatchGroup: { x: Math.ceil(d / c) }, programUniforms: $ }) };
  }, xc = (t, e) => {
    Ey(t.inputs);
    let n = [0];
    t.outputCount > 1 && n.push(-3), t.outputCount > 2 && n.push(-3), t.outputCount > 3 && n.push(3), t.compute(ky(t.inputs, e, t.outputCount, false), { outputs: n });
  };
});
var Py;
var pn;
var Oy;
var Tc;
var zy;
var Dy;
var Ic;
var Cc;
var Ac = V(() => {
  J();
  ne();
  Ie();
  ae();
  Py = (t, e) => {
    if (!t || t.length < 1)
      throw new Error("too few inputs");
    if (e.axes.length !== 0) {
      if (e.axes.length !== e.starts.length || e.axes.length !== e.ends.length)
        throw new Error("axes, starts and ends must have the same length");
    } else if (e.starts.length !== e.ends.length)
      throw new Error("starts and ends must have the same length");
    t.slice(1).forEach((r, n) => {
      if (t[n + 1].dataType !== 6 && t[n + 1].dataType !== 7)
        throw new Error(`Input ${n} must be an array of int32 or int64`);
    });
  }, pn = (t, e) => {
    let r = [];
    if (t.length > e)
      if (t[e].dataType === 7)
        t[e].getBigInt64Array().forEach((n) => r.push(Number(n)));
      else if (t[e].dataType === 6)
        t[e].getInt32Array().forEach((n) => r.push(Number(n)));
      else
        throw new Error(`Input ${e} must be an array of int32 or int64`);
    return r;
  }, Oy = (t, e) => {
    if (t.length > 1) {
      let r = pn(t, 1), n = pn(t, 2), o = pn(t, 3);
      return o.length === 0 && (o = [...Array(t[0].dims.length).keys()]), ee({ starts: r, ends: n, axes: o });
    } else
      return e;
  }, Tc = (t, e, r, n, o) => {
    let i = t;
    return t < 0 && (i += r[n[e]]), o[e] < 0 ? Math.max(0, Math.min(i, r[n[e]] - 1)) : Math.max(0, Math.min(i, r[n[e]]));
  }, zy = (t, e, r) => `fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
          var input_indices: ${t.type.indices};
          var carry = 0u;
          for (var i = ${r.length - 1}; i >= 0; i--) {
            let input_shape_i = ${F("uniforms.input_shape", "i", r.length)};
            let steps_i = ${F("uniforms.steps", "i", r.length)};
            let signs_i = ${F("uniforms.signs", "i", r.length)};
            let starts_i = ${F("uniforms.starts", "i", r.length)};
            var output_index = ${e.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${t.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`, Dy = (t, e) => {
    let r = t[0].dims, n = k.size(r), o = e.axes.length > 0 ? k.normalizeAxes(e.axes, r.length) : [...Array(r.length).keys()], i = pn(t, 4);
    i.forEach((x) => x !== 0 || (() => {
      throw new Error("step cannot be 0");
    })), i.length === 0 && (i = Array(o.length).fill(1));
    let s = e.starts.map((x, $) => Tc(x, $, r, o, i)), u = e.ends.map((x, $) => Tc(x, $, r, o, i));
    if (o.length !== s.length || o.length !== u.length)
      throw new Error("start, ends and axes should have the same number of elements");
    if (o.length !== r.length)
      for (let x = 0;x < r.length; ++x)
        o.includes(x) || (s.splice(x, 0, 0), u.splice(x, 0, r[x]), i.splice(x, 0, 1));
    let d = i.map((x) => Math.sign(x));
    i.forEach((x, $, T) => {
      if (x < 0) {
        let I = (u[$] - s[$]) / x, E = s[$], A = E + I * i[$];
        s[$] = A, u[$] = E, T[$] = -x;
      }
    });
    let c = r.slice(0);
    o.forEach((x, $) => {
      c[x] = Math.ceil((u[x] - s[x]) / i[x]);
    });
    let p = { dims: c, dataType: t[0].dataType }, m = R("output", t[0].dataType, c.length), g = O("input", t[0].dataType, t[0].dims.length), b = k.size(c), y = [{ name: "outputSize", type: "u32" }, { name: "starts", type: "u32", length: s.length }, { name: "signs", type: "i32", length: d.length }, { name: "steps", type: "u32", length: i.length }], w = [{ type: 12, data: b }, { type: 12, data: s }, { type: 6, data: d }, { type: 12, data: i }, ...L(t[0].dims, c)], S = (x) => `
      ${x.registerUniforms(y).declareVariables(g, m)}
        ${zy(g, m, r)}
        ${x.mainStart()}
          ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${m.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${m.setByOffset("global_idx", g.getByIndices("input_indices"))}
      }`;
    return { name: "Slice", shaderCache: { hint: `${d.length}_${s.length}_${i.length}`, inputDependencies: ["rank"] }, getShaderSource: S, getRunData: () => ({ outputs: [p], dispatchGroup: { x: Math.ceil(n / 64) }, programUniforms: w }) };
  }, Ic = (t, e) => {
    Py(t.inputs, e);
    let r = Oy(t.inputs, e);
    t.compute(Dy(t.inputs, r), { inputs: [0] });
  }, Cc = (t) => {
    let { starts: e, ends: r, axes: n } = t;
    return ee({ starts: e, ends: r, axes: n });
  };
});
var By;
var My;
var Ec;
var kc;
var Pc = V(() => {
  J();
  ne();
  Ie();
  pt();
  ae();
  By = (t) => {
    if (!t || t.length !== 1)
      throw new Error("Softmax op requires 1 input.");
  }, My = (t, e) => {
    let r = t.inputs[0], n = r.dims, o = k.size(n), i = n.length, s = k.normalizeAxis(e.axis, i), u = s < n.length - 1, d, c = [];
    u ? (c = Array.from({ length: i }, (z, v) => v), c[s] = i - 1, c[i - 1] = s, d = t.compute(Oe(r, c), { inputs: [r], outputs: [-1] })[0]) : d = r;
    let p = d.dims, m = p[i - 1], g = o / m, b = fe(m), y = m / b, w = 64;
    g === 1 && (w = 256);
    let S = (z, v) => v === 4 ? `max(max(${z}.x, ${z}.y), max(${z}.z, ${z}.w))` : v === 2 ? `max(${z}.x, ${z}.y)` : v === 3 ? `max(max(${z}.x, ${z}.y), ${z}.z)` : z, x = O("x", d.dataType, d.dims, b), $ = R("result", d.dataType, d.dims, b), T = x.type.value, I = be(d.dataType) === "f32" ? `var threadMax = ${T}(-3.4028234663852886e+38f);` : `var threadMax = ${T}(-65504.0h);`, E = (z) => `
      var<workgroup> rowMaxShared : ${T};
      var<workgroup> rowSumShared : ${T};
      var<workgroup> threadShared : array<${T}, ${w}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${T} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${T}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${z.registerUniform("packedCols", "i32").declareVariables(x, $)}
      ${z.mainStart(w)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${w};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${I}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${T}(${S("threadShared[0]", b)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${T}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${T}(${je("threadShared[0]", b)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          // max operation protects against NaN since all values should be >=0
          value = max(value, ${T}(0.0));
          setValue(row, col, row_stride, value);
        }
      }`, A = t.compute({ name: "Softmax", shaderCache: { hint: `${b};${w}`, inputDependencies: ["type"] }, getRunData: () => ({ outputs: [{ dims: p, dataType: d.dataType }], dispatchGroup: { x: g }, programUniforms: [{ type: 6, data: y }] }), getShaderSource: E }, { inputs: [d], outputs: [u ? -1 : 0] })[0];
    u && t.compute(Oe(A, c), { inputs: [A] });
  }, Ec = (t, e) => {
    By(t.inputs), My(t, e);
  }, kc = (t) => ee({ axis: t.axis });
});
var Oc;
var Ry;
var Uy;
var Ny;
var zc;
var Dc = V(() => {
  J();
  ne();
  ae();
  Oc = (t) => Array.from(t.getBigInt64Array(), Number), Ry = (t) => {
    if (!t || t.length !== 2)
      throw new Error("Tile requires 2 inputs.");
    if (t[0].dataType !== 1 && t[0].dataType !== 10 && t[0].dataType !== 6 && t[0].dataType !== 12)
      throw new Error("Tile only support float, float16, int32, and uint32 data types");
    if (t[1].dataType !== 7)
      throw new Error("Tile `repeats` input should be of int64 data type");
    if (t[1].dims.length !== 1)
      throw new Error("Tile `repeats` input should be 1-D");
    if (Oc(t[1]).length !== t[0].dims.length)
      throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
  }, Uy = (t, e) => {
    let r = [];
    for (let n = 0;n < t.length; ++n)
      r.push(t[n] * e[n]);
    return r;
  }, Ny = (t, e) => {
    let r = t[0].dims, n = e ?? Oc(t[1]), o = Uy(r, n), i = k.size(o), s = t[0].dataType, u = O("input", s, r.length), d = R("output", s, o.length), c = (p) => `
      const inputShape = ${u.indices(...r)};
      ${p.registerUniform("output_size", "u32").declareVariables(u, d)}
      ${p.mainStart()}
      ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${d.offsetToIndices("global_idx")};
      var input_indices: ${u.type.indices};
      for (var i = 0; i < ${r.length}; i++) {
        let input_dim_i = ${u.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${d.indicesGet("output_indices", "i")}  % input_dim_i;

        ${u.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${d.setByOffset("global_idx", u.getByIndices("input_indices"))}
    }`;
    return { name: "Tile", shaderCache: { hint: `${n}`, inputDependencies: ["rank"] }, getRunData: () => ({ outputs: [{ dims: o, dataType: t[0].dataType }], dispatchGroup: { x: Math.ceil(i / 64) }, programUniforms: [{ type: 12, data: i }, ...L(t[0].dims, o)] }), getShaderSource: c };
  }, zc = (t) => {
    Ry(t.inputs), t.compute(Ny(t.inputs), { inputs: [0] });
  };
});
var Vy;
var Ly;
var Bc;
var Mc = V(() => {
  J();
  ne();
  ae();
  Vy = (t, e, r, n, o) => {
    let i = R("output_data", o, r.length, 4), s = O("a_data", e[1].dataType, e[1].dims.length, 4), u = O("b_data", e[2].dataType, e[2].dims.length, 4), d = O("c_data", e[0].dataType, e[0].dims.length, 4), c, p = (m, g, b) => `select(${g}, ${m}, ${b})`;
    if (!n)
      c = i.setByOffset("global_idx", p(s.getByOffset("global_idx"), u.getByOffset("global_idx"), d.getByOffset("global_idx")));
    else {
      let m = (g, b, y = "") => {
        let w = `a_data[index_a${b}][component_a${b}]`, S = `b_data[index_b${b}][component_b${b}]`, x = `bool(c_data[index_c${b}] & (0xffu << (component_c${b} * 8)))`;
        return `
            let output_indices${b} = ${i.offsetToIndices(`global_idx * 4u + ${b}u`)};
            let offset_a${b} = ${s.broadcastedIndicesToOffset(`output_indices${b}`, i)};
            let offset_b${b} = ${u.broadcastedIndicesToOffset(`output_indices${b}`, i)};
            let offset_c${b} = ${d.broadcastedIndicesToOffset(`output_indices${b}`, i)};
            let index_a${b} = offset_a${b} / 4u;
            let index_b${b} = offset_b${b} / 4u;
            let index_c${b} = offset_c${b} / 4u;
            let component_a${b} = offset_a${b} % 4u;
            let component_b${b} = offset_b${b} % 4u;
            let component_c${b} = offset_c${b} % 4u;
            ${g}[${b}] = ${y}(${p(w, S, x)});
          `;
      };
      o === 9 ? c = `
            var data = vec4<u32>(0);
            ${m("data", 0, "u32")}
            ${m("data", 1, "u32")}
            ${m("data", 2, "u32")}
            ${m("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));` : c = `
            ${m("output_data[global_idx]", 0)}
            ${m("output_data[global_idx]", 1)}
            ${m("output_data[global_idx]", 2)}
            ${m("output_data[global_idx]", 3)}
          `;
    }
    return `
        ${t.registerUniform("vec_size", "u32").declareVariables(d, s, u, i)}
        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${c}
      }`;
  }, Ly = (t) => {
    let e = t[1].dims, r = t[2].dims, n = t[0].dims, o = t[1].dataType, i = !(k.areEqual(e, r) && k.areEqual(r, n)), s = e, u = k.size(e);
    if (i) {
      let c = ot.calcShape(ot.calcShape(e, r, false), n, false);
      if (!c)
        throw new Error("Can't perform where op on the given tensors");
      s = c, u = k.size(s);
    }
    let d = Math.ceil(u / 4);
    return { name: "Where", shaderCache: { inputDependencies: ["rank", "rank", "rank"] }, getShaderSource: (c) => Vy(c, t, s, i, o), getRunData: () => ({ outputs: [{ dims: s, dataType: o }], dispatchGroup: { x: Math.ceil(u / 64 / 4) }, programUniforms: [{ type: 12, data: d }, ...L(n, e, r, s)] }) };
  }, Bc = (t) => {
    t.compute(Ly(t.inputs));
  };
});
var Rc;
var Uc = V(() => {
  bu();
  Jr();
  vu();
  xu();
  ud();
  wd();
  $d();
  Ud();
  Fd();
  jd();
  Yd();
  rl();
  il();
  sl();
  ll();
  ml();
  gl();
  wl();
  $l();
  Tl();
  Dl();
  Rl();
  Nl();
  Ll();
  Hl();
  ko();
  ql();
  dc();
  pc();
  fc();
  yc();
  Yr();
  $c();
  zo();
  Sc();
  Ac();
  Pc();
  Oo();
  Dc();
  pt();
  tn();
  Mc();
  Rc = new Map([["Abs", [Su]], ["Acos", [Tu]], ["Acosh", [Iu]], ["Add", [dd]], ["ArgMax", [yu, yo]], ["ArgMin", [gu, yo]], ["Asin", [Cu]], ["Asinh", [Au]], ["Atan", [Eu]], ["Atanh", [ku]], ["Attention", [wu]], ["AveragePool", [ec, Jl]], ["BatchNormalization", [_u]], ["BiasAdd", [$u]], ["BiasSplitGelu", [sd]], ["Cast", [Ou, Pu]], ["Ceil", [Du]], ["Clip", [zu]], ["Concat", [_d, vd]], ["Conv", [Io, To]], ["ConvTranspose", [Hd, Wd]], ["Cos", [Bu]], ["Cosh", [Mu]], ["CumSum", [qd, Kd]], ["DepthToSpace", [Zd, Qd]], ["DequantizeLinear", [lc, cc]], ["Div", [ld]], ["Einsum", [el, tl]], ["Elu", [Ru, nr]], ["Equal", [cd]], ["Erf", [Uu]], ["Exp", [Nu]], ["Expand", [ol]], ["FastGelu", [al]], ["Floor", [Vu]], ["FusedConv", [Io, To]], ["Gather", [dl, ul]], ["GatherElements", [bl, yl]], ["GatherBlockQuantized", [fl, hl]], ["GatherND", [cl, pl]], ["Gelu", [Lu]], ["Gemm", [vl, _l]], ["GlobalAveragePool", [nc, rc]], ["GlobalMaxPool", [uc, sc]], ["Greater", [hd]], ["GreaterOrEqual", [yd]], ["GridSample", [xl, Sl]], ["GroupQueryAttention", [zl]], ["HardSigmoid", [Zu, ju]], ["InstanceNormalization", [Ml]], ["LayerNormalization", [Ul]], ["LeakyRelu", [Wu, nr]], ["Less", [gd]], ["LessOrEqual", [bd]], ["Log", [od]], ["MatMul", [Vl]], ["MatMulNBits", [Wl, Gl]], ["MaxPool", [ic, ac]], ["Mul", [pd]], ["MultiHeadAttention", [Al, Cl]], ["Neg", [Hu]], ["Not", [Gu]], ["Pad", [Fl]], ["Pow", [md]], ["QuickGelu", [id, nr]], ["Range", [mc]], ["Reciprocal", [Fu]], ["ReduceMin", [lu]], ["ReduceMean", [iu]], ["ReduceMax", [du]], ["ReduceSum", [pu]], ["ReduceProd", [cu]], ["ReduceL1", [au]], ["ReduceL2", [su]], ["ReduceLogSum", [fu]], ["ReduceLogSumExp", [uu]], ["ReduceSumSquare", [mu]], ["Relu", [qu]], ["Resize", [_c, vc]], ["RotaryEmbedding", [Pl]], ["ScatterND", [gc, hc]], ["Sigmoid", [Ku]], ["Sin", [Qu]], ["Sinh", [Yu]], ["Slice", [Ic, Cc]], ["SkipLayerNormalization", [xc]], ["Split", [El, kl]], ["Sqrt", [Xu]], ["Softmax", [Ec, kc]], ["Sub", [fd]], ["Tan", [Ju]], ["Tanh", [td]], ["ThresholdedRelu", [nd, nr]], ["Tile", [zc]], ["Transpose", [qs, Ks]], ["Where", [Bc]]]);
});
var mn;
var Nc = V(() => {
  Ve();
  nt();
  ae();
  mn = class {
    constructor(e) {
      this.backend = e;
      this.repo = new Map, this.attributesBound = false;
    }
    getArtifact(e) {
      return this.repo.get(e);
    }
    setArtifact(e, r) {
      this.repo.set(e, r);
    }
    run(e, r, n, o, i) {
      Ne(e.programInfo.name);
      let s = this.backend.device, u = this.backend.getComputePassEncoder();
      this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
      let d = [];
      for (let p of r)
        d.push({ binding: d.length, resource: { buffer: p.buffer } });
      for (let p of n)
        d.push({ binding: d.length, resource: { buffer: p.buffer } });
      i && d.push({ binding: d.length, resource: i });
      let c = s.createBindGroup({ layout: e.computePipeline.getBindGroupLayout(0), entries: d, label: e.programInfo.name });
      if (this.backend.sessionStatus === "capturing") {
        let p = { kernelId: this.backend.currentKernelId, computePipeline: e.computePipeline, bindGroup: c, dispatchGroup: o };
        this.backend.capturedCommandList.get(this.backend.currentSessionId).push(p);
      }
      u.setPipeline(e.computePipeline), u.setBindGroup(0, c), u.dispatchWorkgroups(...o), this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1), this.backend.pendingDispatchNumber++, (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") && this.backend.endComputePass(), this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber && this.backend.flush(), Me(e.programInfo.name);
    }
    dispose() {}
    build(e, r) {
      Ne(e.name);
      let n = this.backend.device, o = [];
      [{ feature: "shader-f16", extension: "f16" }, { feature: "subgroups", extension: "subgroups" }].forEach((m) => {
        n.features.has(m.feature) && o.push(`enable ${m.extension};`);
      });
      let s = Hs(r, this.backend.device.limits), u = e.getShaderSource(s), d = `${o.join(`
`)}
${s.additionalImplementations}
${u}`, c = n.createShaderModule({ code: d, label: e.name });
      se("verbose", () => `[WebGPU] ${e.name} shader code: ${d}`);
      let p = n.createComputePipeline({ compute: { module: c, entryPoint: "main" }, layout: "auto", label: e.name });
      return Me(e.name), { programInfo: e, computePipeline: p, uniformVariablesInfo: s.variablesInfo };
    }
    normalizeDispatchGroupSize(e) {
      let r = typeof e == "number" ? e : e.x, n = typeof e == "number" ? 1 : e.y || 1, o = typeof e == "number" ? 1 : e.z || 1, i = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
      if (r <= i && n <= i && o <= i)
        return [r, n, o];
      let s = r * n * o, u = Math.ceil(Math.sqrt(s));
      if (u > i) {
        if (u = Math.ceil(Math.cbrt(s)), u > i)
          throw new Error("Total dispatch size exceeds WebGPU maximum.");
        return [u, u, u];
      } else
        return [u, u, 1];
    }
  };
});
var Vc = {};
Vt(Vc, { WebGpuBackend: () => Bo });
var Wy;
var Gy;
var Do;
var Bo;
var Lc = V(() => {
  Ve();
  J();
  nt();
  oo();
  Ws();
  Uc();
  Nc();
  Wy = (t, e) => {
    if (e.length !== t.length)
      throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${t.length}.`);
    let r = [];
    for (let n = 0;n < t.length; ++n) {
      let o = t[n].dataType;
      switch (e[n]) {
        case "none": {
          r.push("");
          break;
        }
        case "type": {
          r.push(`${o}`);
          break;
        }
        case "rank": {
          let i = t[n].dims.length;
          r.push(`${o};${i}`);
          break;
        }
        case "dims": {
          let i = t[n].dims.join(",");
          r.push(`${o};${i}`);
          break;
        }
        default:
          throw new Error(`unsupported input dependency: ${e[n]}`);
      }
    }
    return r.join("|");
  }, Gy = (t, e, r) => {
    let n = t.name;
    return t.shaderCache?.hint && (n += "[" + t.shaderCache.hint + "]"), n += ":" + r + `:${Wy(e, t.shaderCache?.inputDependencies ?? new Array(e.length).fill("dims"))}`, n;
  }, Do = class {
    constructor(e) {
      e && (this.architecture = e.architecture, this.vendor = e.vendor);
    }
    isArchitecture(e) {
      return this.architecture === e;
    }
    isVendor(e) {
      return this.vendor === e;
    }
  }, Bo = class {
    constructor() {
      this.currentSessionId = null;
      this.currentKernelId = null;
      this.commandEncoder = null;
      this.computePassEncoder = null;
      this.maxDispatchNumber = 16;
      this.pendingDispatchNumber = 0;
      this.pendingKernels = [];
      this.pendingQueries = new Map;
      this.sessionStatus = "default";
      this.capturedCommandList = new Map;
      this.capturedPendingKernels = new Map;
      this.sessionExternalDataMapping = new Map;
    }
    get currentKernelCustomData() {
      if (this.currentKernelId === null)
        throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
      let e = this.kernelCustomData.get(this.currentKernelId);
      return e || (e = {}, this.kernelCustomData.set(this.currentKernelId, e)), e;
    }
    async initialize(e, r) {
      this.env = e;
      let n = [], o = { requiredLimits: { maxComputeWorkgroupStorageSize: r.limits.maxComputeWorkgroupStorageSize, maxComputeWorkgroupsPerDimension: r.limits.maxComputeWorkgroupsPerDimension, maxStorageBufferBindingSize: r.limits.maxStorageBufferBindingSize, maxBufferSize: r.limits.maxBufferSize, maxComputeInvocationsPerWorkgroup: r.limits.maxComputeInvocationsPerWorkgroup, maxComputeWorkgroupSizeX: r.limits.maxComputeWorkgroupSizeX, maxComputeWorkgroupSizeY: r.limits.maxComputeWorkgroupSizeY, maxComputeWorkgroupSizeZ: r.limits.maxComputeWorkgroupSizeZ }, requiredFeatures: n }, i = (s) => r.features.has(s) && n.push(s) && true;
      i("chromium-experimental-timestamp-query-inside-passes") || i("timestamp-query"), i("shader-f16"), i("subgroups"), this.device = await r.requestDevice(o), this.adapterInfo = new Do(r.info || await r.requestAdapterInfo()), this.gpuDataManager = Ls(this), this.programManager = new mn(this), this.kernels = new Map, this.kernelPersistentData = new Map, this.kernelCustomData = new Map, Lr(e.logLevel, !!e.debug), this.device.onuncapturederror = (s) => {
        s.error instanceof GPUValidationError && console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`);
      }, Object.defineProperty(this.env.webgpu, "device", { value: this.device, writable: false, enumerable: true, configurable: false }), Object.defineProperty(this.env.webgpu, "adapter", { value: r, writable: false, enumerable: true, configurable: false }), this.setQueryType();
    }
    dispose() {
      typeof this.querySet < "u" && this.querySet.destroy(), this.gpuDataManager.dispose();
    }
    getCommandEncoder() {
      return this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder()), this.commandEncoder;
    }
    getComputePassEncoder() {
      if (!this.computePassEncoder) {
        let e = this.getCommandEncoder(), r = {};
        this.queryType === "at-passes" && (r.timestampWrites = { querySet: this.querySet, beginningOfPassWriteIndex: this.pendingDispatchNumber * 2, endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1 }), this.computePassEncoder = e.beginComputePass(r);
      }
      return this.computePassEncoder;
    }
    endComputePass() {
      this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);
    }
    flush() {
      if (!this.commandEncoder)
        return;
      Ne(), this.endComputePass();
      let e;
      this.queryType !== "none" && (this.commandEncoder.resolveQuerySet(this.querySet, 0, this.pendingDispatchNumber * 2, this.queryResolveBuffer, 0), e = this.device.createBuffer({ size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }), this.pendingQueries.set(e, this.pendingKernels), this.pendingKernels = [], this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, e, 0, this.pendingDispatchNumber * 2 * 8)), this.device.queue.submit([this.commandEncoder.finish()]), this.gpuDataManager.refreshPendingBuffers(), this.commandEncoder = null, this.pendingDispatchNumber = 0, this.queryType !== "none" && e.mapAsync(GPUMapMode.READ).then(() => {
        let r = new BigUint64Array(e.getMappedRange()), n = this.pendingQueries.get(e);
        for (let o = 0;o < r.length / 2; o++) {
          let i = n[o], s = i.kernelId, u = this.kernels.get(s), d = u.kernelType, c = u.kernelName, p = i.programName, m = i.inputTensorViews, g = i.outputTensorViews, b = r[o * 2], y = r[o * 2 + 1];
          typeof this.queryTimeBase > "u" && (this.queryTimeBase = b);
          let w = Number(b - this.queryTimeBase), S = Number(y - this.queryTimeBase);
          if (!Number.isSafeInteger(w) || !Number.isSafeInteger(S))
            throw new RangeError("incorrect timestamp range");
          if (this.env.webgpu.profiling?.ondata)
            this.env.webgpu.profiling.ondata({ version: 1, inputsMetadata: m.map((x) => ({ dims: x.dims, dataType: rt(x.dataType) })), outputsMetadata: g.map((x) => ({ dims: x.dims, dataType: rt(x.dataType) })), kernelId: s, kernelType: d, kernelName: c, programName: p, startTime: w, endTime: S });
          else {
            let x = "";
            m.forEach((T, I) => {
              x += `input[${I}]: [${T.dims}] | ${rt(T.dataType)}, `;
            });
            let $ = "";
            g.forEach((T, I) => {
              $ += `output[${I}]: [${T.dims}] | ${rt(T.dataType)}, `;
            }), console.log(`[profiling] kernel "${s}|${d}|${c}|${p}" ${x}${$}start time: ${w} ns, execution time: ${S - w} ns`);
          }
          Sr("GPU", `${p}::${b}::${y}`);
        }
        e.unmap(), this.pendingQueries.delete(e);
      }), Me();
    }
    run(e, r, n, o, i, s) {
      Ne(e.name);
      let u = [];
      for (let T = 0;T < r.length; ++T) {
        let I = r[T].data;
        if (I === 0)
          continue;
        let E = this.gpuDataManager.get(I);
        if (!E)
          throw new Error(`no GPU data for input: ${I}`);
        u.push(E);
      }
      let { outputs: d, dispatchGroup: c, programUniforms: p } = e.getRunData(r), m = n.length === 0 ? d.map((T, I) => I) : n;
      if (m.length !== d.length)
        throw new Error(`Output size ${m.length} must be equal to ${d.length}.`);
      let g = [], b = [];
      for (let T = 0;T < d.length; ++T) {
        if (!Number.isInteger(m[T]) || m[T] < -3 || m[T] >= s)
          throw new Error(`Invalid output index: ${m[T]}`);
        if (m[T] === -3)
          continue;
        let I = m[T] === -1, E = m[T] === -2, A = I || E ? i(d[T].dataType, d[T].dims) : o(m[T], d[T].dataType, d[T].dims);
        if (g.push(A), A.data === 0)
          continue;
        let z = this.gpuDataManager.get(A.data);
        if (!z)
          throw new Error(`no GPU data for output: ${A.data}`);
        if (I && this.temporaryData.push(z), E) {
          let v = this.kernelPersistentData.get(this.currentKernelId);
          v || (v = [], this.kernelPersistentData.set(this.currentKernelId, v)), v.push(z);
        }
        b.push(z);
      }
      if (u.length !== r.length || b.length !== g.length) {
        if (b.length === 0)
          return Me(e.name), g;
        throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`);
      }
      let y;
      if (p) {
        let T = 0, I = [];
        p.forEach((v) => {
          let M = typeof v.data == "number" ? [v.data] : v.data;
          if (M.length === 0)
            return;
          let N = v.type === 10 ? 2 : 4, K, q;
          v.type === 10 ? (q = M.length > 4 ? 16 : M.length > 2 ? 8 : M.length * N, K = M.length > 4 ? 16 : N * M.length) : (q = M.length <= 2 ? M.length * N : 16, K = 16), T = Math.ceil(T / q) * q, I.push(T);
          let Q = v.type === 10 ? 8 : 4;
          T += M.length > 4 ? Math.ceil(M.length / Q) * K : M.length * N;
        });
        let E = 16;
        T = Math.ceil(T / E) * E;
        let A = new ArrayBuffer(T);
        p.forEach((v, M) => {
          let N = I[M], K = typeof v.data == "number" ? [v.data] : v.data;
          if (v.type === 6)
            new Int32Array(A, N, K.length).set(K);
          else if (v.type === 12)
            new Uint32Array(A, N, K.length).set(K);
          else if (v.type === 10)
            new Uint16Array(A, N, K.length).set(K);
          else if (v.type === 1)
            new Float32Array(A, N, K.length).set(K);
          else
            throw new Error(`Unsupported uniform type: ${rt(v.type)}`);
        });
        let z = this.gpuDataManager.create(T, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
        this.device.queue.writeBuffer(z.buffer, 0, A, 0, T), this.gpuDataManager.release(z.id), y = { offset: 0, size: T, buffer: z.buffer };
      }
      let w = this.programManager.normalizeDispatchGroupSize(c), S = w[1] === 1 && w[2] === 1, x = Gy(e, r, S), $ = this.programManager.getArtifact(x);
      if ($ || ($ = this.programManager.build(e, w), this.programManager.setArtifact(x, $), se("info", () => `[artifact] key: ${x}, programName: ${e.name}`)), p && $.uniformVariablesInfo) {
        if (p.length !== $.uniformVariablesInfo.length)
          throw new Error(`Uniform variables count mismatch: expect ${$.uniformVariablesInfo.length}, got ${p.length} in program "${$.programInfo.name}".`);
        for (let T = 0;T < p.length; T++) {
          let I = p[T], E = I.type, A = typeof I.data == "number" ? 1 : I.data.length, [z, v] = $.uniformVariablesInfo[T];
          if (E !== z || A !== v)
            throw new Error(`Uniform variable ${T} mismatch: expect type ${z} with size ${v}, got type ${E} with size ${A} in program "${$.programInfo.name}".`);
        }
      }
      if (se("info", () => `[ProgramManager] run "${e.name}" (key=${x}) with ${w[0]}x${w[1]}x${w[2]}`), this.queryType !== "none" || this.sessionStatus === "capturing") {
        let T = { kernelId: this.currentKernelId, programName: $.programInfo.name, inputTensorViews: r, outputTensorViews: g };
        this.pendingKernels.push(T), this.sessionStatus === "capturing" && this.capturedPendingKernels.get(this.currentSessionId).push(T);
      }
      return this.programManager.run($, u, b, w, y), Me(e.name), g;
    }
    upload(e, r) {
      this.gpuDataManager.upload(e, r);
    }
    memcpy(e, r) {
      this.gpuDataManager.memcpy(e, r);
    }
    async download(e, r) {
      await this.gpuDataManager.download(e, r);
    }
    alloc(e) {
      return this.gpuDataManager.create(e).id;
    }
    free(e) {
      return this.gpuDataManager.release(e);
    }
    createKernel(e, r, n, o) {
      let i = Rc.get(e);
      if (!i)
        throw new Error(`kernel not implemented: ${e}`);
      let s = { kernelType: e, kernelName: o, kernelEntry: i[0], attributes: [i[1], n] };
      this.kernels.set(r, s);
    }
    releaseKernel(e) {
      let r = this.kernelPersistentData.get(e);
      if (r) {
        for (let n of r)
          this.gpuDataManager.release(n.id);
        this.kernelPersistentData.delete(e);
      }
      this.kernelCustomData.delete(e), this.kernels.delete(e);
    }
    computeKernel(e, r, n) {
      let o = this.kernels.get(e);
      if (!o)
        throw new Error(`kernel not created: ${e}`);
      let { kernelType: i, kernelName: s, kernelEntry: u, attributes: d } = o;
      if (this.currentKernelId !== null)
        throw new Error(`kernel "[${i}] ${s}" is not allowed to be called recursively`);
      this.currentKernelId = e, d[0] && (d[1] = d[0](d[1]), d[0] = undefined), se("info", () => `[WebGPU] Start to run kernel "[${i}] ${s}"...`);
      let c = this.env.debug;
      this.temporaryData = [];
      try {
        return c && this.device.pushErrorScope("validation"), u(r, d[1]), 0;
      } catch (p) {
        return n.push(Promise.resolve(`[WebGPU] Kernel "[${i}] ${s}" failed. ${p}`)), 1;
      } finally {
        c && n.push(this.device.popErrorScope().then((p) => p ? `GPU validation error for kernel "[${i}] ${s}": ${p.message}` : null));
        for (let p of this.temporaryData)
          this.gpuDataManager.release(p.id);
        this.temporaryData = [], this.currentKernelId = null;
      }
    }
    registerBuffer(e, r, n, o) {
      let i = this.sessionExternalDataMapping.get(e);
      i || (i = new Map, this.sessionExternalDataMapping.set(e, i));
      let s = i.get(r), u = this.gpuDataManager.registerExternalBuffer(n, o, s);
      return i.set(r, [u, n]), u;
    }
    unregisterBuffers(e) {
      let r = this.sessionExternalDataMapping.get(e);
      r && (r.forEach((n) => this.gpuDataManager.unregisterExternalBuffer(n[0])), this.sessionExternalDataMapping.delete(e));
    }
    getBuffer(e) {
      let r = this.gpuDataManager.get(e);
      if (!r)
        throw new Error(`no GPU data for buffer: ${e}`);
      return r.buffer;
    }
    createDownloader(e, r, n) {
      return async () => {
        let o = await co(this, e, r);
        return Gr(o.buffer, n);
      };
    }
    writeTimestamp(e) {
      this.queryType === "inside-passes" && this.computePassEncoder.writeTimestamp(this.querySet, e);
    }
    setQueryType() {
      this.queryType = "none", (this.env.webgpu.profiling?.mode === "default" || (typeof this.env.trace > "u" ? this.env.wasm.trace : this.env.trace)) && (this.device.features.has("chromium-experimental-timestamp-query-inside-passes") ? this.queryType = "inside-passes" : this.device.features.has("timestamp-query") && (this.queryType = "at-passes"), this.queryType !== "none" && typeof this.querySet > "u" && (this.querySet = this.device.createQuerySet({ type: "timestamp", count: this.maxDispatchNumber * 2 }), this.queryResolveBuffer = this.device.createBuffer({ size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE })));
    }
    captureBegin() {
      se("info", "captureBegin"), this.capturedCommandList.get(this.currentSessionId) || this.capturedCommandList.set(this.currentSessionId, []), this.capturedPendingKernels.get(this.currentSessionId) || this.capturedPendingKernels.set(this.currentSessionId, []), this.flush(), this.sessionStatus = "capturing";
    }
    captureEnd() {
      se("info", "captureEnd"), this.flush(), this.sessionStatus = "default";
    }
    replay() {
      se("info", "replay"), this.sessionStatus = "replaying";
      let e = this.capturedCommandList.get(this.currentSessionId), r = this.capturedPendingKernels.get(this.currentSessionId), n = e.length;
      this.pendingKernels = [];
      for (let o = 0;o < n; o++) {
        let i = this.getComputePassEncoder(), s = e[o];
        this.writeTimestamp(this.pendingDispatchNumber * 2), i.setPipeline(s.computePipeline), i.setBindGroup(0, s.bindGroup), i.dispatchWorkgroups(...s.dispatchGroup), this.writeTimestamp(this.pendingDispatchNumber * 2 + 1), this.pendingDispatchNumber++, this.queryType !== "none" && this.pendingKernels.push(r[o]), (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") && this.endComputePass(), this.pendingDispatchNumber >= this.maxDispatchNumber && this.flush();
      }
      this.flush(), this.sessionStatus = "default";
    }
    onCreateSession() {
      this.gpuDataManager.onCreateSession();
    }
    onReleaseSession(e) {
      this.unregisterBuffers(e), this.capturedCommandList.has(e) && this.capturedCommandList.delete(e), this.capturedPendingKernels.has(e) && this.capturedPendingKernels.delete(e), this.gpuDataManager.onReleaseSession(e);
    }
    onRunStart(e) {
      this.currentSessionId = e, this.setQueryType();
    }
  };
});
var Wc = {};
Vt(Wc, { init: () => Hy });
var sr;
var Mo;
var Hy;
var Gc = V(() => {
  J();
  nt();
  ne();
  Rs();
  sr = class t {
    constructor(e, r, n, o) {
      this.module = e;
      this.dataType = r;
      this.data = n;
      this.dims = o;
    }
    getFloat32Array() {
      if (this.dataType !== 1)
        throw new Error("Invalid data type");
      let e = k.size(this.dims);
      return e === 0 ? new Float32Array : new Float32Array(this.module.HEAP8.buffer, this.data, e);
    }
    getBigInt64Array() {
      if (this.dataType !== 7)
        throw new Error("Invalid data type");
      let e = k.size(this.dims);
      return e === 0 ? new BigInt64Array : new BigInt64Array(this.module.HEAP8.buffer, this.data, e);
    }
    getInt32Array() {
      if (this.dataType !== 6)
        throw new Error("Invalid data type");
      let e = k.size(this.dims);
      return e === 0 ? new Int32Array : new Int32Array(this.module.HEAP8.buffer, this.data, e);
    }
    getUint16Array() {
      if (this.dataType !== 10 && this.dataType !== 4)
        throw new Error("Invalid data type");
      let e = k.size(this.dims);
      return e === 0 ? new Uint16Array : new Uint16Array(this.module.HEAP8.buffer, this.data, e);
    }
    reshape(e) {
      if (k.size(e) !== k.size(this.dims))
        throw new Error("Invalid new shape");
      return new t(this.module, this.dataType, this.data, e);
    }
  }, Mo = class {
    constructor(e, r, n) {
      this.module = e;
      this.backend = r;
      this.customDataOffset = 0;
      this.customDataSize = 0;
      this.adapterInfo = r.adapterInfo;
      let o = e.PTR_SIZE, i = n / e.PTR_SIZE, s = o === 4 ? "i32" : "i64";
      this.opKernelContext = Number(e.getValue(o * i++, s));
      let u = Number(e.getValue(o * i++, s));
      this.outputCount = Number(e.getValue(o * i++, s)), this.customDataOffset = Number(e.getValue(o * i++, "*")), this.customDataSize = Number(e.getValue(o * i++, s));
      let d = [];
      for (let c = 0;c < u; c++) {
        let p = Number(e.getValue(o * i++, s)), m = Number(e.getValue(o * i++, "*")), g = Number(e.getValue(o * i++, s)), b = [];
        for (let y = 0;y < g; y++)
          b.push(Number(e.getValue(o * i++, s)));
        d.push(new sr(e, p, m, b));
      }
      this.inputs = d;
    }
    get kernelCustomData() {
      return this.backend.currentKernelCustomData;
    }
    get customDataBuffer() {
      return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
    }
    compute(e, r) {
      let n = r?.inputs?.map((u) => typeof u == "number" ? this.inputs[u] : u) ?? this.inputs, o = r?.outputs ?? [], i = (u, d, c) => new sr(this.module, d, this.output(u, c), c), s = (u, d) => {
        let c = xt(u, d);
        if (!c)
          throw new Error(`Unsupported data type: ${u}`);
        let p = c > 0 ? this.backend.gpuDataManager.create(c).id : 0;
        return new sr(this.module, u, p, d);
      };
      return this.backend.run(e, n, o, i, s, this.outputCount);
    }
    output(e, r) {
      let n = this.module.stackSave();
      try {
        let o = this.module.PTR_SIZE, i = o === 4 ? "i32" : "i64", s = this.module.stackAlloc((1 + r.length) * o);
        this.module.setValue(s, r.length, i);
        for (let u = 0;u < r.length; u++)
          this.module.setValue(s + o * (u + 1), r[u], i);
        return this.module._JsepOutput(this.opKernelContext, e, s);
      } catch (o) {
        throw new Error(`Failed to generate kernel's output[${e}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`);
      } finally {
        this.module.stackRestore(n);
      }
    }
  }, Hy = async (t, e, r, n) => {
    let o = e.jsepInit;
    if (!o)
      throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
    if (t === "webgpu") {
      let i = (Lc(), Yt(Vc)).WebGpuBackend, s = new i;
      await s.initialize(r, n), o("webgpu", [s, (u) => s.alloc(Number(u)), (u) => s.free(u), (u, d, c, p = false) => {
        if (p)
          se("verbose", () => `[WebGPU] jsepCopyGpuToGpu: src=${Number(u)}, dst=${Number(d)}, size=${Number(c)}`), s.memcpy(Number(u), Number(d));
        else {
          se("verbose", () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(u)}, gpuDataId=${Number(d)}, size=${Number(c)}`);
          let m = e.HEAPU8.subarray(Number(u >>> 0), Number(u >>> 0) + Number(c));
          s.upload(Number(d), m);
        }
      }, async (u, d, c) => {
        se("verbose", () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${u}, dataOffset=${d}, size=${c}`), await s.download(Number(u), () => e.HEAPU8.subarray(Number(d) >>> 0, Number(d + c) >>> 0));
      }, (u, d, c) => s.createKernel(u, Number(d), c, e.UTF8ToString(e._JsepGetNodeName(Number(d)))), (u) => s.releaseKernel(u), (u, d, c, p) => {
        se("verbose", () => `[WebGPU] jsepRun: sessionHandle=${c}, kernel=${u}, contextDataOffset=${d}`);
        let m = new Mo(e, s, Number(d));
        return s.computeKernel(Number(u), m, p);
      }, () => s.captureBegin(), () => s.captureEnd(), () => s.replay()]);
    } else {
      let i = new Kr(r);
      o("webnn", [i, () => i.reserveTensorId(), (s) => i.releaseTensorId(s), async (s, u, d, c, p) => i.ensureTensor(s, u, d, c, p), (s, u) => {
        i.uploadTensor(s, u);
      }, async (s, u) => i.downloadTensor(s, u), (s, u) => i.registerMLContext(s, u), !!r.trace]);
    }
  };
});
var Fy;
var Er;
var kr;
var Mt;
var qy;
var Hc;
var Jt;
var Pr;
var Or;
var Fc;
var zr;
var Dr;
var Br;
var Qn = V(() => {
  Ve();
  Ss();
  Is();
  J();
  vt();
  Rr();
  ro();
  Fy = (t, e) => {
    ge()._OrtInit(t, e) !== 0 && me("Can't initialize onnxruntime.");
  }, Er = async (t) => {
    Fy(t.wasm.numThreads, tr(t.logLevel));
  }, kr = async (t, e) => {
    ge().asyncInit?.();
    let r = t.webgpu.adapter;
    if (e === "webgpu") {
      if (typeof navigator > "u" || !navigator.gpu)
        throw new Error("WebGPU is not supported in current environment");
      if (r) {
        if (typeof r.limits != "object" || typeof r.features != "object" || typeof r.requestDevice != "function")
          throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
      } else {
        let n = t.webgpu.powerPreference;
        if (n !== undefined && n !== "low-power" && n !== "high-performance")
          throw new Error(`Invalid powerPreference setting: "${n}"`);
        let o = t.webgpu.forceFallbackAdapter;
        if (o !== undefined && typeof o != "boolean")
          throw new Error(`Invalid forceFallbackAdapter setting: "${o}"`);
        if (r = await navigator.gpu.requestAdapter({ powerPreference: n, forceFallbackAdapter: o }), !r)
          throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.');
      }
    }
    if (e === "webnn" && (typeof navigator > "u" || !navigator.ml))
      throw new Error("WebNN is not supported in current environment");
    {
      let n = (Gc(), Yt(Wc)).init;
      e === "webgpu" && await n("webgpu", ge(), t, r), e === "webnn" && await n("webnn", ge(), t);
    }
  }, Mt = new Map, qy = (t) => {
    let e = ge(), r = e.stackSave();
    try {
      let n = e.PTR_SIZE, o = e.stackAlloc(2 * n);
      e._OrtGetInputOutputCount(t, o, o + n) !== 0 && me("Can't get session input/output count.");
      let s = n === 4 ? "i32" : "i64";
      return [Number(e.getValue(o, s)), Number(e.getValue(o + n, s))];
    } finally {
      e.stackRestore(r);
    }
  }, Hc = (t, e) => {
    let r = ge(), n = r.stackSave(), o = 0;
    try {
      let i = r.PTR_SIZE, s = r.stackAlloc(2 * i);
      r._OrtGetInputOutputMetadata(t, e, s, s + i) !== 0 && me("Can't get session input/output metadata.");
      let d = Number(r.getValue(s, "*"));
      o = Number(r.getValue(s + i, "*"));
      let c = r.HEAP32[o / 4];
      if (c === 0)
        return [d, 0];
      let p = r.HEAPU32[o / 4 + 1], m = [];
      for (let g = 0;g < p; g++) {
        let b = Number(r.getValue(o + 8 + g * i, "*"));
        m.push(b !== 0 ? r.UTF8ToString(b) : Number(r.getValue(o + 8 + (g + p) * i, "*")));
      }
      return [d, c, m];
    } finally {
      r.stackRestore(n), o !== 0 && r._OrtFree(o);
    }
  }, Jt = (t) => {
    let e = ge(), r = e._malloc(t.byteLength);
    if (r === 0)
      throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);
    return e.HEAPU8.set(t, r), [r, t.byteLength];
  }, Pr = async (t, e) => {
    let r, n, o = ge();
    Array.isArray(t) ? [r, n] = t : t.buffer === o.HEAPU8.buffer ? [r, n] = [t.byteOffset, t.byteLength] : [r, n] = Jt(t);
    let i = 0, s = 0, u = 0, d = [], c = [], p = [];
    try {
      if ([s, d] = await Ts(e), e?.externalData && o.mountExternalData) {
        let I = [];
        for (let E of e.externalData) {
          let A = typeof E == "string" ? E : E.path;
          I.push(rr(typeof E == "string" ? E : E.data).then((z) => {
            o.mountExternalData(A, z);
          }));
        }
        await Promise.all(I);
      }
      for (let I of e?.executionProviders ?? [])
        if ((typeof I == "string" ? I : I.name) === "webnn") {
          if (o.shouldTransferToMLTensor = false, typeof I != "string") {
            let A = I, z = A?.context, v = A?.gpuDevice, M = A?.deviceType, N = A?.powerPreference;
            z ? o.currentContext = z : v ? o.currentContext = await o.webnnCreateMLContext(v) : o.currentContext = await o.webnnCreateMLContext({ deviceType: M, powerPreference: N });
          } else
            o.currentContext = await o.webnnCreateMLContext();
          break;
        }
      i = await o._OrtCreateSession(r, n, s), o.webgpuOnCreateSession?.(i), i === 0 && me("Can't create a session."), o.jsepOnCreateSession?.(), o.currentContext && (o.webnnRegisterMLContext(i, o.currentContext), o.currentContext = undefined, o.shouldTransferToMLTensor = true);
      let [m, g] = qy(i), b = !!e?.enableGraphCapture, y = [], w = [], S = [], x = [], $ = [];
      for (let I = 0;I < m; I++) {
        let [E, A, z] = Hc(i, I);
        E === 0 && me("Can't get an input name."), c.push(E);
        let v = o.UTF8ToString(E);
        y.push(v), S.push(A === 0 ? { name: v, isTensor: false } : { name: v, isTensor: true, type: rt(A), shape: z });
      }
      for (let I = 0;I < g; I++) {
        let [E, A, z] = Hc(i, I + m);
        E === 0 && me("Can't get an output name."), p.push(E);
        let v = o.UTF8ToString(E);
        w.push(v), x.push(A === 0 ? { name: v, isTensor: false } : { name: v, isTensor: true, type: rt(A), shape: z });
        {
          if (b && e?.preferredOutputLocation === undefined) {
            $.push("gpu-buffer");
            continue;
          }
          let M = typeof e?.preferredOutputLocation == "string" ? e.preferredOutputLocation : e?.preferredOutputLocation?.[v] ?? "cpu", N = o.webnnIsGraphOutput;
          if (M === "cpu" && N && N(i, v)) {
            $.push("ml-tensor-cpu-output");
            continue;
          }
          if (M !== "cpu" && M !== "cpu-pinned" && M !== "gpu-buffer" && M !== "ml-tensor")
            throw new Error(`Not supported preferred output location: ${M}.`);
          if (b && M !== "gpu-buffer")
            throw new Error(`Not supported preferred output location: ${M}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);
          $.push(M);
        }
      }
      let T = null;
      return $.some((I) => I === "gpu-buffer" || I === "ml-tensor" || I === "ml-tensor-cpu-output") && (u = o._OrtCreateBinding(i), u === 0 && me("Can't create IO binding."), T = { handle: u, outputPreferredLocations: $, outputPreferredLocationsEncoded: $.map((I) => I === "ml-tensor-cpu-output" ? "ml-tensor" : I).map((I) => to(I)) }), Mt.set(i, [i, c, p, T, b, false]), [i, y, w, S, x];
    } catch (m) {
      throw c.forEach((g) => o._OrtFree(g)), p.forEach((g) => o._OrtFree(g)), u !== 0 && o._OrtReleaseBinding(u) !== 0 && me("Can't release IO binding."), i !== 0 && o._OrtReleaseSession(i) !== 0 && me("Can't release session."), m;
    } finally {
      o._free(r), s !== 0 && o._OrtReleaseSessionOptions(s) !== 0 && me("Can't release session options."), d.forEach((m) => o._free(m)), o.unmountExternalData?.();
    }
  }, Or = (t) => {
    let e = ge(), r = Mt.get(t);
    if (!r)
      throw new Error(`cannot release session. invalid session id: ${t}`);
    let [n, o, i, s, u] = r;
    s && (u && e._OrtClearBoundOutputs(s.handle) !== 0 && me("Can't clear bound outputs."), e._OrtReleaseBinding(s.handle) !== 0 && me("Can't release IO binding.")), e.jsepOnReleaseSession?.(t), e.webnnOnReleaseSession?.(t), e.webgpuOnReleaseSession?.(t), o.forEach((d) => e._OrtFree(d)), i.forEach((d) => e._OrtFree(d)), e._OrtReleaseSession(n) !== 0 && me("Can't release session."), Mt.delete(t);
  }, Fc = async (t, e, r, n, o, i, s = false) => {
    if (!t) {
      e.push(0);
      return;
    }
    let u = ge(), d = u.PTR_SIZE, c = t[0], p = t[1], m = t[3], g = m, b, y;
    if (c === "string" && (m === "gpu-buffer" || m === "ml-tensor"))
      throw new Error("String tensor is not supported on GPU.");
    if (s && m !== "gpu-buffer")
      throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);
    if (m === "gpu-buffer") {
      let x = t[2].gpuBuffer;
      y = xt($t(c), p);
      {
        let $ = u.jsepRegisterBuffer;
        if (!$)
          throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
        b = $(n, i, x, y);
      }
    } else if (m === "ml-tensor") {
      let x = t[2].mlTensor;
      y = xt($t(c), p);
      let $ = u.webnnRegisterMLTensor;
      if (!$)
        throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
      b = $(n, x, $t(c), p);
    } else {
      let x = t[2];
      if (Array.isArray(x)) {
        y = d * x.length, b = u._malloc(y), r.push(b);
        for (let $ = 0;$ < x.length; $++) {
          if (typeof x[$] != "string")
            throw new TypeError(`tensor data at index ${$} is not a string`);
          u.setValue(b + $ * d, We(x[$], r), "*");
        }
      } else {
        let { webnnIsGraphInput: $, webnnIsGraphOutput: T } = u;
        if (c !== "string" && $ && T) {
          let I = u.UTF8ToString(o);
          if ($(n, I) || T(n, I)) {
            let E = $t(c);
            y = xt(E, p), g = "ml-tensor";
            let { webnnCreateTemporaryTensor: A, webnnUploadTensor: z } = u;
            if (!A || !z)
              throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
            let v = await A(n, E, p);
            z(v, new Uint8Array(x.buffer, x.byteOffset, x.byteLength)), b = v;
          } else
            y = x.byteLength, b = u._malloc(y), r.push(b), u.HEAPU8.set(new Uint8Array(x.buffer, x.byteOffset, y), b);
        } else
          y = x.byteLength, b = u._malloc(y), r.push(b), u.HEAPU8.set(new Uint8Array(x.buffer, x.byteOffset, y), b);
      }
    }
    let w = u.stackSave(), S = u.stackAlloc(4 * p.length);
    try {
      p.forEach(($, T) => u.setValue(S + T * d, $, d === 4 ? "i32" : "i64"));
      let x = u._OrtCreateTensor($t(c), b, y, S, p.length, to(g));
      x === 0 && me(`Can't create tensor for input/output. session=${n}, index=${i}.`), e.push(x);
    } finally {
      u.stackRestore(w);
    }
  }, zr = async (t, e, r, n, o, i) => {
    let s = ge(), u = s.PTR_SIZE, d = Mt.get(t);
    if (!d)
      throw new Error(`cannot run inference. invalid session id: ${t}`);
    let c = d[0], p = d[1], m = d[2], g = d[3], b = d[4], y = d[5], w = e.length, S = n.length, x = 0, $ = [], T = [], I = [], E = [], A = [], z = s.stackSave(), v = s.stackAlloc(w * u), M = s.stackAlloc(w * u), N = s.stackAlloc(S * u), K = s.stackAlloc(S * u);
    try {
      [x, $] = xs(i), wt("wasm prepareInputOutputTensor");
      for (let W = 0;W < w; W++)
        await Fc(r[W], T, E, t, p[e[W]], e[W], b);
      for (let W = 0;W < S; W++)
        await Fc(o[W], I, E, t, m[n[W]], w + n[W], b);
      _t("wasm prepareInputOutputTensor");
      for (let W = 0;W < w; W++)
        s.setValue(v + W * u, T[W], "*"), s.setValue(M + W * u, p[e[W]], "*");
      for (let W = 0;W < S; W++)
        s.setValue(N + W * u, I[W], "*"), s.setValue(K + W * u, m[n[W]], "*");
      if (g && !y) {
        let { handle: W, outputPreferredLocations: j, outputPreferredLocationsEncoded: Y } = g;
        if (p.length !== w)
          throw new Error(`input count from feeds (${w}) is expected to be always equal to model's input count (${p.length}).`);
        wt("wasm bindInputsOutputs");
        for (let Z = 0;Z < w; Z++) {
          let te = e[Z];
          await s._OrtBindInput(W, p[te], T[Z]) !== 0 && me(`Can't bind input[${Z}] for session=${t}.`);
        }
        for (let Z = 0;Z < S; Z++) {
          let te = n[Z];
          o[Z]?.[3] ? (A.push(I[Z]), s._OrtBindOutput(W, m[te], I[Z], 0) !== 0 && me(`Can't bind pre-allocated output[${Z}] for session=${t}.`)) : s._OrtBindOutput(W, m[te], 0, Y[te]) !== 0 && me(`Can't bind output[${Z}] to ${j[Z]} for session=${t}.`);
        }
        _t("wasm bindInputsOutputs"), Mt.set(t, [c, p, m, g, b, true]);
      }
      s.jsepOnRunStart?.(c), s.webnnOnRunStart?.(c);
      let q;
      g ? q = await s._OrtRunWithBinding(c, g.handle, S, N, x) : q = await s._OrtRun(c, M, v, w, K, S, N, x), q !== 0 && me("failed to call OrtRun().");
      let Q = [], D = [];
      wt("wasm ProcessOutputTensor");
      for (let W = 0;W < S; W++) {
        let j = Number(s.getValue(N + W * u, "*"));
        if (j === I[W] || A.includes(I[W])) {
          Q.push(o[W]), j !== I[W] && s._OrtReleaseTensor(j) !== 0 && me("Can't release tensor.");
          continue;
        }
        let Y = s.stackSave(), Z = s.stackAlloc(4 * u), te = false, ie, we = 0;
        try {
          s._OrtGetTensorData(j, Z, Z + u, Z + 2 * u, Z + 3 * u) !== 0 && me(`Can't access output tensor data on index ${W}.`);
          let re = u === 4 ? "i32" : "i64", U = Number(s.getValue(Z, re));
          we = s.getValue(Z + u, "*");
          let X = s.getValue(Z + u * 2, "*"), Se = Number(s.getValue(Z + u * 3, re)), Be = [];
          for (let Ce = 0;Ce < Se; Ce++)
            Be.push(Number(s.getValue(X + Ce * u, re)));
          s._OrtFree(X) !== 0 && me("Can't free memory for tensor dims.");
          let ze = Be.reduce((Ce, $e) => Ce * $e, 1);
          ie = rt(U);
          let Xe = g?.outputPreferredLocations[n[W]];
          if (ie === "string") {
            if (Xe === "gpu-buffer" || Xe === "ml-tensor")
              throw new Error("String tensor is not supported on GPU.");
            let Ce = [];
            for (let $e = 0;$e < ze; $e++) {
              let Fe = s.getValue(we + $e * u, "*"), Ue = s.getValue(we + ($e + 1) * u, "*"), ve = $e === ze - 1 ? undefined : Ue - Fe;
              Ce.push(s.UTF8ToString(Fe, ve));
            }
            Q.push([ie, Be, Ce, "cpu"]);
          } else if (Xe === "gpu-buffer" && ze > 0) {
            let Ce = s.jsepGetBuffer;
            if (!Ce)
              throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
            let $e = Ce(we), Fe = xt(U, ze);
            if (Fe === undefined || !Nr(ie))
              throw new Error(`Unsupported data type: ${ie}`);
            te = true, Q.push([ie, Be, { gpuBuffer: $e, download: s.jsepCreateDownloader($e, Fe, ie), dispose: () => {
              s._OrtReleaseTensor(j) !== 0 && me("Can't release tensor.");
            } }, "gpu-buffer"]);
          } else if (Xe === "ml-tensor" && ze > 0) {
            let { webnnEnsureTensor: Ce, webnnIsGraphInputOutputTypeSupported: $e } = s;
            if (!Ce || !$e)
              throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
            if (xt(U, ze) === undefined || !Vr(ie))
              throw new Error(`Unsupported data type: ${ie}`);
            if (!$e(t, ie, false))
              throw new Error(`preferredLocation "ml-tensor" for ${ie} output is not supported by current WebNN Context.`);
            let Ue = await Ce(t, we, U, Be, false);
            te = true, Q.push([ie, Be, { mlTensor: Ue, download: s.webnnCreateMLTensorDownloader(we, ie), dispose: () => {
              s.webnnReleaseTensorId(we), s._OrtReleaseTensor(j);
            } }, "ml-tensor"]);
          } else if (Xe === "ml-tensor-cpu-output" && ze > 0) {
            let Ce = s.webnnCreateMLTensorDownloader(we, ie)(), $e = Q.length;
            te = true, D.push((async () => {
              let Fe = [$e, await Ce];
              return s.webnnReleaseTensorId(we), s._OrtReleaseTensor(j), Fe;
            })()), Q.push([ie, Be, [], "cpu"]);
          } else {
            let Ce = Lt(ie), $e = new Ce(ze);
            new Uint8Array($e.buffer, $e.byteOffset, $e.byteLength).set(s.HEAPU8.subarray(we, we + $e.byteLength)), Q.push([ie, Be, $e, "cpu"]);
          }
        } finally {
          s.stackRestore(Y), ie === "string" && we && s._free(we), te || s._OrtReleaseTensor(j);
        }
      }
      g && !b && (s._OrtClearBoundOutputs(g.handle) !== 0 && me("Can't clear bound outputs."), Mt.set(t, [c, p, m, g, b, false]));
      for (let [W, j] of await Promise.all(D))
        Q[W][2] = j;
      return _t("wasm ProcessOutputTensor"), Q;
    } finally {
      s.webnnOnRunEnd?.(c), s.stackRestore(z), T.forEach((q) => s._OrtReleaseTensor(q)), I.forEach((q) => s._OrtReleaseTensor(q)), E.forEach((q) => s._free(q)), x !== 0 && s._OrtReleaseRunOptions(x), $.forEach((q) => s._free(q));
    }
  }, Dr = (t) => {
    let e = ge(), r = Mt.get(t);
    if (!r)
      throw new Error("invalid session id");
    let n = r[0], o = e._OrtEndProfiling(n);
    o === 0 && me("Can't get an profile file name."), e._OrtFree(o);
  }, Br = (t) => {
    let e = [];
    for (let r of t) {
      let n = r[2];
      !Array.isArray(n) && "buffer" in n && e.push(n.buffer);
    }
    return e;
  };
});
var Rt;
var He;
var ur;
var hn;
var gn;
var fn;
var Ro;
var Uo;
var Ft;
var qt;
var jy;
var qc;
var Kc;
var jc;
var Zc;
var Qc;
var Yc;
var Xc;
var No = V(() => {
  Ve();
  Qn();
  vt();
  Cr();
  Rt = () => !!ye.wasm.proxy && typeof document < "u", ur = false, hn = false, gn = false, Uo = new Map, Ft = (t, e) => {
    let r = Uo.get(t);
    r ? r.push(e) : Uo.set(t, [e]);
  }, qt = () => {
    if (ur || !hn || gn || !He)
      throw new Error("worker not ready");
  }, jy = (t) => {
    switch (t.data.type) {
      case "init-wasm":
        ur = false, t.data.err ? (gn = true, Ro[1](t.data.err)) : (hn = true, Ro[0]()), fn && (URL.revokeObjectURL(fn), fn = undefined);
        break;
      case "init-ep":
      case "copy-from":
      case "create":
      case "release":
      case "run":
      case "end-profiling": {
        let e = Uo.get(t.data.type);
        t.data.err ? e.shift()[1](t.data.err) : e.shift()[0](t.data.out);
        break;
      }
      default:
    }
  }, qc = async () => {
    if (!hn) {
      if (ur)
        throw new Error("multiple calls to 'initWasm()' detected.");
      if (gn)
        throw new Error("previous call to 'initWasm()' failed.");
      if (ur = true, Rt())
        return new Promise((t, e) => {
          He?.terminate(), _s().then(([r, n]) => {
            try {
              He = n, He.onerror = (i) => e(i), He.onmessage = jy, Ro = [t, e];
              let o = { type: "init-wasm", in: ye };
              !o.in.wasm.wasmPaths && (r || Xn) && (o.in.wasm.wasmPaths = { wasm: new URL("ort-wasm-simd-threaded.jsep.wasm", import.meta.url).href }), He.postMessage(o), fn = r;
            } catch (o) {
              e(o);
            }
          }, e);
        });
      try {
        await Ar(ye.wasm), await Er(ye), hn = true;
      } catch (t) {
        throw gn = true, t;
      } finally {
        ur = false;
      }
    }
  }, Kc = async (t) => {
    if (Rt())
      return qt(), new Promise((e, r) => {
        Ft("init-ep", [e, r]);
        let n = { type: "init-ep", in: { epName: t, env: ye } };
        He.postMessage(n);
      });
    await kr(ye, t);
  }, jc = async (t) => Rt() ? (qt(), new Promise((e, r) => {
    Ft("copy-from", [e, r]);
    let n = { type: "copy-from", in: { buffer: t } };
    He.postMessage(n, [t.buffer]);
  })) : Jt(t), Zc = async (t, e) => {
    if (Rt()) {
      if (e?.preferredOutputLocation)
        throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
      return qt(), new Promise((r, n) => {
        Ft("create", [r, n]);
        let o = { type: "create", in: { model: t, options: { ...e } } }, i = [];
        t instanceof Uint8Array && i.push(t.buffer), He.postMessage(o, i);
      });
    } else
      return Pr(t, e);
  }, Qc = async (t) => {
    if (Rt())
      return qt(), new Promise((e, r) => {
        Ft("release", [e, r]);
        let n = { type: "release", in: t };
        He.postMessage(n);
      });
    Or(t);
  }, Yc = async (t, e, r, n, o, i) => {
    if (Rt()) {
      if (r.some((s) => s[3] !== "cpu"))
        throw new Error("input tensor on GPU is not supported for proxy.");
      if (o.some((s) => s))
        throw new Error("pre-allocated output tensor is not supported for proxy.");
      return qt(), new Promise((s, u) => {
        Ft("run", [s, u]);
        let d = r, c = { type: "run", in: { sessionId: t, inputIndices: e, inputs: d, outputIndices: n, options: i } };
        He.postMessage(c, Br(d));
      });
    } else
      return zr(t, e, r, n, o, i);
  }, Xc = async (t) => {
    if (Rt())
      return qt(), new Promise((e, r) => {
        Ft("end-profiling", [e, r]);
        let n = { type: "end-profiling", in: t };
        He.postMessage(n);
      });
    Dr(t);
  };
});
var Jc;
var Zy;
var yn;
var ep = V(() => {
  Ve();
  No();
  J();
  Ir();
  ro();
  Jc = (t, e) => {
    switch (t.location) {
      case "cpu":
        return [t.type, t.dims, t.data, "cpu"];
      case "gpu-buffer":
        return [t.type, t.dims, { gpuBuffer: t.gpuBuffer }, "gpu-buffer"];
      case "ml-tensor":
        return [t.type, t.dims, { mlTensor: t.mlTensor }, "ml-tensor"];
      default:
        throw new Error(`invalid data location: ${t.location} for ${e()}`);
    }
  }, Zy = (t) => {
    switch (t[3]) {
      case "cpu":
        return new Ke(t[0], t[2], t[1]);
      case "gpu-buffer": {
        let e = t[0];
        if (!Nr(e))
          throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);
        let { gpuBuffer: r, download: n, dispose: o } = t[2];
        return Ke.fromGpuBuffer(r, { dataType: e, dims: t[1], download: n, dispose: o });
      }
      case "ml-tensor": {
        let e = t[0];
        if (!Vr(e))
          throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);
        let { mlTensor: r, download: n, dispose: o } = t[2];
        return Ke.fromMLTensor(r, { dataType: e, dims: t[1], download: n, dispose: o });
      }
      default:
        throw new Error(`invalid data location: ${t[3]}`);
    }
  }, yn = class {
    async fetchModelAndCopyToWasmMemory(e) {
      return jc(await rr(e));
    }
    async loadModel(e, r) {
      Ne();
      let n;
      typeof e == "string" ? n = await this.fetchModelAndCopyToWasmMemory(e) : n = e, [this.sessionId, this.inputNames, this.outputNames, this.inputMetadata, this.outputMetadata] = await Zc(n, r), Me();
    }
    async dispose() {
      return Qc(this.sessionId);
    }
    async run(e, r, n) {
      Ne();
      let o = [], i = [];
      Object.entries(e).forEach((g) => {
        let b = g[0], y = g[1], w = this.inputNames.indexOf(b);
        if (w === -1)
          throw new Error(`invalid input '${b}'`);
        o.push(y), i.push(w);
      });
      let s = [], u = [];
      Object.entries(r).forEach((g) => {
        let b = g[0], y = g[1], w = this.outputNames.indexOf(b);
        if (w === -1)
          throw new Error(`invalid output '${b}'`);
        s.push(y), u.push(w);
      });
      let d = o.map((g, b) => Jc(g, () => `input "${this.inputNames[i[b]]}"`)), c = s.map((g, b) => g ? Jc(g, () => `output "${this.outputNames[u[b]]}"`) : null), p = await Yc(this.sessionId, i, d, u, c, n), m = {};
      for (let g = 0;g < p.length; g++)
        m[this.outputNames[u[g]]] = s[g] ?? Zy(p[g]);
      return Me(), m;
    }
    startProfiling() {}
    endProfiling() {
      Xc(this.sessionId);
    }
  };
});
var rp = {};
Vt(rp, { OnnxruntimeWebAssemblyBackend: () => bn, initializeFlags: () => tp, wasmBackend: () => Qy });
var tp;
var bn;
var Qy;
var np = V(() => {
  Ve();
  No();
  ep();
  tp = () => {
    (typeof ye.wasm.initTimeout != "number" || ye.wasm.initTimeout < 0) && (ye.wasm.initTimeout = 0);
    let t = ye.wasm.simd;
    if (typeof t != "boolean" && t !== undefined && t !== "fixed" && t !== "relaxed" && (console.warn(`Property "env.wasm.simd" is set to unknown value "${t}". Reset it to \`false\` and ignore SIMD feature checking.`), ye.wasm.simd = false), typeof ye.wasm.proxy != "boolean" && (ye.wasm.proxy = false), typeof ye.wasm.trace != "boolean" && (ye.wasm.trace = false), typeof ye.wasm.numThreads != "number" || !Number.isInteger(ye.wasm.numThreads) || ye.wasm.numThreads <= 0)
      if (typeof self < "u" && !self.crossOriginIsolated)
        ye.wasm.numThreads = 1;
      else {
        let e = typeof navigator > "u" ? Gn("node:os").cpus().length : navigator.hardwareConcurrency;
        ye.wasm.numThreads = Math.min(4, Math.ceil((e || 1) / 2));
      }
  }, bn = class {
    async init(e) {
      tp(), await qc(), await Kc(e);
    }
    async createInferenceSessionHandler(e, r) {
      let n = new yn;
      return await n.loadModel(e, r), n;
    }
  }, Qy = new bn;
});
Ve();
Ve();
Ve();
var ss = "1.24.1";
{
  let t = (np(), Yt(rp)).wasmBackend;
  kt("webgpu", t, 5), kt("webnn", t, 5), kt("cpu", t, 10), kt("wasm", t, 10);
}
Object.defineProperty(ye.versions, "web", { value: ss, enumerable: true });

// src/lib/ai-infer-engine.ts
var SAMPLING_RATE = 44100;
var MAX_TIME = 5;
var INPUT_LENGTH = SAMPLING_RATE * MAX_TIME;
var session = null;
var inferenceQueue = Promise.resolve(null);
async function initEngine(modelBuffer, wasmBuffer) {
  try {
    ye.wasm.numThreads = 1;
    ye.wasm.wasmBinary = wasmBuffer;
    session = await vf.create(modelBuffer, {
      executionProviders: ["wasm"]
    });
    console.log("[trashbin+ AI] Inference engine initialized");
    return true;
  } catch (error) {
    console.error("[trashbin+ AI] Failed to init engine:", error);
    return false;
  }
}
async function infer(audioData) {
  if (!session)
    return null;
  try {
    const tensor = new Ke("float32", audioData, [1, INPUT_LENGTH]);
    const results = await session.run({ audio: tensor });
    const outputData = results.prob.data;
    return Array.from(outputData)[0];
  } catch (error) {
    console.error("[trashbin+ AI] Inference error:", error);
    return null;
  }
}
function queueInference(audioData) {
  const promise = inferenceQueue.then(() => infer(audioData), () => infer(audioData));
  inferenceQueue = promise.then(() => null, () => null);
  return promise;
}
function disposeEngine() {
  if (session) {
    session.release();
    session = null;
  }
  inferenceQueue = Promise.resolve(null);
  console.log("[trashbin+ AI] Engine disposed");
}

// src/lib/ai-audio-fetcher.ts
var audioContext = null;
function getAudioContext() {
  if (!audioContext || audioContext.state === "closed") {
    audioContext = new AudioContext({
      latencyHint: "playback",
      sampleRate: SAMPLING_RATE
    });
  }
  return audioContext;
}
async function getPreviewUrl(trackUri) {
  try {
    const trackId = trackUri.split(":")[2];
    if (!trackId)
      return null;
    const token = (await Spicetify.Platform.AuthorizationAPI.getState()).token.accessToken;
    const response = await fetch(`https://api.spotify.com/v1/tracks/${trackId}`, { headers: { Authorization: `Bearer ${token}` } });
    if (!response.ok)
      return null;
    const data = await response.json();
    return data.preview_url ?? null;
  } catch (error) {
    console.error("[trashbin+ AI] Failed to get preview URL:", error);
    return null;
  }
}
async function fetchAudioWaveform(url) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch audio: ${response.status}`);
  }
  const arrayBuffer = await response.arrayBuffer();
  const ctx = getAudioContext();
  const decodedBuffer = await ctx.decodeAudioData(arrayBuffer);
  return decodedBuffer.getChannelData(0);
}
function extractMiddleChunk(waveform, targetLength = INPUT_LENGTH) {
  if (waveform.length <= targetLength) {
    const padded = new Float32Array(targetLength);
    const offset = Math.floor((targetLength - waveform.length) / 2);
    padded.set(waveform, offset);
    return padded;
  }
  const start = Math.floor(waveform.length / 2) - Math.floor(targetLength / 2);
  const end = start + targetLength;
  return waveform.slice(start, end);
}
function closeAudioContext() {
  if (audioContext && audioContext.state !== "closed") {
    audioContext.close();
    audioContext = null;
  }
}

// src/lib/ai-track-handler.ts
class LimitedMap {
  map;
  maxLength;
  constructor(maxLength) {
    this.map = new Map;
    this.maxLength = maxLength;
  }
  set(key, value) {
    if (this.map.size >= this.maxLength) {
      const firstKey = this.map.keys().next().value;
      this.map.delete(firstKey);
    }
    this.map.set(key, value);
  }
  get(key) {
    return this.map.get(key);
  }
  clear() {
    this.map.clear();
  }
}
var resultCache = new LimitedMap(1000);
var processingTracks = new Set;
function getCachedResult(trackUri) {
  return resultCache.get(trackUri);
}
function isProcessing(trackUri) {
  return processingTracks.has(trackUri);
}
async function classifyTrack(trackUri) {
  const cached = resultCache.get(trackUri);
  if (cached !== undefined)
    return cached;
  if (processingTracks.has(trackUri))
    return null;
  processingTracks.add(trackUri);
  try {
    const previewUrl = await getPreviewUrl(trackUri);
    if (!previewUrl) {
      return null;
    }
    const waveform = await fetchAudioWaveform(previewUrl);
    const chunk = extractMiddleChunk(waveform);
    const probability = await queueInference(chunk);
    if (probability !== null) {
      resultCache.set(trackUri, probability);
    }
    return probability;
  } catch (error) {
    console.error(`[trashbin+ AI] Failed to classify ${trackUri}:`, error);
    return null;
  } finally {
    processingTracks.delete(trackUri);
  }
}
async function initializeAiDetection(onProgress) {
  try {
    onProgress?.("Checking assets...");
    const assetsReady = await ensureAssets(onProgress);
    if (!assetsReady)
      return false;
    onProgress?.("Loading WASM runtime...");
    const wasmBuffer = await getAsset(ASSET_NAMES.WASM_SIMD);
    if (!wasmBuffer)
      return false;
    onProgress?.("Loading AI model...");
    const modelBuffer = await getAsset(ASSET_NAMES.MODEL);
    if (!modelBuffer)
      return false;
    onProgress?.("Initializing engine...");
    const initialized = await initEngine(modelBuffer, wasmBuffer);
    if (initialized) {
      onProgress?.("Ready");
    }
    return initialized;
  } catch (error) {
    console.error("[trashbin+ AI] Initialization failed:", error);
    return false;
  }
}
function cleanupAiDetection() {
  disposeEngine();
  closeAudioContext();
  resultCache.clear();
  processingTracks.clear();
}

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set;
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/zustand/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = import_react.default.useSyncExternalStore(api.subscribe, import_react.default.useCallback(() => selector(api.getState()), [api, selector]), import_react.default.useCallback(() => selector(api.getInitialState()), [api, selector]));
  import_react.default.useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// node_modules/i18next/dist/esm/i18next.js
var isString = (obj) => typeof obj === "string";
var defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
var makeString = (object) => {
  if (object == null)
    return "";
  return "" + object;
};
var copy = (a, s, t) => {
  a.forEach((m) => {
    if (s[m])
      t[m] = s[m];
  });
};
var lastOfPathSeparatorRegExp = /###/g;
var cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
var canNotTraverseDeeper = (object) => !object || isString(object);
var getLastOfPath = (object, path, Empty) => {
  const stack = !isString(path) ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object))
      return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty)
      object[key] = new Empty;
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object))
    return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
var setPath = (object, path, newValue) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path, Object);
  if (obj !== undefined || path.length === 1) {
    obj[k2] = newValue;
    return;
  }
  let e = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === undefined && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== "undefined") {
      last.obj = undefined;
    }
  }
  last.obj[`${last.k}.${e}`] = newValue;
};
var pushPath = (object, path, newValue, concat) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path, Object);
  obj[k2] = obj[k2] || [];
  obj[k2].push(newValue);
};
var getPath = (object, path) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path);
  if (!obj)
    return;
  if (!Object.prototype.hasOwnProperty.call(obj, k2))
    return;
  return obj[k2];
};
var getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== undefined) {
    return value;
  }
  return getPath(defaultData, key);
};
var deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
var regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
var escape = (data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
};

class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = new Map;
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== undefined) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
var chars = [" ", ",", "?", "!", ";"];
var looksLikeObjectPathRegExpCache = new RegExpCache(20);
var looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0)
    return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
var deepFind = (obj, path, keySeparator = ".") => {
  if (!obj)
    return;
  if (obj[path]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path))
      return;
    return obj[path];
  }
  const tokens = path.split(keySeparator);
  let current = obj;
  for (let i = 0;i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return;
    }
    let next;
    let nextPath = "";
    for (let j = i;j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== undefined) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
var getCleanedCode = (code) => code?.replace("_", "-");
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    console?.[type]?.apply?.(console, args);
  }
};

class Logger {
  constructor(concreteLogger, options = {}) {
    this.init(concreteLogger, options);
  }
  init(concreteLogger, options = {}) {
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log(...args) {
    return this.forward(args, "log", "", true);
  }
  warn(...args) {
    return this.forward(args, "warn", "", true);
  }
  error(...args) {
    return this.forward(args, "error", "");
  }
  deprecate(...args) {
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug)
      return null;
    if (isString(args[0]))
      args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger;

class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event])
        this.observers[event] = new Map;
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event])
      return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event, ...args) {
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i = 0;i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i = 0;i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}

class ResourceStore extends EventEmitter {
  constructor(data, options = {
    ns: ["translation"],
    defaultNS: "translation"
  }) {
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === undefined) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === undefined) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns2) {
    if (this.options.ns.indexOf(ns2) < 0) {
      this.options.ns.push(ns2);
    }
  }
  removeNamespaces(ns2) {
    const index = this.options.ns.indexOf(ns2);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns2, key, options = {}) {
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    } else {
      path = [lng, ns2];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns2 && !key && lng.indexOf(".") > -1) {
      lng = path[0];
      ns2 = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString(key))
      return result;
    return deepFind(this.data?.[lng]?.[ns2], key, keySeparator);
  }
  addResource(lng, ns2, key, value, options = {
    silent: false
  }) {
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns2];
    if (key)
      path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns2;
      ns2 = path[1];
    }
    this.addNamespaces(ns2);
    setPath(this.data, path, value);
    if (!options.silent)
      this.emit("added", lng, ns2, key, value);
  }
  addResources(lng, ns2, resources, options = {
    silent: false
  }) {
    for (const m in resources) {
      if (isString(resources[m]) || Array.isArray(resources[m]))
        this.addResource(lng, ns2, m, resources[m], {
          silent: true
        });
    }
    if (!options.silent)
      this.emit("added", lng, ns2, resources);
  }
  addResourceBundle(lng, ns2, resources, deep, overwrite, options = {
    silent: false,
    skipCopy: false
  }) {
    let path = [lng, ns2];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources;
      resources = ns2;
      ns2 = path[1];
    }
    this.addNamespaces(ns2);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy)
      resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent)
      this.emit("added", lng, ns2, resources);
  }
  removeResourceBundle(lng, ns2) {
    if (this.hasResourceBundle(lng, ns2)) {
      delete this.data[lng][ns2];
    }
    this.removeNamespaces(ns2);
    this.emit("removed", lng, ns2);
  }
  hasResourceBundle(lng, ns2) {
    return this.getResource(lng, ns2) !== undefined;
  }
  getResourceBundle(lng, ns2) {
    if (!ns2)
      ns2 = this.options.defaultNS;
    return this.getResource(lng, ns2);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      value = this.processors[processor]?.process(value, key, options, translator) ?? value;
    });
    return value;
  }
};
var PATH_KEY = Symbol("i18next/PATH_KEY");
function createProxy() {
  const state = [];
  const handler = Object.create(null);
  let proxy;
  handler.get = (target, key) => {
    proxy?.revoke?.();
    if (key === PATH_KEY)
      return state;
    state.push(key);
    proxy = Proxy.revocable(target, handler);
    return proxy.proxy;
  };
  return Proxy.revocable(Object.create(null), handler).proxy;
}
function keysFromSelector(selector, opts) {
  const {
    [PATH_KEY]: path
  } = selector(createProxy());
  return path.join(opts?.keySeparator ?? ".");
}
var checkedLoadedFor = {};
var shouldHandleAsObject = (res) => !isString(res) && typeof res !== "boolean" && typeof res !== "number";

class Translator extends EventEmitter {
  constructor(services, options = {}) {
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === undefined) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng)
      this.language = lng;
  }
  exists(key, o = {
    interpolation: {}
  }) {
    const opt = {
      ...o
    };
    if (key == null)
      return false;
    const resolved = this.resolve(key, opt);
    if (resolved?.res === undefined)
      return false;
    const isObject = shouldHandleAsObject(resolved.res);
    if (opt.returnObjects === false && isObject) {
      return false;
    }
    return true;
  }
  extractFromKey(key, opt) {
    let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === undefined)
      nsSeparator = ":";
    const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;
    let namespaces = opt.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
        namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, o, lastKey) {
    let opt = typeof o === "object" ? {
      ...o
    } : o;
    if (typeof opt !== "object" && this.options.overloadTranslationOptionHandler) {
      opt = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof opt === "object")
      opt = {
        ...opt
      };
    if (!opt)
      opt = {};
    if (keys == null)
      return "";
    if (typeof keys === "function")
      keys = keysFromSelector(keys, {
        ...this.options,
        ...opt
      });
    if (!Array.isArray(keys))
      keys = [String(keys)];
    const returnDetails = opt.returnDetails !== undefined ? opt.returnDetails : this.options.returnDetails;
    const keySeparator = opt.keySeparator !== undefined ? opt.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], opt);
    const namespace = namespaces[namespaces.length - 1];
    let nsSeparator = opt.nsSeparator !== undefined ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === undefined)
      nsSeparator = ":";
    const lng = opt.lng || this.language;
    const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng?.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(opt)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(opt)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, opt);
    let res = resolved?.res;
    const resUsedKey = resolved?.usedKey || key;
    const resExactUsedKey = resolved?.exactUsedKey || key;
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = opt.joinArrays !== undefined ? opt.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const needsPluralHandling = opt.count !== undefined && !isString(opt.count);
    const hasDefaultValue = Translator.hasDefaultValue(opt);
    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : "";
    const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
      ordinal: false
    }) : "";
    const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
    const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
    let resForObjHndl = res;
    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
      resForObjHndl = defaultValue;
    }
    const handleAsObject = shouldHandleAsObject(resForObjHndl);
    const resType = Object.prototype.toString.apply(resForObjHndl);
    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {
      if (!opt.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
          ...opt,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(opt);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(resForObjHndl);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in resForObjHndl) {
          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            if (hasDefaultValue && !res) {
              copy2[m] = this.translate(deepKey, {
                ...opt,
                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : undefined,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            } else {
              copy2[m] = this.translate(deepKey, {
                ...opt,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            }
            if (copy2[m] === deepKey)
              copy2[m] = resForObjHndl[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res)
        res = this.extendTranslation(res, keys, opt, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...opt,
            keySeparator: false
          });
          if (fk && fk.res)
            this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0;i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
        } else {
          lngs.push(opt.lng || this.language);
        }
        const send = (l, k2, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k2, defaultForMissing, updateMissing, opt);
          } else if (this.backendConnector?.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k2, defaultForMissing, updateMissing, opt);
          }
          this.emit("missingKey", l, namespace, k2, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, opt);
              if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, opt, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {
        res = `${namespace}${nsSeparator}${key}`;
      }
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : undefined, opt);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(opt);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, opt, resolved, lastKey) {
    if (this.i18nFormat?.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...opt
      }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!opt.skipInterpolation) {
      if (opt.interpolation)
        this.interpolator.init({
          ...opt,
          ...{
            interpolation: {
              ...this.options.interpolation,
              ...opt.interpolation
            }
          }
        });
      const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== undefined ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;
      if (this.options.interpolation.defaultVariables)
        data = {
          ...this.options.interpolation.defaultVariables,
          ...data
        };
      res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft)
          opt.nest = false;
      }
      if (!opt.lng && resolved && resolved.res)
        opt.lng = this.language || resolved.usedLng;
      if (opt.nest !== false)
        res = this.interpolator.nest(res, (...args) => {
          if (lastKey?.[0] === args[0] && !opt.context) {
            this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
            return null;
          }
          return this.translate(...args, key);
        }, opt);
      if (opt.interpolation)
        this.interpolator.reset();
    }
    const postProcess = opt.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(opt)
        },
        ...opt
      } : opt, this);
    }
    return res;
  }
  resolve(keys, opt = {}) {
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys))
      keys = [keys];
    keys.forEach((k2) => {
      if (this.isValidLookup(found))
        return;
      const extracted = this.extractFromKey(k2, opt);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS)
        namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = opt.count !== undefined && !isString(opt.count);
      const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
      const needsContextHandling = opt.context !== undefined && (isString(opt.context) || typeof opt.context === "number") && opt.context !== "";
      const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
      namespaces.forEach((ns2) => {
        if (this.isValidLookup(found))
          return;
        usedNS = ns2;
        if (!checkedLoadedFor[`${codes[0]}-${ns2}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns2}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found))
            return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat?.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns2, opt);
          } else {
            let pluralSuffix;
            if (needsPluralHandling)
              pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              finalKeys.push(key + pluralSuffix);
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator || "_"}${opt.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                finalKeys.push(contextKey + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns2, possibleKey, opt);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns2, key, options = {}) {
    if (this.i18nFormat?.getResource)
      return this.i18nFormat.getResource(code, ns2, key, options);
    return this.resourceStore.getResource(code, ns2, key, options);
  }
  getUsedParamsDetails(options = {}) {
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && options[option] !== undefined) {
        return true;
      }
    }
    return false;
  }
}

class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return null;
    const p = code.split("-");
    if (p.length === 2)
      return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x")
      return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf("-") > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e) {}
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode)
        return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes)
      return null;
    let found;
    codes.forEach((code) => {
      if (found)
        return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
        found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found)
          return;
        const lngScOnly = this.getScriptPartFromCode(code);
        if (this.isSupportedCode(lngScOnly))
          return found = lngScOnly;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly))
          return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly)
            return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
            return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly)
            return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1)
            return supportedLng;
        });
      });
    }
    if (!found)
      found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks)
      return [];
    if (typeof fallbacks === "function")
      fallbacks = fallbacks(code);
    if (isString(fallbacks))
      fallbacks = [fallbacks];
    if (Array.isArray(fallbacks))
      return fallbacks;
    if (!code)
      return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found)
      found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found)
      found = fallbacks[this.formatLanguageCode(code)];
    if (!found)
      found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found)
      found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c)
        return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (isString(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly")
        addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
        addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly")
        addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc2) => {
      if (codes.indexOf(fc2) < 0)
        addCode(this.formatLanguageCode(fc2));
    });
    return codes;
  }
}
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
var dummyRule = {
  select: (count) => count === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};

class PluralResolver {
  constructor(languageUtils, options = {}) {
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    this.pluralRulesCache = {};
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code, options = {}) {
    const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
    const type = options.ordinal ? "ordinal" : "cardinal";
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error("No Intl support, please use an Intl polyfill!");
        return dummyRule;
      }
      if (!code.match(/-|_/))
        return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule)
      rule = this.getRule("dev", options);
    return rule?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(code, key, options = {}) {
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule)
      rule = this.getRule("dev", options);
    if (!rule)
      return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
  }
  getSuffix(code, count, options = {}) {
    const rule = this.getRule(code, options);
    if (rule) {
      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix("dev", count, options);
  }
}
var deepFindWithDefaults = (data, defaultData, key, keySeparator = ".", ignoreJSONStructure = true) => {
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === undefined)
      path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
var regexSafe = (val) => val.replace(/\$/g, "$$$$");

class Interpolator {
  constructor(options = {}) {
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options?.interpolation?.format || ((value) => value);
    this.init(options);
  }
  init(options = {}) {
    if (!options.interpolation)
      options.interpolation = {
        escapeValue: true
      };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== undefined ? escape$1 : escape;
    this.escapeValue = escapeValue !== undefined ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1000;
    this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options)
      this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp?.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, undefined, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k2 = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k2
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === undefined) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc2, options = {}) {
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0)
        return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions)
          clonedOptions = {
            ...inheritedOptions,
            ...clonedOptions
          };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1)
        delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf("}") + 1 : match[1].indexOf(this.formatSeparator);
      if (keyEndIndex !== -1) {
        formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map((elem) => elem.trim()).filter(Boolean);
        match[1] = match[1].slice(0, keyEndIndex);
      }
      value = fc2(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString(value))
        return value;
      if (!isString(value))
        value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (formatters.length) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
var parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey])
            formatOptions[trimmedKey] = val;
          if (val === "false")
            formatOptions[trimmedKey] = false;
          if (val === "true")
            formatOptions[trimmedKey] = true;
          if (!isNaN(val))
            formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
var createCachedFormatter = (fn2) => {
  const cache = {};
  return (v, l, o) => {
    let optForCache = o;
    if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [o.interpolationkey]: undefined
      };
    }
    const key = l + JSON.stringify(optForCache);
    let frm = cache[key];
    if (!frm) {
      frm = fn2(getCleanedCode(l), o);
      cache[key] = frm;
    }
    return frm(v);
  };
};
var createNonCachedFormatter = (fn2) => (v, l, o) => fn2(getCleanedCode(l), o)(v);

class Formatter {
  constructor(options = {}) {
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.init(options);
  }
  init(services, options = {
    interpolation: {}
  }) {
    this.formatSeparator = options.interpolation.formatSeparator || ",";
    const cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;
    this.formats = {
      number: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: cf((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: cf((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: cf((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
  }
  add(name, fc2) {
    this.formats[name.toLowerCase().trim()] = fc2;
  }
  addCached(name, fc2) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc2);
  }
  format(value, format, lng, options = {}) {
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options?.formatParams?.[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
}
var removePending = (q, name) => {
  if (q.pending[name] !== undefined) {
    delete q.pending[name];
    q.pendingCount--;
  }
};

class Connector extends EventEmitter {
  constructor(backend, store, services, options = {}) {
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    this.backend?.init?.(services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns2) => {
        const name = `${lng}|${ns2}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns2)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0)
          ;
        else if (this.state[name] === 1) {
          if (pending[name] === undefined)
            pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === undefined)
            pending[name] = true;
          if (toLoad[name] === undefined)
            toLoad[name] = true;
          if (toLoadNamespaces[ns2] === undefined)
            toLoadNamespaces[ns2] = true;
        }
      });
      if (!hasAllNamespaces)
        toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split("|");
    const lng = s[0];
    const ns2 = s[1];
    if (err)
      this.emit("failedLoading", lng, ns2, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns2, data, undefined, undefined, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data)
      this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns2);
      removePending(q, name);
      if (err)
        q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l])
            loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === undefined)
                loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns2, fcName, tried = 0, wait = this.retryTimeout, callback) {
    if (!lng.length)
      return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns: ns2,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns2, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc2 = this.backend[fcName].bind(this.backend);
    if (fc2.length === 2) {
      try {
        const r = fc2(lng, ns2);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc2(lng, ns2, resolver);
  }
  prepareLoading(languages, namespaces, options = {}, callback) {
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages))
      languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces))
      namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length)
        callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name, prefix = "") {
    const s = name.split("|");
    const lng = s[0];
    const ns2 = s[1];
    this.read(lng, ns2, "read", undefined, undefined, (err, data) => {
      if (err)
        this.logger.warn(`${prefix}loading namespace ${ns2} for language ${lng} failed`, err);
      if (!err && data)
        this.logger.log(`${prefix}loaded namespace ${ns2} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}, clb = () => {}) {
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === undefined || key === null || key === "")
      return;
    if (this.backend?.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc2 = this.backend.create.bind(this.backend);
      if (fc2.length < 6) {
        try {
          let r;
          if (fc2.length === 5) {
            r = fc2(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc2(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc2(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0])
      return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
var get = () => ({
  debug: false,
  initAsync: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object")
      ret = args[1];
    if (isString(args[1]))
      ret.defaultValue = args[1];
    if (isString(args[2]))
      ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1000,
    skipOnVariables: true
  },
  cacheInBuiltFormats: true
});
var transformOptions = (options) => {
  if (isString(options.ns))
    options.ns = [options.ns];
  if (isString(options.fallbackLng))
    options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS))
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs?.indexOf?.("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  if (typeof options.initImmediate === "boolean")
    options.initAsync = options.initImmediate;
  return options;
};
var noop = () => {};
var bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
var usesLocize = (inst) => {
  if (inst?.modules?.backend?.name?.indexOf("Locize") > 0)
    return true;
  if (inst?.modules?.backend?.constructor?.name?.indexOf("Locize") > 0)
    return true;
  if (inst?.options?.backend?.backends) {
    if (inst.options.backend.backends.some((b) => b?.name?.indexOf("Locize") > 0 || b?.constructor?.name?.indexOf("Locize") > 0))
      return true;
  }
  return false;
};

class I18n extends EventEmitter {
  constructor(options = {}, callback) {
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initAsync) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init(options = {}, callback) {
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (options.defaultNS == null && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options.keySeparator !== undefined) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== undefined) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    if (typeof this.options.overloadTranslationOptionHandler !== "function") {
      this.options.overloadTranslationOptionHandler = defOpts.overloadTranslationOptionHandler;
    }
    if (this.options.showSupportNotice !== false && !usesLocize(this)) {
      if (typeof console !== "undefined" && typeof console.info !== "undefined")
        console.info("\uD83C\uDF10 i18next is maintained with support from locize.com — consider powering your project with managed localization (AI, CDN, integrations): https://locize.com \uD83D\uDC99");
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject)
        return null;
      if (typeof ClassOrObject === "function")
        return new ClassOrObject;
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu2 = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu2;
      s.pluralResolver = new PluralResolver(lu2, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;
      if (usingLegacyFormatFunction) {
        this.logger.deprecate(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);
      }
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        if (s.formatter.init)
          s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init)
          s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init)
          s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init)
          m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback)
      callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev")
        this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = (...args) => this.store[fcName](...args);
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = (...args) => {
        this.store[fcName](...args);
        return this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce)
          this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone)
          this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t);
        callback(err, t);
      };
      if (this.languages && !this.isInitialized)
        return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language, callback = noop) {
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === "function")
      usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
        return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng)
          return;
        if (lng === "cimode")
          return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode")
            return;
          if (toLoad.indexOf(l) < 0)
            toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      this.options.preload?.forEach?.((l) => append(l));
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language)
          this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns2, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = undefined;
    }
    if (typeof ns2 === "function") {
      callback = ns2;
      ns2 = undefined;
    }
    if (!lngs)
      lngs = this.languages;
    if (!ns2)
      ns2 = this.options.ns;
    if (!callback)
      callback = noop;
    this.services.backendConnector.reload(lngs, ns2, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages)
      return;
    if (["cimode", "dev"].indexOf(l) > -1)
      return;
    for (let li = 0;li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1)
        continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
    if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {
      this.resolvedLanguage = l;
      this.languages.unshift(l);
    }
  }
  changeLanguage(lng, callback) {
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = undefined;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        if (this.isLanguageChangingTo === lng) {
          setLngProps(l);
          this.translator.changeLanguage(l);
          this.isLanguageChangingTo = undefined;
          this.emit("languageChanged", l);
          this.logger.log("languageChanged", l);
        }
      } else {
        this.isLanguageChangingTo = undefined;
      }
      deferred.resolve((...args) => this.t(...args));
      if (callback)
        callback(err, (...args) => this.t(...args));
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector)
        lngs = [];
      const fl2 = isString(lngs) ? lngs : lngs && lngs[0];
      const l = this.store.hasLanguageSomeTranslations(fl2) ? fl2 : this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [lngs] : lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language)
          this.translator.changeLanguage(l);
        this.services.languageDetector?.cacheUserLanguage?.(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns2, keyPrefix) {
    const fixedT = (key, opts, ...rest) => {
      let o;
      if (typeof opts !== "object") {
        o = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        o = {
          ...opts
        };
      }
      o.lng = o.lng || fixedT.lng;
      o.lngs = o.lngs || fixedT.lngs;
      o.ns = o.ns || fixedT.ns;
      if (o.keyPrefix !== "")
        o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = this.options.keySeparator || ".";
      let resultKey;
      if (o.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k2) => {
          if (typeof k2 === "function")
            k2 = keysFromSelector(k2, {
              ...this.options,
              ...opts
            });
          return `${o.keyPrefix}${keySeparator}${k2}`;
        });
      } else {
        if (typeof key === "function")
          key = keysFromSelector(key, {
            ...this.options,
            ...opts
          });
        resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;
      }
      return this.t(resultKey, o);
    };
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns2;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t(...args) {
    return this.translator?.translate(...args);
  }
  exists(...args) {
    return this.translator?.exists(...args);
  }
  setDefaultNamespace(ns2) {
    this.options.defaultNS = ns2;
  }
  hasLoadedNamespace(ns2, options = {}) {
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode")
      return true;
    const loadNotPending = (l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== undefined)
        return preResult;
    }
    if (this.hasResourceBundle(lng, ns2))
      return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
      return true;
    if (loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2)))
      return true;
    return false;
  }
  loadNamespaces(ns2, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    if (isString(ns2))
      ns2 = [ns2];
    ns2.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0)
        this.options.ns.push(n);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs))
      lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng)
      lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
    if (!lng)
      return "rtl";
    try {
      const l = new Intl.Locale(lng);
      if (l && l.getTextInfo) {
        const ti = l.getTextInfo();
        if (ti && ti.direction)
          return ti.direction;
      }
    } catch (e) {}
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services?.languageUtils || new LanguageUtil(get());
    if (lng.toLowerCase().indexOf("-latn") > 1)
      return "ltr";
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance(options = {}, callback) {
    const instance = new I18n(options, callback);
    instance.createInstance = I18n.createInstance;
    return instance;
  }
  cloneInstance(options = {}, callback = noop) {
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore)
      delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== undefined || options.prefix !== undefined) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev, l) => {
        prev[l] = {
          ...this.store.data[l]
        };
        prev[l] = Object.keys(prev[l]).reduce((acc, n) => {
          acc[n] = {
            ...prev[l][n]
          };
          return acc;
        }, prev[l]);
        return prev;
      }, {});
      clone.store = new ResourceStore(clonedData, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    if (options.interpolation) {
      const defOpts = get();
      const mergedInterpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation,
        ...options.interpolation
      };
      const mergedForInterpolator = {
        ...mergedOptions,
        interpolation: mergedInterpolation
      };
      clone.services.interpolator = new Interpolator(mergedForInterpolator);
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", (event, ...args) => {
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
var instance = I18n.createInstance();
var createInstance = instance.createInstance;
var dir = instance.dir;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;

// src/components/providers/providers.tsx
var import_react5 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/utils.js
var warn = (i18n, code, msg, rest) => {
  const args = [msg, {
    code,
    ...rest || {}
  }];
  if (i18n?.services?.logger?.forward) {
    return i18n.services.logger.forward(args, "warn", "react-i18next::", true);
  }
  if (isString2(args[0]))
    args[0] = `react-i18next:: ${args[0]}`;
  if (i18n?.services?.logger?.warn) {
    i18n.services.logger.warn(...args);
  } else if (console?.warn) {
    console.warn(...args);
  }
};
var alreadyWarned = {};
var warnOnce = (i18n, code, msg, rest) => {
  if (isString2(msg) && alreadyWarned[msg])
    return;
  if (isString2(msg))
    alreadyWarned[msg] = new Date;
  warn(i18n, code, msg, rest);
};
var loadedClb = (i18n, cb) => () => {
  if (i18n.isInitialized) {
    cb();
  } else {
    const initialized = () => {
      setTimeout(() => {
        i18n.off("initialized", initialized);
      }, 0);
      cb();
    };
    i18n.on("initialized", initialized);
  }
};
var loadNamespaces2 = (i18n, ns2, cb) => {
  i18n.loadNamespaces(ns2, loadedClb(i18n, cb));
};
var loadLanguages2 = (i18n, lng, ns2, cb) => {
  if (isString2(ns2))
    ns2 = [ns2];
  if (i18n.options.preload && i18n.options.preload.indexOf(lng) > -1)
    return loadNamespaces2(i18n, ns2, cb);
  ns2.forEach((n) => {
    if (i18n.options.ns.indexOf(n) < 0)
      i18n.options.ns.push(n);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb));
};
var hasLoadedNamespace2 = (ns2, i18n, options = {}) => {
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce(i18n, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
      languages: i18n.languages
    });
    return true;
  }
  return i18n.hasLoadedNamespace(ns2, {
    lng: options.lng,
    precheck: (i18nInstance, loadNotPending) => {
      if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance.services.backendConnector.backend && i18nInstance.isLanguageChangingTo && !loadNotPending(i18nInstance.isLanguageChangingTo, ns2))
        return false;
    }
  });
};
var isString2 = (obj) => typeof obj === "string";
var isObject = (obj) => typeof obj === "object" && obj !== null;

// node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
var htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
};
var unescapeHtmlEntity = (m) => htmlEntities[m];
var unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);

// node_modules/react-i18next/dist/es/defaults.js
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape,
  transDefaultProps: undefined
};
var setDefaults = (options = {}) => {
  defaultOptions = {
    ...defaultOptions,
    ...options
  };
};
var getDefaults = () => defaultOptions;

// node_modules/react-i18next/dist/es/i18nInstance.js
var i18nInstance;
var setI18n = (instance2) => {
  i18nInstance = instance2;
};
var getI18n = () => i18nInstance;

// node_modules/react-i18next/dist/es/context.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/initReactI18next.js
var initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};

// node_modules/react-i18next/dist/es/context.js
var I18nContext = import_react2.createContext();

class ReportNamespaces {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(namespaces) {
    namespaces.forEach((ns2) => {
      if (!this.usedNamespaces[ns2])
        this.usedNamespaces[ns2] = true;
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}

// node_modules/react-i18next/dist/es/useTranslation.js
var import_react3 = __toESM(require_react(), 1);
var import_shim = __toESM(require_shim(), 1);
var notReadyT = (k2, optsOrDefaultValue) => {
  if (isString2(optsOrDefaultValue))
    return optsOrDefaultValue;
  if (isObject(optsOrDefaultValue) && isString2(optsOrDefaultValue.defaultValue))
    return optsOrDefaultValue.defaultValue;
  return Array.isArray(k2) ? k2[k2.length - 1] : k2;
};
var notReadySnapshot = {
  t: notReadyT,
  ready: false
};
var dummySubscribe = () => () => {};
var useTranslation = (ns2, props = {}) => {
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = import_react3.useContext(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces;
  if (!i18n) {
    warnOnce(i18n, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
  }
  const i18nOptions = import_react3.useMemo(() => ({
    ...getDefaults(),
    ...i18n?.options?.react,
    ...props
  }), [i18n, props]);
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  const nsOrContext = ns2 || defaultNSFromContext || i18n?.options?.defaultNS;
  const unstableNamespaces = isString2(nsOrContext) ? [nsOrContext] : nsOrContext || ["translation"];
  const namespaces = import_react3.useMemo(() => unstableNamespaces, unstableNamespaces);
  i18n?.reportNamespaces?.addUsedNamespaces?.(namespaces);
  const revisionRef = import_react3.useRef(0);
  const subscribe = import_react3.useCallback((callback) => {
    if (!i18n)
      return dummySubscribe;
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    const wrappedCallback = () => {
      revisionRef.current += 1;
      callback();
    };
    if (bindI18n)
      i18n.on(bindI18n, wrappedCallback);
    if (bindI18nStore)
      i18n.store.on(bindI18nStore, wrappedCallback);
    return () => {
      if (bindI18n)
        bindI18n.split(" ").forEach((e) => i18n.off(e, wrappedCallback));
      if (bindI18nStore)
        bindI18nStore.split(" ").forEach((e) => i18n.store.off(e, wrappedCallback));
    };
  }, [i18n, i18nOptions]);
  const snapshotRef = import_react3.useRef();
  const getSnapshot = import_react3.useCallback(() => {
    if (!i18n) {
      return notReadySnapshot;
    }
    const calculatedReady = !!(i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n) => hasLoadedNamespace2(n, i18n, i18nOptions));
    const currentLng = props.lng || i18n.language;
    const currentRevision = revisionRef.current;
    const lastSnapshot = snapshotRef.current;
    if (lastSnapshot && lastSnapshot.ready === calculatedReady && lastSnapshot.lng === currentLng && lastSnapshot.keyPrefix === keyPrefix && lastSnapshot.revision === currentRevision) {
      return lastSnapshot;
    }
    const calculatedT = i18n.getFixedT(currentLng, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
    const newSnapshot = {
      t: calculatedT,
      ready: calculatedReady,
      lng: currentLng,
      keyPrefix,
      revision: currentRevision
    };
    snapshotRef.current = newSnapshot;
    return newSnapshot;
  }, [i18n, namespaces, keyPrefix, i18nOptions, props.lng]);
  const [loadCount, setLoadCount] = import_react3.useState(0);
  const {
    t: t2,
    ready
  } = import_shim.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
  import_react3.useEffect(() => {
    if (i18n && !ready && !useSuspense) {
      const onLoaded = () => setLoadCount((c) => c + 1);
      if (props.lng) {
        loadLanguages2(i18n, props.lng, namespaces, onLoaded);
      } else {
        loadNamespaces2(i18n, namespaces, onLoaded);
      }
    }
  }, [i18n, props.lng, namespaces, ready, useSuspense, loadCount]);
  const finalI18n = i18n || {};
  const wrapperRef = import_react3.useRef(null);
  const wrapperLangRef = import_react3.useRef();
  const createI18nWrapper = (original) => {
    const descriptors = Object.getOwnPropertyDescriptors(original);
    if (descriptors.__original)
      delete descriptors.__original;
    const wrapper = Object.create(Object.getPrototypeOf(original), descriptors);
    if (!Object.prototype.hasOwnProperty.call(wrapper, "__original")) {
      try {
        Object.defineProperty(wrapper, "__original", {
          value: original,
          writable: false,
          enumerable: false,
          configurable: false
        });
      } catch (_) {}
    }
    return wrapper;
  };
  const ret = import_react3.useMemo(() => {
    const original = finalI18n;
    const lang = original?.language;
    let i18nWrapper = original;
    if (original) {
      if (wrapperRef.current && wrapperRef.current.__original === original) {
        if (wrapperLangRef.current !== lang) {
          i18nWrapper = createI18nWrapper(original);
          wrapperRef.current = i18nWrapper;
          wrapperLangRef.current = lang;
        } else {
          i18nWrapper = wrapperRef.current;
        }
      } else {
        i18nWrapper = createI18nWrapper(original);
        wrapperRef.current = i18nWrapper;
        wrapperLangRef.current = lang;
      }
    }
    const arr = [t2, i18nWrapper, ready];
    arr.t = t2;
    arr.i18n = i18nWrapper;
    arr.ready = ready;
    return arr;
  }, [t2, finalI18n, ready, finalI18n.resolvedLanguage, finalI18n.language, finalI18n.languages]);
  if (i18n && useSuspense && !ready) {
    throw new Promise((resolve) => {
      const onLoaded = () => resolve();
      if (props.lng) {
        loadLanguages2(i18n, props.lng, namespaces, onLoaded);
      } else {
        loadNamespaces2(i18n, namespaces, onLoaded);
      }
    });
  }
  return ret;
};
// node_modules/react-i18next/dist/es/I18nextProvider.js
var import_react4 = __toESM(require_react(), 1);
function I18nextProvider({
  i18n,
  defaultNS,
  children
}) {
  const value = import_react4.useMemo(() => ({
    i18n,
    defaultNS
  }), [i18n, defaultNS]);
  return import_react4.createElement(I18nContext.Provider, {
    value
  }, children);
}
// src/components/providers/providers.tsx
var messages = {
  af: () => Promise.resolve().then(() => __toESM(require_af(), 1)),
  am: () => Promise.resolve().then(() => __toESM(require_am(), 1)),
  "ar-EG": () => Promise.resolve().then(() => __toESM(require_ar_EG(), 1)),
  "ar-MA": () => Promise.resolve().then(() => __toESM(require_ar_MA(), 1)),
  "ar-SA": () => Promise.resolve().then(() => __toESM(require_ar_SA(), 1)),
  ar: () => Promise.resolve().then(() => __toESM(require_ar(), 1)),
  az: () => Promise.resolve().then(() => __toESM(require_az(), 1)),
  bg: () => Promise.resolve().then(() => __toESM(require_bg(), 1)),
  bho: () => Promise.resolve().then(() => __toESM(require_bho(), 1)),
  bn: () => Promise.resolve().then(() => __toESM(require_bn(), 1)),
  bs: () => Promise.resolve().then(() => __toESM(require_bs(), 1)),
  ca: () => Promise.resolve().then(() => __toESM(require_ca(), 1)),
  cs: () => Promise.resolve().then(() => __toESM(require_cs(), 1)),
  da: () => Promise.resolve().then(() => __toESM(require_da(), 1)),
  de: () => Promise.resolve().then(() => __toESM(require_de(), 1)),
  el: () => Promise.resolve().then(() => __toESM(require_el(), 1)),
  "en-GB": () => Promise.resolve().then(() => __toESM(require_en_GB(), 1)),
  en: () => Promise.resolve().then(() => __toESM(require_en(), 1)),
  "es-419": () => Promise.resolve().then(() => __toESM(require_es_419(), 1)),
  "es-AR": () => Promise.resolve().then(() => __toESM(require_es_AR(), 1)),
  "es-MX": () => Promise.resolve().then(() => __toESM(require_es_MX(), 1)),
  es: () => Promise.resolve().then(() => __toESM(require_es(), 1)),
  et: () => Promise.resolve().then(() => __toESM(require_et(), 1)),
  eu: () => Promise.resolve().then(() => __toESM(require_eu(), 1)),
  fa: () => Promise.resolve().then(() => __toESM(require_fa(), 1)),
  fi: () => Promise.resolve().then(() => __toESM(require_fi(), 1)),
  fil: () => Promise.resolve().then(() => __toESM(require_fil(), 1)),
  "fr-CA": () => Promise.resolve().then(() => __toESM(require_fr_CA(), 1)),
  fr: () => Promise.resolve().then(() => __toESM(require_fr(), 1)),
  gl: () => Promise.resolve().then(() => __toESM(require_gl(), 1)),
  gu: () => Promise.resolve().then(() => __toESM(require_gu(), 1)),
  he: () => Promise.resolve().then(() => __toESM(require_he(), 1)),
  hi: () => Promise.resolve().then(() => __toESM(require_hi(), 1)),
  hr: () => Promise.resolve().then(() => __toESM(require_hr(), 1)),
  hu: () => Promise.resolve().then(() => __toESM(require_hu(), 1)),
  id: () => Promise.resolve().then(() => __toESM(require_id(), 1)),
  is: () => Promise.resolve().then(() => __toESM(require_is(), 1)),
  it: () => Promise.resolve().then(() => __toESM(require_it(), 1)),
  ja: () => Promise.resolve().then(() => __toESM(require_ja(), 1)),
  kn: () => Promise.resolve().then(() => __toESM(require_kn(), 1)),
  ko: () => Promise.resolve().then(() => __toESM(require_ko(), 1)),
  lt: () => Promise.resolve().then(() => __toESM(require_lt(), 1)),
  lv: () => Promise.resolve().then(() => __toESM(require_lv(), 1)),
  mk: () => Promise.resolve().then(() => __toESM(require_mk(), 1)),
  ml: () => Promise.resolve().then(() => __toESM(require_ml(), 1)),
  mr: () => Promise.resolve().then(() => __toESM(require_mr(), 1)),
  ms: () => Promise.resolve().then(() => __toESM(require_ms(), 1)),
  nb: () => Promise.resolve().then(() => __toESM(require_nb(), 1)),
  ne: () => Promise.resolve().then(() => __toESM(require_ne(), 1)),
  nl: () => Promise.resolve().then(() => __toESM(require_nl(), 1)),
  or: () => Promise.resolve().then(() => __toESM(require_or(), 1)),
  "pa-IN": () => Promise.resolve().then(() => __toESM(require_pa_IN(), 1)),
  "pa-PK": () => Promise.resolve().then(() => __toESM(require_pa_PK(), 1)),
  pl: () => Promise.resolve().then(() => __toESM(require_pl(), 1)),
  "pt-BR": () => Promise.resolve().then(() => __toESM(require_pt_BR(), 1)),
  "pt-PT": () => Promise.resolve().then(() => __toESM(require_pt_PT(), 1)),
  ro: () => Promise.resolve().then(() => __toESM(require_ro(), 1)),
  ru: () => Promise.resolve().then(() => __toESM(require_ru(), 1)),
  sk: () => Promise.resolve().then(() => __toESM(require_sk(), 1)),
  sl: () => Promise.resolve().then(() => __toESM(require_sl(), 1)),
  sr: () => Promise.resolve().then(() => __toESM(require_sr(), 1)),
  sv: () => Promise.resolve().then(() => __toESM(require_sv(), 1)),
  sw: () => Promise.resolve().then(() => __toESM(require_sw(), 1)),
  ta: () => Promise.resolve().then(() => __toESM(require_ta(), 1)),
  te: () => Promise.resolve().then(() => __toESM(require_te(), 1)),
  th: () => Promise.resolve().then(() => __toESM(require_th(), 1)),
  tr: () => Promise.resolve().then(() => __toESM(require_tr(), 1)),
  uk: () => Promise.resolve().then(() => __toESM(require_uk(), 1)),
  ur: () => Promise.resolve().then(() => __toESM(require_ur(), 1)),
  vi: () => Promise.resolve().then(() => __toESM(require_vi(), 1)),
  "zh-CN": () => Promise.resolve().then(() => __toESM(require_zh_CN(), 1)),
  "zh-HK": () => Promise.resolve().then(() => __toESM(require_zh_HK(), 1)),
  "zh-TW": () => Promise.resolve().then(() => __toESM(require_zh_TW(), 1)),
  zu: () => Promise.resolve().then(() => __toESM(require_zu(), 1))
};
var Providers = (props) => {
  const [locale, setLocale] = import_react5.useState(Spicetify.Locale.getLocale());
  const [i18nReady, setI18nReady] = import_react5.useState(false);
  import_react5.useEffect(() => {
    const currentLocale = Spicetify.Locale.getLocale();
    setLocale(currentLocale);
    const loadMessages = async () => {
      const resources = {};
      for (const [lang, loader] of Object.entries(messages)) {
        const module = await loader();
        resources[lang] = { translation: module.default };
      }
      await instance.use(initReactI18next).init({
        resources,
        lng: currentLocale,
        fallbackLng: "en",
        interpolation: { escapeValue: false }
      });
      setI18nReady(true);
    };
    loadMessages();
  }, [Spicetify.Platform.Session.locale, Spicetify.Locale._locale]);
  if (!i18nReady)
    return null;
  return /* @__PURE__ */ import_react5.default.createElement(I18nextProvider, {
    i18n: instance
  }, props.children);
};

// src/lib/constants.ts
var SELECTORS = {
  SKIP_BACK_BUTTON: ".main-skipBackButton-button",
  SKIP_BACK_BUTTON_ALT: ".player-controls__left > button[data-encore-id='buttonTertiary']",
  ARTIST_LINK: 'a[href*="/artist/"]',
  TRACK_CREDITS_MODAL: ".main-trackCreditsModal-mainSection",
  TRACK_CREDITS_MODAL_CONTAINER: ".main-trackCreditsModal-container",
  SMART_SHUFFLE_BUTTON: 'button svg path[d^="M4.502 0a.637"]'
};
var TRACKLIST_CONFIG = {
  containerSelector: "main",
  buttonSelector: ".trashbin-tracklist-btn",
  rowSelector: ".main-trackList-trackListRow",
  moreButtonSelector: "button[aria-haspopup='menu'], button[data-testid='add-to-playlist-button']",
  buttonClassName: "trashbin-tracklist-btn"
};
var QUEUELIST_CONFIG = {
  containerSelector: "#Desktop_PanelContainer_Id",
  buttonSelector: ".trashbin-queue-btn",
  rowSelector: '[role="row"]',
  moreButtonSelector: 'button[aria-haspopup="menu"]',
  buttonClassName: "trashbin-queue-btn"
};
var AUTO_ADD_CONFIG = {
  gridSelector: '[aria-label^="Recommended based on"]',
  rowSelector: '[role="row"]',
  trashButtonSelector: ".trashbin-tracklist-btn",
  addButtonSelector: 'button[data-testid="add-to-playlist-button"]',
  autoAddButtonClassName: "trashbin-auto-add-btn"
};

// src/lib/track-utils.ts
var ENHANCED_RECOMMENDATION_REGEX = /enhanced_recommendation/;
function findTrackUriInProps(obj, depth = 0, maxDepth = 10) {
  if (depth > maxDepth || !obj || typeof obj !== "object")
    return null;
  if (typeof obj.uri === "string" && obj.uri.startsWith("spotify:track:")) {
    return obj.uri;
  }
  if (obj.props?.uri && typeof obj.props.uri === "string" && obj.props.uri.startsWith("spotify:track:")) {
    return obj.props.uri;
  }
  if (Array.isArray(obj.children)) {
    for (const child of obj.children) {
      const found = findTrackUriInProps(child, depth + 1, maxDepth);
      if (found)
        return found;
    }
  }
  if (obj.children && typeof obj.children === "object" && !Array.isArray(obj.children)) {
    const found = findTrackUriInProps(obj.children, depth + 1, maxDepth);
    if (found)
      return found;
  }
  if (obj.props?.children) {
    const found = findTrackUriInProps(obj.props.children, depth + 1, maxDepth);
    if (found)
      return found;
  }
  return null;
}
function getQueueTracks() {
  return (Spicetify?.Queue?.nextTracks || []).filter((track) => track.contextTrack.uri.includes("track"));
}
function extractTrackData(element) {
  let trackURI = null;
  let isEnhancedRecommendation = false;
  const elementWithFiber = element;
  const reactKey = Object.keys(elementWithFiber).find((k2) => k2.toLowerCase().includes("reactFiber".toLowerCase()));
  if (reactKey) {
    let fiber = elementWithFiber[reactKey];
    while (fiber) {
      try {
        const props = fiber.memoizedProps ?? fiber.pendingProps ?? fiber.props ?? {};
        if (props.item && typeof props.item === "object") {
          const item = props.item;
          if (item.uri && typeof item.uri === "string" && item.uri.startsWith("spotify:track:")) {
            trackURI = item.uri;
          }
          if (item.metadata && typeof item.metadata === "object") {
            const metadataString = JSON.stringify(item.metadata);
            if (ENHANCED_RECOMMENDATION_REGEX.test(metadataString)) {
              isEnhancedRecommendation = true;
            }
          }
          if (trackURI) {
            break;
          }
        }
        if (!trackURI) {
          const foundUri = findTrackUriInProps(props);
          if (foundUri) {
            trackURI = foundUri;
            break;
          }
        }
        fiber = fiber.return;
      } catch {
        break;
      }
    }
  }
  const artistURIs = Array.from(element.querySelectorAll(SELECTORS.ARTIST_LINK)).map((a) => a.href.match(/\/artist\/([a-zA-Z0-9]+)/)?.[1]).filter((id2) => Boolean(id2)).map((id2) => `spotify:artist:${id2}`);
  return { trackURI, artistURIs, isEnhancedRecommendation };
}
function isTrackEffectivelyTrashed(track) {
  const state = useTrashbinStore.getState();
  if (!track || !track.uri)
    return true;
  if (state.trashSongList[track.uri])
    return true;
  const artistUris = new Set;
  const playerTrack = track;
  for (const artist of playerTrack?.artists || []) {
    if (artist && artist.uri)
      artistUris.add(artist.uri);
  }
  if (track.metadata?.artist_uri)
    artistUris.add(track.metadata.artist_uri);
  let metaIndex = 1;
  while (track.metadata?.[`artist_uri:${metaIndex}`]) {
    artistUris.add(track.metadata[`artist_uri:${metaIndex}`]);
    metaIndex++;
  }
  for (const artistUri of artistUris) {
    if (state.trashArtistList[artistUri])
      return true;
  }
  return false;
}
async function skipToNextAllowedTrack() {
  const currentPlayerState = Spicetify.Player.data;
  if (!currentPlayerState?.context?.uri) {
    Spicetify.Player.next();
    return;
  }
  const currentContextUri = currentPlayerState.context.uri;
  for (const nextTrack of getQueueTracks()) {
    if (!isTrackEffectivelyTrashed(nextTrack.contextTrack)) {
      try {
        return await Spicetify.Player.playUri(currentContextUri, { featureIdentifier: "playlist" }, { skipTo: { uri: nextTrack.contextTrack.uri } });
      } catch (err) {
        console.error("Error skipping to next allowed track:", err);
      }
    }
  }
  Spicetify.Player.next();
}
function shouldSkipTrack(uri, type) {
  const currentTrack = Spicetify.Player.data?.item;
  if (!currentTrack)
    return false;
  if (type === Spicetify.URI.Type.TRACK) {
    return uri === currentTrack.uri;
  }
  if (type === Spicetify.URI.Type.ARTIST) {
    let count = 0;
    let artUri = currentTrack.metadata?.artist_uri;
    while (artUri) {
      if (uri === artUri)
        return true;
      count++;
      artUri = currentTrack.metadata?.[`artist_uri:${count}`];
    }
  }
  return false;
}
async function manageSmartShuffleQueue() {
  if (!document.querySelector(SELECTORS.SMART_SHUFFLE_BUTTON))
    return;
  const queueTracks = getQueueTracks();
  if (queueTracks.length === 0)
    return;
  const enhancedRecommendations = queueTracks.filter((track) => track?.contextTrack.metadata?.provider === "enhanced_recommendation");
  if (queueTracks.length > 4 && queueTracks.length > enhancedRecommendations.length) {
    const tracksToRemove = queueTracks.filter((track) => track.contextTrack.uri && !(track.contextTrack.metadata?.provider === "enhanced_recommendation") && useTrashbinStore.getState().getTrashStatus(track.contextTrack.uri).isTrashed).map((track) => ({
      uri: track.contextTrack.uri,
      uid: track.contextTrack.uid
    }));
    if (tracksToRemove.length === 0)
      return;
    await Spicetify.removeFromQueue(tracksToRemove);
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }
}

// src/store/trashbin-store.ts
var STORAGE_KEYS = {
  ENABLED: "trashbin-enabled",
  WIDGET: "TrashbinWidgetIcon",
  SONGS: "TrashSongList",
  ARTISTS: "TrashArtistList",
  AUTOPLAY_ON_START: "trashbin-autoplay-on-start",
  QUEUE_TRASHBIN: "trashbin-queue-enabled",
  TRACKLIST_TRASHBIN: "trashbin-tracklist-enabled",
  SKIP_TRASHED_TRACKS: "trashbin-skip-trashed-tracks",
  AUTO_CLEAN_QUEUE: "trashbin-auto-clean-queue",
  PLAYLIST_MONITOR: "trashbin-playlist-monitor",
  TRASH_ON_NEXT_HOTKEY: "trashbin-trash-on-next-hotkey",
  REMOTE_TOGGLE_ENABLED: "trashbin-remote-toggle-enabled",
  REMOTE_SKIPPING_ENABLED: "trashbin-remote-skipping-enabled",
  TRASH_VIA_LIKE: "trashbin-trash-via-like",
  AI_DETECTION: "trashbin-ai-detection"
};
function initValue(item, defaultValue) {
  try {
    const value = Spicetify.LocalStorage.get(item);
    return value ? JSON.parse(value) ?? defaultValue : defaultValue;
  } catch {
    return defaultValue;
  }
}
var useTrashbinStore = create((set, get2) => ({
  trashbinEnabled: true,
  widgetEnabled: true,
  autoplayOnStart: false,
  queueTrashbinEnabled: true,
  tracklistTrashbinEnabled: true,
  skipTrashedTracks: true,
  autoCleanQueue: false,
  playlistMonitorEnabled: true,
  trashOnNextHotkey: false,
  trashSongList: {},
  trashArtistList: {},
  userHitBack: false,
  remoteToggleEnabled: false,
  remoteSkippingEnabled: false,
  trashViaLikeEnabled: false,
  aiDetectionEnabled: false,
  aiAssetsReady: false,
  aiAssetsDownloading: false,
  initializeFromStorage: () => {
    set({
      trashbinEnabled: initValue(STORAGE_KEYS.ENABLED, true),
      widgetEnabled: initValue(STORAGE_KEYS.WIDGET, true),
      trashSongList: initValue(STORAGE_KEYS.SONGS, {}),
      trashArtistList: initValue(STORAGE_KEYS.ARTISTS, {}),
      autoplayOnStart: initValue(STORAGE_KEYS.AUTOPLAY_ON_START, false),
      queueTrashbinEnabled: initValue(STORAGE_KEYS.QUEUE_TRASHBIN, true),
      tracklistTrashbinEnabled: initValue(STORAGE_KEYS.TRACKLIST_TRASHBIN, true),
      skipTrashedTracks: initValue(STORAGE_KEYS.SKIP_TRASHED_TRACKS, true),
      autoCleanQueue: initValue(STORAGE_KEYS.AUTO_CLEAN_QUEUE, false),
      playlistMonitorEnabled: initValue(STORAGE_KEYS.PLAYLIST_MONITOR, true),
      trashOnNextHotkey: initValue(STORAGE_KEYS.TRASH_ON_NEXT_HOTKEY, false),
      remoteToggleEnabled: initValue(STORAGE_KEYS.REMOTE_TOGGLE_ENABLED, false),
      remoteSkippingEnabled: initValue(STORAGE_KEYS.REMOTE_SKIPPING_ENABLED, false),
      trashViaLikeEnabled: initValue(STORAGE_KEYS.TRASH_VIA_LIKE, false),
      aiDetectionEnabled: initValue(STORAGE_KEYS.AI_DETECTION, false)
    });
  },
  setTrashbinEnabled: (enabled) => {
    set({ trashbinEnabled: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.ENABLED, JSON.stringify(enabled));
  },
  setWidgetEnabled: (enabled) => {
    set({ widgetEnabled: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.WIDGET, JSON.stringify(enabled));
  },
  setAutoplayOnStart: (enabled) => {
    set({ autoplayOnStart: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.AUTOPLAY_ON_START, JSON.stringify(enabled));
  },
  setQueueTrashbinEnabled: (enabled) => {
    set({ queueTrashbinEnabled: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.QUEUE_TRASHBIN, JSON.stringify(enabled));
  },
  setTracklistTrashbinEnabled: (enabled) => {
    set({ tracklistTrashbinEnabled: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.TRACKLIST_TRASHBIN, JSON.stringify(enabled));
  },
  setSkipTrashedTracks: (enabled) => {
    set({ skipTrashedTracks: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.SKIP_TRASHED_TRACKS, JSON.stringify(enabled));
  },
  setAutoCleanQueue: (enabled) => {
    set({ autoCleanQueue: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.AUTO_CLEAN_QUEUE, JSON.stringify(enabled));
  },
  setPlaylistMonitorEnabled: (enabled) => {
    set({ playlistMonitorEnabled: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.PLAYLIST_MONITOR, JSON.stringify(enabled));
  },
  setTrashOnNextHotkey: (enabled) => {
    set({ trashOnNextHotkey: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.TRASH_ON_NEXT_HOTKEY, JSON.stringify(enabled));
  },
  setUserHitBack: (hitBack) => set({ userHitBack: hitBack }),
  setRemoteToggleEnabled: (enabled) => {
    set({ remoteToggleEnabled: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.REMOTE_TOGGLE_ENABLED, JSON.stringify(enabled));
  },
  setRemoteSkippingEnabled: (enabled) => {
    set({ remoteSkippingEnabled: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.REMOTE_SKIPPING_ENABLED, JSON.stringify(enabled));
  },
  toggleRemoteSkipping: () => {
    const state = get2();
    const newValue = !state.remoteSkippingEnabled;
    set({ remoteSkippingEnabled: newValue });
    Spicetify.LocalStorage.set(STORAGE_KEYS.REMOTE_SKIPPING_ENABLED, JSON.stringify(newValue));
  },
  setTrashViaLikeEnabled: (enabled) => {
    set({ trashViaLikeEnabled: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.TRASH_VIA_LIKE, JSON.stringify(enabled));
  },
  setAiDetectionEnabled: (enabled) => {
    set({ aiDetectionEnabled: enabled });
    Spicetify.LocalStorage.set(STORAGE_KEYS.AI_DETECTION, JSON.stringify(enabled));
  },
  setAiAssetsReady: (ready) => set({ aiAssetsReady: ready }),
  setAiAssetsDownloading: (downloading) => set({ aiAssetsDownloading: downloading }),
  toggleSongTrash: (uri, showNotification = true) => {
    const state = get2();
    const isTrashed = !!state.trashSongList[uri];
    const newList = { ...state.trashSongList };
    if (isTrashed) {
      delete newList[uri];
      if (showNotification) {
        Spicetify.showNotification(instance.t("MESSAGE_SONG_REMOVED"));
      }
    } else {
      newList[uri] = true;
      if (showNotification) {
        Spicetify.showNotification(instance.t("MESSAGE_SONG_ADDED"));
      }
      const currentSpotifyTrack = Spicetify.Player.data?.item;
      if (state.trashbinEnabled && currentSpotifyTrack && shouldSkipTrack(uri, Spicetify.URI.Type.TRACK)) {
        Spicetify.Player.next();
      }
    }
    set({ trashSongList: newList });
    Spicetify.LocalStorage.set(STORAGE_KEYS.SONGS, JSON.stringify(newList));
  },
  toggleArtistTrash: (uri, showNotification = true) => {
    const state = get2();
    const isTrashed = !!state.trashArtistList[uri];
    const newList = { ...state.trashArtistList };
    if (isTrashed) {
      delete newList[uri];
      if (showNotification) {
        Spicetify.showNotification(instance.t("MESSAGE_ARTIST_REMOVED"));
      }
    } else {
      newList[uri] = true;
      if (showNotification) {
        Spicetify.showNotification(instance.t("MESSAGE_ARTIST_ADDED"));
      }
      const currentSpotifyTrack = Spicetify.Player.data?.item;
      if (state.trashbinEnabled && currentSpotifyTrack && shouldSkipTrack(uri, Spicetify.URI.Type.ARTIST)) {
        Spicetify.Player.next();
      }
    }
    set({ trashArtistList: newList });
    Spicetify.LocalStorage.set(STORAGE_KEYS.ARTISTS, JSON.stringify(newList));
  },
  getTrashStatus: (uri) => {
    const state = get2();
    const uriObj = Spicetify.URI.fromString(uri);
    const isTrashed = uriObj.type === Spicetify.URI.Type.TRACK ? !!state.trashSongList[uri] : !!state.trashArtistList[uri];
    return { isTrashed, type: uriObj.type };
  },
  importTrashData: (songs, artists) => {
    set({ trashSongList: songs, trashArtistList: artists });
    Spicetify.LocalStorage.set(STORAGE_KEYS.SONGS, JSON.stringify(songs));
    Spicetify.LocalStorage.set(STORAGE_KEYS.ARTISTS, JSON.stringify(artists));
  },
  clearTrashbin: () => {
    const emptyList = {};
    set({ trashSongList: emptyList, trashArtistList: emptyList });
    Spicetify.LocalStorage.set(STORAGE_KEYS.SONGS, JSON.stringify(emptyList));
    Spicetify.LocalStorage.set(STORAGE_KEYS.ARTISTS, JSON.stringify(emptyList));
  },
  exportData: () => {
    const state = get2();
    return { songs: state.trashSongList, artists: state.trashArtistList };
  }
}));

// src/components/features/ai-probability-indicator.tsx
var import_react6 = __toESM(require_react(), 1);
var AiProbabilityIndicator = (props) => {
  const fillRef = import_react6.useRef(null);
  import_react6.useEffect(() => {
    const timer = setTimeout(() => {
      if (fillRef.current) {
        fillRef.current.style.width = `${props.probability * 100}%`;
      }
    }, 10);
    return () => clearTimeout(timer);
  }, [props.probability]);
  return /* @__PURE__ */ import_react6.default.createElement("span", {
    className: "inline-flex! items-center! gap-0.5! whitespace-nowrap!"
  }, /* @__PURE__ */ import_react6.default.createElement("span", {
    className: "text-xs!"
  }, "\uD83E\uDDD1‍\uD83C\uDFA4"), /* @__PURE__ */ import_react6.default.createElement("span", {
    className: "relative! inline-block! h-2! w-12! overflow-hidden! rounded-full!",
    style: { backgroundColor: "#22c55e" }
  }, /* @__PURE__ */ import_react6.default.createElement("span", {
    ref: fillRef,
    className: "absolute! right-0! h-full!",
    style: {
      backgroundColor: "#c53232",
      transition: "width 0.5s ease-out",
      width: "50%"
    }
  })), /* @__PURE__ */ import_react6.default.createElement("span", {
    className: "text-xs!"
  }, "\uD83E\uDD16"));
};
function createAiIndicatorHTML(probability) {
  const fillWidth = `${probability * 100}%`;
  return `<span style="display:inline-flex;align-items:center;gap:2px;white-space:nowrap" class="trashbin-ai-indicator">
    <span style="font-size:12px">\uD83E\uDDD1‍\uD83C\uDFA4</span>
    <span style="position:relative;display:inline-block;width:50px;height:8px;border-radius:9999px;background:#22c55e;overflow:hidden">
      <span style="position:absolute;right:0;height:100%;width:${fillWidth};background:#c53232;transition:width 0.5s ease-out"></span>
    </span>
    <span style="font-size:12px">\uD83E\uDD16</span>
  </span>`;
}

// src/components/features/ai-detection-widget.tsx
var AiDetectionWidget = () => {
  const store = useTrashbinStore();
  const [probability, setProbability] = import_react7.useState(null);
  const [currentUri, setCurrentUri] = import_react7.useState(null);
  import_react7.useEffect(() => {
    if (!store.aiDetectionEnabled || !store.aiAssetsReady) {
      setProbability(null);
      return;
    }
    const classify = async () => {
      const track = Spicetify.Player.data?.item;
      if (!track?.uri || !track.uri.startsWith("spotify:track:")) {
        setProbability(null);
        return;
      }
      setCurrentUri(track.uri);
      const cached = getCachedResult(track.uri);
      if (cached !== undefined) {
        setProbability(cached);
        return;
      }
      setProbability(null);
      const result = await classifyTrack(track.uri);
      const current = Spicetify.Player.data?.item;
      if (current?.uri === track.uri) {
        setProbability(result);
      }
    };
    classify();
    const handleSongChange = () => classify();
    Spicetify.Player.addEventListener("songchange", handleSongChange);
    return () => {
      Spicetify.Player.removeEventListener("songchange", handleSongChange);
    };
  }, [store.aiDetectionEnabled, store.aiAssetsReady]);
  if (!store.aiDetectionEnabled || !store.aiAssetsReady || probability === null) {
    return null;
  }
  return /* @__PURE__ */ import_react7.default.createElement("div", {
    className: "pointer-events-auto! fixed! z-50!",
    style: { bottom: "90px", right: "24px" }
  }, /* @__PURE__ */ import_react7.default.createElement(AiProbabilityIndicator, {
    probability
  }));
};

// src/hooks/use-ai-indicator-injection.ts
var import_react9 = __toESM(require_react(), 1);

// src/hooks/use-mutation-observer.ts
var import_react8 = __toESM(require_react(), 1);
var useMutationObserver = (callback, shouldTrigger, options = {}) => {
  const { enabled = true } = options;
  import_react8.useEffect(() => {
    if (!enabled)
      return;
    const observer = new MutationObserver((mutations) => {
      if (shouldTrigger(mutations)) {
        callback();
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    return () => observer.disconnect();
  }, [enabled, callback, shouldTrigger]);
};

// src/hooks/use-ai-indicator-injection.ts
var INDICATOR_CLASS = "trashbin-ai-indicator";
var useAiIndicatorInjection = () => {
  const store = useTrashbinStore();
  const enabled = store.aiDetectionEnabled && store.aiAssetsReady && store.trashbinEnabled;
  const removeIndicators = () => {
    document.querySelectorAll(`.${INDICATOR_CLASS}`).forEach((el2) => el2.remove());
  };
  const injectIndicators = async () => {
    if (!enabled)
      return;
    const container = document.querySelector(TRACKLIST_CONFIG.containerSelector);
    if (!container)
      return;
    const rows = container.querySelectorAll(TRACKLIST_CONFIG.rowSelector);
    for (const row of rows) {
      if (row.querySelector(`.${INDICATOR_CLASS}`))
        continue;
      const trackData = extractTrackData(row);
      if (!trackData.trackURI)
        continue;
      const cached = getCachedResult(trackData.trackURI);
      if (cached !== undefined) {
        const indicator = document.createElement("span");
        indicator.innerHTML = createAiIndicatorHTML(cached);
        indicator.className = INDICATOR_CLASS;
        indicator.style.marginLeft = "auto";
        indicator.style.pointerEvents = "auto";
        const moreBtn = row.querySelector(TRACKLIST_CONFIG.moreButtonSelector);
        if (moreBtn?.parentElement) {
          moreBtn.parentElement.insertBefore(indicator, moreBtn);
        }
      } else if (!isProcessing(trackData.trackURI)) {
        classifyTrack(trackData.trackURI).then((result) => {
          if (result !== null) {
            injectIndicators();
          }
        });
      }
    }
  };
  import_react9.useEffect(() => {
    if (!enabled) {
      removeIndicators();
    } else {
      injectIndicators();
    }
  }, [enabled]);
  const shouldTrigger = (mutations) => mutations.some((mutation) => Array.from(mutation.addedNodes).some((node) => {
    if (node.nodeType !== Node.ELEMENT_NODE)
      return false;
    const element = node;
    return (element.closest?.(TRACKLIST_CONFIG.containerSelector) || element.querySelector?.(TRACKLIST_CONFIG.containerSelector)) && !element.classList?.contains(INDICATOR_CLASS);
  }));
  useMutationObserver(injectIndicators, shouldTrigger, { enabled });
};

// src/components/features/injections/ai-tracklist.tsx
var AiTracklist = () => {
  useAiIndicatorInjection();
  return null;
};

// src/hooks/use-auto-add-recommendations.tsx
var import_react12 = __toESM(require_react(), 1);

// node_modules/react-icons/lib/iconBase.mjs
var import_react11 = __toESM(require_react(), 1);

// node_modules/react-icons/lib/iconContext.mjs
var import_react10 = __toESM(require_react(), 1);
var DefaultContext = {
  color: undefined,
  size: undefined,
  className: undefined,
  style: undefined,
  attr: undefined
};
var IconContext = import_react10.default.createContext && /* @__PURE__ */ import_react10.default.createContext(DefaultContext);

// node_modules/react-icons/lib/iconBase.mjs
var _excluded = ["attr", "size", "title"];
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0;i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function ownKeys(e, r) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread(e) {
  for (var r = 1;r < arguments.length; r++) {
    var t2 = arguments[r] != null ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t2), true).forEach(function(r2) {
      _defineProperty(e, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return typeof i == "symbol" ? i : i + "";
}
function _toPrimitive(t2, r) {
  if (typeof t2 != "object" || !t2)
    return t2;
  var e = t2[Symbol.toPrimitive];
  if (e !== undefined) {
    var i = e.call(t2, r || "default");
    if (typeof i != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(t2);
}
function Tree2Element(tree) {
  return tree && tree.map((node, i) => /* @__PURE__ */ import_react11.default.createElement(node.tag, _objectSpread({
    key: i
  }, node.attr), Tree2Element(node.child)));
}
function GenIcon(data) {
  return (props) => /* @__PURE__ */ import_react11.default.createElement(IconBase, _extends({
    attr: _objectSpread({}, data.attr)
  }, props), Tree2Element(data.child));
}
function IconBase(props) {
  var elem = (conf) => {
    var {
      attr,
      size,
      title
    } = props, svgProps = _objectWithoutProperties(props, _excluded);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return /* @__PURE__ */ import_react11.default.createElement("svg", _extends({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: _objectSpread(_objectSpread({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && /* @__PURE__ */ import_react11.default.createElement("title", null, title), props.children);
  };
  return IconContext !== undefined ? /* @__PURE__ */ import_react11.default.createElement(IconContext.Consumer, null, (conf) => elem(conf)) : elem(DefaultContext);
}

// node_modules/react-icons/bs/index.mjs
function BsFillPauseFill(props) {
  return GenIcon({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5m5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5" }, child: [] }] })(props);
}
function BsFillPlayFill(props) {
  return GenIcon({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393" }, child: [] }] })(props);
}
function BsMusicNote(props) {
  return GenIcon({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M9 13c0 1.105-1.12 2-2.5 2S4 14.105 4 13s1.12-2 2.5-2 2.5.895 2.5 2" }, child: [] }, { tag: "path", attr: { fillRule: "evenodd", d: "M9 3v10H8V3z" }, child: [] }, { tag: "path", attr: { d: "M8 2.82a1 1 0 0 1 .804-.98l3-.6A1 1 0 0 1 13 2.22V4L8 5z" }, child: [] }] })(props);
}
function BsPerson(props) {
  return GenIcon({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M8 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6m2-3a2 2 0 1 1-4 0 2 2 0 0 1 4 0m4 8c0 1-1 1-1 1H3s-1 0-1-1 1-4 6-4 6 3 6 4m-1-.004c-.001-.246-.154-.986-.832-1.664C11.516 10.68 10.289 10 8 10s-3.516.68-4.168 1.332c-.678.678-.83 1.418-.832 1.664z" }, child: [] }] })(props);
}
function BsTrash3(props) {
  return GenIcon({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M6.5 1h3a.5.5 0 0 1 .5.5v1H6v-1a.5.5 0 0 1 .5-.5M11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3A1.5 1.5 0 0 0 5 1.5v1H1.5a.5.5 0 0 0 0 1h.538l.853 10.66A2 2 0 0 0 4.885 16h6.23a2 2 0 0 0 1.994-1.84l.853-10.66h.538a.5.5 0 0 0 0-1zm1.958 1-.846 10.58a1 1 0 0 1-.997.92h-6.23a1 1 0 0 1-.997-.92L3.042 3.5zm-7.487 1a.5.5 0 0 1 .528.47l.5 8.5a.5.5 0 0 1-.998.06L5 5.03a.5.5 0 0 1 .47-.53Zm5.058 0a.5.5 0 0 1 .47.53l-.5 8.5a.5.5 0 1 1-.998-.06l.5-8.5a.5.5 0 0 1 .528-.47M8 4.5a.5.5 0 0 1 .5.5v8.5a.5.5 0 0 1-1 0V5a.5.5 0 0 1 .5-.5" }, child: [] }] })(props);
}

// src/hooks/use-auto-add-recommendations.tsx
var DELAY_BETWEEN_ADDS = 800;
var DELAY_AFTER_REFRESH = 3000;
var DELAY_BETWEEN_CYCLES = 1500;
var INJECT_CHECK_INTERVAL = 2000;
function wait(ms2) {
  return new Promise((resolve) => setTimeout(resolve, ms2));
}
var PLAY_ICON = Spicetify.ReactDOMServer.renderToString(/* @__PURE__ */ import_react12.default.createElement(BsFillPlayFill, {
  size: 26
}));
var PAUSE_ICON = Spicetify.ReactDOMServer.renderToString(/* @__PURE__ */ import_react12.default.createElement(BsFillPauseFill, {
  size: 26
}));
function findRefreshButton() {
  const grid = document.querySelector(AUTO_ADD_CONFIG.gridSelector);
  if (!grid)
    return null;
  let container = grid.parentElement;
  while (container && container.tagName !== "MAIN") {
    const buttons = container.querySelectorAll("button");
    for (const btn of buttons) {
      if (btn.textContent?.trim() === "Refresh") {
        return btn;
      }
    }
    container = container.parentElement;
  }
  return null;
}
var useAutoAddRecommendations = () => {
  const store = useTrashbinStore();
  const isRunningRef = import_react12.useRef(false);
  const abortRef = import_react12.useRef(false);
  const buttonRef = import_react12.useRef(null);
  const updateButtonIcon = () => {
    if (buttonRef.current) {
      buttonRef.current.innerHTML = isRunningRef.current ? PAUSE_ICON : PLAY_ICON;
    }
  };
  const runLoop = async () => {
    while (isRunningRef.current && !abortRef.current) {
      const grid = document.querySelector(AUTO_ADD_CONFIG.gridSelector);
      if (!grid) {
        isRunningRef.current = false;
        updateButtonIcon();
        return;
      }
      const rows = grid.querySelectorAll(AUTO_ADD_CONFIG.rowSelector);
      if (rows.length === 0) {
        await wait(DELAY_BETWEEN_CYCLES);
        continue;
      }
      const nonTrashedRows = [];
      let allHaveTrashButtons = true;
      for (const row of rows) {
        const trashBtn = row.querySelector(AUTO_ADD_CONFIG.trashButtonSelector);
        if (!trashBtn) {
          allHaveTrashButtons = false;
          continue;
        }
        const isTrashed = trashBtn.dataset.visuallyTrashed === "true";
        if (!isTrashed) {
          nonTrashedRows.push(row);
        }
      }
      if (!allHaveTrashButtons && nonTrashedRows.length === 0) {
        await wait(DELAY_BETWEEN_CYCLES);
        continue;
      }
      if (nonTrashedRows.length > 0) {
        for (const row of nonTrashedRows) {
          if (!isRunningRef.current || abortRef.current)
            return;
          const addBtn = row.querySelector(AUTO_ADD_CONFIG.addButtonSelector);
          if (addBtn) {
            addBtn.click();
            await wait(DELAY_BETWEEN_ADDS);
          }
        }
        await wait(DELAY_BETWEEN_CYCLES);
      } else {
        const refreshBtn = findRefreshButton();
        if (refreshBtn) {
          refreshBtn.click();
          await wait(DELAY_AFTER_REFRESH);
        } else {
          isRunningRef.current = false;
          updateButtonIcon();
          return;
        }
      }
    }
  };
  const startLoop = () => {
    isRunningRef.current = true;
    abortRef.current = false;
    updateButtonIcon();
    runLoop();
  };
  const stopLoop = () => {
    isRunningRef.current = false;
    updateButtonIcon();
  };
  const cleanupButton = () => {
    const wrapper = document.querySelector(`.${AUTO_ADD_CONFIG.autoAddButtonClassName}-wrapper`);
    if (wrapper) {
      const refreshBtn = wrapper.querySelector(`button:not(.${AUTO_ADD_CONFIG.autoAddButtonClassName})`);
      if (refreshBtn) {
        wrapper.parentElement?.insertBefore(refreshBtn, wrapper);
      }
      wrapper.remove();
    }
    buttonRef.current = null;
  };
  const injectAutoAddButton = () => {
    if (!store.trashbinEnabled) {
      cleanupButton();
      return;
    }
    if (buttonRef.current?.isConnected)
      return;
    const refreshBtn = findRefreshButton();
    if (!refreshBtn)
      return;
    const btn = document.createElement("button");
    btn.className = `${refreshBtn.className} ${AUTO_ADD_CONFIG.autoAddButtonClassName}`;
    btn.title = "Auto-add recommendations";
    btn.innerHTML = isRunningRef.current ? PAUSE_ICON : PLAY_ICON;
    btn.setAttribute("data-encore-id", refreshBtn.getAttribute("data-encore-id") || "buttonTertiary");
    btn.onclick = (e) => {
      e.stopPropagation();
      if (isRunningRef.current) {
        stopLoop();
      } else {
        startLoop();
      }
    };
    buttonRef.current = btn;
    const wrapper = document.createElement("div");
    wrapper.className = `${AUTO_ADD_CONFIG.autoAddButtonClassName}-wrapper flex items-center justify-between w-full`;
    refreshBtn.parentElement?.insertBefore(wrapper, refreshBtn);
    wrapper.appendChild(btn);
    wrapper.appendChild(refreshBtn);
  };
  import_react12.useEffect(() => {
    if (!store.trashbinEnabled) {
      abortRef.current = true;
      isRunningRef.current = false;
      cleanupButton();
      return;
    }
    injectAutoAddButton();
    const interval = setInterval(injectAutoAddButton, INJECT_CHECK_INTERVAL);
    return () => {
      clearInterval(interval);
    };
  }, [store.trashbinEnabled]);
  import_react12.useEffect(() => {
    return () => {
      abortRef.current = true;
      isRunningRef.current = false;
      cleanupButton();
    };
  }, []);
};

// src/components/features/injections/auto-add-recommendations.tsx
var AutoAddRecommendations = () => {
  useAutoAddRecommendations();
  return null;
};

// src/hooks/use-trash-button-injection.ts
var import_react14 = __toESM(require_react(), 1);

// src/components/icons.tsx
var import_react13 = __toESM(require_react(), 1);
var TRASH_ICON = (size, className) => Spicetify.ReactDOMServer.renderToString(/* @__PURE__ */ import_react13.default.createElement(BsTrash3, {
  className,
  size
}));

// src/hooks/use-trash-button-injection.ts
var useTrashButtonInjection = (config, enabled = true) => {
  const store = useTrashbinStore();
  const removeTrashButtons = () => {
    document.querySelectorAll(config.buttonSelector).forEach((btn) => btn.remove());
  };
  const injectTrashButtons = async () => {
    removeTrashButtons();
    if (!enabled || !store.trashbinEnabled)
      return;
    const container = document.querySelector(config.containerSelector);
    if (!container)
      return;
    container.querySelectorAll(config.moreButtonSelector).forEach((moreBtn) => {
      const row = moreBtn.closest(config.rowSelector);
      if (!row)
        return;
      const trackData = extractTrackData(moreBtn.parentElement || row);
      if (!trackData.trackURI || row.querySelector(config.buttonSelector))
        return;
      const isTrashed = !!store.trashSongList[trackData.trackURI];
      const btn = document.createElement("button");
      btn.className = `${config.buttonClassName} bg-transparent border-none p-2 opacity-70 cursor-pointer hover:opacity-100 transition-opacity`;
      btn.innerHTML = TRASH_ICON(16, isTrashed ? "fill-[#22c55e]" : "");
      btn.dataset.visuallyTrashed = isTrashed.toString();
      btn.onclick = (e) => {
        e.stopPropagation();
        const newState = btn.dataset.visuallyTrashed !== "true";
        btn.innerHTML = TRASH_ICON(16, newState ? "fill-[#22c55e]" : "");
        btn.dataset.visuallyTrashed = newState.toString();
        store.toggleSongTrash(trackData.trackURI);
      };
      moreBtn.parentElement?.insertBefore(btn, moreBtn);
    });
  };
  import_react14.useEffect(() => {
    if (!enabled || !store.trashbinEnabled) {
      removeTrashButtons();
    } else {
      injectTrashButtons();
    }
  }, [enabled, store.trashbinEnabled, removeTrashButtons, injectTrashButtons]);
  const shouldTrigger = (mutations) => mutations.some((mutation) => Array.from(mutation.addedNodes).some((node) => {
    if (node.nodeType !== Node.ELEMENT_NODE)
      return false;
    const element = node;
    return (element.closest?.(config.containerSelector) || element.querySelector?.(config.containerSelector)) && !element.classList?.contains(config.buttonClassName.split(" ")[0]);
  }));
  useMutationObserver(injectTrashButtons, shouldTrigger, {
    enabled: store.trashbinEnabled && enabled
  });
};

// src/components/features/injections/trashbin-queuelist.tsx
var TrashbinQueuelist = () => {
  const queueTrashbinEnabled = useTrashbinStore((state) => state.queueTrashbinEnabled);
  useTrashButtonInjection(QUEUELIST_CONFIG, queueTrashbinEnabled);
  return null;
};

// src/components/features/injections/trashbin-tracklist.tsx
var TrashbinTracklist = () => {
  const tracklistTrashbinEnabled = useTrashbinStore((state) => state.tracklistTrashbinEnabled);
  useTrashButtonInjection(TRACKLIST_CONFIG, tracklistTrashbinEnabled);
  return null;
};

// src/components/features/trashbin-context-menu.tsx
var import_react15 = __toESM(require_react(), 1);

// src/hooks/use-trash-operations.ts
var useTrashOperations = () => {
  const { t: t2 } = useTranslation();
  const store = useTrashbinStore();
  const handleTrashToggle = (uris) => {
    const uri = uris[0];
    const uriObj = Spicetify.URI.fromString(uri);
    if (uriObj.type === Spicetify.URI.Type.TRACK) {
      store.toggleSongTrash(uri);
    } else if (uriObj.type === Spicetify.URI.Type.ARTIST) {
      store.toggleArtistTrash(uri);
    }
  };
  const shouldAddContextMenu = (uris) => {
    if (uris.length > 1 || !store.trashbinEnabled)
      return false;
    const { type } = store.getTrashStatus(uris[0]);
    return type === Spicetify.URI.Type.TRACK || type === Spicetify.URI.Type.ARTIST;
  };
  const getContextMenuLabel = (uri) => {
    const { isTrashed } = store.getTrashStatus(uri);
    return isTrashed ? t2("ACTION_UNTHROW") : t2("ACTION_THROW");
  };
  return {
    handleTrashToggle,
    shouldAddContextMenu,
    getContextMenuLabel
  };
};

// src/components/features/trashbin-context-menu.tsx
function TrashbinContextMenu() {
  const { t: t2 } = useTranslation();
  const trashOperations = useTrashOperations();
  const contextMenuItemRef = import_react15.useRef(null);
  const shouldAddContextMenuWithUpdate = (uris) => {
    const shouldAdd = trashOperations.shouldAddContextMenu(uris);
    if (shouldAdd && contextMenuItemRef.current) {
      contextMenuItemRef.current.name = trashOperations.getContextMenuLabel(uris[0]);
    }
    return shouldAdd;
  };
  import_react15.useEffect(() => {
    const contextMenuItem = new Spicetify.ContextMenu.Item(t2("ACTION_THROW"), trashOperations.handleTrashToggle, shouldAddContextMenuWithUpdate, TRASH_ICON(15));
    contextMenuItemRef.current = contextMenuItem;
    contextMenuItem.register();
    return () => contextMenuItem.deregister();
  }, [trashOperations.handleTrashToggle, shouldAddContextMenuWithUpdate]);
  return null;
}

// src/components/features/trashbin-widget.tsx
var import_react16 = __toESM(require_react(), 1);
var TrashbinWidget = import_react16.default.memo(() => {
  const { t: t2 } = useTranslation();
  const store = useTrashbinStore();
  const widgetRef = import_react16.useRef(null);
  const updateWidgetState = (widget) => {
    const currentTrack = Spicetify.Player.data?.item;
    if (!currentTrack)
      return;
    const isTrack = Spicetify.URI.fromString(currentTrack.uri).type === Spicetify.URI.Type.TRACK;
    const isTrashed = !!store.trashSongList[currentTrack.uri];
    if (isTrack) {
      widget.active = isTrashed;
      widget.label = isTrashed ? t2("ACTION_UNTHROW") : t2("ACTION_THROW");
      widget.icon = TRASH_ICON(18, isTrashed ? "fill-[#22c55e]" : "");
    } else {
      widget.deregister();
    }
  };
  import_react16.useEffect(() => {
    const widget = new Spicetify.Playbar.Widget(t2("ACTION_THROW"), TRASH_ICON(18), () => {
      const currentTrack = Spicetify.Player.data?.item;
      if (currentTrack)
        store.toggleSongTrash(currentTrack.uri);
    }, false, false, store.widgetEnabled && store.trashbinEnabled);
    widgetRef.current = widget;
    updateWidgetState(widget);
    const handleSongChange = () => updateWidgetState(widget);
    Spicetify.Player.addEventListener("songchange", handleSongChange);
    return () => {
      Spicetify.Player.removeEventListener("songchange", handleSongChange);
      widget.deregister();
    };
  }, [store.trashbinEnabled, store.widgetEnabled, store.trashSongList]);
  return null;
});

// src/components/ui/settings-modal.tsx
var import_react17 = __toESM(require_react(), 1);

// node_modules/react-icons/hi2/index.mjs
function HiOutlineQuestionMarkCircle(props) {
  return GenIcon({ tag: "svg", attr: { fill: "none", viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", d: "M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z" }, child: [] }] })(props);
}

// src/lib/utils.ts
function cn2(...inputs) {
  return inputs.filter(Boolean).join(" ");
}

// src/components/ui/settings-modal.tsx
var Tooltip = ({ children, content }) => {
  const [isVisible, setIsVisible] = import_react17.useState(false);
  const [position, setPosition] = import_react17.useState({ x: 0, y: 0 });
  const timeoutRef = import_react17.useRef();
  const handleMouseEnter = (e) => {
    clearTimeout(timeoutRef.current);
    const rect = e.currentTarget.getBoundingClientRect();
    setPosition({
      x: rect.left + rect.width / 2,
      y: rect.top - 8
    });
    setIsVisible(true);
  };
  const handleMouseLeave = () => {
    timeoutRef.current = setTimeout(() => {
      setIsVisible(false);
    }, 100);
  };
  import_react17.useEffect(() => {
    return () => clearTimeout(timeoutRef.current);
  }, []);
  return /* @__PURE__ */ import_react17.default.createElement(import_react17.default.Fragment, null, /* @__PURE__ */ import_react17.default.createElement("span", {
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }, children), isVisible && /* @__PURE__ */ import_react17.default.createElement("div", {
    className: "pointer-events-none fixed z-50 rounded px-2 py-1 text-xs shadow-lg",
    style: {
      left: position.x,
      top: position.y,
      transform: "translate(-50%, -100%)",
      maxWidth: "200px",
      wordWrap: "break-word",
      backgroundColor: "black",
      color: "white"
    }
  }, content, /* @__PURE__ */ import_react17.default.createElement("div", {
    className: "absolute top-full left-1/2 -translate-x-1/2 transform border-4 border-transparent",
    style: { borderTopColor: "black" }
  })));
};
var Toggle = ({ label, enabled, onChange, description, disabled }) => /* @__PURE__ */ import_react17.default.createElement("div", {
  className: cn2("flex items-center justify-between gap-2.5! py-2.5!", disabled && "opacity-50!")
}, /* @__PURE__ */ import_react17.default.createElement("label", {
  className: "flex w-full items-center gap-1.5! pr-4"
}, label, description && /* @__PURE__ */ import_react17.default.createElement(Tooltip, {
  content: description
}, /* @__PURE__ */ import_react17.default.createElement("span", {
  className: "inline-flex! cursor-help! text-[rgba(var(--spice-rgb-text),0.5)]! transition-colors! hover:text-(--spice-text)!"
}, /* @__PURE__ */ import_react17.default.createElement(HiOutlineQuestionMarkCircle, {
  size: 14
})))), /* @__PURE__ */ import_react17.default.createElement("div", {
  className: "text-right"
}, /* @__PURE__ */ import_react17.default.createElement("button", {
  className: cn2("flex! items-center! rounded-full! border-0!", "ml-3! p-2! transition-colors!", "bg-[rgba(var(--spice-rgb-shadow),0.7)]! text-(--spice-text)!", !enabled && "text-[rgba(var(--spice-rgb-text),0.3)]!", disabled ? "cursor-not-allowed!" : "cursor-pointer!"),
  type: "button",
  disabled,
  onClick: (event) => {
    event.preventDefault();
    event.stopPropagation();
    if (!disabled)
      onChange(!enabled);
  }
}, /* @__PURE__ */ import_react17.default.createElement("svg", {
  height: "16",
  width: "16",
  viewBox: "0 0 16 16",
  fill: "currentColor"
}, enabled && /* @__PURE__ */ import_react17.default.createElement("path", {
  d: "M8.797 2.5a.5.5 0 0 0-.594 0L2.5 6.5v7a1 1 0 0 0 1 1h9a1 1 0 0 0 1-1v-7l-5.703-4z"
})))));
var ActionButton = ({ label, description, onClick }) => /* @__PURE__ */ import_react17.default.createElement("div", {
  className: "flex items-center justify-between gap-2.5! py-2.5!"
}, /* @__PURE__ */ import_react17.default.createElement("label", {
  className: "w-full pr-4"
}, description), /* @__PURE__ */ import_react17.default.createElement("div", {
  className: "text-right"
}, /* @__PURE__ */ import_react17.default.createElement("button", {
  className: cn2("rounded-full! bg-transparent! font-bold! transition-transform!", "border! border-[#727272]! px-3.75! duration-33!", "min-h-8! cursor-pointer! text-(--spice-text)!", "hover:scale-[1.04]! hover:border-(--spice-text)!"),
  onClick
}, label)));
var SettingsModal = () => {
  const { t: t2 } = useTranslation();
  const store = useTrashbinStore();
  const handleFileImport = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.onchange = (e) => {
      const file = e.target.files?.[0];
      if (!file)
        return;
      const reader = new FileReader;
      reader.onload = (e2) => {
        try {
          const data = JSON.parse(e2.target?.result);
          store.importTrashData(data.songs || {}, data.artists || {});
          Spicetify.showNotification(t2("BACKUP_RESTORE_SUCCESS"));
        } catch {
          Spicetify.showNotification(t2("BACKUP_FILE_READ_FAILED"), true);
        }
      };
      reader.readAsText(file);
    };
    input.click();
  };
  const handleExport = async () => {
    try {
      const handle = await window.showSaveFilePicker?.({
        suggestedName: t2("BACKUP_SUGGESTED_FILENAME"),
        types: [{ accept: { "application/json": [".json"] } }]
      });
      const writable = await handle?.createWritable();
      await writable?.write(JSON.stringify(store.exportData()));
      await writable?.close();
      Spicetify.showNotification(t2("BACKUP_SAVE_SUCCESS"));
    } catch {
      Spicetify.showNotification(t2("BACKUP_SAVE_FAILED"));
    }
  };
  const handleCopy = () => {
    Spicetify.Platform.ClipboardAPI.copy(JSON.stringify(store.exportData()));
    Spicetify.showNotification(t2("MESSAGE_COPIED"));
  };
  const handleClear = () => {
    store.clearTrashbin();
    Spicetify.showNotification(t2("MESSAGE_CLEARED"));
  };
  return /* @__PURE__ */ import_react17.default.createElement("div", {
    className: "p-4"
  }, /* @__PURE__ */ import_react17.default.createElement("h2", {
    className: "my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"
  }, t2("SETTINGS_OPTIONS")), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_ENABLED"),
    enabled: store.trashbinEnabled,
    onChange: store.setTrashbinEnabled,
    description: t2("DESCRIPTION_SETTINGS_ENABLED")
  }), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_SHOW_WIDGET"),
    enabled: store.widgetEnabled,
    onChange: store.setWidgetEnabled,
    description: t2("DESCRIPTION_SETTINGS_SHOW_WIDGET")
  }), /* @__PURE__ */ import_react17.default.createElement("h2", {
    className: "my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"
  }, t2("SETTINGS_FEATURES")), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_AUTOPLAY"),
    enabled: store.autoplayOnStart,
    onChange: store.setAutoplayOnStart,
    description: t2("DESCRIPTION_SETTINGS_AUTOPLAY")
  }), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_QUEUE_TRASHBIN"),
    enabled: store.queueTrashbinEnabled,
    onChange: store.setQueueTrashbinEnabled,
    description: t2("DESCRIPTION_SETTINGS_QUEUE_TRASHBIN")
  }), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_TRACKLIST_TRASHBIN"),
    enabled: store.tracklistTrashbinEnabled,
    onChange: store.setTracklistTrashbinEnabled,
    description: t2("DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN")
  }), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_SKIP_TRASHED_TRACKS"),
    enabled: store.skipTrashedTracks,
    onChange: store.setSkipTrashedTracks,
    description: t2("DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS")
  }), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_AUTO_CLEAN_QUEUE"),
    enabled: store.autoCleanQueue,
    onChange: store.setAutoCleanQueue,
    description: t2("DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE")
  }), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_PLAYLIST_MONITOR"),
    enabled: store.playlistMonitorEnabled,
    onChange: store.setPlaylistMonitorEnabled,
    description: t2("DESCRIPTION_SETTINGS_PLAYLIST_MONITOR")
  }), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_TRASH_ON_NEXT_HOTKEY"),
    enabled: store.trashOnNextHotkey,
    onChange: store.setTrashOnNextHotkey,
    description: t2("DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY")
  }), /* @__PURE__ */ import_react17.default.createElement("h2", {
    className: "my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"
  }, t2("SETTINGS_REMOTE_CONTROL")), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_REMOTE_TOGGLE"),
    enabled: store.remoteToggleEnabled,
    onChange: store.setRemoteToggleEnabled,
    description: t2("DESCRIPTION_SETTINGS_REMOTE_TOGGLE")
  }), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_REMOTE_SKIPPING"),
    enabled: store.remoteSkippingEnabled,
    onChange: store.setRemoteSkippingEnabled,
    description: t2("DESCRIPTION_SETTINGS_REMOTE_SKIPPING"),
    disabled: !store.remoteToggleEnabled
  }), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_TRASH_VIA_LIKE"),
    enabled: store.trashViaLikeEnabled,
    onChange: store.setTrashViaLikeEnabled,
    description: t2("DESCRIPTION_SETTINGS_TRASH_VIA_LIKE"),
    disabled: !store.remoteToggleEnabled
  }), /* @__PURE__ */ import_react17.default.createElement("h2", {
    className: "my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"
  }, t2("SETTINGS_AI_DETECTION")), /* @__PURE__ */ import_react17.default.createElement(Toggle, {
    label: t2("SETTINGS_AI_DETECTION_ENABLED"),
    enabled: store.aiDetectionEnabled,
    onChange: store.setAiDetectionEnabled,
    description: t2("DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED")
  }), store.aiDetectionEnabled && /* @__PURE__ */ import_react17.default.createElement("div", {
    className: "py-1! text-xs! text-[rgba(var(--spice-rgb-text),0.5)]!"
  }, store.aiAssetsDownloading ? t2("AI_ASSETS_DOWNLOADING") : store.aiAssetsReady ? t2("AI_ASSETS_READY") : t2("AI_ASSETS_NOT_READY")), /* @__PURE__ */ import_react17.default.createElement("h2", {
    className: "my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"
  }, t2("SETTINGS_LOCAL_STORAGE")), /* @__PURE__ */ import_react17.default.createElement(ActionButton, {
    label: t2("ACTION_COPY"),
    description: t2("DESCRIPTION_COPY"),
    onClick: handleCopy
  }), /* @__PURE__ */ import_react17.default.createElement(ActionButton, {
    label: t2("ACTION_EXPORT"),
    description: t2("DESCRIPTION_EXPORT"),
    onClick: handleExport
  }), /* @__PURE__ */ import_react17.default.createElement(ActionButton, {
    label: t2("ACTION_IMPORT"),
    description: t2("DESCRIPTION_IMPORT"),
    onClick: handleFileImport
  }), /* @__PURE__ */ import_react17.default.createElement(ActionButton, {
    label: t2("ACTION_CLEAR"),
    description: t2("DESCRIPTION_CLEAR"),
    onClick: handleClear
  }));
};
function TrashbinSettings() {
  const { t: t2 } = useTranslation();
  const [isOpen, setIsOpen] = import_react17.useState(false);
  import_react17.useEffect(() => {
    const menuItem = new Spicetify.Menu.Item(t2("TRASHBIN_NAME"), false, () => setIsOpen(true), TRASH_ICON(15));
    menuItem.register();
    return () => menuItem.deregister();
  }, []);
  import_react17.useEffect(() => {
    if (!isOpen)
      return;
    Spicetify.PopupModal.display({
      title: t2("SETTINGS_TITLE"),
      content: /* @__PURE__ */ import_react17.default.createElement(SettingsModal, null)
    });
    const observer = new MutationObserver(() => {
      if (!document.querySelector(SELECTORS.TRACK_CREDITS_MODAL_CONTAINER)) {
        setIsOpen(false);
      }
    });
    observer.observe(document.body, { childList: true, subtree: true });
    return () => {
      observer.disconnect();
    };
  }, [isOpen]);
  return null;
}

// src/components/ui/trashed-items-modal.tsx
var import_react21 = __toESM(require_react(), 1);

// src/components/views/trashed-items/index.tsx
var import_react20 = __toESM(require_react(), 1);

// src/components/views/trashed-items/ui-components.tsx
var import_react18 = __toESM(require_react(), 1);

// node_modules/react-icons/io5/index.mjs
function IoClose(props) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "m289.94 256 95-95A24 24 0 0 0 351 127l-95 95-95-95a24 24 0 0 0-34 34l95 95-95 95a24 24 0 1 0 34 34l95-95 95 95a24 24 0 0 0 34-34z" }, child: [] }] })(props);
}

// src/components/views/trashed-items/ui-components.tsx
var ItemRow = ({ item, onUntrash }) => {
  const isArtist = "type" in item && item.type === "artist";
  const imageClass = isArtist ? "rounded-full" : "rounded";
  const Icon = isArtist ? BsPerson : BsMusicNote;
  const secondaryText = isArtist ? item.secondaryText : item.artist;
  return /* @__PURE__ */ import_react18.default.createElement("div", {
    className: "trashbin-item-row flex items-center justify-between rounded-md p-3 transition-colors"
  }, /* @__PURE__ */ import_react18.default.createElement("div", {
    className: "flex min-w-0 flex-1 items-center gap-3"
  }, item.imageUrl ? /* @__PURE__ */ import_react18.default.createElement("img", {
    src: item.imageUrl,
    alt: item.name,
    className: `h-12 w-12 ${imageClass} object-cover`
  }) : /* @__PURE__ */ import_react18.default.createElement("div", {
    className: `flex h-12 w-12 items-center justify-center ${imageClass}`,
    style: { backgroundColor: "rgba(255, 255, 255, 0.1)" }
  }, /* @__PURE__ */ import_react18.default.createElement(Icon, {
    className: "h-6 w-6",
    style: { color: "rgba(255, 255, 255, 0.7)" }
  })), /* @__PURE__ */ import_react18.default.createElement("div", {
    className: "min-w-0 flex-1"
  }, /* @__PURE__ */ import_react18.default.createElement("div", {
    className: "truncate font-medium",
    style: { color: "white" }
  }, item.name), /* @__PURE__ */ import_react18.default.createElement("div", {
    className: "truncate text-sm",
    style: { color: "rgba(255, 255, 255, 0.6)" }
  }, secondaryText))), /* @__PURE__ */ import_react18.default.createElement("button", {
    onClick: () => navigator.clipboard.writeText(item.uri),
    className: "trashbin-uri-btn shrink-0 cursor-pointer text-xs transition-colors",
    title: "Click to copy URI"
  }, item.uri), /* @__PURE__ */ import_react18.default.createElement("button", {
    onClick: (e) => {
      e.stopPropagation();
      e.preventDefault();
      onUntrash(item.uri);
    },
    className: "trashbin-remove-btn mx-2! cursor-pointer rounded-full p-2! transition-colors",
    title: "Remove from trashbin"
  }, /* @__PURE__ */ import_react18.default.createElement(IoClose, {
    className: "h-5 w-5 transition-colors"
  })));
};
var EmptyState = (props) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ import_react18.default.createElement("div", {
    className: "p-8 text-center"
  }, /* @__PURE__ */ import_react18.default.createElement("div", {
    className: "flex flex-col items-center gap-6 py-12"
  }, /* @__PURE__ */ import_react18.default.createElement(BsTrash3, {
    className: "h-20 w-20",
    style: { color: "rgba(255, 255, 255, 0.2)" }
  }), /* @__PURE__ */ import_react18.default.createElement("div", null, /* @__PURE__ */ import_react18.default.createElement("h3", {
    className: "mb-2 text-xl font-semibold",
    style: { color: "white" }
  }, props.type === "songs" ? t2("ITEMS_EMPTY_SONGS_TITLE") : t2("ITEMS_EMPTY_ARTISTS_TITLE")), /* @__PURE__ */ import_react18.default.createElement("p", {
    style: { color: "rgba(255, 255, 255, 0.6)" },
    dangerouslySetInnerHTML: {
      __html: props.type === "songs" ? t2("ITEMS_EMPTY_SONGS") : t2("ITEMS_EMPTY_ARTISTS")
    }
  }))));
};
var TabButton = (props) => /* @__PURE__ */ import_react18.default.createElement("button", {
  onClick: props.onClick,
  className: cn2("trashbin-tab-btn relative px-4! py-2! text-lg font-medium transition-colors", "border-b-2", props.isActive && "trashbin-tab-btn--active")
}, props.label, /* @__PURE__ */ import_react18.default.createElement("span", {
  className: "trashbin-tab-count mx-1! text-xs"
}, "(", props.count, ")"), props.isActive && /* @__PURE__ */ import_react18.default.createElement("div", {
  className: "trashbin-tab-indicator absolute right-0 bottom-0 left-0 h-0.5"
}));

// src/components/views/trashed-items/virtual-list.tsx
var import_react19 = __toESM(require_react(), 1);

// src/lib/metadata-utils.ts
var BASE62 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function toHex(id2) {
  let n = BigInt(0);
  for (const c of id2) {
    const i = BASE62.indexOf(c);
    if (i === -1)
      return "0".repeat(32);
    n = n * 62n + BigInt(i);
  }
  return n.toString(16).padStart(32, "0");
}
async function fetchMetadata(type, id2) {
  const token = (await Spicetify.Platform.AuthorizationAPI.getState()).token.accessToken;
  const res = await fetch(`https://spclient.wg.spotify.com/metadata/4/${type}/${toHex(id2)}?market=from_token`, {
    headers: { Accept: "application/json", Authorization: `Bearer ${token}` }
  });
  return res.json();
}
async function fetchTracksMetadata(uris) {
  return Promise.all(uris.map(async (uri) => {
    const id2 = uri.split(":")[2];
    try {
      const r = await fetchMetadata("track", id2);
      return {
        uri,
        name: r?.name || "Unknown Track",
        artist: r?.artist?.map((a) => a.name).join(", ") || "Unknown Artist",
        imageUrl: r?.album?.cover_group?.image?.[0]?.file_id ? `https://i.scdn.co/image/${r.album.cover_group.image[0].file_id}` : undefined
      };
    } catch {
      return { uri, name: "Error loading track", artist: "Failed to load" };
    }
  }));
}
async function fetchArtistsMetadata(uris) {
  return Promise.all(uris.map(async (uri) => {
    const id2 = uri.split(":")[2];
    try {
      const r = await fetchMetadata("artist", id2);
      return {
        uri,
        name: r?.name || "Unknown Artist",
        type: "artist",
        imageUrl: r?.portrait_group?.image?.[0]?.file_id ? `https://i.scdn.co/image/${r.portrait_group.image[0].file_id}` : undefined,
        secondaryText: "Artist"
      };
    } catch {
      return {
        uri,
        name: "Error loading artist",
        type: "artist",
        secondaryText: "Failed to load"
      };
    }
  }));
}

// src/components/views/trashed-items/virtual-list.tsx
var ITEM_HEIGHT = 60;
var OVERSCAN = 5;
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = import_react19.useState(value);
  import_react19.useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(timer);
  }, [value, delay]);
  return debouncedValue;
}
var VirtualList = (props) => {
  const { t: t2 } = useTranslation();
  const containerRef = import_react19.useRef(null);
  const [scrollTop, setScrollTop] = import_react19.useState(0);
  const [containerHeight, setContainerHeight] = import_react19.useState(0);
  const [itemCache, setItemCache] = import_react19.useState(new Map);
  const [loadingBatches, setLoadingBatches] = import_react19.useState(new Set);
  const [searchQuery, setSearchQuery] = import_react19.useState("");
  const debouncedSearch = useDebounce(searchQuery, 300);
  const getFilteredItems = () => {
    if (!debouncedSearch.trim()) {
      return props.items.map((uri, index) => ({ uri, originalIndex: index }));
    }
    const query = debouncedSearch.toLowerCase();
    return props.items.map((uri, index) => ({ uri, originalIndex: index })).filter(({ uri, originalIndex }) => {
      const cachedData = itemCache.get(originalIndex);
      if (cachedData) {
        const nameMatch = cachedData.name.toLowerCase().includes(query);
        const secondaryMatch = "artist" in cachedData ? cachedData.artist.toLowerCase().includes(query) : cachedData.secondaryText.toLowerCase().includes(query);
        return nameMatch || secondaryMatch || uri.toLowerCase().includes(query);
      }
      return uri.toLowerCase().includes(query);
    });
  };
  const filteredItems = getFilteredItems();
  const totalHeight = filteredItems.length * ITEM_HEIGHT;
  const startIndex = Math.max(0, Math.floor(scrollTop / ITEM_HEIGHT) - OVERSCAN);
  const visibleCount = Math.ceil(containerHeight / ITEM_HEIGHT) + OVERSCAN * 2;
  const endIndex = Math.min(filteredItems.length, startIndex + visibleCount);
  const visibleItems = filteredItems.slice(startIndex, endIndex).map((item, i) => ({
    ...item,
    virtualIndex: startIndex + i
  }));
  const handleScroll = (e) => {
    setScrollTop(e.currentTarget.scrollTop);
  };
  import_react19.useEffect(() => {
    const container = containerRef.current;
    if (!container)
      return;
    const observer = new ResizeObserver((entries) => {
      setContainerHeight(entries[0]?.contentRect.height ?? 0);
    });
    observer.observe(container);
    setContainerHeight(container.clientHeight);
    return () => observer.disconnect();
  }, []);
  const loadBatch = async (batchIndex) => {
    const batchKey = `${props.activeTab}-${batchIndex}`;
    if (loadingBatches.has(batchKey))
      return;
    const BATCH_SIZE = 50;
    const startIdx = batchIndex * BATCH_SIZE;
    const endIdx = Math.min(startIdx + BATCH_SIZE, props.items.length);
    setLoadingBatches((prev) => new Set(prev).add(batchKey));
    try {
      const urisSlice = props.items.slice(startIdx, endIdx);
      const data = props.activeTab === "songs" ? await fetchTracksMetadata(urisSlice) : await fetchArtistsMetadata(urisSlice);
      setItemCache((prev) => {
        const newCache = new Map(prev);
        data.forEach((item, i) => newCache.set(startIdx + i, item));
        return newCache;
      });
    } catch (error) {
      console.error(`Failed to load ${props.activeTab} batch:`, error);
    } finally {
      setLoadingBatches((prev) => {
        const newSet = new Set(prev);
        newSet.delete(batchKey);
        return newSet;
      });
    }
  };
  import_react19.useEffect(() => {
    const BATCH_SIZE = 50;
    const batchesToLoad = new Set;
    visibleItems.forEach((item) => {
      if (!itemCache.has(item.originalIndex)) {
        batchesToLoad.add(Math.floor(item.originalIndex / BATCH_SIZE));
      }
    });
    batchesToLoad.forEach(loadBatch);
  }, [startIndex, endIndex, itemCache]);
  import_react19.useEffect(() => {
    setItemCache(new Map);
    setLoadingBatches(new Set);
  }, [props.activeTab, props.items]);
  return /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null, /* @__PURE__ */ import_react19.default.createElement("div", {
    className: "mb-3"
  }, /* @__PURE__ */ import_react19.default.createElement("input", {
    type: "text",
    value: searchQuery,
    onChange: (e) => setSearchQuery(e.target.value),
    placeholder: t2("ITEMS_SEARCH_PLACEHOLDER"),
    className: "trashbin-search-input w-full rounded-lg border px-4 py-2 text-sm outline-none"
  })), /* @__PURE__ */ import_react19.default.createElement("div", {
    ref: containerRef,
    onScroll: handleScroll,
    className: "trashbin-list-container h-100 overflow-auto rounded-lg border"
  }, /* @__PURE__ */ import_react19.default.createElement("div", {
    style: { height: totalHeight, position: "relative" }
  }, visibleItems.map((item) => {
    const data = itemCache.get(item.originalIndex);
    return /* @__PURE__ */ import_react19.default.createElement("div", {
      key: item.uri,
      style: {
        position: "absolute",
        top: item.virtualIndex * ITEM_HEIGHT,
        left: 0,
        right: 0,
        height: ITEM_HEIGHT
      }
    }, data ? /* @__PURE__ */ import_react19.default.createElement(ItemRow, {
      item: data,
      onUntrash: props.onUntrash
    }) : /* @__PURE__ */ import_react19.default.createElement("div", {
      className: "flex h-full items-center justify-center"
    }, /* @__PURE__ */ import_react19.default.createElement("div", {
      className: "trashbin-spinner h-6 w-6 animate-spin rounded-full border-2"
    })));
  }))), /* @__PURE__ */ import_react19.default.createElement("div", {
    className: "py-4! text-center"
  }, /* @__PURE__ */ import_react19.default.createElement("p", {
    className: "trashbin-loaded-count text-sm"
  }, t2("ITEMS_LOADED_COUNT", {
    loaded: itemCache.size,
    total: props.items.length,
    type: props.activeTab
  }))));
};

// src/components/views/trashed-items/index.tsx
var TrashedItemsView = () => {
  const { t: t2 } = useTranslation();
  const store = useTrashbinStore();
  const [activeTab, setActiveTab] = import_react20.useState("songs");
  const trashedSongUris = import_react20.useMemo(() => Object.keys(store.trashSongList), [store.trashSongList]);
  const trashedArtistUris = import_react20.useMemo(() => Object.keys(store.trashArtistList), [store.trashArtistList]);
  const tabs = [
    {
      key: "songs",
      label: t2("ITEMS_TAB_SONGS"),
      count: trashedSongUris.length,
      uris: trashedSongUris
    },
    {
      key: "artists",
      label: t2("ITEMS_TAB_ARTISTS"),
      count: trashedArtistUris.length,
      uris: trashedArtistUris
    }
  ];
  const currentTab = tabs.find((tab) => tab.key === activeTab);
  const handleUntrash = (uri) => {
    if (activeTab === "songs") {
      store.toggleSongTrash(uri, false);
    } else {
      store.toggleArtistTrash(uri, false);
    }
  };
  const hasItems = trashedSongUris.length > 0 || trashedArtistUris.length > 0;
  if (!hasItems)
    return /* @__PURE__ */ import_react20.default.createElement(EmptyState, {
      type: activeTab
    });
  return /* @__PURE__ */ import_react20.default.createElement(import_react20.default.Fragment, null, /* @__PURE__ */ import_react20.default.createElement("style", null, `
        ${SELECTORS.TRACK_CREDITS_MODAL} {overflow-y: hidden !important;}
        .trashbin-search-input {
          border-color: rgba(255, 255, 255, 0.1) !important;
          background-color: rgba(0, 0, 0, 0.3) !important;
          color: white !important;
        }
        .trashbin-search-input::placeholder {
          color: rgba(255, 255, 255, 0.4) !important;
        }
        .trashbin-search-input:focus {
          border-color: rgba(255, 255, 255, 0.3) !important;
        }
        .trashbin-list-container {
          border-color: rgba(255, 255, 255, 0.1) !important;
          background-color: rgba(0, 0, 0, 0.2) !important;
        }
        .trashbin-item-row {
          background-color: transparent !important;
        }
        .trashbin-item-row:hover {
          background-color: rgba(255, 255, 255, 0.05) !important;
        }
        .trashbin-uri-btn {
          color: rgba(255, 255, 255, 0.4) !important;
          background: transparent !important;
          border: none !important;
        }
        .trashbin-uri-btn:hover {
          color: rgba(255, 255, 255, 0.6) !important;
        }
        .trashbin-remove-btn {
          background: transparent !important;
          border: none !important;
        }
        .trashbin-remove-btn svg {
          color: rgba(255, 255, 255, 0.7) !important;
        }
        .trashbin-remove-btn:hover {
          background-color: rgba(239, 68, 68, 0.2) !important;
        }
        .trashbin-remove-btn:hover svg {
          color: #f87171 !important;
        }
        .trashbin-spinner {
          border-color: rgba(255, 255, 255, 0.2) !important;
          border-top-color: rgba(255, 255, 255, 0.6) !important;
        }
        .trashbin-loaded-count {
          color: rgba(255, 255, 255, 0.4) !important;
        }
        .trashbin-tab-btn {
          color: rgba(255, 255, 255, 0.6) !important;
          border-color: transparent !important;
          background: transparent !important;
        }
        .trashbin-tab-btn:hover {
          color: rgba(255, 255, 255, 0.8) !important;
        }
        .trashbin-tab-btn--active {
          color: white !important;
          border-color: #22c55e !important;
        }
        .trashbin-tab-btn--active:hover {
          color: white !important;
        }
        .trashbin-tab-count {
          color: rgba(255, 255, 255, 0.6) !important;
        }
        .trashbin-tab-indicator {
          background-color: #22c55e !important;
        }
      `), /* @__PURE__ */ import_react20.default.createElement("div", {
    className: "mb-4! flex border-b",
    style: { borderColor: "rgba(255, 255, 255, 0.1)" }
  }, tabs.map((tab) => /* @__PURE__ */ import_react20.default.createElement(TabButton, {
    key: tab.key,
    label: tab.label,
    count: tab.count,
    isActive: activeTab === tab.key,
    onClick: () => setActiveTab(tab.key)
  }))), currentTab.uris.length === 0 ? /* @__PURE__ */ import_react20.default.createElement(EmptyState, {
    type: activeTab
  }) : /* @__PURE__ */ import_react20.default.createElement(VirtualList, {
    items: currentTab.uris,
    activeTab,
    onUntrash: handleUntrash
  }));
};

// src/components/ui/trashed-items-modal.tsx
function TrashedItemsModal() {
  const { t: t2 } = useTranslation();
  const [isOpen, setIsOpen] = import_react21.useState(false);
  import_react21.useEffect(() => {
    const menuItem = new Spicetify.Menu.Item(t2("ITEMS_TITLE"), false, () => setIsOpen(true), Spicetify.ReactDOMServer.renderToString(/* @__PURE__ */ import_react21.default.createElement(BsTrash3, {
      size: 15
    })));
    menuItem.register();
    return () => menuItem.deregister();
  }, []);
  import_react21.useEffect(() => {
    if (!isOpen)
      return;
    Spicetify.PopupModal.display({
      title: t2("ITEMS_TITLE"),
      content: /* @__PURE__ */ import_react21.default.createElement(TrashedItemsView, null),
      isLarge: true
    });
    const observer = new MutationObserver(() => {
      if (!document.querySelector(SELECTORS.TRACK_CREDITS_MODAL_CONTAINER)) {
        setIsOpen(false);
      }
    });
    observer.observe(document.body, { childList: true, subtree: true });
    return () => {
      observer.disconnect();
    };
  }, [isOpen]);
  return null;
}

// src/hooks/use-hotkey-trash.ts
var import_react22 = __toESM(require_react(), 1);
var useHotkeyTrash = () => {
  const store = useTrashbinStore();
  const trackToTrashRef = import_react22.useRef(null);
  import_react22.useEffect(() => {
    if (!store.trashbinEnabled || !store.trashOnNextHotkey)
      return;
    const handleTrashAndNext = () => {
      const currentTrack = Spicetify.Player.data?.item;
      if (currentTrack?.uri) {
        trackToTrashRef.current = currentTrack.uri;
        Spicetify.Player.next();
      }
    };
    const handleSongChange = () => {
      if (trackToTrashRef.current) {
        store.toggleSongTrash(trackToTrashRef.current, true);
        trackToTrashRef.current = null;
      }
    };
    Spicetify.Mousetrap.bind("ctrl+right", handleTrashAndNext);
    Spicetify.Player.addEventListener("songchange", handleSongChange);
    return () => {
      Spicetify.Mousetrap.unbind("ctrl+right");
      Spicetify.Player.removeEventListener("songchange", handleSongChange);
    };
  }, [store.trashbinEnabled, store.trashOnNextHotkey, store.toggleSongTrash]);
};

// src/hooks/use-playlist-monitor.ts
var import_react23 = __toESM(require_react(), 1);
var MONITOR_INTERVAL = 3000;
var STORAGE_KEY = "trashbin-playlist-monitor";
function usePlaylistMonitor() {
  const trashbinStore = useTrashbinStore();
  const intervalRef = import_react23.useRef(null);
  const stateRef = import_react23.useRef({ currentPlaylistUri: null });
  const loadState = import_react23.useCallback(() => {
    try {
      const stored = Spicetify.LocalStorage.get(STORAGE_KEY);
      if (stored) {
        const parsedState = JSON.parse(stored);
        stateRef.current.currentPlaylistUri = parsedState.currentPlaylistUri;
      }
    } catch (error) {
      console.error("usePlaylistMonitor: Failed to load state:", error);
    }
  }, []);
  const saveState = import_react23.useCallback(() => {
    try {
      Spicetify.LocalStorage.set(STORAGE_KEY, JSON.stringify({
        currentPlaylistUri: stateRef.current.currentPlaylistUri
      }));
    } catch (error) {
      console.error("usePlaylistMonitor: Failed to save state:", error);
    }
  }, []);
  const handleSongChange = import_react23.useCallback(() => {
    const contextUri = Spicetify.Player.data?.context?.uri;
    if (contextUri && Spicetify.URI.isPlaylistV1OrV2(contextUri)) {
      stateRef.current.currentPlaylistUri = contextUri;
      saveState();
    }
  }, [saveState]);
  const resumeLastPlaylist = import_react23.useCallback(async () => {
    if (!stateRef.current.currentPlaylistUri)
      return;
    try {
      await Spicetify.Player.playUri(stateRef.current.currentPlaylistUri);
    } catch (error) {
      console.error("usePlaylistMonitor: Failed to resume playlist:", error);
    }
  }, []);
  const checkPlaybackStatus = import_react23.useCallback(() => {
    const playerData = Spicetify.Player.data;
    const isPlaying = Spicetify.Player.isPlaying();
    const hasContext = !!playerData?.context?.uri;
    const hasItem = !!playerData?.item;
    if (stateRef.current.currentPlaylistUri && isPlaying && !hasContext && !hasItem) {
      resumeLastPlaylist();
    }
  }, [resumeLastPlaylist]);
  const startMonitoring = import_react23.useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    intervalRef.current = setInterval(checkPlaybackStatus, MONITOR_INTERVAL);
  }, [checkPlaybackStatus]);
  const stopMonitoring = import_react23.useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  import_react23.useEffect(() => {
    loadState();
  }, [loadState]);
  import_react23.useEffect(() => {
    if (!trashbinStore.playlistMonitorEnabled) {
      stopMonitoring();
      Spicetify.Player.removeEventListener("songchange", handleSongChange);
      return;
    }
    Spicetify.Player.addEventListener("songchange", handleSongChange);
    startMonitoring();
    return () => {
      stopMonitoring();
      Spicetify.Player.removeEventListener("songchange", handleSongChange);
    };
  }, [
    trashbinStore.playlistMonitorEnabled,
    handleSongChange,
    startMonitoring,
    stopMonitoring
  ]);
}

// src/hooks/use-recommendation-monitor.ts
var import_react24 = __toESM(require_react(), 1);
var useRecommendationMonitor = () => {
  const store = useTrashbinStore();
  const lastHeart = import_react24.useRef(false);
  const lastUri = import_react24.useRef(null);
  const processing = import_react24.useRef(false);
  import_react24.useEffect(() => {
    if (!store.trashbinEnabled || !store.remoteToggleEnabled || !store.trashViaLikeEnabled)
      return;
    const interval = setInterval(async () => {
      if (processing.current)
        return;
      if (Spicetify.Platform.ConnectAPI.state.activeDevice.id === "local_device")
        return;
      const track = Spicetify.Player.data?.item;
      if (!track?.uri)
        return;
      const heart = Spicetify.Player.getHeart();
      if (track.uri !== lastUri.current) {
        lastUri.current = track.uri;
        lastHeart.current = heart;
        return;
      }
      if (!lastHeart.current && heart) {
        processing.current = true;
        try {
          const trackId = track.uri.split(":")[2];
          await Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/me/tracks?ids=${trackId}`);
          if (!store.getTrashStatus(track.uri).isTrashed) {
            store.toggleSongTrash(track.uri, false);
            Spicetify.showNotification(instance.t("MESSAGE_SONG_ADDED_REMOTE"));
            Spicetify.Player.next();
          }
        } catch (e) {
          console.error("Remote trash failed:", e);
        }
        processing.current = false;
      }
      lastHeart.current = heart;
    }, 2000);
    return () => clearInterval(interval);
  }, [
    store.trashbinEnabled,
    store.remoteToggleEnabled,
    store.trashViaLikeEnabled,
    store.getTrashStatus,
    store.toggleSongTrash
  ]);
};

// src/hooks/use-ai-detection.ts
var import_react25 = __toESM(require_react(), 1);
var useAiDetection = () => {
  const store = useTrashbinStore();
  import_react25.useEffect(() => {
    if (!store.aiDetectionEnabled) {
      cleanupAiDetection();
      store.setAiAssetsReady(false);
      return;
    }
    let cancelled = false;
    const init2 = async () => {
      store.setAiAssetsDownloading(true);
      const ready = await initializeAiDetection((message) => {
        console.log(`[trashbin+ AI] ${message}`);
      });
      if (!cancelled) {
        store.setAiAssetsReady(ready);
        store.setAiAssetsDownloading(false);
        if (ready) {
          Spicetify.showNotification("AI detection ready");
        }
      }
    };
    init2();
    return () => {
      cancelled = true;
      cleanupAiDetection();
    };
  }, [store.aiDetectionEnabled]);
};

// src/hooks/use-remote-toggle.ts
var import_react26 = __toESM(require_react(), 1);
var useRemoteToggle = () => {
  const store = useTrashbinStore();
  const lastPause = import_react26.useRef(0);
  const cooldown = import_react26.useRef(false);
  import_react26.useEffect(() => {
    if (!store.trashbinEnabled || !store.remoteToggleEnabled)
      return;
    const handler = (event) => {
      if (Spicetify.Platform.ConnectAPI.state.activeDevice.id === "local_device")
        return;
      if (cooldown.current)
        return;
      const isPaused = event?.data?.isPaused;
      const now = Date.now();
      if (isPaused) {
        lastPause.current = now;
      } else if (lastPause.current > 0 && now - lastPause.current < 3000) {
        cooldown.current = true;
        const wasEnabled = useTrashbinStore.getState().remoteSkippingEnabled;
        store.toggleRemoteSkipping();
        Spicetify.showNotification(instance.t(wasEnabled ? "MESSAGE_REMOTE_SKIPPING_DISABLED" : "MESSAGE_REMOTE_SKIPPING_ENABLED"));
        Spicetify.Player.next();
        lastPause.current = 0;
        setTimeout(() => {
          cooldown.current = false;
        }, 3000);
      }
    };
    Spicetify.Player.addEventListener("onplaypause", handler);
    return () => Spicetify.Player.removeEventListener("onplaypause", handler);
  }, [
    store.trashbinEnabled,
    store.remoteToggleEnabled,
    store.toggleRemoteSkipping
  ]);
};

// src/app.tsx
function App() {
  console.log("trashbin+ loaded v1.0.10!");
  const trashbinStore = useTrashbinStore();
  useHotkeyTrash();
  usePlaylistMonitor();
  useRemoteToggle();
  useRecommendationMonitor();
  useAiDetection();
  import_react27.useEffect(() => {
    trashbinStore.initializeFromStorage();
  }, [trashbinStore.initializeFromStorage]);
  import_react27.useEffect(() => {
    if (trashbinStore.autoplayOnStart && !Spicetify.Player.isPlaying()) {
      setTimeout(Spicetify.Player.play, 5000);
      setTimeout(Spicetify.Player.play, 60000);
    }
  }, [trashbinStore.autoplayOnStart]);
  import_react27.useEffect(() => {
    if (!trashbinStore.trashbinEnabled)
      return;
    const skipBackBtn = document.querySelector(SELECTORS.SKIP_BACK_BUTTON) ?? document.querySelector(SELECTORS.SKIP_BACK_BUTTON_ALT);
    const eventListener = () => trashbinStore.setUserHitBack(true);
    const handleSongChange = async () => {
      const track = Spicetify.Player.data?.item;
      const state = useTrashbinStore.getState();
      const isLocalDevice = Spicetify.Platform.ConnectAPI.state.activeDevice.id === "local_device";
      if (!isLocalDevice && !state.remoteSkippingEnabled) {
        return;
      }
      if (state.userHitBack) {
        trashbinStore.setUserHitBack(false);
        return;
      }
      if (state.autoCleanQueue) {
        manageSmartShuffleQueue();
      }
      if (state.skipTrashedTracks && isTrackEffectivelyTrashed(track)) {
        skipToNextAllowedTrack();
      }
    };
    skipBackBtn?.addEventListener("click", eventListener);
    Spicetify.Player.addEventListener("songchange", handleSongChange);
    return () => {
      skipBackBtn?.removeEventListener("click", eventListener);
      Spicetify.Player.removeEventListener("songchange", handleSongChange);
    };
  }, [trashbinStore.trashbinEnabled]);
  return /* @__PURE__ */ import_react27.default.createElement(import_react27.default.Fragment, null, /* @__PURE__ */ import_react27.default.createElement(Providers, null, /* @__PURE__ */ import_react27.default.createElement(TrashbinWidget, null), /* @__PURE__ */ import_react27.default.createElement(TrashbinSettings, null), /* @__PURE__ */ import_react27.default.createElement(TrashedItemsModal, null), /* @__PURE__ */ import_react27.default.createElement(TrashbinContextMenu, null), /* @__PURE__ */ import_react27.default.createElement(TrashbinTracklist, null), /* @__PURE__ */ import_react27.default.createElement(TrashbinQueuelist, null), /* @__PURE__ */ import_react27.default.createElement(AutoAddRecommendations, null), /* @__PURE__ */ import_react27.default.createElement(AiDetectionWidget, null), /* @__PURE__ */ import_react27.default.createElement(AiTracklist, null)));
}
async function main() {
  const appRoot = document.createElement("div");
  appRoot.id = "trashbin-plus-root";
  appRoot.className = "fixed top-0 left-0 z-50 pointer-events-none";
  document.body.appendChild(appRoot);
  import_react_dom.default.render(/* @__PURE__ */ import_react27.default.createElement(App, null), appRoot);
  return () => {
    import_react_dom.default.unmountComponentAtNode(appRoot);
    appRoot.remove();
  };
}
var app_default = main;

// ../../../../../tmp/trashbin-plus/entry.ts
(async () => {
  await app_default();
})();

;(()=>{if(!document.getElementById("trashbinDplus")){const s=document.createElement("style");s.id="trashbinDplus";s.textContent=String.raw`/* src/global.css */
/*! tailwindcss v4.1.18 | MIT License | https://tailwindcss.com */
@layer properties;
@layer theme;

@layer theme {
  :root, :host {
    --color-red-400: oklch(70.4% .191 22.216);
    --color-red-500: oklch(63.7% .237 25.331);
    --color-green-500: oklch(72.3% .219 149.579);
    --color-black: #000;
    --color-white: #fff;
    --spacing: .25rem;
    --text-xs: .75rem;
    --text-xs--line-height: calc(1 / .75);
    --text-sm: .875rem;
    --text-sm--line-height: calc(1.25 / .875);
    --text-lg: 1.125rem;
    --text-lg--line-height: calc(1.75 / 1.125);
    --text-xl: 1.25rem;
    --text-xl--line-height: calc(1.75 / 1.25);
    --font-weight-medium: 500;
    --font-weight-semibold: 600;
    --font-weight-bold: 700;
    --radius-md: .375rem;
    --radius-lg: .5rem;
    --ease-out: cubic-bezier(0, 0, .2, 1);
    --animate-spin: spin 1s linear infinite;
    --default-transition-duration: .15s;
    --default-transition-timing-function: cubic-bezier(.4, 0, .2, 1);
  }
}

.pointer-events-auto {
  pointer-events: auto;
}

.pointer-events-auto\! {
  pointer-events: auto !important;
}

.pointer-events-none {
  pointer-events: none;
}

.visible {
  visibility: visible;
}

.absolute {
  position: absolute;
}

.absolute\! {
  position: absolute !important;
}

.fixed {
  position: fixed;
}

.fixed\! {
  position: fixed !important;
}

.relative {
  position: relative;
}

.relative\! {
  position: relative !important;
}

.static {
  position: static;
}

.top-0 {
  top: calc(var(--spacing) * 0);
}

.top-full {
  top: 100%;
}

.right-0 {
  right: calc(var(--spacing) * 0);
}

.right-0\! {
  right: calc(var(--spacing) * 0) !important;
}

.bottom-0 {
  bottom: calc(var(--spacing) * 0);
}

.left-0 {
  left: calc(var(--spacing) * 0);
}

.left-1 {
  left: calc(var(--spacing) * 1);
}

.left-1\/2 {
  left: 50%;
}

.z-50 {
  z-index: 50;
}

.z-50\! {
  z-index: 50 !important;
}

.container {
  width: 100%;
}

@media (min-width: 40rem) {
  .container {
    max-width: 40rem;
  }
}

@media (min-width: 48rem) {
  .container {
    max-width: 48rem;
  }
}

@media (min-width: 64rem) {
  .container {
    max-width: 64rem;
  }
}

@media (min-width: 80rem) {
  .container {
    max-width: 80rem;
  }
}

@media (min-width: 96rem) {
  .container {
    max-width: 96rem;
  }
}

.mx-1 {
  margin-inline: calc(var(--spacing) * 1);
}

.mx-1\! {
  margin-inline: calc(var(--spacing) * 1) !important;
}

.mx-2 {
  margin-inline: calc(var(--spacing) * 2);
}

.mx-2\! {
  margin-inline: calc(var(--spacing) * 2) !important;
}

.my-2 {
  margin-block: calc(var(--spacing) * 2);
}

.my-2\.5\! {
  margin-block: calc(var(--spacing) * 2.5) !important;
}

.mb-2 {
  margin-bottom: calc(var(--spacing) * 2);
}

.mb-3 {
  margin-bottom: calc(var(--spacing) * 3);
}

.mb-4 {
  margin-bottom: calc(var(--spacing) * 4);
}

.mb-4\! {
  margin-bottom: calc(var(--spacing) * 4) !important;
}

.ml-3 {
  margin-left: calc(var(--spacing) * 3);
}

.ml-3\! {
  margin-left: calc(var(--spacing) * 3) !important;
}

.block {
  display: block;
}

.contents {
  display: contents;
}

.flex {
  display: flex;
}

.flex\! {
  display: flex !important;
}

.grid {
  display: grid;
}

.hidden {
  display: none;
}

.inline {
  display: inline;
}

.inline-block {
  display: inline-block;
}

.inline-block\! {
  display: inline-block !important;
}

.inline-flex {
  display: inline-flex;
}

.inline-flex\! {
  display: inline-flex !important;
}

.table {
  display: table;
}

.h-0 {
  height: calc(var(--spacing) * 0);
}

.h-0\.5 {
  height: calc(var(--spacing) * .5);
}

.h-2 {
  height: calc(var(--spacing) * 2);
}

.h-2\! {
  height: calc(var(--spacing) * 2) !important;
}

.h-5 {
  height: calc(var(--spacing) * 5);
}

.h-6 {
  height: calc(var(--spacing) * 6);
}

.h-12 {
  height: calc(var(--spacing) * 12);
}

.h-20 {
  height: calc(var(--spacing) * 20);
}

.h-100 {
  height: calc(var(--spacing) * 100);
}

.h-full {
  height: 100%;
}

.h-full\! {
  height: 100% !important;
}

.min-h-8 {
  min-height: calc(var(--spacing) * 8);
}

.min-h-8\! {
  min-height: calc(var(--spacing) * 8) !important;
}

.w-5 {
  width: calc(var(--spacing) * 5);
}

.w-6 {
  width: calc(var(--spacing) * 6);
}

.w-12 {
  width: calc(var(--spacing) * 12);
}

.w-12\! {
  width: calc(var(--spacing) * 12) !important;
}

.w-20 {
  width: calc(var(--spacing) * 20);
}

.w-full {
  width: 100%;
}

.min-w-0 {
  min-width: calc(var(--spacing) * 0);
}

.flex-1 {
  flex: 1;
}

.flex-shrink {
  flex-shrink: 1;
}

.shrink-0 {
  flex-shrink: 0;
}

.-translate-x-1 {
  --tw-translate-x: calc(var(--spacing) * -1);
  translate: var(--tw-translate-x) var(--tw-translate-y);
}

.-translate-x-1\/2 {
  --tw-translate-x: calc(calc(1 / 2 * 100%) * -1);
  translate: var(--tw-translate-x) var(--tw-translate-y);
}

.transform {
  transform: var(--tw-rotate-x, ) var(--tw-rotate-y, ) var(--tw-rotate-z, ) var(--tw-skew-x, ) var(--tw-skew-y, );
}

.animate-spin {
  animation: var(--animate-spin);
}

.cursor-help {
  cursor: help;
}

.cursor-help\! {
  cursor: help !important;
}

.cursor-not-allowed {
  cursor: not-allowed;
}

.cursor-not-allowed\! {
  cursor: not-allowed !important;
}

.cursor-pointer {
  cursor: pointer;
}

.cursor-pointer\! {
  cursor: pointer !important;
}

.resize {
  resize: both;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items:  center;
}

.items-center\! {
  align-items:  center !important;
}

.justify-between {
  justify-content: space-between;
}

.justify-center {
  justify-content: center;
}

.gap-0 {
  gap: calc(var(--spacing) * 0);
}

.gap-0\.5\! {
  gap: calc(var(--spacing) * .5) !important;
}

.gap-1 {
  gap: calc(var(--spacing) * 1);
}

.gap-1\.5\! {
  gap: calc(var(--spacing) * 1.5) !important;
}

.gap-2 {
  gap: calc(var(--spacing) * 2);
}

.gap-2\.5\! {
  gap: calc(var(--spacing) * 2.5) !important;
}

.gap-3 {
  gap: calc(var(--spacing) * 3);
}

.gap-6 {
  gap: calc(var(--spacing) * 6);
}

.truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.overflow-auto {
  overflow: auto;
}

.overflow-hidden {
  overflow: hidden;
}

.overflow-hidden\! {
  overflow: hidden !important;
}

.rounded {
  border-radius: .25rem;
}

.rounded-full {
  border-radius: 3.40282e38px;
}

.rounded-full\! {
  border-radius: 3.40282e38px !important;
}

.rounded-lg {
  border-radius: var(--radius-lg);
}

.rounded-md {
  border-radius: var(--radius-md);
}

.border {
  border-style: var(--tw-border-style);
  border-width: 1px;
}

.border\! {
  border-style: var(--tw-border-style) !important;
  border-width: 1px !important;
}

.border-0 {
  border-style: var(--tw-border-style);
  border-width: 0;
}

.border-0\! {
  border-style: var(--tw-border-style) !important;
  border-width: 0 !important;
}

.border-2 {
  border-style: var(--tw-border-style);
  border-width: 2px;
}

.border-4 {
  border-style: var(--tw-border-style);
  border-width: 4px;
}

.border-b {
  border-bottom-style: var(--tw-border-style);
  border-bottom-width: 1px;
}

.border-b-2 {
  border-bottom-style: var(--tw-border-style);
  border-bottom-width: 2px;
}

.border-none {
  --tw-border-style: none;
  border-style: none;
}

.border-\[\#727272\]\! {
  border-color: #727272 !important;
}

.border-green-500 {
  border-color: var(--color-green-500);
}

.border-transparent {
  border-color: #0000;
}

.border-white {
  border-color: var(--color-white);
}

.border-t-white {
  border-top-color: var(--color-white);
}

.bg-\[rgba\(var\(--spice-rgb-shadow\)\,0\.7\)\]\! {
  background-color: rgba(var(--spice-rgb-shadow), .7) !important;
}

.bg-black {
  background-color: var(--color-black);
}

.bg-transparent {
  background-color: #0000;
}

.bg-transparent\! {
  background-color: #0000 !important;
}

.bg-white {
  background-color: var(--color-white);
}

.fill-\[\#22c55e\] {
  fill: #22c55e;
}

.object-cover {
  object-fit: cover;
}

.p-2 {
  padding: calc(var(--spacing) * 2);
}

.p-2\! {
  padding: calc(var(--spacing) * 2) !important;
}

.p-3 {
  padding: calc(var(--spacing) * 3);
}

.p-4 {
  padding: calc(var(--spacing) * 4);
}

.p-8 {
  padding: calc(var(--spacing) * 8);
}

.px-2 {
  padding-inline: calc(var(--spacing) * 2);
}

.px-3 {
  padding-inline: calc(var(--spacing) * 3);
}

.px-3\.75\! {
  padding-inline: calc(var(--spacing) * 3.75) !important;
}

.px-4 {
  padding-inline: calc(var(--spacing) * 4);
}

.px-4\! {
  padding-inline: calc(var(--spacing) * 4) !important;
}

.py-1 {
  padding-block: calc(var(--spacing) * 1);
}

.py-1\! {
  padding-block: calc(var(--spacing) * 1) !important;
}

.py-2 {
  padding-block: calc(var(--spacing) * 2);
}

.py-2\! {
  padding-block: calc(var(--spacing) * 2) !important;
}

.py-2\.5\! {
  padding-block: calc(var(--spacing) * 2.5) !important;
}

.py-4 {
  padding-block: calc(var(--spacing) * 4);
}

.py-4\! {
  padding-block: calc(var(--spacing) * 4) !important;
}

.py-12 {
  padding-block: calc(var(--spacing) * 12);
}

.pr-4 {
  padding-right: calc(var(--spacing) * 4);
}

.text-center {
  text-align: center;
}

.text-right {
  text-align: right;
}

.text-lg {
  font-size: var(--text-lg);
  line-height: var(--tw-leading, var(--text-lg--line-height));
}

.text-sm {
  font-size: var(--text-sm);
  line-height: var(--tw-leading, var(--text-sm--line-height));
}

.text-xl {
  font-size: var(--text-xl);
  line-height: var(--tw-leading, var(--text-xl--line-height));
}

.text-xs {
  font-size: var(--text-xs);
  line-height: var(--tw-leading, var(--text-xs--line-height));
}

.text-xs\! {
  font-size: var(--text-xs) !important;
  line-height: var(--tw-leading, var(--text-xs--line-height)) !important;
}

.font-bold {
  --tw-font-weight: var(--font-weight-bold);
  font-weight: var(--font-weight-bold);
}

.font-bold\! {
  --tw-font-weight: var(--font-weight-bold) !important;
  font-weight: var(--font-weight-bold) !important;
}

.font-medium {
  --tw-font-weight: var(--font-weight-medium);
  font-weight: var(--font-weight-medium);
}

.font-semibold {
  --tw-font-weight: var(--font-weight-semibold);
  font-weight: var(--font-weight-semibold);
}

.whitespace-nowrap {
  white-space: nowrap;
}

.whitespace-nowrap\! {
  white-space: nowrap !important;
}

.text-\(--spice-text\) {
  color: var(--spice-text);
}

.text-\(--spice-text\)\! {
  color: var(--spice-text) !important;
}

.text-\[rgba\(var\(--spice-rgb-text\)\,0\.3\)\]\! {
  color: rgba(var(--spice-rgb-text), .3) !important;
}

.text-\[rgba\(var\(--spice-rgb-text\)\,0\.5\)\]\! {
  color: rgba(var(--spice-rgb-text), .5) !important;
}

.text-green-500 {
  color: var(--color-green-500);
}

.text-white {
  color: var(--color-white);
}

.lowercase {
  text-transform: lowercase;
}

.uppercase {
  text-transform: uppercase;
}

.ordinal {
  --tw-ordinal: ordinal;
  font-variant-numeric: var(--tw-ordinal, ) var(--tw-slashed-zero, ) var(--tw-numeric-figure, ) var(--tw-numeric-spacing, ) var(--tw-numeric-fraction, );
}

.opacity-50 {
  opacity: .5;
}

.opacity-50\! {
  opacity: .5 !important;
}

.opacity-70 {
  opacity: .7;
}

.shadow-lg {
  --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, #0000001a), 0 4px 6px -4px var(--tw-shadow-color, #0000001a);
  box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
}

.filter {
  filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );
}

.transition {
  transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter, display, content-visibility, overlay, pointer-events;
  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
  transition-duration: var(--tw-duration, var(--default-transition-duration));
}

.transition-colors {
  transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;
  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
  transition-duration: var(--tw-duration, var(--default-transition-duration));
}

.transition-colors\! {
  transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to !important;
  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function)) !important;
  transition-duration: var(--tw-duration, var(--default-transition-duration)) !important;
}

.transition-opacity {
  transition-property: opacity;
  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
  transition-duration: var(--tw-duration, var(--default-transition-duration));
}

.transition-transform {
  transition-property: transform, translate, scale, rotate;
  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
  transition-duration: var(--tw-duration, var(--default-transition-duration));
}

.transition-transform\! {
  transition-property: transform, translate, scale, rotate !important;
  transition-timing-function: var(--tw-ease, var(--default-transition-timing-function)) !important;
  transition-duration: var(--tw-duration, var(--default-transition-duration)) !important;
}

.duration-33 {
  --tw-duration: 33ms;
  transition-duration: 33ms;
}

.duration-33\! {
  --tw-duration: 33ms !important;
  transition-duration: 33ms !important;
}

.ease-out {
  --tw-ease: var(--ease-out);
  transition-timing-function: var(--ease-out);
}

.outline-none {
  --tw-outline-style: none;
  outline-style: none;
}

.first-of-type\:mt-0:first-of-type {
  margin-top: calc(var(--spacing) * 0);
}

@media (hover: hover) {
  .hover\:scale-\[1\.04\]\!:hover {
    scale: 1.04 !important;
  }
}

@media (hover: hover) {
  .hover\:border-\(--spice-text\)\!:hover {
    border-color: var(--spice-text) !important;
  }
}

@media (hover: hover) {
  .hover\:text-\(--spice-text\)\!:hover {
    color: var(--spice-text) !important;
  }
}

@media (hover: hover) {
  .hover\:opacity-100:hover {
    opacity: 1;
  }
}

.main-trackCreditsModal-mainSection button, .main-addButton-button {
  background-color: #0000 !important;
  border: none !important;
  margin: 0 !important;
  padding: 0 !important;
}

.main-addButton-button {
  padding-top: 4px !important;
  padding-left: 3px !important;
}

@property --tw-translate-x {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-translate-y {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-translate-z {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}

@property --tw-rotate-x {
  syntax: "*";
  inherits: false
}

@property --tw-rotate-y {
  syntax: "*";
  inherits: false
}

@property --tw-rotate-z {
  syntax: "*";
  inherits: false
}

@property --tw-skew-x {
  syntax: "*";
  inherits: false
}

@property --tw-skew-y {
  syntax: "*";
  inherits: false
}

@property --tw-border-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}

@property --tw-font-weight {
  syntax: "*";
  inherits: false
}

@property --tw-ordinal {
  syntax: "*";
  inherits: false
}

@property --tw-slashed-zero {
  syntax: "*";
  inherits: false
}

@property --tw-numeric-figure {
  syntax: "*";
  inherits: false
}

@property --tw-numeric-spacing {
  syntax: "*";
  inherits: false
}

@property --tw-numeric-fraction {
  syntax: "*";
  inherits: false
}

@property --tw-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-shadow-color {
  syntax: "*";
  inherits: false
}

@property --tw-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}

@property --tw-inset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-inset-shadow-color {
  syntax: "*";
  inherits: false
}

@property --tw-inset-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}

@property --tw-ring-color {
  syntax: "*";
  inherits: false
}

@property --tw-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-inset-ring-color {
  syntax: "*";
  inherits: false
}

@property --tw-inset-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-ring-inset {
  syntax: "*";
  inherits: false
}

@property --tw-ring-offset-width {
  syntax: "<length>";
  inherits: false;
  initial-value: 0;
}

@property --tw-ring-offset-color {
  syntax: "*";
  inherits: false;
  initial-value: #fff;
}

@property --tw-ring-offset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}

@property --tw-blur {
  syntax: "*";
  inherits: false
}

@property --tw-brightness {
  syntax: "*";
  inherits: false
}

@property --tw-contrast {
  syntax: "*";
  inherits: false
}

@property --tw-grayscale {
  syntax: "*";
  inherits: false
}

@property --tw-hue-rotate {
  syntax: "*";
  inherits: false
}

@property --tw-invert {
  syntax: "*";
  inherits: false
}

@property --tw-opacity {
  syntax: "*";
  inherits: false
}

@property --tw-saturate {
  syntax: "*";
  inherits: false
}

@property --tw-sepia {
  syntax: "*";
  inherits: false
}

@property --tw-drop-shadow {
  syntax: "*";
  inherits: false
}

@property --tw-drop-shadow-color {
  syntax: "*";
  inherits: false
}

@property --tw-drop-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}

@property --tw-drop-shadow-size {
  syntax: "*";
  inherits: false
}

@property --tw-duration {
  syntax: "*";
  inherits: false
}

@property --tw-ease {
  syntax: "*";
  inherits: false
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

@layer properties {
  @supports ((-webkit-hyphens: none) and ( not (margin-trim: inline))) or ((-moz-orient: inline) and ( not (color:rgb(from red r g b)))) {
    *, :before, :after, ::backdrop {
      --tw-translate-x: 0;
      --tw-translate-y: 0;
      --tw-translate-z: 0;
      --tw-rotate-x: initial;
      --tw-rotate-y: initial;
      --tw-rotate-z: initial;
      --tw-skew-x: initial;
      --tw-skew-y: initial;
      --tw-border-style: solid;
      --tw-font-weight: initial;
      --tw-ordinal: initial;
      --tw-slashed-zero: initial;
      --tw-numeric-figure: initial;
      --tw-numeric-spacing: initial;
      --tw-numeric-fraction: initial;
      --tw-shadow: 0 0 #0000;
      --tw-shadow-color: initial;
      --tw-shadow-alpha: 100%;
      --tw-inset-shadow: 0 0 #0000;
      --tw-inset-shadow-color: initial;
      --tw-inset-shadow-alpha: 100%;
      --tw-ring-color: initial;
      --tw-ring-shadow: 0 0 #0000;
      --tw-inset-ring-color: initial;
      --tw-inset-ring-shadow: 0 0 #0000;
      --tw-ring-inset: initial;
      --tw-ring-offset-width: 0px;
      --tw-ring-offset-color: #fff;
      --tw-ring-offset-shadow: 0 0 #0000;
      --tw-blur: initial;
      --tw-brightness: initial;
      --tw-contrast: initial;
      --tw-grayscale: initial;
      --tw-hue-rotate: initial;
      --tw-invert: initial;
      --tw-opacity: initial;
      --tw-saturate: initial;
      --tw-sepia: initial;
      --tw-drop-shadow: initial;
      --tw-drop-shadow-color: initial;
      --tw-drop-shadow-alpha: 100%;
      --tw-drop-shadow-size: initial;
      --tw-duration: initial;
      --tw-ease: initial;
    }
  }
}
`.trim();document.head.appendChild(s)}})()})()