(async()=>{while(!Spicetify.React||!Spicetify.ReactDOM)await new Promise(r=>setTimeout(r,10));var ev=Object.create;var{getPrototypeOf:ov,defineProperty:H7,getOwnPropertyNames:nv}=Object;var hv=Object.prototype.hasOwnProperty;var Z=(a,t,r)=>{r=a!=null?ev(ov(a)):{};let l=t||!a||!a.__esModule?H7(r,"default",{value:a,enumerable:!0}):r;for(let i of nv(a))if(!hv.call(l,i))H7(l,i,{get:()=>a[i],enumerable:!0});return l};var K=(a,t)=>()=>(t||a((t={exports:{}}).exports,t),t.exports);var f4=((a)=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(a,{get:(t,r)=>(typeof require<"u"?require:t)[r]}):a)(function(a){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+a+'" is not supported')});var B1=K((Qs,V7)=>{V7.exports=Spicetify.React});var N7=K((Xs,k7)=>{k7.exports=Spicetify.ReactDOM});var St=K((Gv)=>{var Y1=Z(B1());(function(){function a(s,M){return s===M&&(s!==0||1/s===1/M)||s!==s&&M!==M}function t(s,M){d||Y1.startTransition===void 0||(d=!0,console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));var A=M();if(!u){var E=M();i(A,E)||(console.error("The result of getSnapshot should be cached to avoid an infinite loop"),u=!0)}E=e({inst:{value:A,getSnapshot:M}});var x=E[0].inst,m=E[1];return n(function(){x.value=A,x.getSnapshot=M,r(x)&&m({inst:x})},[s,A,M]),o(function(){return r(x)&&m({inst:x}),s(function(){r(x)&&m({inst:x})})},[s]),c(A),A}function r(s){var M=s.getSnapshot;s=s.value;try{var A=M();return!i(s,A)}catch(E){return!0}}function l(s,M){return M()}typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());var i=typeof Object.is==="function"?Object.is:a,e=Y1.useState,o=Y1.useEffect,n=Y1.useLayoutEffect,c=Y1.useDebugValue,d=!1,u=!1,g=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?l:t;Gv.useSyncExternalStore=Y1.useSyncExternalStore!==void 0?Y1.useSyncExternalStore:g,typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error())})()});var At=K((Up,yv)=>{yv.exports={TRASHBIN_NAME:"Asblik+",ACTION_THROW:"Plaas in asblik",ACTION_UNTHROW:"Verwyder uit asblik",ACTION_CLEAR:"Duidelik",ACTION_COPY:"Kopieer",ACTION_EXPORT:"Uitvoer",ACTION_IMPORT:"Invoer",MESSAGE_COPIED:"Gekopieer na knipbord",MESSAGE_CLEARED:"Asblik suksesvol skoongemaak!",MESSAGE_SONG_ADDED:"Liedjie by prullenmandjie gevoeg",MESSAGE_SONG_REMOVED:"Liedjie uit asblik verwyder",MESSAGE_ARTIST_ADDED:"Kunstenaar by afvalblik gevoeg",MESSAGE_ARTIST_REMOVED:"Kunstenaar verwyder uit asblik",BACKUP_SAVE_SUCCESS:"Back-up suksesvol gestoor.",BACKUP_SAVE_FAILED:"Kon nie rugsteunkopie stoor nie, probeer om inhoud van asblik na knipbord te kopieer en rugsteunkopie handmatig te skep.",BACKUP_RESTORE_SUCCESS:"Back-up suksesvol herstel.",BACKUP_FILE_READ_FAILED:"Het nie die lêer kon lees nie, verseker asseblief dit is 'n geldige JSON-lêer.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Papiermandjie+ Instellings",SETTINGS_OPTIONS:"Opsies",SETTINGS_FEATURES:"Kenmerke",SETTINGS_LOCAL_STORAGE:"Lokale Stoorruimte",SETTINGS_ENABLED:"Aangetrek",SETTINGS_SHOW_WIDGET:"Wys werktuigikoon",SETTINGS_AUTOPLAY:"Speel outomaties af vanaf begin",SETTINGS_QUEUE_TRASHBIN:"Aktiveer Wachtrashblik",SETTINGS_TRACKLIST_TRASHBIN:"Aktiveer Lys van nummers-asblik",SETTINGS_PLAYLIST_MONITOR:"Afspeellys Monitor",ITEMS_TITLE:"Asblik+ Items",ITEMS_EMPTY_SONGS:"<strong>Geen verwyderde liedjies!</strong><br/>Liedjies wat jy na die asblik toe skuif, sal hier verskyn.",ITEMS_EMPTY_ARTISTS:"<strong>Geen verwyderde kunstenaars!</strong><br/>Kunstenaars wat jy by die asblik voeg, sal hier verskyn.",ITEMS_TAB_SONGS:"Liedjies",ITEMS_TAB_ARTISTS:"Kunstenaars",ITEMS_LOADED_COUNT:"{{loaded}} van {{total}} {{type}} gelaai",DESCRIPTION_COPY:"Kopieer alle items in die asblik na die knipbord.",DESCRIPTION_EXPORT:"Stoor alle items in die asblik na 'n .json-lêer.",DESCRIPTION_IMPORT:"Oorskryf alle items in die asblik via .json-lêer.",DESCRIPTION_CLEAR:"Verwyder alle items uit die asblik (kan nie ongedaan gemaak word nie).",ITEMS_EMPTY_SONGS_TITLE:"Geen verwyderde liedjies nie!",ITEMS_EMPTY_ARTISTS_TITLE:"Geen verwoeste kunstenaars nie!",DESCRIPTION_SETTINGS_ENABLED:"Meesterwisselaar om alle Trashbin+-funksies in- of uit te skakel",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Wys 'n asblikikoon in die afspeelbalk langs die huidige liedjie vir vinnige toegang",DESCRIPTION_SETTINGS_AUTOPLAY:"Begin outomaties met die speel van musiek wanneer Spotify oopgaan of die uitbreiding gelaai word",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Voeg asblik-ikone langs elke liedjie in jou komende tou by vir maklike bestuur",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Voeg asblik-ikone langs liedjies by album- en afspeellys-views vir vinnige filtring",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Herstel outomaties vanaf Spotify-afspeelfoutjies deur jou laaste afspeellys voort te sit",SETTINGS_SKIP_TRASHED_TRACKS:"Slaan Verwoeste Spore oor",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Slaan outomaties verwyderde liedjies oor en vind die volgende toegelate liedjie tydens afspeel",SETTINGS_AUTO_CLEAN_QUEUE:"Outomatiese skoonmaakry",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Verwyder outomaties verwyderde liedjies uit jou Slim Skud-gids",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Afval op Volgende Sneltoets",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Verwyder outomaties die huidige liedjie wanneer Ctrl+Regs gebruik word om na die volgende snit te spring",SETTINGS_REMOTE_CONTROL:"Afstandbeheer",SETTINGS_REMOTE_TOGGLE:"Aktiveer Verweide Wisselknoppie",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Tik twee keer op speel/pouse vanaf die selfoon om verwekte oorslaan aan/af te skakel. 'n Oorskakeling van 'n nommer bevestig die skakelaar.",SETTINGS_REMOTE_SKIPPING:"Afstandskipping Aktief",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Wanneer dit geaktiveer is, werk die oorslaan van asblik selfs wanneer Spotify vanaf 'n ander toestel beheer word (byvoorbeeld, selfoon)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Afstandskipping toegelaat",MESSAGE_REMOTE_SKIPPING_DISABLED:"Afstandskipping gedeaktiveer",MESSAGE_SONG_ADDED_REMOTE:"Lied verwoes via afstandbeheer",SETTINGS_TRASH_VIA_LIKE:"Afval via Soos",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:`Soos 'n liedjie vanaf mobiel na dit te verwyder. Verwyder outomaties die "like" en slaan oor na die volgende liedjie.`,SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Tt=K((Wp,bv)=>{bv.exports={TRASHBIN_NAME:"ሳንጠቆ ሳጥን+",ACTION_THROW:"ውስጥ ያስቀምጡ የፍርፍር ሳጥን",ACTION_UNTHROW:"ከዝቧ ሳጥን ያስወግዱ",ACTION_CLEAR:"ጠቃሚ",ACTION_COPY:"ኮፒ አድርግ",ACTION_EXPORT:"ይገባል",ACTION_IMPORT:"ማስገቢያ",MESSAGE_COPIED:"በክሊፕቦርድ ላይ ተቀናብሷል",MESSAGE_CLEARED:"የመዋረድ ሳጥን በተሳካ ሁኔታ ተሰራ!",MESSAGE_SONG_ADDED:"ሶንግ ወደ ካሬ ተጨምሯል",MESSAGE_SONG_REMOVED:"አውድ ከቆሻሻው ግዙፍ ተወስዶአል",MESSAGE_ARTIST_ADDED:"አርቲስት ወደ ፍሳሽ ሳጥን ተጨምሯል",MESSAGE_ARTIST_REMOVED:"አርቲስት ከቆሻሻ ሳጥን ተወግሯል",BACKUP_SAVE_SUCCESS:"ደጋፊው በተሳካ ሁኔታ ተቀምጧል።",BACKUP_SAVE_FAILED:"ማስቀመጫ ስራ አልተሳካም፣ የዝውውር ሳጥን ውስጥ ስለሚገኘው ይቅር በክሊፕቦርድ ላይ እና በእጅ ማስቀመጫ ይሞክሩ።",BACKUP_RESTORE_SUCCESS:"ማስቀመጫው በተሳካ ሁኔታ ወደ መጀመሪያ ሰርተዋል።",BACKUP_FILE_READ_FAILED:"ማስተዋል አልተቻለም፣ እባክዎ እንደሚገባ የ JSON ፋይል መሆኑን ያረጋግጡ።",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"የመጥረቢያ ማውጫ ማውጫ",SETTINGS_OPTIONS:"አማራጮች",SETTINGS_FEATURES:"የተለያዩ ባህሪዎች",SETTINGS_LOCAL_STORAGE:"የአካባቢ ማከማቻ",SETTINGS_ENABLED:"ተቋቋመ",SETTINGS_SHOW_WIDGET:"አይሮ ምልክት አሳይ",SETTINGS_AUTOPLAY:"ራስ ማውጣት በመጀመሪያ",SETTINGS_QUEUE_TRASHBIN:"የአንድ አንዴ የመቀመሪያ ማዕከል መክፈቻ",SETTINGS_TRACKLIST_TRASHBIN:"የመተግበሪያ ዝርዝር ስንጠቀ መቋቋም አድርገው",SETTINGS_PLAYLIST_MONITOR:"የፕሌሊስት ቅጂ",ITEMS_TITLE:"የመጥፎ ነገሮች ነጥቦች",ITEMS_EMPTY_SONGS:"<strong>የተወረወሩ ድግስ የለም!</strong><br/>ወደ መዋረጃ ሳጥን የምትጨምሩት ድግስ በዚህ ይታያሉ።",ITEMS_EMPTY_ARTISTS:"<strong>ምንም የተወረወሩ አርቲስቶች የሉም!</strong><br/>ወደ መዋቅሪያ የትሸቱባቸው አርቲስቶች እዚህ ይታያሉ።",ITEMS_TAB_SONGS:"ዘፈረሱ ግጥሞች",ITEMS_TAB_ARTISTS:"አርቲስቶች",ITEMS_LOADED_COUNT:"{{ተጫነ}} ከ {{ጠቅላላ}} የ {{አይነት}} ጋር ተጫንቷል",DESCRIPTION_COPY:"ሁሉንም የተወረዱ አይጥሞች ወደ ክሊፕቦርድ ይቅዱ።",DESCRIPTION_EXPORT:"ሁሉንም የተወገዱ ነገሮች ወደ .json ፋይል አስቀምጥ።",DESCRIPTION_IMPORT:"ሁሉንም አይтем በ መቆለፊያ ውስጥ ያለውን የ .json ፋይል ይጻፉ በማዳበር።",DESCRIPTION_CLEAR:"ሁሉንም የተወረወሩ ነገሮች ከቆሻሻ ሳጥን ያስወግዱ (ማስመለስ አይቻልም)።",ITEMS_EMPTY_SONGS_TITLE:"የተወረደ ድግስ የለም!",ITEMS_EMPTY_ARTISTS_TITLE:"ምንም የተወረደ አርቲስቶች የሉም!",DESCRIPTION_SETTINGS_ENABLED:"ዋና ማጥፊያ ለማንቃት ወይም ለመጥፋት ሁሉንም የ ትራሽቢን+ ተግባራት",DESCRIPTION_SETTINGS_SHOW_WIDGET:"የመቀመጫ ባር ላይ ለአሁኑ የሚጫው ጣራ ከጎን ለፈጣን መዳረሻ የመቀመጫ ᆖረራ ፊደል አሳይ",DESCRIPTION_SETTINGS_AUTOPLAY:"ራስ ብራሱ ስፖቲፋይ ተክፈቶ ወይም ልዩ አማራጭ ተጫነ የሙዚቃ መዝሙር ይጀምር",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"የማጥፋት አይኮን ወደ የሚመጣው የሙዚቃ ዝርዝር ሁሉንም የሙዚቃ መዝሙራት አጠገብ አክሉ ለቀላል አስተዳደር",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"የመቀመጫ አይኮኖችን በאלבום እና በፕሌልስት አቀራረቦች ውስጥ ያሉ የሙዚቃ ትዕይንቶች ከጎን ያክሉ ለፍጥነት ፍልተር ለማድረግ",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"በአውቶማቲክ ከስፖቲፋይ መዝሙር መቆራረጥ ይልቅ የመጨረሻዎ የመዝሙር ዝርዝር ሲቀጥል ከዚያ ይሰርዙ",SETTINGS_SKIP_TRASHED_TRACKS:"ዝተገደሉ ትራኮች አስቀድም",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"ከመዝገብ ውስጥ የተወገዱ ድምፆችን በራስ በራስ ያስገድዱ እና በመዝገበ ጊዜ ውስጥ ያለውን ቀጣይ የተፈቀደ መዝገብ ያግኙ",SETTINGS_AUTO_CLEAN_QUEUE:"ራስ ግልጽ የሚያደርገው የአንድ ቁጥር ዝርዝር",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"ከራስ በራሱ የተወረዱ ድግስ ስብስቦችን ከስማርት ሼፍል ዋና መስመር ያስወግዱ",SETTINGS_TRASH_ON_NEXT_HOTKEY:"ዝናብ በሚቀጥለው የሞገድ ቁልፍ",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"አሁኑኑ የተጫነውን ግንብር በሚቀጥለው መዝሙር ለመተካት የ Ctrl+ቀኝ የመተካት ቁልፍ ሲጠቀሙ አውቶማቲክ አጥር ውስጥ ያስገቡ",SETTINGS_REMOTE_CONTROL:"ሪሞት ኮንትሮል",SETTINGS_REMOTE_TOGGLE:"የራስ ቁልፍ ማብሪያ አቋርጥ/መብራት",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"የሞባይል ማውጫ ማጉጠሚያ ለመጠቀም ለማስጀመር/ለማቆም ሁለቴ ጠቅ ያድርጉ። መዝሙር ማስቀመጥ ማውጫውን እንዲያጥፍ ያረጋግጣል።",SETTINGS_REMOTE_SKIPPING:"የተላላይ የመዝለል ማስቆሚያ አንቀሳቅሷል",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"በማንኛውም ማስተላለፊያ ላይ ከስፖቲፋይ (ለምሳሌ፣ ሞባይል) በሚቆጣጠርበት ጊዜ የመዋጮ ቦታ ማለፍ ከተፈቀደ ይሰራል።",MESSAGE_REMOTE_SKIPPING_ENABLED:"የተጠቀሰው የማቆም ስርዓት አንቃጢ ነው",MESSAGE_REMOTE_SKIPPING_DISABLED:"የተጠቀመው ችግር አልተፈቀደም",MESSAGE_SONG_ADDED_REMOTE:"አሶና ከራስ በር ተደብቷል",SETTINGS_TRASH_VIA_LIKE:"ዝር በልይክ ማስወገድ",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"እንደ ሞባይል የተላለፈ መዝሙር ወደ መዋቅር ማስወገድ አውቶማቲክ ሁኔታ ያስወግዳል እና ወደ የሚቀጥለው መዝሙር ይዝዋል።",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Et=K((Kp,jv)=>{jv.exports={TRASHBIN_NAME:"سلة المهملات+",ACTION_THROW:"ضع في سلة المهملات",ACTION_UNTHROW:"اخرج من سلة المهملات",ACTION_CLEAR:"واضح",ACTION_COPY:"انسخ",ACTION_EXPORT:"تصدير",ACTION_IMPORT:"استيراد",MESSAGE_COPIED:"تم النسخ إلى الحافظة",MESSAGE_CLEARED:"اتممسح سلة المهملات بنجاح!",MESSAGE_SONG_ADDED:"اتضاف التسجيلة للسلة المهملات",MESSAGE_SONG_REMOVED:"تمت إزالة الأغنية من سلة المهملات",MESSAGE_ARTIST_ADDED:"اتضاف الفنان للسلة المهملات",MESSAGE_ARTIST_REMOVED:"اتمسح الفنان من سلة المهملات",BACKUP_SAVE_SUCCESS:"اتحفظ البك اب بنجاح.",BACKUP_SAVE_FAILED:"فشلت عملية حفظ النسخة الاحتياطية، جرب نسخ محتويات سلة المهملات إلى الحافظة وإنشاء نسخة احتياطية يدويًا.",BACKUP_RESTORE_SUCCESS:"ات\trestore النسخة الاحتياطية بنجاح.",BACKUP_FILE_READ_FAILED:"فشل قراءة الملف، يرجى التأكد من أنه ملف JSON صالح.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"إعدادات سلة المهملات+",SETTINGS_OPTIONS:"خيارات",SETTINGS_FEATURES:"مميزات",SETTINGS_LOCAL_STORAGE:"المساحة التخزينية المحلية",SETTINGS_ENABLED:"مُمَكَّن",SETTINGS_SHOW_WIDGET:"اعرض أيقونة الودجيت",SETTINGS_AUTOPLAY:"تشغيل تلقائي عند البدء",SETTINGS_QUEUE_TRASHBIN:"تفعيل سلة مهملات الطابور",SETTINGS_TRACKLIST_TRASHBIN:"تفعيل سلة مهملات قائمة الأغاني",SETTINGS_PLAYLIST_MONITOR:"مُراقب التشغيل",ITEMS_TITLE:"عناصر سلة المهملات+",ITEMS_EMPTY_SONGS:"<strong>مفيش أغانى فى السلة!</strong><br/>الأغانى اللى هتضيفها فى سلة المهملات هتظهر هنا.",ITEMS_EMPTY_ARTISTS:"<strong>مفيش فنانين في المزبلة!</strong><br/>الفنانين اللي تحطهم في سلة المهملات هيظهروا هنا.",ITEMS_TAB_SONGS:"أغانى",ITEMS_TAB_ARTISTS:"الفنانين",ITEMS_LOADED_COUNT:"تم تحميل {{loaded}} من أصل {{total}} {{type}}",DESCRIPTION_COPY:"انسخ كل العناصر في سلة المهملات للحافظة.",DESCRIPTION_EXPORT:"احفظ كل العناصر في سلة المهملات في ملف .json.",DESCRIPTION_IMPORT:"اكتب فوق كل العناصر في سلة المهملات باستخدام ملف .json.",DESCRIPTION_CLEAR:"امسح كل العناصر من سلة المهملات (مفيش رجعة).",ITEMS_EMPTY_SONGS_TITLE:"مفيش أغانى هبّلة!",ITEMS_EMPTY_ARTISTS_TITLE:"مفيش فنانين وحشين!",DESCRIPTION_SETTINGS_ENABLED:"مفتاح رئيسي لتفعيل أو إيقاف كل وظائف سلة المهملات+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"اعرض أيقونة سلة المهملات في شريط التشغيل بجانب التسجيل الصوتي اللي بتشتغل دلوقتي للوصول السريع",DESCRIPTION_SETTINGS_AUTOPLAY:"إبدأ العزف التلقائي لما يفتح سبوتيفاي أو لما يشتغل الامتداد",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"أضف أيقونات سلة المهملات بجانب كل أغنية في قائمة الانتظار الخاصة بك لإدارتها بسهولة",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"اضف أيقونات سلة مهملات بجانب الأغاني في عروض الألبوم والقوائم علشان التصفية السريعة",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"استرجاع تلقائي من أعطال تشغيل سبوتيفاي باستئناف قائم التشغيل الأخيرة بتاعك",SETTINGS_SKIP_TRASHED_TRACKS:"تجاوز المسارات التالفة",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"تخطي الأغاني المحذوفة تلقائيًا وإيجاد المسار المسموح به التالي أثناء التشغيل",SETTINGS_AUTO_CLEAN_QUEUE:"قائمة التنظيف التلقائي",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"اُحذف الأغاني الممحية من قائمة التشغيل العشوائية الذكية تلقائيًا",SETTINGS_TRASH_ON_NEXT_HOTKEY:"القمامة على الزر الساخن التالي",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"احذف الأغنية الحالية تلقائيًا لما تستخدم اختصار لوحة المفاتيح كترل+يمين للانتقال للأغنية الجاية",SETTINGS_REMOTE_CONTROL:"ريموت كنترول",SETTINGS_REMOTE_TOGGLE:"تفعيل التبديل عن بعد",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"اضغط مرتين على تشغيل/إيقاف من الموبايل علشان تشغل أو توقف تخطي التحكم عن بعد. تخطي الأغنية بيأكد التبديل.",SETTINGS_REMOTE_SKIPPING:"التخطي عن بعد مفعل",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"لو تم تفعيله، هيتم تخطي المحتوى الغير مرغوب فيه حتى لو كنت بتحكّم في سبوتيفاي من جهاز تاني (زي الموبايل)",MESSAGE_REMOTE_SKIPPING_ENABLED:"تم تفعيل التخطي عن بعد",MESSAGE_REMOTE_SKIPPING_DISABLED:"تم إيقاف التخطي عن بعد",MESSAGE_SONG_ADDED_REMOTE:"اتكسرت الأغنية عن بعد",SETTINGS_TRASH_VIA_LIKE:"زبالة عن طريق لايك",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"زي أغنية من الموبايل تتحذف. بيشيل اللايك تلقائي وياخد الأغنية الجاية.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var It=K((qp,Uv)=>{Uv.exports={TRASHBIN_NAME:"سلة المهملات+",ACTION_THROW:"ضع في سلة المهملات",ACTION_UNTHROW:"احذف من السلة",ACTION_CLEAR:"واضح",ACTION_COPY:"انسخ",ACTION_EXPORT:"صّدر",ACTION_IMPORT:"استيراد",MESSAGE_COPIED:"نُسخ للحافظة",MESSAGE_CLEARED:"تم مسح سلة المهملات بنجاح!",MESSAGE_SONG_ADDED:"تزادات الأغنية للسلة دلخردة",MESSAGE_SONG_REMOVED:"تتمسح الأغنية من السلة",MESSAGE_ARTIST_ADDED:"الفنان تزاد للسلة ديال اللخرق",MESSAGE_ARTIST_REMOVED:"الفنان تتمسح من السلة",BACKUP_SAVE_SUCCESS:"النّسخ الاحتياطي تمّ حفظه بنجاح.",BACKUP_SAVE_FAILED:"ما تقدرتش تحفض النسخة الاحتياطية، جرب تنجمو محتوى سلة المهملات للحافظة وتحدد نسخة احتياطية يدويًا.",BACKUP_RESTORE_SUCCESS:"تم استرجاع النسخة الاحتياطية بنجاح.",BACKUP_FILE_READ_FAILED:"ما تقدرتش تقرأ الملف، تأكد منين أنو ملف JSON سليم.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"الإعدادات+سلة المهملات",SETTINGS_OPTIONS:"خيارات",SETTINGS_FEATURES:"مميزات",SETTINGS_LOCAL_STORAGE:"التخزين المحلي",SETTINGS_ENABLED:"مُفعّل",SETTINGS_SHOW_WIDGET:"عرض أيقونة الودجيت",SETTINGS_AUTOPLAY:"التشغيل التلقائي فاش تبدا",SETTINGS_QUEUE_TRASHBIN:"دوز على سلة المحذوفات للطابور",SETTINGS_TRACKLIST_TRASHBIN:"دوز على سلة مهملات اللائحة",SETTINGS_PLAYLIST_MONITOR:"مراقب اللائحة",ITEMS_TITLE:"عناصر سلة المهملات+",ITEMS_EMPTY_SONGS:"<strong>ماشي دواير الأغاني!</strong><br/>الآغاني اللي بغيتي تزيدها فسلة المهملات غادي تظهر هنا.",ITEMS_EMPTY_ARTISTS:"<strong>ماشي فنانين في السلة!</strong><br/>الفنانين اللي تزيدهم في السلة غادي يظهرو هنا.",ITEMS_TAB_SONGS:"أغاني",ITEMS_TAB_ARTISTS:"فنانين",ITEMS_LOADED_COUNT:"{{loaded}} من أصل {{total}} {{type}} تحمّلوا",DESCRIPTION_COPY:"انسخ جميع العناصر اللي فالسلة للحافظة.",DESCRIPTION_EXPORT:"خزن جميع العناصر اللي فالسلة فملف .json.",DESCRIPTION_IMPORT:"اكتب فوق جميع العناصر في سلة المهملات عبر ملف .json.",DESCRIPTION_CLEAR:"امسح جميع العناصر من سلة المهملات (ما يقدرش يرجع للورا).",ITEMS_EMPTY_SONGS_TITLE:"ماشي البلايص المزروبة!",ITEMS_EMPTY_ARTISTS_TITLE:"والا فنانين متدهاسين!",DESCRIPTION_SETTINGS_ENABLED:"مفتاح رئيسي للتفعيل أو التعطيل جميع وظائف سلة المهملات+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"عرض أيقونة السلة في شريط التشغيل بجانب التسجيل اللي كيتم تشغيله باش يسهل الوصول ليها",DESCRIPTION_SETTINGS_AUTOPLAY:"ابدأ بتشغيل الموسيقى أوتوماتيكيًا وقت ما يفتح فيه سبوتيفاي ولا ما يحمل فيه الامتداد",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"ضيف أيقونات الزبالة بجانب كل أغنية في قائمة الانتظار الخاصة بيك باش تديرو تدبير ساهل",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"زيد أيقونات الزبالة بجانب الأغاني في عروض الألبومات والقوائم باش تتم إزالتها بسرعة",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"استرجاع تلقائي من أعطال التشغيل في سبوتيفاي بمواصلة آخر لائحة تشغيل لك",SETTINGS_SKIP_TRASHED_TRACKS:"تخطى المسارات التالفة",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"تخطي تلقائي للاغاني الممسوحة وباحث تلقائي على اغنية الموافقة الجاية فاش تدوز",SETTINGS_AUTO_CLEAN_QUEUE:"طابور التنظيف التلقائي",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"احذف تلقائيا الأغاني الممحية من قائمة التشغيل العشوائية الذكية ديالك",SETTINGS_TRASH_ON_NEXT_HOTKEY:"الزبالة على الزر الساخن الجاي",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"احذف تلقائياً الأغنية الحالية باش تستخدم اختصار لوحة المفاتيح كنترول+ليمين باش تتخطى للمسار الجاي",SETTINGS_REMOTE_CONTROL:"الريموت كونترول",SETTINGS_REMOTE_TOGGLE:"شغّل التبديل عن بعد",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"اضغط مرتين على تشغيل/إيقاف من الجوال باش تبدّل تخطي التّحكم عن بعد على/إيقاف. تخطي التّسجيل تأكيد للتبديل.",SETTINGS_REMOTE_SKIPPING:"التنقل البعيد شغال",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"ويمكنش تخطي التّفريغ حتى لو كنتي تدير سبوتيفاي من جهاز آخر (مثلا من التيليفون)",MESSAGE_REMOTE_SKIPPING_ENABLED:"تمكين التخطي عن بعد",MESSAGE_REMOTE_SKIPPING_DISABLED:"تم تعطيل التخطي عن بعد",MESSAGE_SONG_ADDED_REMOTE:"تَدَمَّر البلاصة بِالرِّيموت",SETTINGS_TRASH_VIA_LIKE:"النفايات عبر الاعجاب",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"بلاصة تغنية من الموبايل للسلة. يمسح الإعجاب تلقائياً ويتقدم للشيكة الجاية.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var mt=K((Yp,Wv)=>{Wv.exports={TRASHBIN_NAME:"سلة المهملات+",ACTION_THROW:"ضع في سلة المهملات",ACTION_UNTHROW:"أزل من سلة المهملات",ACTION_CLEAR:"واضح",ACTION_COPY:"نسخ",ACTION_EXPORT:"تصدير",ACTION_IMPORT:"استيراد",MESSAGE_COPIED:"تم النسخ إلى الحافظة",MESSAGE_CLEARED:"تم مسح سلة المهملات بنجاح!",MESSAGE_SONG_ADDED:"أُضيفت الأغنية إلى سلة المهملات",MESSAGE_SONG_REMOVED:"أُزيلت الأغنية من سلة المهملات",MESSAGE_ARTIST_ADDED:"تمت إضافة الفنان إلى سلة المهملات",MESSAGE_ARTIST_REMOVED:"تمت إزالة الفنان من سلة المهملات",BACKUP_SAVE_SUCCESS:"تم حفظ النسخة الاحتياطية بنجاح.",BACKUP_SAVE_FAILED:"فشل في حفظ النسخة الاحتياطية، جرّب نسخ محتويات سلة المهملات إلى الحافظة وإنشاء نسخة احتياطية يدويًا.",BACKUP_RESTORE_SUCCESS:"تم استعادة النسخة الاحتياطية بنجاح.",BACKUP_FILE_READ_FAILED:"فشل قراءة الملف، يرجى التأكد من أنه ملف JSON صالح.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"إعدادات سلة المهملات+",SETTINGS_OPTIONS:"خيارات",SETTINGS_FEATURES:"الميزات",SETTINGS_LOCAL_STORAGE:"التخزين المحلي",SETTINGS_ENABLED:"مُمَكَّن",SETTINGS_SHOW_WIDGET:"إظهار أيقونة الأداة",SETTINGS_AUTOPLAY:"التشغيل التلقائي عند البدء",SETTINGS_QUEUE_TRASHBIN:"تمكين سلة مهملات الطابور",SETTINGS_TRACKLIST_TRASHBIN:"تمكين سلة مهملات قائمة المسارات",SETTINGS_PLAYLIST_MONITOR:"مُراقبة قائمة التشغيل",ITEMS_TITLE:"عناصر سلة المهملات+",ITEMS_EMPTY_SONGS:"<strong>لا توجد أغانٍ في سلة المهملات!</strong><br/>ستظهر الأغانـي التي تضيفها إلى سلة المهملات هنا.",ITEMS_EMPTY_ARTISTS:"<strong>ما فيش فنانين في المهملات!</strong><br/>الفنانين اللي تضيفهم إلى سلة المهملات سيظهرون هنا.",ITEMS_TAB_SONGS:"أغاني",ITEMS_TAB_ARTISTS:"الفنانين",ITEMS_LOADED_COUNT:"تم تحميل {{loaded}} من أصل {{total}} {{type}}",DESCRIPTION_COPY:"انسخ جميع العناصر في سلة المهملات إلى الحافظة.",DESCRIPTION_EXPORT:"احفظ جميع العناصر في سلة المهملات في ملف .json.",DESCRIPTION_IMPORT:"استبدال جميع العناصر في سلة المهملات عبر ملف .json.",DESCRIPTION_CLEAR:"امسح جميع العناصر من سلة المهملات (لا يمكن التراجع عن هذا الإجراء).",ITEMS_EMPTY_SONGS_TITLE:"ما فيش أغانٍ مهملة!",ITEMS_EMPTY_ARTISTS_TITLE:"لا فنانين مرفوضين!",DESCRIPTION_SETTINGS_ENABLED:"مفتاح رئيسي لتفعيل أو تعطيل جميع وظائف سلة المهملات+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"عرض أيقونة سلة المهملات في شريط التشغيل بجانب المسار الذي يتم تشغيله حاليًا للوصول السريع",DESCRIPTION_SETTINGS_AUTOPLAY:"ابدأ تشغيل الموسيقى تلقائيًا عند فتح Spotify أو تحميل الإضافة",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"أضف أيقونات سلة المهملات بجانب كل أغنية في قائمة الانتظار الخاصة بك لإدارتها بسهولة",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"أضف أيقونات سلة المهملات بجانب الأغاني في عروض الألبومات وقوائم التشغيل لتصفية سريعة",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"استعادة تلقائية من أعطال تشغيل Spotify باستئناف قائمة التشغيل الأخيرة الخاصة بك",SETTINGS_SKIP_TRASHED_TRACKS:"تخطي المسارات المحذوفة",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"تخطي الأغاني المحذوفة تلقائيًا وإيجاد المسار المسموح به التالي أثناء التشغيل",SETTINGS_AUTO_CLEAN_QUEUE:"طابور التنظيف التلقائي",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"أزل تلقائيًا الأغاني المحذوفة من قائمة التشغيل العشوائية الذكية الخاصة بك",SETTINGS_TRASH_ON_NEXT_HOTKEY:"النفايات على مفتاح التشغيل التالي",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"حذف الأغنية الحالية تلقائيًا عند استخدام اختصار لوحة المفاتيح Ctrl+اليمين للانتقال إلى المسار التالي",SETTINGS_REMOTE_CONTROL:"جهاز التحكم عن بعد",SETTINGS_REMOTE_TOGGLE:"تمكين التبديل عن بعد",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"اضغط مرتين على تشغيل/إيقاف من الهاتف لتغيير تخطي التحكم عن بعد تشغيل/إيقاف. يؤكد تخطي المسار التبديل.",SETTINGS_REMOTE_SKIPPING:"التخطي عن بعد مفعل",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"عند التمكين، يعمل تخطي المهملات حتى عند التحكم في Spotify من جهاز آخر (مثلاً الهاتف)",MESSAGE_REMOTE_SKIPPING_ENABLED:"تم تمكين التخطي عن بعد",MESSAGE_REMOTE_SKIPPING_DISABLED:"تم تعطيل التخطي عن بعد",MESSAGE_SONG_ADDED_REMOTE:"تم حذف الأغنية عن بعد",SETTINGS_TRASH_VIA_LIKE:"نفايات عبر لايك",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"مثل أغنية من الهاتف إلى سلة المهملات. يتم إزالة الإعجاب تلقائيًا والانتقال تلقائيًا إلى المسار التالي.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var ft=K((Qp,Kv)=>{Kv.exports={TRASHBIN_NAME:"سلة المهملات+",ACTION_THROW:"ضع في سلة المهملات",ACTION_UNTHROW:"إزالة من سلة المهملات",ACTION_CLEAR:"واضح",ACTION_COPY:"نسخ",ACTION_EXPORT:"تصدير",ACTION_IMPORT:"استيراد",MESSAGE_COPIED:"تم النسخ إلى الحافظة",MESSAGE_CLEARED:"تم مسح سلة المهملات بنجاح!",MESSAGE_SONG_ADDED:"أُضيفت الأغنية إلى سلة المهملات",MESSAGE_SONG_REMOVED:"تمت إزالة الأغنية من سلة المهملات",MESSAGE_ARTIST_ADDED:"تمت إضافة الفنان إلى سلة المهملات",MESSAGE_ARTIST_REMOVED:"تمت إزالة الفنان من سلة المهملات",BACKUP_SAVE_SUCCESS:"تم حفظ النسخة الاحتياطية بنجاح.",BACKUP_SAVE_FAILED:"فشل حفظ النسخة الاحتياطية، حاول نسخ محتويات سلة المهملات إلى الحافظة وإنشاء نسخة احتياطية يدويًا.",BACKUP_RESTORE_SUCCESS:"تم استعادة النسخة الاحتياطية بنجاح.",BACKUP_FILE_READ_FAILED:"فشل في قراءة الملف، يرجى التأكد من أنه ملف JSON صالح.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"إعدادات سلة المهملات+",SETTINGS_OPTIONS:"خيارات",SETTINGS_FEATURES:"الميزات",SETTINGS_LOCAL_STORAGE:"التخزين المحلي",SETTINGS_ENABLED:"مُمكَّن",SETTINGS_SHOW_WIDGET:"عرض أيقونة الأداة",SETTINGS_AUTOPLAY:"تشغيل تلقائي عند البدء",SETTINGS_QUEUE_TRASHBIN:"تمكين سلة مهملات الطابور",SETTINGS_TRACKLIST_TRASHBIN:"تمكين سلة مهملات قائمة المسارات",SETTINGS_PLAYLIST_MONITOR:"مُراقب القوائم التشغيلية",ITEMS_TITLE:"عناصر سلة المهملات+",ITEMS_EMPTY_SONGS:"<strong>لا توجد أغانٍ في سلة المهملات!</strong><br/>ستظهر الأغانـي التي تضيفها إلى سلة المهملات هنا.",ITEMS_EMPTY_ARTISTS:"<strong>لا يوجد فنانين في سلة المهملات!</strong><br/>سيظهر الفنانون الذين تضيفهم إلى سلة المهملات هنا.",ITEMS_TAB_SONGS:"أغاني",ITEMS_TAB_ARTISTS:"الفنانون",ITEMS_LOADED_COUNT:"تم تحميل {{loaded}} من أصل {{total}} {{type}}",DESCRIPTION_COPY:"نسخ جميع العناصر في سلة المهملات إلى الحافظة.",DESCRIPTION_EXPORT:"احفظ جميع العناصر في سلة المهملات في ملف .json.",DESCRIPTION_IMPORT:"استبدال جميع العناصر في سلة المهملات عبر ملف .json",DESCRIPTION_CLEAR:"مسح جميع العناصر من سلة المهملات (لا يمكن التراجع عن هذا الإجراء).",ITEMS_EMPTY_SONGS_TITLE:"لا توجد أغانٍ محذوفة!",ITEMS_EMPTY_ARTISTS_TITLE:"لا فنانين مهملين!",DESCRIPTION_SETTINGS_ENABLED:"مفتاح رئيسي لتمكين أو تعطيل جميع وظائف سلة المهملات+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"عرض أيقونة سلة المهملات في شريط التشغيل بجانب المسار الذي يتم تشغيله حاليًا للوصول السريع",DESCRIPTION_SETTINGS_AUTOPLAY:"تشغيل الموسيقى تلقائيًا عند فتح Spotify أو تحميل الإضافة",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"أضف أيقونات سلة المهملات بجانب كل أغنية في قائمة الانتظار الخاصة بك لإدارتها بسهولة",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"إضافة أيقونات سلة المهملات بجانب الأغاني في عروض الألبومات وقوائم التشغيل لتصفية سريعة",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"استعادة التشغيل تلقائيًا بعد حدوث أخطار في تشغيل Spotify باستئناف قائمتك الأخيرة",SETTINGS_SKIP_TRASHED_TRACKS:"تخطي المسارات المحذوفة",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"تخطي الأغاني المحذوفة تلقائيًا والبحث عن المسار المسموح به التالي أثناء التشغيل",SETTINGS_AUTO_CLEAN_QUEUE:"قائمة التنظيف التلقائي",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"قم تلقائيًا بإزالة الأغاني المحذوفة من قائمة التشغيل العشوائية الذكية الخاصة بك",SETTINGS_TRASH_ON_NEXT_HOTKEY:"النفايات على المفتاح الساخن التالي",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"حذف الأغنية الحالية تلقائيًا عند استخدام اختصار لوحة المفاتيح Ctrl+يمين للانتقال إلى المسار التالي",SETTINGS_REMOTE_CONTROL:"جهاز التحكم عن بعد",SETTINGS_REMOTE_TOGGLE:"تمكين التبديل عن بُعد",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"انقر مرتين على تشغيل/إيقاف من الهاتف لتغيير تخطي التحكم عن بُعد تشغيل/إيقاف. يؤكد تخطي المسار هذا التبديل.",SETTINGS_REMOTE_SKIPPING:"التجازؤ عن بعد نشط",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"عند التمكين، يعمل تخطي سلة المهملات حتى عند التحكم في Spotify من جهاز آخر (مثل الهاتف المحمول)",MESSAGE_REMOTE_SKIPPING_ENABLED:"تم تمكين التخطي عن بُعد",MESSAGE_REMOTE_SKIPPING_DISABLED:"تم تعطيل التخطي عن بُعد",MESSAGE_SONG_ADDED_REMOTE:"تم حذف الأغنية عن بُعد",SETTINGS_TRASH_VIA_LIKE:"نفايات عبر الإعجاب",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"مثل أغنية من الهاتف إلى سلة المهملات. يتم إلغاء الإعجاب تلقائيًا والانتقال تلقائيًا إلى المسار التالي.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var xt=K((Xp,qv)=>{qv.exports={TRASHBIN_NAME:"Tullantı qutusu+",ACTION_THROW:"Tullantı qutusuna yerləşdirin",ACTION_UNTHROW:"Səbətdən silin",ACTION_CLEAR:"Açıq",ACTION_COPY:"Kopyalamaq",ACTION_EXPORT:"İxracat",ACTION_IMPORT:"İdxal",MESSAGE_COPIED:"Mübadilə buferinə köçürülüb",MESSAGE_CLEARED:"Zibilqutusu uğurla təmizləndi!",MESSAGE_SONG_ADDED:"Mahnı səbətə əlavə edildi",MESSAGE_SONG_REMOVED:"Mahnı səbətdən silindi",MESSAGE_ARTIST_ADDED:"Sənətçi tullantı qutusuna əlavə edildi",MESSAGE_ARTIST_REMOVED:"Sənətkar tullantı qutusundan silindi",BACKUP_SAVE_SUCCESS:"Ehtiyyat nüsxə uğurla saxlanıldı.",BACKUP_SAVE_FAILED:"Arxiv yadda saxlanılmadı, zibil qutusunun məzmununu mübadilə buferinə kopyalamağa və əl ilə arxiv yaratmağa cəhd edin.",BACKUP_RESTORE_SUCCESS:"Ehtiyyat nüsxə uğurla bərpa edildi.",BACKUP_FILE_READ_FAILED:"Fayl oxuna bilmədi, lütfən, onun düzgün JSON fayl olduğuna əmin olun.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Səbət+ Parametrləri",SETTINGS_OPTIONS:"Seçimlər",SETTINGS_FEATURES:"Xüsusiyyətlər",SETTINGS_LOCAL_STORAGE:"Yerli Yaddaş",SETTINGS_ENABLED:"Aktivləşdirildi",SETTINGS_SHOW_WIDGET:"Vidjet İkonunu Göstər",SETTINGS_AUTOPLAY:"Başlanğıcda avtomatik oynatma",SETTINGS_QUEUE_TRASHBIN:"Növbəni təmizləmə qutusunu aktivləşdirin",SETTINGS_TRACKLIST_TRASHBIN:"Treklər siyahısının səbətini aktivləşdirin",SETTINGS_PLAYLIST_MONITOR:"Playlist Monitoru",ITEMS_TITLE:"Zibildan + Məhsullar",ITEMS_EMPTY_SONGS:"<strong>Çöpə atılmış mahnılar yoxdur!</strong><br/>Səbətə əlavə etdiyiniz mahnılar burada görünəcək.",ITEMS_EMPTY_ARTISTS:"<strong>Çöp edilmiş ifaçılar yoxdur!</strong><br/>Siz çöp qutusuna əlavə etdiyiniz ifaçılar burada görünəcək.",ITEMS_TAB_SONGS:"Mahnılar",ITEMS_TAB_ARTISTS:"Sənətçilər",ITEMS_LOADED_COUNT:"Yüklenilib: {{loaded}}/{{total}} {{type}}",DESCRIPTION_COPY:"Səbətdəki bütün elementləri mübadilə buferinə kopyalayın.",DESCRIPTION_EXPORT:"Səbətdəki bütün elementləri .json faylına yadda saxlayın.",DESCRIPTION_IMPORT:"Zibilqutusundakı bütün elementləri .json faylı ilə əvəz edin.",DESCRIPTION_CLEAR:"Səbətdəki bütün elementləri silin (geri qaytarıla bilməz).",ITEMS_EMPTY_SONGS_TITLE:"Heç bir səslənmiş mahnı yoxdur!",ITEMS_EMPTY_ARTISTS_TITLE:"Heç bir sənətçi təhqir olunmasın!",DESCRIPTION_SETTINGS_ENABLED:"Bütün Zibilqutusu+ funksiyalarını aktivləşdirmək və ya deaktivləşdirmək üçün əsas keçid",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Hazırda səsləndirilən mahnının yanında tez giriş üçün səs yazısı çubuğunda səbət ikonu göstərin",DESCRIPTION_SETTINGS_AUTOPLAY:"Spotify aça və ya uzantı yüklənəndə avtomatik olaraq musiqi oxumağa başlayın",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Növbəti sırada olan hər mahnının yanına ləğv etmə ikonu əlavə edin ki, idarə etmək asan olsun",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Albom və çalma siyahısı görünüşlərində mahnıların yanında tez filtrasiya üçün səbət ikonları əlavə edin",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Son oynatma siyahısını davam etdirərək Spotify oynatma xətalarından avtomatik şəkildə bərpa edin",SETTINGS_SKIP_TRASHED_TRACKS:"Zibil Melodiyalardan Keç",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Səsləndirmə zamanı səbətdəki mahnıları avtomatik olaraq keçin və növbəti icazə verilən mahnını tapın",SETTINGS_AUTO_CLEAN_QUEUE:"Avtomatik Təmizləmə Növbəsi",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Ağıllı qarışıq növbənizdən avtomatik olaraq səsləri silin",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Növbəti qısayol düyməsində tullantılar",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Növbəti mahnıya keçmək üçün Ctrl+Sağ düyməsini istifadə etdikdə cari mahnını avtomatik olaraq səbətə at",SETTINGS_REMOTE_CONTROL:"Uzaqdan idarəetmə",SETTINGS_REMOTE_TOGGLE:"Uzaqdan Keçid Rejimini Aktivləşdirin",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Obyektin keçidini açmaq/deaktiv etmək üçün mobil cihazda oxutma/fasiləni iki dəfə basın. Mahnı keçidini təsdiqləmək üçün keçid.",SETTINGS_REMOTE_SKIPPING:"Uzaqdan Keçid Aktivdir",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Aktiv edildikdə, Spotify-ı digər cihazdan (məsələn, mobil) idarə edərkən belə səbətdən keçmə işləyir",MESSAGE_REMOTE_SKIPPING_ENABLED:"Uzaqdan keçid etmə aktivdir",MESSAGE_REMOTE_SKIPPING_DISABLED:"Uzaqdan keçid etmək deaktiv edildi",MESSAGE_SONG_ADDED_REMOTE:"Mahnı uzaqdan məhv edildi",SETTINGS_TRASH_VIA_LIKE:"Like vasitəsilə tullantılar",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Mobil telefonun çöp qutusuna mahnı kimi. Avtomatik olaraq bəyənməni ləğv edir və növbəti mahnıya keçir.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Ct=K((Jp,Yv)=>{Yv.exports={TRASHBIN_NAME:"Кошче+",ACTION_THROW:"Поставете в кошчето за боклук",ACTION_UNTHROW:"Премахни от кошчето",ACTION_CLEAR:"Ясно",ACTION_COPY:"Копиране",ACTION_EXPORT:"Експорт",ACTION_IMPORT:"Внос",MESSAGE_COPIED:"Копирано в клипборда",MESSAGE_CLEARED:"Кошът беше изпразнен успешно!",MESSAGE_SONG_ADDED:"Песента е добавена в кошчето",MESSAGE_SONG_REMOVED:"Песента е премахната от кошчето",MESSAGE_ARTIST_ADDED:"Художникът е добавен в кошчето за боклук",MESSAGE_ARTIST_REMOVED:"Художникът е премахнат от кошчето за боклук",BACKUP_SAVE_SUCCESS:"Резервното копие е запазено успешно.",BACKUP_SAVE_FAILED:"Неуспешно запазване на резервно копие, опитайте да копирате съдържанието на кошчето в клипборда и създайте резервно копие ръчно.",BACKUP_RESTORE_SUCCESS:"Резервното копие бе възстановено успешно.",BACKUP_FILE_READ_FAILED:"Неуспешно прочитане на файла, моля, уверете се, че е валиден JSON файл.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Настройки на кошчето+",SETTINGS_OPTIONS:"Опции",SETTINGS_FEATURES:"Характеристики",SETTINGS_LOCAL_STORAGE:"Локално съхранение",SETTINGS_ENABLED:"Активирано",SETTINGS_SHOW_WIDGET:"Показване на иконата за джаджа",SETTINGS_AUTOPLAY:"Автоматично възпроизвеждане при стартиране",SETTINGS_QUEUE_TRASHBIN:"Активиране на кош за опашка",SETTINGS_TRACKLIST_TRASHBIN:"Активиране на кошчето за списъка с песни",SETTINGS_PLAYLIST_MONITOR:"Плейлист Монитор",ITEMS_TITLE:"Елементи в кошчето+",ITEMS_EMPTY_SONGS:"<strong>Няма изтрити песни!</strong><br/>Песните, които добавите в кошчето, ще се появят тук.",ITEMS_EMPTY_ARTISTS:"<strong>Няма изтрити изпълнители!</strong><br/>Изпълнителите, които добавите в кошчето, ще се появят тук.",ITEMS_TAB_SONGS:"Песни",ITEMS_TAB_ARTISTS:"Художници",ITEMS_LOADED_COUNT:"{{loaded}} от {{total}} {{type}} заредени",DESCRIPTION_COPY:"Копиране на всички елементи в кошчето в клипборда.",DESCRIPTION_EXPORT:"Запазване на всички елементи в кошчето в .json файл.",DESCRIPTION_IMPORT:"Презаписване на всички елементи в кошчето чрез .json файл.",DESCRIPTION_CLEAR:"Изчистване на всички елементи от кошчето (не може да бъде възстановено).",ITEMS_EMPTY_SONGS_TITLE:"Няма изтрити песни!",ITEMS_EMPTY_ARTISTS_TITLE:"Никакви захвърлени артисти!",DESCRIPTION_SETTINGS_ENABLED:"Главен превключвател за активиране или деактивиране на цялата функционалност на кошчето+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Показване на икона за кош в лентата за възпроизвеждане до текущо възпроизвеждания трек за бърз достъп",DESCRIPTION_SETTINGS_AUTOPLAY:"Автоматично стартиране на музиката при отваряне на Spotify или зареждане на разширението",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Добавете икони за кошче до всяка песен в предстоящата си опашка за лесно управление",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Добавяне на икони за кошче до песните в албумите и плейлистите за бързо филтриране",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Автоматично възстановяване от проблеми с възпроизвеждането в Spotify чрез продължаване на последния ви плейлист",SETTINGS_SKIP_TRASHED_TRACKS:"Пропусни изтритите песни",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Автоматично пропускане на изтритите песни и намиране на следващата разрешена песен по време на възпроизвеждане",SETTINGS_AUTO_CLEAN_QUEUE:"Автоматично почистване на опашката",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Автоматично премахване на изтритите песни от опашката за смарт разбъркване",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Свалете със следващия бутон за бърз достъп",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Автоматично премахване на текущата песен при използване на клавишната комбинация Ctrl+дясно, за да се премине към следващата песен",SETTINGS_REMOTE_CONTROL:"Дистанционно управление",SETTINGS_REMOTE_TOGGLE:"Активиране на дистанционно превключване",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Докоснете два пъти бутона за възпроизвеждане/пауза от мобилното устройство, за да включите/изключите пропускането на песни на дистанция. Пропускането на песен потвърждава превключването.",SETTINGS_REMOTE_SKIPPING:"Дистанционно пропускане активно",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Когато е активирана, функцията за пропускане на кошчето работи дори когато управлявате Spotify от друго устройство (например мобилен телефон)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Активирано е дистанционно пропускане",MESSAGE_REMOTE_SKIPPING_DISABLED:"Дистанционното пропускане е деактивирано",MESSAGE_SONG_ADDED_REMOTE:"Песента е унищожена от разстояние",SETTINGS_TRASH_VIA_LIKE:"Смет за лайк",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Като песен от мобилно към кошчето. Автоматично премахва харесването и превърта към следващата песен.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var _t=K(($p,Qv)=>{Qv.exports={TRASHBIN_NAME:"कूड़ादान+",ACTION_THROW:"ट्रैशबिन में राखू",ACTION_UNTHROW:"ट्रैशबिन लेले हटा दें",ACTION_CLEAR:"साफ़",ACTION_COPY:"कॉपी",ACTION_EXPORT:"निर्यात",ACTION_IMPORT:"आयात",MESSAGE_COPIED:"क्लिपबोर्ड में कॉपी करलय गेल",MESSAGE_CLEARED:"कचरा बाल्टी सफलतापूर्वक साफ कएल गेल!",MESSAGE_SONG_ADDED:"गाना कें रद्दी के टोकरी में जोड़ल गेल",MESSAGE_SONG_REMOVED:"गाना रद्दी के टोकरी से हटा देल गेल छल",MESSAGE_ARTIST_ADDED:"कलाकार कें रद्दी डिब्बा में जोड़ल गेलय",MESSAGE_ARTIST_REMOVED:"कलाकार कें रद्दी डिब्बा लेले हटा देल गेलय हईय",BACKUP_SAVE_SUCCESS:"बैकअप सफलतापूर्वक सुरक्षित कएल गेलए।",BACKUP_SAVE_FAILED:"बैकअप सुरक्षित करे में असफल, ट्रैशबिन कें सामग्री कें क्लिपबोर्ड पर कॉपी करे आऊर मैन्युअल रूप सँ बैकअप बनाए कें कोशिश करूं।",BACKUP_RESTORE_SUCCESS:"बैकअप सफलतापूर्वक बहाल कएल गेल।",BACKUP_FILE_READ_FAILED:"फाइल पढ़े में असफल, कृपया सुनिश्चित करीं कि इ एगो मान्य JSON फाइल हई।",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ट्रैशबिन + सेटिंग्स",SETTINGS_OPTIONS:"विकल्प",SETTINGS_FEATURES:"विशेषताएं",SETTINGS_LOCAL_STORAGE:"स्थानीय भंडारण",SETTINGS_ENABLED:"सक्षम",SETTINGS_SHOW_WIDGET:"विजेट आइकन देखाएं",SETTINGS_AUTOPLAY:"शुरू में ऑटोप्ले",SETTINGS_QUEUE_TRASHBIN:"कतार ट्रेशबिन सक्षम करूं",SETTINGS_TRACKLIST_TRASHBIN:"ट्रैकलिस्ट ट्रैशबिन सक्षम करूं",SETTINGS_PLAYLIST_MONITOR:"प्लेलिस्ट मॉनिटर",ITEMS_TITLE:"ट्रैशबिन+ आइटम",ITEMS_EMPTY_SONGS:"<strong>कोनो गाना कें फेंकल नीं!</strong><br/>गाना जे अहां रद्दी डिब्बा में डालैत हईं इ लेल देखाई देत हईं।",ITEMS_EMPTY_ARTISTS:"<strong>कोनो कलाकार कें फेंकल नीं!</strong><br/>कलाकार जेकर अउ अपन रद्दी डिब्बा में जोड़त हईं इ लेल देखाई देत हईं।",ITEMS_TAB_SONGS:"गाना",ITEMS_TAB_ARTISTS:"कलाकार",ITEMS_LOADED_COUNT:"{{total}} में से {{loaded}} {{type}} लोड कएल गेल",DESCRIPTION_COPY:"ट्रैशबिन में सभी आइटम कें क्लिपबोर्ड पर कॉपी करूं।",DESCRIPTION_EXPORT:"ट्रैशबिन में सभी आइटम कें .json फाइल में सहेजल जाय।",DESCRIPTION_IMPORT:"ट्रैशबिन कें सभी आइटम कें .json फाइल कें माध्यम सँ ओवरराइट करूं।",DESCRIPTION_CLEAR:"कचरा बाल्टी से सभ पदार्थ निकाल दें (पलट नहीं सकैत छलई)।",ITEMS_EMPTY_SONGS_TITLE:"कोनो फेंकल गेल गाना नईं!",ITEMS_EMPTY_ARTISTS_TITLE:"कोनो निकृष्ट कलाकार नहि!",DESCRIPTION_SETTINGS_ENABLED:"सभ ट्रैशबिन+ कार्यक्षमता कें सक्षम या अक्षम करय कें मास्टर टॉगल",DESCRIPTION_SETTINGS_SHOW_WIDGET:"चलत ट्रैक कें बगल में प्लेबैक बार में त्वरित पहुंच कें लेल एक ट्रैश आइकन देखावल जाए",DESCRIPTION_SETTINGS_AUTOPLAY:"जब स्पॉटिफाई खुले या एक्सटेंशन लोड होए त' स्वचालित रूप सँ संगीत बजाए में शुरू करूं",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"अपन आगामी कतार में हर गीत कें बगल में कचरा आइकन जोड़ें आसान प्रबंधन कें लेल",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"एल्बम आ चलत लिस्ट देखलाइ में गाना कें बगल में कचरा आइकन जोड़ें ताकि त्वरित फ़िल्टरिंग हो सके",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"अपन पिछला प्लेलिस्ट कें फिर से शुरू कर के स्पॉटिफाई प्लेबैक गड़बड़ी से अपन आप ठीक हो जाएं",SETTINGS_SKIP_TRASHED_TRACKS:"हटाएल गेल ट्रैक्स छोड़ें",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"स्वचालित रूप से खराब गानान कें छोड़िया आऊर प्लेबैक के दौरान अगला अनुमति ट्रैक ढूंढिया",SETTINGS_AUTO_CLEAN_QUEUE:"ऑटो क्लीन कतार",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"अपन Smart Shuffle कतार में से अपनेआप फेंकल गेल गाना कें हटा दें",SETTINGS_TRASH_ON_NEXT_HOTKEY:"अगला हॉटकी पर ट्रैश",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"अगला ट्रैक पर जाने लेल Ctrl+Right कीबोर्ड शॉर्टकट के उपयोग करते समय स्वचालित रूप सँ वर्तमान गाना कें ट्रैश करें",SETTINGS_REMOTE_CONTROL:"रिमोट कंट्रोल",SETTINGS_REMOTE_TOGGLE:"दूरस्थ टॉगल सक्षम करें",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"मोबाइल से रिमोट स्किपिंग चालू/बंद करे कें लेल डबल-टैप प्ले/विराम दें। एगो ट्रैक स्किप टॉगल कें पुष्टि करत हई।",SETTINGS_REMOTE_SKIPPING:"दूरस्थ छोड़ना सक्रिय",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"जब सक्षम कएल जाईत छल, तब अन्य डिवाइस (उदाहरण के तौर पर, मोबाइल) से स्पॉटिफाई कें नियंत्रित करै कें बाद में भी ट्रैश-छलांग काम करईत छलि",MESSAGE_REMOTE_SKIPPING_ENABLED:"दूरस्थ छलांग लगाबैय सक्षम छलई",MESSAGE_REMOTE_SKIPPING_DISABLED:"दूरस्थ छलांग अक्षम कएल गेलए हई",MESSAGE_SONG_ADDED_REMOTE:"गाना रिमोट कें द्वारा नष्ट कएल गेल",SETTINGS_TRASH_VIA_LIKE:"लाइक कें माध्यम से कचरा",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"मोबाइल से ट्रैश कें लेल गाना कें अनलाइक करि दें। स्वचालित रूप सँ अनलाइक करि दें आ अगला ट्रैक पर स्किप करि दें।",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Bt=K((aS,Xv)=>{Xv.exports={TRASHBIN_NAME:"আবর্জনার বাক্স+",ACTION_THROW:"আবর্জনা বাক্সে রাখুন",ACTION_UNTHROW:"ট্রাশবিন থেকে সরান",ACTION_CLEAR:"স্পষ্ট",ACTION_COPY:"কপি",ACTION_EXPORT:"রপ্তানি",ACTION_IMPORT:"আমদানি করুন",MESSAGE_COPIED:"ক্লিপবোর্ডে কপি করা হয়েছে",MESSAGE_CLEARED:"ট্র্যাশবিন সফলভাবে খালি করা হয়েছে!",MESSAGE_SONG_ADDED:"গানটি আবর্জনাদণ্ডে যোগ করা হয়েছে",MESSAGE_SONG_REMOVED:"আবর্জনার ঝুড়ি থেকে গানটি সরানো হয়েছে",MESSAGE_ARTIST_ADDED:"শিল্পীকে আবর্জনাদণ্ডে যোগ করা হয়েছে",MESSAGE_ARTIST_REMOVED:"শিল্পীকে আবর্জনা বাক্স থেকে সরানো হয়েছে",BACKUP_SAVE_SUCCESS:"ব্যাকআপ সফলভাবে সংরক্ষিত হয়েছে।",BACKUP_SAVE_FAILED:"ব্যাকআপ সংরক্ষণ করতে ব্যর্থ হয়েছে, ট্র্যাশবিনের সামগ্রী ক্লিপবোর্ডে কপি করে ম্যানুয়ালি একটি ব্যাকআপ তৈরি করার চেষ্টা করুন।",BACKUP_RESTORE_SUCCESS:"ব্যাকআপ সফলভাবে পুনরুদ্ধার করা হয়েছে।",BACKUP_FILE_READ_FAILED:"ফাইল পড়তে ব্যর্থ হয়েছে, দয়া করে নিশ্চিত করুন যে এটি একটি বৈধ JSON ফাইল।",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ট্র্যাশবিন+ সেটিংস",SETTINGS_OPTIONS:"বিকল্পগুলি",SETTINGS_FEATURES:"বৈশিষ্ট্যগুলি",SETTINGS_LOCAL_STORAGE:"স্থানীয় সংরক্ষণ",SETTINGS_ENABLED:"সক্ষম করা হয়েছে",SETTINGS_SHOW_WIDGET:"উইজেট আইকন দেখান",SETTINGS_AUTOPLAY:"শুরুতে অটোপ্লে চালু",SETTINGS_QUEUE_TRASHBIN:"সারি আবর্জনা বাক্স সক্ষম করুন",SETTINGS_TRACKLIST_TRASHBIN:"ট্র‍্যাকলিস্ট ট্র‍্যাশবিন সক্ষম করুন",SETTINGS_PLAYLIST_MONITOR:"প্লেলিস্ট মনিটর",ITEMS_TITLE:"ট্র্যাশবিন+ আইটেমগুলি",ITEMS_EMPTY_SONGS:"<strong>কোন মুছে ফেলা গান নেই!</strong><br/>যে সব গান আপনি আবর্জনা বাক্সে যোগ করবেন সেগুলি এখানে দেখাবে।",ITEMS_EMPTY_ARTISTS:"<strong>কোনও আর্টিস্ট মুছবেন না!</strong><br/>আপনি যে আর্টিস্টদের আবর্জনা বাক্সে যোগ করবেন তারা এখানে দেখা যাবে।",ITEMS_TAB_SONGS:"গানগুলি",ITEMS_TAB_ARTISTS:"শিল্পীরা",ITEMS_LOADED_COUNT:"{{total}} এর {{loaded}} {{type}} লোড হয়েছে",DESCRIPTION_COPY:"ট্র্যাশবিনের সমস্ত আইটেম ক্লিপবোর্ডে কপি করুন।",DESCRIPTION_EXPORT:"ট্র্যাশবিনে সমস্ত আইটেমগুলি .json ফাইলে সংরক্ষণ করুন।",DESCRIPTION_IMPORT:"ট্র্যাশবিনের সমস্ত আইটেম .json ফাইলের মাধ্যমে ওভাররাইট করুন।",DESCRIPTION_CLEAR:"ট্র্যাশবিন থেকে সমস্ত আইটেম মুছে ফেলুন (পূর্বাবস্থায় ফিরিয়ে আনা যাবে না)।",ITEMS_EMPTY_SONGS_TITLE:"কোনো ত্রাশ করা গান নেই!",ITEMS_EMPTY_ARTISTS_TITLE:"কোনো নিকৃষ্ট শিল্পী নয়!",DESCRIPTION_SETTINGS_ENABLED:"সমস্ত ট্র্যাশবিন+ কার্যকারিতা চালু বা বন্ধ করার জন্য মাস্টার টগল",DESCRIPTION_SETTINGS_SHOW_WIDGET:"বর্তমানে চলমান ট্র‍্যাকের পাশে প্লেব্যাক বারে ট্র‍্যাশ আইকন প্রদর্শন করুন দ্রুত অ্যাক্সেসের জন্য",DESCRIPTION_SETTINGS_AUTOPLAY:"স্পটিফাই খোলার সময় বা এক্সটেনশন লোড হওয়ার সময় স্বয়ংক্রিয়ভাবে সঙ্গীত চালু করুন",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"আপনার আসন্ন কিউতে প্রতিটি গানের পাশে ট্র্যাশ আইকন যোগ করুন সহজ ব্যবস্থাপনার জন্য",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"অ্যালবাম এবং প্লেলিস্ট ভিউতে দ্রুত ফিল্টারিংয়ের জন্য গানগুলির পাশে ট্র্যাশ আইকন যোগ করুন",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"স্পটিফাই প্লেব্যাকের ত্রুটি থেকে স্বয়ংক্রিয়ভাবে পুনরুদ্ধার করুন আপনার শেষ প্লেলিস্টটি চালু করে",SETTINGS_SKIP_TRASHED_TRACKS:"মুছে ফেলা ট্র‍্যাকগুলি এড়িয়ে যান",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"স্বয়ংক্রিয়ভাবে মুছে ফেলা গানগুলি এড়িয়ে চলুন এবং চলমান অবস্থায় পরবর্তী অনুমোদিত ট্র‍্যাকটি খুঁজুন",SETTINGS_AUTO_CLEAN_QUEUE:"অটো ক্লিন কিউ",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"আপনার স্মার্ট শাফল সারিতে থেকে আবর্জনা গানগুলি স্বয়ংক্রিয়ভাবে সরানো হবে",SETTINGS_TRASH_ON_NEXT_HOTKEY:"পরবর্তী হটকি-এ আবর্জনা",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"পরবর্তী ট্র‍্যাকে যাওয়ার জন্য Ctrl+Right কীবোর্ড শর্টকাট ব্যবহার করার সময় বর্তমান গানটি স্বয়ংক্রিয়ভাবে ট্র্যাশ করুন",SETTINGS_REMOTE_CONTROL:"দূরবর্তী নিয়ন্ত্রণ",SETTINGS_REMOTE_TOGGLE:"দূরবর্তী টগল সক্ষম করুন",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"মোবাইল থেকে রিমোট স্কিপিং চালু/বন্ধ করতে প্লে/বিরতি দ্বিগুণ-ট্যাপ করুন। একটি ট্র্যাক স্কিপ টগল নিশ্চিত করে।",SETTINGS_REMOTE_SKIPPING:"দূরবর্তী স্কিপিং সক্রিয়",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"যখন সক্ষম করা হয়, তখন অন্য ডিভাইস (যেমন, মোবাইল) থেকে স্পটিফাই নিয়ন্ত্রণ করার সময়ও ট্র্যাশ-স্কিপিং কাজ করে",MESSAGE_REMOTE_SKIPPING_ENABLED:"দূরবর্তী স্কিপিং সক্ষম করা হয়েছে",MESSAGE_REMOTE_SKIPPING_DISABLED:"দূরবর্তী স্কিপিং অক্ষম",MESSAGE_SONG_ADDED_REMOTE:"গানটি দূর থেকে নষ্ট করা হয়েছে",SETTINGS_TRASH_VIA_LIKE:"লাইকের মাধ্যমে আবর্জনা",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"মোবাইল থেকে ট্র্যাশে এটি পাঠানোর জন্য একটি গানের মতো। স্বয়ংক্রিয়ভাবে অপছন্দ করে এবং পরবর্তী ট্র্যাকে চলে যায়।",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var zt=K((tS,Jv)=>{Jv.exports={TRASHBIN_NAME:"Smeće+",ACTION_THROW:"Stavi u kantu za đubre",ACTION_UNTHROW:"Ukloni iz kante za otpatke",ACTION_CLEAR:"Jasno",ACTION_COPY:"Kopiraj",ACTION_EXPORT:"Izvoz",ACTION_IMPORT:"Uvoz",MESSAGE_COPIED:"Kopirano u međuspremnik",MESSAGE_CLEARED:"Smeće je uspješno očišćeno!",MESSAGE_SONG_ADDED:"Pjesma dodana u kantu za otpatke",MESSAGE_SONG_REMOVED:"Pjesma uklonjena iz kante za otpatke",MESSAGE_ARTIST_ADDED:"Umjetnik dodan u kantu za otpatke",MESSAGE_ARTIST_REMOVED:"Umjetnik uklonjen iz kante za otpatke",BACKUP_SAVE_SUCCESS:"Sigurnosna kopija je uspješno sačuvana.",BACKUP_SAVE_FAILED:"Nije uspjelo spremanje sigurnosne kopije, pokušajte kopirati sadržaj kante za smeće u međuspremnik i ručno kreirati sigurnosnu kopiju.",BACKUP_RESTORE_SUCCESS:"Sigurnosna kopija je uspješno vraćena.",BACKUP_FILE_READ_FAILED:"Nije uspjeo pročitati datoteku, molimo provjerite da li je validna JSON datoteka.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Postavke smeća+",SETTINGS_OPTIONS:"Opcije",SETTINGS_FEATURES:"Karakteristike",SETTINGS_LOCAL_STORAGE:"Lokalno skladište",SETTINGS_ENABLED:"Omogućeno",SETTINGS_SHOW_WIDGET:"Prikaži ikonu vidžeta",SETTINGS_AUTOPLAY:"Automatsko pokretanje pri pokretanju",SETTINGS_QUEUE_TRASHBIN:"Omogući korpu za otpatke reda čekanja",SETTINGS_TRACKLIST_TRASHBIN:"Omogući kantu za otpatke na listi staza",SETTINGS_PLAYLIST_MONITOR:"Plejlista Monitor",ITEMS_TITLE:"Stavke kantu za otpatke+",ITEMS_EMPTY_SONGS:"<strong>Nema pjesama u smeću!</strong><br/>Pjesme koje dodate u kantu za smeće pojaviti će se ovdje.",ITEMS_EMPTY_ARTISTS:"<strong>Nema odbačenih izvođača!</strong><br/>Izvođači koje dodate u kantu za otpatke pojaviti će se ovdje.",ITEMS_TAB_SONGS:"Pjesme",ITEMS_TAB_ARTISTS:"Umjetnici",ITEMS_LOADED_COUNT:"{{loaded}} od {{total}} {{type}} učitano",DESCRIPTION_COPY:"Kopiraj sve stavke u kantu za otpatke u međuspremnik.",DESCRIPTION_EXPORT:"Sačuvaj sve stavke u kantu za otpatke u .json datoteku.",DESCRIPTION_IMPORT:"Prepiši sve stavke u kanti za otpatke putem .json datoteke.",DESCRIPTION_CLEAR:"Obriši sve stavke iz kante za otpatke (ne može se poništiti).",ITEMS_EMPTY_SONGS_TITLE:"Nema odbačenih pjesama!",ITEMS_EMPTY_ARTISTS_TITLE:"Nema odbačenih umjetnika!",DESCRIPTION_SETTINGS_ENABLED:"Glavni prekidač za omogućavanje ili onemogućavanje svih funkcija Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Prikaži ikonu kante za otpatke na traci za reprodukciju pored trenutno sviranog numerka radi brzeg pristupa",DESCRIPTION_SETTINGS_AUTOPLAY:"Automatski pokreni sviranje muzike kada se Spotify otvori ili kada se proširenje učita",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Dodajte ikone za otpad pored svake pjesme u vašoj nadolazećoj redu za jednostavno upravljanje",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Dodajte ikone za otpad pored pjesama u prikazima albuma i plejlista za brzo filtriranje",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatski se oporavite od kvarova pri reprodukciji na Spotifyju tako što ćete nastaviti sa svojom posljednjom plejlistom",SETTINGS_SKIP_TRASHED_TRACKS:"Preskoči odbačene staze",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Automatski preskoči obrisane pjesme i pronađi sljedeći dozvoljeni zapis tokom reprodukcije",SETTINGS_AUTO_CLEAN_QUEUE:"Automatska red čišćenja",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Automatski uklonite pjesme izbačene u smeće iz vaše Smart Shuffle reda",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Smeće na sljedećem prečicu",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Automatski bacite trenutnu pjesmu kada koristite prečicu na tastaturi Ctrl+Desno da preskočite na sljedeću pjesmu",SETTINGS_REMOTE_CONTROL:"Daljinski upravljač",SETTINGS_REMOTE_TOGGLE:"Omogući daljinsko prebacivanje",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dvaput dodirnite reprodukciju/pauzu sa mobilnog uređaja da biste uključili/isključili preskakanje na daljinu. Preskakanje numerka potvrđuje uključivanje/isključivanje.",SETTINGS_REMOTE_SKIPPING:"Daljinsko preskakanje aktivno",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Kada je omogućeno, preskakanje otpada funkcioniše čak i kada upravljate Spotify-om sa drugog uređaja (npr. mobilnog telefona)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Preskakanje na daljinu omogućeno",MESSAGE_REMOTE_SKIPPING_DISABLED:"Daljinsko preskakanje onemogućeno",MESSAGE_SONG_ADDED_REMOTE:"Pjesma oštećena na daljinu",SETTINGS_TRASH_VIA_LIKE:"Smeće putem Sviđa mi se",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Kao pjesma s mobilnog, izbaci je u otpad. Automatski uklanja sviđanje i prelazi na sljedeću pjesmu.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Lt=K((rS,$v)=>{$v.exports={TRASHBIN_NAME:"Paperera+",ACTION_THROW:"Posa a la paperera",ACTION_UNTHROW:"Elimina de la paperera",ACTION_CLEAR:"Clar",ACTION_COPY:"Còpia",ACTION_EXPORT:"Exportar",ACTION_IMPORT:"Importar",MESSAGE_COPIED:"Copiat al porta-retalls",MESSAGE_CLEARED:"Paperera buidada amb èxit!",MESSAGE_SONG_ADDED:"Cançó afegida a la paperera",MESSAGE_SONG_REMOVED:"Cançó eliminada de la paperera",MESSAGE_ARTIST_ADDED:"Artista afegit a la paperera",MESSAGE_ARTIST_REMOVED:"Artista eliminat de la paperera",BACKUP_SAVE_SUCCESS:"Còpia de seguretat desada correctament.",BACKUP_SAVE_FAILED:"No s'ha pogut desar la còpia de seguretat, intenta copiar el contingut de la paperera al porta-retalls i crear una còpia de seguretat manualment.",BACKUP_RESTORE_SUCCESS:"Còpia de seguretat restaurada amb èxit.",BACKUP_FILE_READ_FAILED:"No s'ha pogut llegir el fitxer, assegureu-vos que és un fitxer JSON vàlid.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Configuració de la Paperera+",SETTINGS_OPTIONS:"Opcions",SETTINGS_FEATURES:"Característiques",SETTINGS_LOCAL_STORAGE:"Emmagatzematge local",SETTINGS_ENABLED:"Habilitat",SETTINGS_SHOW_WIDGET:"Mostra la icona del giny",SETTINGS_AUTOPLAY:"Reproducció automàtica en iniciar",SETTINGS_QUEUE_TRASHBIN:"Habilita la paperera de la cua",SETTINGS_TRACKLIST_TRASHBIN:"Habilita la paperera de la llista de pistes",SETTINGS_PLAYLIST_MONITOR:"Monitor de llistes de reproducció",ITEMS_TITLE:"Elements de la paperera+",ITEMS_EMPTY_SONGS:"<strong>No hi ha cançons esborrades!</strong><br/>Les cançons que afegeixis a la paperera apareixeran aquí.",ITEMS_EMPTY_ARTISTS:"<strong>Cap artista esborrat!</strong><br/>Els artistes que afegeixis a la paperera apareixeran aquí.",ITEMS_TAB_SONGS:"Cançons",ITEMS_TAB_ARTISTS:"Artistes",ITEMS_LOADED_COUNT:"{{loaded}} de {{total}} {{type}} carregats",DESCRIPTION_COPY:"Copia tots els elements de la paperera al porta-retalls.",DESCRIPTION_EXPORT:"Desa tots els elements de la paperera en un fitxer .json.",DESCRIPTION_IMPORT:"Sobreescriu tots els elements de la paperera mitjançant el fitxer .json.",DESCRIPTION_CLEAR:"Esborra tots els elements de la paperera (no es pot desfer).",ITEMS_EMPTY_SONGS_TITLE:"Cap cançó esborrada!",ITEMS_EMPTY_ARTISTS_TITLE:"Cap artista esbotzat!",DESCRIPTION_SETTINGS_ENABLED:"Commutador principal per activar o desactivar totes les funcionalitats de la Paperera+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Mostra una icona de paperera a la barra de reproducció al costat de la pista que s'està reproduint per accedir-hi ràpidament",DESCRIPTION_SETTINGS_AUTOPLAY:"Inicia automàticament la reproducció de música quan s'obre Spotify o es carrega l'extensió",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Afegeix icones de paperera al costat de cada cançó de la teva cua propera per gestionar-les fàcilment",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Afegeix icones de paperera al costat de les cançons a les vistes d'àlbum i llista de reproducció per a un filtrat ràpid",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recupera't automàticament dels errors de reproducció del Spotify reprement l'última llista de reproducció",SETTINGS_SKIP_TRASHED_TRACKS:"Omet els pistes esborrats",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Omet automàticament les cançons esborrades i troba la següent pista permesa durant la reproducció",SETTINGS_AUTO_CLEAN_QUEUE:"Cua de neteja automàtica",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Elimina automàticament les cançons esborrades de la teva cua de reproducció aleatòria intel·ligent",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Paperera amb la següent tecla ràpida",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Elimina automàticament la cançó actual quan utilitzes la drecera de teclat Ctrl+Dreta per passar a la següent pista",SETTINGS_REMOTE_CONTROL:"Control remot",SETTINGS_REMOTE_TOGGLE:"Habilita l'activació remota",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Toca dues vegades reproduir/pausar des del mòbil per activar o desactivar el salt de pista a distància. El salt d'una pista confirma l'activació o desactivació.",SETTINGS_REMOTE_SKIPPING:"Omplert remot actiu",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Quan està activat, saltar-se la paperera funciona fins i tot quan es controla Spotify des d'un altre dispositiu (per exemple, mòbil)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Salt d'execució remot activat",MESSAGE_REMOTE_SKIPPING_DISABLED:"Salt remot desactivat",MESSAGE_SONG_ADDED_REMOTE:"Cançó esborrada mitjançant control remot",SETTINGS_TRASH_VIA_LIKE:"Brossa mitjançant Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:`Com una cançó del mòbil a la paperera. Elimina automàticament el "m'agrada" i passa a la següent pista.`,SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Ht=K((lS,au)=>{au.exports={TRASHBIN_NAME:"Koš+",ACTION_THROW:"Umístit do koše",ACTION_UNTHROW:"Odstranit z koše",ACTION_CLEAR:"Jasné",ACTION_COPY:"Kopírovat",ACTION_EXPORT:"Export",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Zkopírováno do schránky",MESSAGE_CLEARED:"Koš byl úspěšně vyprázdněn!",MESSAGE_SONG_ADDED:"Píseň přidána do koše",MESSAGE_SONG_REMOVED:"Píseň odstraněna z koše",MESSAGE_ARTIST_ADDED:"Umělec přidán do koše",MESSAGE_ARTIST_REMOVED:"Umělec odstraněn z koše",BACKUP_SAVE_SUCCESS:"Záloha byla úspěšně uložena.",BACKUP_SAVE_FAILED:"Nepodařilo se uložit zálohu, zkuste zkopírovat obsah koše do schránky a vytvořit zálohu ručně.",BACKUP_RESTORE_SUCCESS:"Záloha byla úspěšně obnovena.",BACKUP_FILE_READ_FAILED:"Nepodařilo se přečíst soubor, ujistěte se, že jde o platný soubor JSON.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Nastavení koše+",SETTINGS_OPTIONS:"Možnosti",SETTINGS_FEATURES:"Funkce",SETTINGS_LOCAL_STORAGE:"Místní úložiště",SETTINGS_ENABLED:"Povoleno",SETTINGS_SHOW_WIDGET:"Zobrazit ikonu widgetu",SETTINGS_AUTOPLAY:"Automatické spuštění při startu",SETTINGS_QUEUE_TRASHBIN:"Povolit koš fronty",SETTINGS_TRACKLIST_TRASHBIN:"Povolit koš pro seznam stop",SETTINGS_PLAYLIST_MONITOR:"Monitor seznamu skladeb",ITEMS_TITLE:"Položky koše+",ITEMS_EMPTY_SONGS:"<strong>Žádné smazané skladby!</strong><br/>Skladby, které přidáte do koše, se zobrazí zde.",ITEMS_EMPTY_ARTISTS:"<strong>Žádní umělci ve koši!</strong><br/>Umělci, které přidáte do koše, se objeví zde.",ITEMS_TAB_SONGS:"Písně",ITEMS_TAB_ARTISTS:"Umělci",ITEMS_LOADED_COUNT:"Načteno {{loaded}} z {{total}} položek typu {{type}}",DESCRIPTION_COPY:"Zkopírovat všechny položky v koši do schránky.",DESCRIPTION_EXPORT:"Uložit všechny položky v koši do souboru .json.",DESCRIPTION_IMPORT:"Přepsat všechny položky v koši pomocí souboru .json.",DESCRIPTION_CLEAR:"Odstranit všechny položky z koše (nelze vrátit zpět).",ITEMS_EMPTY_SONGS_TITLE:"Žádné smazané skladby!",ITEMS_EMPTY_ARTISTS_TITLE:"Žádní zdiskreditovaní umělci!",DESCRIPTION_SETTINGS_ENABLED:"Hlavní přepínač pro povolení nebo zakázání veškeré funkce Koš+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Zobrazit ikonu koše na liště přehrávání vedle právě přehrávané skladby pro rychlý přístup",DESCRIPTION_SETTINGS_AUTOPLAY:"Automaticky spustit přehrávání hudby při otevření Spotify nebo načtení rozšíření",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Přidejte ikony koše vedle každé skladby ve vaší nadcházející frontě pro snadnou správu",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Přidejte ikony koše vedle skladeb v zobrazení alba a seznamu skladeb pro rychlé filtrování",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatické obnovení přehrávání ve Spotify po chybách obnovením poslední playlistu",SETTINGS_SKIP_TRASHED_TRACKS:"Přeskočit smazané skladby",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Automaticky přeskakovat smazané skladby a během přehrávání najít další povolenou skladbu",SETTINGS_AUTO_CLEAN_QUEUE:"Fronta čištění vozidel",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Automaticky odstraňuj smazané skladby ze své fronty chytrého náhodného přehrávání",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Koš při dalším klávesovém zkratku",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Automaticky odstranit aktuální skladbu do koše při použití klávesové zkratky Ctrl+šipka doprava pro přeskočení na další skladbu",SETTINGS_REMOTE_CONTROL:"Dálkové ovládání",SETTINGS_REMOTE_TOGGLE:"Povolit vzdálené přepínání",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dvojitým klepnutím na přehrávání/pauzu z mobilního zařízení zapnete nebo vypnete vzdálené přeskakování. Přeskočení skladby potvrdí změnu nastavení.",SETTINGS_REMOTE_SKIPPING:"Vzdálené přeskočení aktivní",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Když je tato funkce povolená, přeskakování koše funguje i při ovládání Spotify z jiného zařízení (např. mobilního telefonu).",MESSAGE_REMOTE_SKIPPING_ENABLED:"Vzdálené přeskakování povoleno",MESSAGE_REMOTE_SKIPPING_DISABLED:"Vzdálené přeskakování zakázáno",MESSAGE_SONG_ADDED_REMOTE:"Píseň zničena na dálku",SETTINGS_TRASH_VIA_LIKE:"Odpadky přes Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Jako píseň z mobilu do koše. Automaticky odlajkne a přeskočí na další skladbu.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Vt=K((iS,tu)=>{tu.exports={TRASHBIN_NAME:"Papirkurv+",ACTION_THROW:"Placer i papirkurven",ACTION_UNTHROW:"Fjern fra papirkurven",ACTION_CLEAR:"Klar",ACTION_COPY:"Kopiér",ACTION_EXPORT:"Eksport",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Kopieret til udklipsholder",MESSAGE_CLEARED:"Papirkurven er tømt med succes!",MESSAGE_SONG_ADDED:"Sang tilføjet til papirkurven",MESSAGE_SONG_REMOVED:"Sang fjernet fra papirkurven",MESSAGE_ARTIST_ADDED:"Kunstner tilføjet til papirkurven",MESSAGE_ARTIST_REMOVED:"Kunstner fjernet fra papirkurven",BACKUP_SAVE_SUCCESS:"Sikkerhedskopien blev gemt succesfuldt.",BACKUP_SAVE_FAILED:"Kunne ikke gemme sikkerhedskopien, prøv at kopiere papirkassens indhold til udklipsholderen og opret en sikkerhedskopi manuelt.",BACKUP_RESTORE_SUCCESS:"Sikkerhedskopien blev gendannet succesfuldt.",BACKUP_FILE_READ_FAILED:"Kunne ikke læse filen, sørg venligst for, at det er en gyldig JSON-fil.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Trashbin+ Indstillinger",SETTINGS_OPTIONS:"Valgmuligheder",SETTINGS_FEATURES:"Funktioner",SETTINGS_LOCAL_STORAGE:"Lokal lagerplads",SETTINGS_ENABLED:"Aktiveret",SETTINGS_SHOW_WIDGET:"Vis widget-ikon",SETTINGS_AUTOPLAY:"Automatisk afspilning ved start",SETTINGS_QUEUE_TRASHBIN:"Aktivér kø-papirkurv",SETTINGS_TRACKLIST_TRASHBIN:"Aktivér slettelsesbakke for sporliste",SETTINGS_PLAYLIST_MONITOR:"Aftaleskema Monitor",ITEMS_TITLE:"Papirkurv+ emner",ITEMS_EMPTY_SONGS:"<strong>Ingen slettede sange!</strong><br/>Sange, som du lægger i papirkurven, vises her.",ITEMS_EMPTY_ARTISTS:"<strong>Ingen slettet kunstnere!</strong><br/>Kunstnere, som du tilføjer til papirkurven, vises her.",ITEMS_TAB_SONGS:"Sange",ITEMS_TAB_ARTISTS:"Kunstnere",ITEMS_LOADED_COUNT:"{{loaded}} af {{total}} {{type}} indlæst",DESCRIPTION_COPY:"Kopier alle elementer i papirkurven til udklipsholderen.",DESCRIPTION_EXPORT:"Gem alle elementer i papirkurven i en .json-fil.",DESCRIPTION_IMPORT:"Overskriv alle elementer i papirkurven via .json-fil.",DESCRIPTION_CLEAR:"Ryd alle elementer fra papirkurven (kan ikke fortrydes).",ITEMS_EMPTY_SONGS_TITLE:"Ingen slettede sange!",ITEMS_EMPTY_ARTISTS_TITLE:"Ingen kasseret kunstnere!",DESCRIPTION_SETTINGS_ENABLED:"Masterkontakt til at aktivere eller deaktivere al Papirkurv+-funktionalitet",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Vis et papirkurv-ikon i afspilningslinjen ved siden af den aktuelle sang for hurtig adgang",DESCRIPTION_SETTINGS_AUTOPLAY:"Start automatisk afspilning af musik, når Spotify åbnes eller udvidelsen indlæses",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Tilføj papirkurv-ikoner ud for hver sang i din kommende kø for nem administration",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Tilføj papirkurv-ikoner ved siden af sange i album- og afspilningslistevisninger til hurtig filtrering",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Gendan automatisk fra afspilningsproblemer i Spotify ved at genoptage din sidste playliste",SETTINGS_SKIP_TRASHED_TRACKS:"Spring slettede spor over",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Spring automatisk over slettede sange og find det næste tilladte nummer under afspilning",SETTINGS_AUTO_CLEAN_QUEUE:"Automatisk rensning af kø",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Fjern automatisk slettede sange fra din Smart Shuffle-kø",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Papirkurv ved næste genvejstast",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Slet automatisk det nuværende nummer, når du bruger genvejen Ctrl+Højre til at springe til næste sporing",SETTINGS_REMOTE_CONTROL:"Fjernbetjening",SETTINGS_REMOTE_TOGGLE:"Aktivér fjernbetjeningstilstand",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dobbelttryk på afspil/pause fra mobilen for at slå fjernhåndtering af spring til/fra. Et spring til næste nummer bekræfter ændringen.",SETTINGS_REMOTE_SKIPPING:"Fjernbetjent springer aktivt over",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Når det er aktiveret, fungerer sletning uden papirkurv, selv når Spotify styres fra en anden enhed (f.eks. mobil)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Fjernhåndtering af springer aktiveret",MESSAGE_REMOTE_SKIPPING_DISABLED:"Fjernhåndtering af spring over deaktiveret",MESSAGE_SONG_ADDED_REMOTE:"Sang ødelagt via fjernbetjening",SETTINGS_TRASH_VIA_LIKE:"Affald via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Som en sang fra mobil til papirkurven. Fjerner automatisk like og springer til næste sporing.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var kt=K((eS,ru)=>{ru.exports={TRASHBIN_NAME:"Papierkorb+",ACTION_THROW:"In den Papierkorb legen",ACTION_UNTHROW:"Aus dem Papierkorb entfernen",ACTION_CLEAR:"Klar",ACTION_COPY:"Kopieren",ACTION_EXPORT:"Export",ACTION_IMPORT:"Import",MESSAGE_COPIED:"In die Zwischenablage kopiert",MESSAGE_CLEARED:"Papierkorb erfolgreich geleert!",MESSAGE_SONG_ADDED:"Lied in den Papierkorb verschoben",MESSAGE_SONG_REMOVED:"Lied aus dem Papierkorb entfernt",MESSAGE_ARTIST_ADDED:"Künstler in den Papierkorb hinzugefügt",MESSAGE_ARTIST_REMOVED:"Künstler aus dem Papierkorb entfernt",BACKUP_SAVE_SUCCESS:"Sicherung erfolgreich gespeichert.",BACKUP_SAVE_FAILED:"Speichern der Sicherungskopie fehlgeschlagen, versuchen Sie, den Inhalt des Papierkorbs in die Zwischenablage zu kopieren und manuell eine Sicherungskopie zu erstellen.",BACKUP_RESTORE_SUCCESS:"Sicherung erfolgreich wiederhergestellt.",BACKUP_FILE_READ_FAILED:"Fehler beim Lesen der Datei, bitte stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Trashbin+ Einstellungen",SETTINGS_OPTIONS:"Optionen",SETTINGS_FEATURES:"Eigenschaften",SETTINGS_LOCAL_STORAGE:"Lokaler Speicher",SETTINGS_ENABLED:"Aktiviert",SETTINGS_SHOW_WIDGET:"Widget-Symbol anzeigen",SETTINGS_AUTOPLAY:"Automatisches Abspielen beim Start",SETTINGS_QUEUE_TRASHBIN:"Warteschlangen-Papierkorb aktivieren",SETTINGS_TRACKLIST_TRASHBIN:"Aktiviere Tracklist-Papierkorb",SETTINGS_PLAYLIST_MONITOR:"Playlist-Monitor",ITEMS_TITLE:"Papierkorb+ Elemente",ITEMS_EMPTY_SONGS:"<strong>Keine gelöschten Songs!</strong><br/>Songs, die du in den Papierkorb legst, werden hier angezeigt.",ITEMS_EMPTY_ARTISTS:"<strong>Keine gelöschten Künstler!</strong><br/>Künstler, die Sie in den Papierkorb verschieben, werden hier angezeigt.",ITEMS_TAB_SONGS:"Lieder",ITEMS_TAB_ARTISTS:"Künstler",ITEMS_LOADED_COUNT:"{{loaded}} von {{total}} {{type}} geladen",DESCRIPTION_COPY:"Kopiere alle Elemente im Papierkorb in die Zwischenablage.",DESCRIPTION_EXPORT:"Alle Elemente im Papierkorb in einer .json-Datei speichern.",DESCRIPTION_IMPORT:"Alle Elemente im Papierkorb über die .json-Datei überschreiben.",DESCRIPTION_CLEAR:"Alle Elemente aus dem Papierkorb löschen (kann nicht rückgängig gemacht werden).",ITEMS_EMPTY_SONGS_TITLE:"Keine gelöschten Songs!",ITEMS_EMPTY_ARTISTS_TITLE:"Keine verworfenen Künstler!",DESCRIPTION_SETTINGS_ENABLED:"Hauptschalter zum Aktivieren oder Deaktivieren aller Papierkorb+-Funktionen",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Ein Papierkorb-Symbol in der Wiedergabeleiste neben dem gerade abgespielten Titel für schnellen Zugriff anzeigen",DESCRIPTION_SETTINGS_AUTOPLAY:"Musik automatisch abspielen, wenn Spotify geöffnet wird oder die Erweiterung geladen wird",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Fügen Sie neben jedem Lied in Ihrer Warteschlange Papierkorb-Symbole hinzu, um eine einfache Verwaltung zu ermöglichen",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Abfall-Icons neben Songs in den Ansichten „Album“ und „Wiedergabeliste“ hinzufügen, um eine schnelle Filterung zu ermöglichen",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatische Wiederherstellung bei Spotify-Wiedergabeproblemen durch Fortsetzung Ihrer letzten Wiedergabeliste",SETTINGS_SKIP_TRASHED_TRACKS:"Überspringe gelöschte Titel",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Überspringe automatisch gelöschte Songs und finde während der Wiedergabe den nächsten erlaubten Titel",SETTINGS_AUTO_CLEAN_QUEUE:"Auto-Reinigungs-Warteschlange",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Entferne automatisch gelöschte Songs aus deiner Smart-Shuffle-Warteschlange",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Papierkorb beim nächsten Hotkey",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Aktuellen Song automatisch in den Papierkorb legen, wenn mit der Tastenkombination Strg+Rechts zum nächsten Titel gesprungen wird",SETTINGS_REMOTE_CONTROL:"Fernbedienung",SETTINGS_REMOTE_TOGGLE:"Fernumschaltung aktivieren",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Doppeltes Antippen von Wiedergabe/Pause auf dem Mobilgerät, um das Überspringen per Fernbedienung ein- oder auszuschalten. Das Überspringen eines Titels bestätigt die Umschaltung.",SETTINGS_REMOTE_SKIPPING:"Fernüberspringen aktiv",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Wenn aktiviert, funktioniert das Überspringen von Titeln auch dann, wenn Spotify von einem anderen Gerät (z. B. einem Mobilgerät) gesteuert wird.",MESSAGE_REMOTE_SKIPPING_ENABLED:"Fernüberspringen aktiviert",MESSAGE_REMOTE_SKIPPING_DISABLED:"Fernüberspringen deaktiviert",MESSAGE_SONG_ADDED_REMOTE:"Lied über Fernbedienung zerstört",SETTINGS_TRASH_VIA_LIKE:"Müll über Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Wie ein Lied vom Handy, um es zu löschen. Entmag automatisch und springt zum nächsten Titel.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Nt=K((oS,lu)=>{lu.exports={TRASHBIN_NAME:"Κάδος απορριμμάτων+",ACTION_THROW:"Τοποθέτηση στον κάδο απορριμμάτων",ACTION_UNTHROW:"Αφαίρεση από τον Κάδο Απορριμμάτων",ACTION_CLEAR:"Ξεκάθαρο",ACTION_COPY:"Αντιγραφή",ACTION_EXPORT:"Εξαγωγή",ACTION_IMPORT:"Εισαγωγή",MESSAGE_COPIED:"Αντιγράφηκε στο πρόχειρο",MESSAGE_CLEARED:"Το καλάθι αχρήστων καθαρίστηκε επιτυχώς!",MESSAGE_SONG_ADDED:"Το τραγούδι προστέθηκε στον κάδο απορριμμάτων",MESSAGE_SONG_REMOVED:"Το τραγούδι αφαιρέθηκε από τον κάδο απορριμμάτων",MESSAGE_ARTIST_ADDED:"Ο καλλιτέχνης προστέθηκε στον κάδο απορριμμάτων",MESSAGE_ARTIST_REMOVED:"Ο καλλιτέχνης αφαιρέθηκε από τον κάδο απορριμμάτων",BACKUP_SAVE_SUCCESS:"Η αντίγραφο ασφαλείας αποθηκεύτηκε επιτυχώς.",BACKUP_SAVE_FAILED:"Αποτυχία αποθήκευσης αντιγράφου ασφαλείας, δοκιμάστε να αντιγράψετε τα περιεχόμενα του κάδου απορριμμάτων στο πρόχειρο και να δημιουργήσετε ένα αντίγραφο ασφαλείας χειροκίνητα.",BACKUP_RESTORE_SUCCESS:"Η δημιουργία αντιγράφου ασφαλείας αποκαταστάθηκε επιτυχώς.",BACKUP_FILE_READ_FAILED:"Αποτυχία ανάγνωσης αρχείου, παρακαλούμε βεβαιωθείτε ότι είναι έγκυρο αρχείο JSON.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Ρυθμίσεις Trashbin+",SETTINGS_OPTIONS:"Επιλογές",SETTINGS_FEATURES:"Χαρακτηριστικά",SETTINGS_LOCAL_STORAGE:"Τοπική αποθήκευση",SETTINGS_ENABLED:"Ενεργοποιημένο",SETTINGS_SHOW_WIDGET:"Εμφάνιση εικονιδίου γραφικού στοιχείου",SETTINGS_AUTOPLAY:"Αυτόματη έναρξη κατά την εκκίνηση",SETTINGS_QUEUE_TRASHBIN:"Ενεργοποίηση Κάδου Απορριμμάτων Ουράς",SETTINGS_TRACKLIST_TRASHBIN:"Ενεργοποίηση Κάδου Απορριμμάτων Λίστας Κομματιών",SETTINGS_PLAYLIST_MONITOR:"Παρακολούθηση λίστας αναπαραγωγής",ITEMS_TITLE:"Αντικείμενα Trashbin+",ITEMS_EMPTY_SONGS:"<strong>Καμία διαγραμμένα τραγούδια!</strong><br/>Τα τραγούδια που προσθέτετε στον κάδο απορριμμάτων θα εμφανίζονται εδώ.",ITEMS_EMPTY_ARTISTS:"<strong>Κανένας καλλιτέχνης στα σκουπίδια!</strong><br/>Οι καλλιτέχνες που προσθέτετε στον κάδο απορριμμάτων θα εμφανίζονται εδώ.",ITEMS_TAB_SONGS:"Τραγούδια",ITEMS_TAB_ARTISTS:"Καλλιτέχνες",ITEMS_LOADED_COUNT:"{{loaded}} από {{total}} {{type}} φορτώθηκαν",DESCRIPTION_COPY:"Αντιγραφή όλων των αντικειμένων στον κάδο απορριμμάτων στο πρόχειρο.",DESCRIPTION_EXPORT:"Αποθηκεύστε όλα τα αντικείμενα στον κάδο απορριμμάτων σε ένα αρχείο .json.",DESCRIPTION_IMPORT:"Αντικατάσταση όλων των αντικειμένων στον κάδο απορριμμάτων μέσω αρχείου .json.",DESCRIPTION_CLEAR:"Διαγραφή όλων των αντικειμένων από τον κάδο απορριμμάτων (δεν μπορεί να αναιρεθεί).",ITEMS_EMPTY_SONGS_TITLE:"Καμία διαγραμμένη μουσική!",ITEMS_EMPTY_ARTISTS_TITLE:"Κανένας κατεστραμμένος καλλιτέχνης!",DESCRIPTION_SETTINGS_ENABLED:"Κύριος διακόπτης για ενεργοποίηση ή απενεργοποίηση όλων των λειτουργιών του Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Εμφάνιση εικονιδίου κάδου απορριμμάτων στη γραμμή αναπαραγωγής δίπλα στο τρέχον τραγούδι για γρήγορη πρόσβαση",DESCRIPTION_SETTINGS_AUTOPLAY:"Αυτόματη έναρξη αναπαραγωγής μουσικής όταν ανοίγει το Spotify ή φορτώνεται η επέκταση",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Προσθέστε εικονίδια απορριμμάτων δίπλα σε κάθε τραγούδι στην ουρά σας για εύκολη διαχείριση",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Προσθέστε εικονίδια απορριμμάτων δίπλα στα τραγούδια στις προβολές άλμπουμ και λίστας αναπαραγωγής για γρήγορη φιλτράρισμα",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Αυτόματη ανάκτηση από προβλήματα αναπαραγωγής στο Spotify με τη συνέχιση της τελευταίας λίστας αναπαραγωγής σας",SETTINGS_SKIP_TRASHED_TRACKS:"Παράλειψη Απορριμμένων Κομματιών",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Παράκαμψη αυτόματα των διαγραμμένων τραγουδιών και εύρεση του επόμενου επιτρεπόμενου κομματιού κατά τη διάρκεια αναπαραγωγής",SETTINGS_AUTO_CLEAN_QUEUE:"Ουρά αυτόματου καθαρισμού",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Αυτόματη αφαίρεση διαγραμμένων τραγουδιών από την ουρά Smart Shuffle",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Άχρηστα με το επόμενο συντόμευση πλήκτρων",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Αυτόματη διαγραφή του τρέχοντος τραγουδιού όταν χρησιμοποιείται η συντόμευση πληκτρολογίου Ctrl+Δεξιά για παράκαμψη στο επόμενο κομμάτι",SETTINGS_REMOTE_CONTROL:"Τηλεχειριστήριο",SETTINGS_REMOTE_TOGGLE:"Ενεργοποίηση απομακρυσμένης εναλλαγής",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Πατήστε δύο φορές το πλήκτρο αναπαραγωγής/παύσης από το κινητό για να ενεργοποιήσετε/απενεργοποιήσετε τη λειτουργία παράκαμψης από απόσταση. Η παράκαμψη ενός κομματιού επιβεβαιώνει την εναλλαγή.",SETTINGS_REMOTE_SKIPPING:"Ενεργό Απομακρυσμένο Παράλειψη",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Όταν ενεργοποιηθεί, η παράκαμψη των απορριμμάτων λειτουργεί ακόμα και όταν ελέγχετε το Spotify από άλλη συσκευή (π.χ. κινητό)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Ενεργοποιημένη η απομακρυσμένη παράκαμψη",MESSAGE_REMOTE_SKIPPING_DISABLED:"Η απομακρυσμένη παράλειψη απενεργοποιήθηκε",MESSAGE_SONG_ADDED_REMOTE:"Το τραγούδι καταστράφηκε μέσω τηλεχειριστηρίου",SETTINGS_TRASH_VIA_LIKE:"Απορρίμματα μέσω Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Όπως ένα τραγούδι από το κινητό για να το πετάξεις. Αποδιαγράφεται αυτόματα και πηγαίνει στο επόμενο κομμάτι.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Ot=K((nS,iu)=>{iu.exports={TRASHBIN_NAME:"Bin+",ACTION_THROW:"Put in Trashbin",ACTION_UNTHROW:"Remove from Trash",ACTION_CLEAR:"Clear",ACTION_COPY:"Copy",ACTION_EXPORT:"Export",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Copied to clipboard",MESSAGE_CLEARED:"Trashbin cleared successfully!",MESSAGE_SONG_ADDED:"Song added to bin",MESSAGE_SONG_REMOVED:"Song removed from trash bin",MESSAGE_ARTIST_ADDED:"Artist added to trash bin",MESSAGE_ARTIST_REMOVED:"Artist removed from trash bin",BACKUP_SAVE_SUCCESS:"Backup saved successfully.",BACKUP_SAVE_FAILED:"Failed to save backup; try copying trashbin contents to clipboard and creating a backup manually.",BACKUP_RESTORE_SUCCESS:"Backup restored successfully.",BACKUP_FILE_READ_FAILED:"Failed to read file; please ensure it is a valid JSON file.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Trashbin+ Settings",SETTINGS_OPTIONS:"Options",SETTINGS_FEATURES:"Features",SETTINGS_LOCAL_STORAGE:"Local Storage",SETTINGS_ENABLED:"Enabled",SETTINGS_SHOW_WIDGET:"Show Widget Icon",SETTINGS_AUTOPLAY:"Autoplay on Start",SETTINGS_QUEUE_TRASHBIN:"Enable Queue Trashbin",SETTINGS_TRACKLIST_TRASHBIN:"Enable Tracklist Trash Bin",SETTINGS_PLAYLIST_MONITOR:"Playlist Monitor",ITEMS_TITLE:"Trashbin+ Items",ITEMS_EMPTY_SONGS:"<strong>No trashed songs!</strong><br/>Songs you add to the bin will appear here.",ITEMS_EMPTY_ARTISTS:"<strong>No trashed artists!</strong><br/>Artists you add to the bin will appear here.",ITEMS_TAB_SONGS:"Songs",ITEMS_TAB_ARTISTS:"Artists",ITEMS_LOADED_COUNT:"{{loaded}} of {{total}} {{type}} loaded",DESCRIPTION_COPY:"Copy all items in the bin to clipboard.",DESCRIPTION_EXPORT:"Save all items in the trashbin to a .json file.",DESCRIPTION_IMPORT:"Overwrite all items in the bin via .json file.",DESCRIPTION_CLEAR:"Empty the trashbin (this action cannot be undone).",ITEMS_EMPTY_SONGS_TITLE:"No deleted songs!",ITEMS_EMPTY_ARTISTS_TITLE:"No artists trashed!",DESCRIPTION_SETTINGS_ENABLED:"Master switch to enable or disable all Trashbin+ functionality",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Display a bin icon in the playback bar next to the currently playing track for quick access",DESCRIPTION_SETTINGS_AUTOPLAY:"Automatically start playing music when Spotify opens or the extension loads",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Add bin icons next to each song in your upcoming queue for easy management",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Add bin icons next to songs in album and playlist views for quick filtering",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatically recover from Spotify playback glitches by resuming your last playlist",SETTINGS_SKIP_TRASHED_TRACKS:"Skip Trashed Tracks",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Automatically skip deleted songs and find the next available track during playback",SETTINGS_AUTO_CLEAN_QUEUE:"Auto Clean Queue",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Automatically remove deleted songs from your Smart Shuffle queue",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Trash on Next Hotkey",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Automatically move the current song to trash when using the Ctrl+Right keyboard shortcut to skip to the next track",SETTINGS_REMOTE_CONTROL:"Remote Control",SETTINGS_REMOTE_TOGGLE:"Enable Remote Toggle",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Double-tap play/pause on your mobile to toggle remote skipping on or off. A track skip confirms the toggle.",SETTINGS_REMOTE_SKIPPING:"Remote Skipping Active",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"When enabled, trash-skipping works even when controlling Spotify from another device (e.g. mobile)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Remote skipping enabled",MESSAGE_REMOTE_SKIPPING_DISABLED:"Skipping à distance désactivé",MESSAGE_SONG_ADDED_REMOTE:"Song trashed via remote",SETTINGS_TRASH_VIA_LIKE:"Rubbish via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Like a song from mobile to trash it. Automatically unlikes and skips to the next track.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Rt=K((hS,eu)=>{eu.exports={TRASHBIN_NAME:"Trashbin+",ACTION_THROW:"Place in Trashbin",ACTION_UNTHROW:"Remove from Trashbin",ACTION_CLEAR:"Clear",ACTION_COPY:"Copy",ACTION_EXPORT:"Export",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Copied to clipboard",MESSAGE_CLEARED:"Trashbin cleared successfully!",MESSAGE_SONG_ADDED:"Song added to trashbin",MESSAGE_SONG_REMOVED:"Song removed from trashbin",MESSAGE_ARTIST_ADDED:"Artist added to trashbin",MESSAGE_ARTIST_REMOVED:"Artist removed from trashbin",BACKUP_SAVE_SUCCESS:"Backup saved successfully.",BACKUP_SAVE_FAILED:"Failed to save backup, try copying trashbin contents to clipboard and creating a backup manually.",BACKUP_RESTORE_SUCCESS:"Backup restored successfully.",BACKUP_FILE_READ_FAILED:"Failed to read file, please ensure it is a valid JSON file.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Trashbin+ Settings",SETTINGS_OPTIONS:"Options",SETTINGS_FEATURES:"Features",SETTINGS_LOCAL_STORAGE:"Local Storage",SETTINGS_ENABLED:"Enabled",SETTINGS_SHOW_WIDGET:"Show Widget Icon",SETTINGS_AUTOPLAY:"Autoplay on Start",SETTINGS_QUEUE_TRASHBIN:"Enable Queue Trashbin",SETTINGS_TRACKLIST_TRASHBIN:"Enable Tracklist Trashbin",SETTINGS_PLAYLIST_MONITOR:"Playlist Monitor",ITEMS_TITLE:"Trashbin+ Items",ITEMS_EMPTY_SONGS:"<strong>No trashed songs!</strong><br/>Songs you add to the trashbin will appear here.",ITEMS_EMPTY_ARTISTS:"<strong>No trashed artists!</strong><br/>Artists you add to the trashbin will appear here.",ITEMS_TAB_SONGS:"Songs",ITEMS_TAB_ARTISTS:"Artists",ITEMS_LOADED_COUNT:"{{loaded}} of {{total}} {{type}} loaded",ITEMS_SEARCH_PLACEHOLDER:"Search by name, artist, or URI...",DESCRIPTION_COPY:"Copy all items in trashbin to clipboard.",DESCRIPTION_EXPORT:"Save all items in trashbin to a .json file.",DESCRIPTION_IMPORT:"Overwrite all items in trashbin via .json file.",DESCRIPTION_CLEAR:"Clear all items from trashbin (cannot be reverted).",ITEMS_EMPTY_SONGS_TITLE:"No trashed songs!",ITEMS_EMPTY_ARTISTS_TITLE:"No trashed artists!",DESCRIPTION_SETTINGS_ENABLED:"Master toggle to enable or disable all Trashbin+ functionality",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Display a trash icon in the playback bar next to the currently playing track for quick access",DESCRIPTION_SETTINGS_AUTOPLAY:"Automatically start playing music when Spotify opens or the extension loads",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Add trash icons next to each song in your upcoming queue for easy management",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Add trash icons next to songs in album and playlist views for quick filtering",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatically recover from Spotify playback glitches by resuming your last playlist",SETTINGS_SKIP_TRASHED_TRACKS:"Skip Trashed Tracks",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Automatically skip trashed songs and find the next allowed track during playback",SETTINGS_AUTO_CLEAN_QUEUE:"Auto Clean Queue",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Automatically remove trashed songs from your Smart Shuffle queue",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Trash on Next Hotkey",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Automatically trash the current song when using Ctrl+Right keyboard shortcut to skip to next track",SETTINGS_REMOTE_CONTROL:"Remote Control",SETTINGS_REMOTE_TOGGLE:"Enable Remote Toggle",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Double-tap play/pause from mobile to toggle remote skipping on/off. A track skip confirms the toggle.",SETTINGS_REMOTE_SKIPPING:"Remote Skipping Active",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"When enabled, trash-skipping works even when controlling Spotify from another device (e.g., mobile)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Remote skipping enabled",MESSAGE_REMOTE_SKIPPING_DISABLED:"Remote skipping disabled",MESSAGE_SONG_ADDED_REMOTE:"Song trashed via remote",SETTINGS_TRASH_VIA_LIKE:"Trash via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Like a song from mobile to trash it. Automatically unlikes and skips to next track.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var wt=K((cS,ou)=>{ou.exports={TRASHBIN_NAME:"Papelera+",ACTION_THROW:"Colocar en la papelera",ACTION_UNTHROW:"Eliminar de la Papelera",ACTION_CLEAR:"Claro",ACTION_COPY:"Copiar",ACTION_EXPORT:"Exportar",ACTION_IMPORT:"Importar",MESSAGE_COPIED:"Copiado al portapapeles",MESSAGE_CLEARED:"¡Papelera vaciada con éxito!",MESSAGE_SONG_ADDED:"Canción agregada a la papelera",MESSAGE_SONG_REMOVED:"Canción eliminada de la papelera",MESSAGE_ARTIST_ADDED:"Artista agregado a la papelera",MESSAGE_ARTIST_REMOVED:"Artista eliminado de la papelera",BACKUP_SAVE_SUCCESS:"Copia de respaldo guardada exitosamente.",BACKUP_SAVE_FAILED:"No se pudo guardar la copia de seguridad, intente copiar el contenido de la papelera al portapapeles y crear una copia de seguridad manualmente.",BACKUP_RESTORE_SUCCESS:"Copia de seguridad restaurada con éxito.",BACKUP_FILE_READ_FAILED:"No se pudo leer el archivo, asegúrese de que sea un archivo JSON válido.",BACKUP_SUGGESTED_FILENAME:"spicetify-basurero.json",SETTINGS_TITLE:"Configuración de Trashbin+",SETTINGS_OPTIONS:"Opciones",SETTINGS_FEATURES:"Características",SETTINGS_LOCAL_STORAGE:"Almacenamiento local",SETTINGS_ENABLED:"Habilitado",SETTINGS_SHOW_WIDGET:"Mostrar icono del widget",SETTINGS_AUTOPLAY:"Reproducción automática al iniciar",SETTINGS_QUEUE_TRASHBIN:"Habilitar la papelera de la cola",SETTINGS_TRACKLIST_TRASHBIN:"Habilitar Papelera de la Lista de Pistas",SETTINGS_PLAYLIST_MONITOR:"Monitor de listas de reproducción",ITEMS_TITLE:"Artículos de Papelera+",ITEMS_EMPTY_SONGS:"<strong>¡Ninguna canción en la papelera!</strong><br/>Las canciones que agregues a la papelera aparecerán aquí.",ITEMS_EMPTY_ARTISTS:"<strong>¡Ningún artista eliminado!</strong><br/>Los artistas que agregues a la papelera aparecerán aquí.",ITEMS_TAB_SONGS:"Canciones",ITEMS_TAB_ARTISTS:"Artistas",ITEMS_LOADED_COUNT:"{{loaded}} de {{total}} {{type}} cargados",DESCRIPTION_COPY:"Copiar todos los elementos de la papelera al portapapeles.",DESCRIPTION_EXPORT:"Guardar todos los elementos de la papelera en un archivo .json.",DESCRIPTION_IMPORT:"Sobrescribir todos los elementos en la papelera mediante el archivo .json.",DESCRIPTION_CLEAR:"Eliminar todos los elementos de la papelera (no se puede deshacer).",ITEMS_EMPTY_SONGS_TITLE:"¡Ninguna canción eliminada!",ITEMS_EMPTY_ARTISTS_TITLE:"¡Ningún artista eliminado!",DESCRIPTION_SETTINGS_ENABLED:"Conmutador principal para activar o desactivar todas las funciones de Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Mostrar un icono de papelera en la barra de reproducción junto a la pista que se está reproduciendo para un acceso rápido",DESCRIPTION_SETTINGS_AUTOPLAY:"Iniciar automáticamente la reproducción de música cuando se abra Spotify o se cargue la extensión",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Agrega íconos de basura junto a cada canción en tu cola próxima para una gestión fácil",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Agregar iconos de basura junto a las canciones en las vistas de álbum y lista de reproducción para filtrado rápido",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recupérate automáticamente de errores en la reproducción de Spotify al reanudar tu última lista de reproducción",SETTINGS_SKIP_TRASHED_TRACKS:"Omitir pistas eliminadas",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Omitir automáticamente las canciones eliminadas y encontrar la siguiente pista permitida durante la reproducción",SETTINGS_AUTO_CLEAN_QUEUE:"Cola de limpieza automática",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Eliminar automáticamente canciones eliminadas de tu cola de reproducción aleatoria inteligente",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Papelera en la siguiente tecla de acceso rápido",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Mover automáticamente la canción actual a la papelera al usar el atajo de teclado Ctrl+Derecha para pasar a la siguiente pista",SETTINGS_REMOTE_CONTROL:"Control remoto",SETTINGS_REMOTE_TOGGLE:"Habilitar conmutación remota",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Toca dos veces reproducir/pausa desde el móvil para activar o desactivar el salto remoto. Saltar una pista confirma el cambio.",SETTINGS_REMOTE_SKIPPING:"Omisión remota activa",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Cuando está activado, omitir la papelera funciona incluso cuando se controla Spotify desde otro dispositivo (por ejemplo, móvil).",MESSAGE_REMOTE_SKIPPING_ENABLED:"Omisión remota habilitada",MESSAGE_REMOTE_SKIPPING_DISABLED:"Omisión remota desactivada",MESSAGE_SONG_ADDED_REMOTE:"Canción eliminada mediante control remoto",SETTINGS_TRASH_VIA_LIKE:"Basura a través de Me gusta",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Como una canción desde el móvil hasta eliminarla. Automáticamente deja de gustar y pasa a la siguiente pista.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Dt=K((dS,nu)=>{nu.exports={TRASHBIN_NAME:"Papelera+",ACTION_THROW:"Colocar en la papelera",ACTION_UNTHROW:"Eliminar de la Papelera",ACTION_CLEAR:"Claro",ACTION_COPY:"Copiar",ACTION_EXPORT:"Exportar",ACTION_IMPORT:"Importar",MESSAGE_COPIED:"Copiado al portapapeles",MESSAGE_CLEARED:"¡Papelera vaciada con éxito!",MESSAGE_SONG_ADDED:"Canción agregada a la papelera",MESSAGE_SONG_REMOVED:"Canción eliminada de la papelera",MESSAGE_ARTIST_ADDED:"Artista agregado a la papelera",MESSAGE_ARTIST_REMOVED:"Artista eliminado de la papelera",BACKUP_SAVE_SUCCESS:"Copia de respaldo guardada con éxito.",BACKUP_SAVE_FAILED:"No se pudo guardar la copia de seguridad, intente copiar el contenido de la papelera al portapapeles y crear una copia de seguridad manualmente.",BACKUP_RESTORE_SUCCESS:"Copia de seguridad restaurada con éxito.",BACKUP_FILE_READ_FAILED:"No se pudo leer el archivo, asegúrese de que sea un archivo JSON válido.",BACKUP_SUGGESTED_FILENAME:"spicetify-basurero.json",SETTINGS_TITLE:"Configuración de Trashbin+",SETTINGS_OPTIONS:"Opciones",SETTINGS_FEATURES:"Características",SETTINGS_LOCAL_STORAGE:"Almacenamiento local",SETTINGS_ENABLED:"Habilitado",SETTINGS_SHOW_WIDGET:"Mostrar ícono del widget",SETTINGS_AUTOPLAY:"Reproducción automática al iniciar",SETTINGS_QUEUE_TRASHBIN:"Habilitar la papelera de la cola",SETTINGS_TRACKLIST_TRASHBIN:"Habilitar Papelera de la Lista de Pistas",SETTINGS_PLAYLIST_MONITOR:"Monitor de listas de reproducción",ITEMS_TITLE:"Elementos de Papelera+",ITEMS_EMPTY_SONGS:"<strong>¡No hay canciones en la papelera!</strong><br/>Las canciones que agregues a la papelera aparecerán aquí.",ITEMS_EMPTY_ARTISTS:"<strong>¡No hay artistas en la papelera!</strong><br/>Los artistas que agregues a la papelera aparecerán aquí.",ITEMS_TAB_SONGS:"Canciones",ITEMS_TAB_ARTISTS:"Artistas",ITEMS_LOADED_COUNT:"{{loaded}} de {{total}} {{type}} cargados",DESCRIPTION_COPY:"Copiar todos los elementos de la papelera al portapapeles.",DESCRIPTION_EXPORT:"Guardar todos los elementos de la papelera en un archivo .json.",DESCRIPTION_IMPORT:"Sobrescribir todos los elementos en la papelera mediante archivo .json.",DESCRIPTION_CLEAR:"Eliminar todos los elementos de la papelera (no se puede deshacer).",ITEMS_EMPTY_SONGS_TITLE:"¡Ninguna canción eliminada!",ITEMS_EMPTY_ARTISTS_TITLE:"¡Nada de artistas truchos!",DESCRIPTION_SETTINGS_ENABLED:"Conmutador principal para activar o desactivar todas las funciones de Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Mostrar un ícono de papelera en la barra de reproducción junto a la pista que se está reproduciendo para un acceso rápido",DESCRIPTION_SETTINGS_AUTOPLAY:"Iniciar automáticamente la reproducción de música cuando se abra Spotify o se cargue la extensión",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Agregá íconos de basura al lado de cada canción en tu cola próxima para una gestión fácil",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Agregar íconos de basura junto a las canciones en las vistas de álbum y lista de reproducción para filtrar rápidamente",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recupérate automáticamente de fallos en la reproducción de Spotify reanudando tu última lista de reproducción",SETTINGS_SKIP_TRASHED_TRACKS:"Omitir pistas eliminadas",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Omitir automáticamente las canciones eliminadas y encontrar la siguiente pista permitida durante la reproducción",SETTINGS_AUTO_CLEAN_QUEUE:"Cola de limpieza automática",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Eliminar automáticamente las canciones eliminadas de tu cola de reproducción aleatoria inteligente",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Basura en la próxima tecla rápida",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Mover automáticamente la canción actual a la papelera al usar el atajo de teclado Ctrl+Derecha para pasar a la siguiente pista",SETTINGS_REMOTE_CONTROL:"Control remoto",SETTINGS_REMOTE_TOGGLE:"Habilitar conmutación remota",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Toca dos veces reproducir/pausa desde el móvil para activar o desactivar el salto remoto de pistas. Saltar una pista confirma el cambio.",SETTINGS_REMOTE_SKIPPING:"Omisión remota activa",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Cuando está activado, omitir la papelera funciona incluso cuando se controla Spotify desde otro dispositivo (por ejemplo, móvil)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Salto remoto habilitado",MESSAGE_REMOTE_SKIPPING_DISABLED:"Salto remoto desactivado",MESSAGE_SONG_ADDED_REMOTE:"Canción eliminada a distancia",SETTINGS_TRASH_VIA_LIKE:"Basura a través de Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:'Como una canción desde el móvil hasta la papelera. Automáticamente quita el "me gusta" y pasa a la siguiente pista.',SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Gt=K((vS,hu)=>{hu.exports={TRASHBIN_NAME:"Papelera+",ACTION_THROW:"Colocar en la papelera",ACTION_UNTHROW:"Eliminar de la Papelera",ACTION_CLEAR:"Claro",ACTION_COPY:"Copiar",ACTION_EXPORT:"Exportar",ACTION_IMPORT:"Importar",MESSAGE_COPIED:"Copiado al portapapeles",MESSAGE_CLEARED:"¡Papelera vaciada con éxito!",MESSAGE_SONG_ADDED:"Canción agregada a la papelera",MESSAGE_SONG_REMOVED:"Canción eliminada de la papelera",MESSAGE_ARTIST_ADDED:"Artista agregado a la papelera",MESSAGE_ARTIST_REMOVED:"Artista eliminado de la papelera",BACKUP_SAVE_SUCCESS:"Copia de seguridad guardada correctamente.",BACKUP_SAVE_FAILED:"No se pudo guardar la copia de seguridad, intenta copiar el contenido de la papelera al portapapeles y crear una copia de seguridad manualmente.",BACKUP_RESTORE_SUCCESS:"Copia de seguridad restaurada correctamente.",BACKUP_FILE_READ_FAILED:"No se pudo leer el archivo, asegúrese de que sea un archivo JSON válido.",BACKUP_SUGGESTED_FILENAME:"spicetify-basurero.json",SETTINGS_TITLE:"Configuración de Trashbin+",SETTINGS_OPTIONS:"Opciones",SETTINGS_FEATURES:"Características",SETTINGS_LOCAL_STORAGE:"Almacenamiento local",SETTINGS_ENABLED:"Habilitado",SETTINGS_SHOW_WIDGET:"Mostrar icono del widget",SETTINGS_AUTOPLAY:"Reproducción automática al iniciar",SETTINGS_QUEUE_TRASHBIN:"Habilitar la papelera de la cola",SETTINGS_TRACKLIST_TRASHBIN:"Habilitar la papelera de la lista de pistas",SETTINGS_PLAYLIST_MONITOR:"Monitor de listas de reproducción",ITEMS_TITLE:"Artículos de la papelera+",ITEMS_EMPTY_SONGS:"<strong>¡No hay canciones en la papelera!</strong><br/>Las canciones que agregues a la papelera aparecerán aquí.",ITEMS_EMPTY_ARTISTS:"<strong>¡No hay artistas en la papelera!</strong><br/>Los artistas que agregues a la papelera aparecerán aquí.",ITEMS_TAB_SONGS:"Canciones",ITEMS_TAB_ARTISTS:"Artistas",ITEMS_LOADED_COUNT:"{{loaded}} de {{total}} {{type}} cargados",DESCRIPTION_COPY:"Copiar todos los elementos de la papelera al portapapeles.",DESCRIPTION_EXPORT:"Guardar todos los elementos en la papelera en un archivo .json.",DESCRIPTION_IMPORT:"Sobrescribir todos los elementos en la papelera mediante el archivo .json.",DESCRIPTION_CLEAR:"Eliminar todos los elementos de la papelera (no se puede deshacer).",ITEMS_EMPTY_SONGS_TITLE:"¡No hay canciones eliminadas!",ITEMS_EMPTY_ARTISTS_TITLE:"¡Nada de artistas descartados!",DESCRIPTION_SETTINGS_ENABLED:"Conmutador principal para activar o desactivar todas las funciones de Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Mostrar un icono de papelera en la barra de reproducción junto a la pista que se está reproduciendo para un acceso rápido",DESCRIPTION_SETTINGS_AUTOPLAY:"Iniciar automáticamente la reproducción de música cuando se abre Spotify o se carga la extensión",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Agrega íconos de basura junto a cada canción en tu cola de reproducción para una administración más fácil",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Agregar iconos de basura junto a las canciones en las vistas de álbum y lista de reproducción para filtrado rápido",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recupérate automáticamente de fallos en la reproducción de Spotify al reanudar tu última lista de reproducción",SETTINGS_SKIP_TRASHED_TRACKS:"Omitir pistas eliminadas",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Omitir automáticamente las canciones eliminadas y encontrar la siguiente pista permitida durante la reproducción",SETTINGS_AUTO_CLEAN_QUEUE:"Cola de limpieza automática",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Eliminar automáticamente las canciones eliminadas de tu cola de reproducción aleatoria inteligente",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Basura en la siguiente tecla rápida",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Mover automáticamente la canción actual a la papelera al usar el atajo de teclado Ctrl+Derecha para pasar a la siguiente pista",SETTINGS_REMOTE_CONTROL:"Control remoto",SETTINGS_REMOTE_TOGGLE:"Habilitar conmutación remota",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Toca dos veces reproducir/pausa desde el móvil para activar o desactivar el salto remoto de pistas. Saltar una pista confirma el cambio.",SETTINGS_REMOTE_SKIPPING:"Omisión remota activa",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Cuando está activado, omitir la papelera funciona incluso cuando se controla Spotify desde otro dispositivo (por ejemplo, móvil)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Omisión remota habilitada",MESSAGE_REMOTE_SKIPPING_DISABLED:"Omisión remota desactivada",MESSAGE_SONG_ADDED_REMOTE:"Canción eliminada mediante control remoto",SETTINGS_TRASH_VIA_LIKE:"Basura mediante Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:'Como una canción desde el móvil hasta la papelera. Automáticamente quita la marca de "me gusta" y pasa a la siguiente pista.',SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Pt=K((uS,cu)=>{cu.exports={TRASHBIN_NAME:"Papelera+",ACTION_THROW:"Colocar en la papelera",ACTION_UNTHROW:"Eliminar de la Papelera",ACTION_CLEAR:"Claro",ACTION_COPY:"Copiar",ACTION_EXPORT:"Exportar",ACTION_IMPORT:"Importar",MESSAGE_COPIED:"Copiado al portapapeles",MESSAGE_CLEARED:"¡Papelera vaciada con éxito!",MESSAGE_SONG_ADDED:"Canción agregada a la papelera",MESSAGE_SONG_REMOVED:"Canción eliminada de la papelera",MESSAGE_ARTIST_ADDED:"Artista agregado a la papelera",MESSAGE_ARTIST_REMOVED:"Artista eliminado de la papelera",BACKUP_SAVE_SUCCESS:"Copia de seguridad guardada correctamente.",BACKUP_SAVE_FAILED:"No se pudo guardar la copia de seguridad, intente copiar el contenido de la papelera al portapapeles y crear una copia de seguridad manualmente.",BACKUP_RESTORE_SUCCESS:"Copia de seguridad restaurada con éxito.",BACKUP_FILE_READ_FAILED:"No se pudo leer el archivo, asegúrese de que sea un archivo JSON válido.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Configuración de Trashbin+",SETTINGS_OPTIONS:"Opciones",SETTINGS_FEATURES:"Características",SETTINGS_LOCAL_STORAGE:"Almacenamiento local",SETTINGS_ENABLED:"Habilitado",SETTINGS_SHOW_WIDGET:"Mostrar icono del widget",SETTINGS_AUTOPLAY:"Reproducción automática al iniciar",SETTINGS_QUEUE_TRASHBIN:"Habilitar la papelera de la cola",SETTINGS_TRACKLIST_TRASHBIN:"Habilitar la papelera de la lista de pistas",SETTINGS_PLAYLIST_MONITOR:"Monitor de lista de reproducción",ITEMS_TITLE:"Elementos de la papelera+",ITEMS_EMPTY_SONGS:"<strong>¡No hay canciones en la papelera!</strong><br/>Las canciones que agregues a la papelera aparecerán aquí.",ITEMS_EMPTY_ARTISTS:"<strong>¡Ningún artista en la papelera!</strong><br/>Los artistas que agregues a la papelera aparecerán aquí.",ITEMS_TAB_SONGS:"Canciones",ITEMS_TAB_ARTISTS:"Artistas",ITEMS_LOADED_COUNT:"{{loaded}} de {{total}} {{type}} cargados",DESCRIPTION_COPY:"Copiar todos los elementos de la papelera al portapapeles.",DESCRIPTION_EXPORT:"Guardar todos los elementos en la papelera en un archivo .json.",DESCRIPTION_IMPORT:"Sobrescribir todos los elementos en la papelera mediante el archivo .json.",DESCRIPTION_CLEAR:"Borrar todos los elementos de la papelera (no se puede deshacer).",ITEMS_EMPTY_SONGS_TITLE:"¡No hay canciones eliminadas!",ITEMS_EMPTY_ARTISTS_TITLE:"¡Ningún artista eliminado!",DESCRIPTION_SETTINGS_ENABLED:"Conmutador principal para activar o desactivar todas las funciones de Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Mostrar un icono de papelera en la barra de reproducción junto a la pista que se está reproduciendo para un acceso rápido",DESCRIPTION_SETTINGS_AUTOPLAY:"Iniciar automáticamente la reproducción de música cuando se abra Spotify o se cargue la extensión",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Agrega íconos de basura junto a cada canción en tu cola próxima para una fácil gestión",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Agregar iconos de basura junto a las canciones en las vistas de álbum y lista de reproducción para filtrado rápido",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recupérate automáticamente de fallos en la reproducción de Spotify reanudando tu última lista de reproducción",SETTINGS_SKIP_TRASHED_TRACKS:"Omitir pistas eliminadas",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Omitir automáticamente las canciones eliminadas y encontrar la siguiente pista permitida durante la reproducción",SETTINGS_AUTO_CLEAN_QUEUE:"Cola de limpieza automática",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Eliminar automáticamente canciones eliminadas de tu cola de reproducción aleatoria inteligente",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Basura en la próxima tecla rápida",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Eliminar automáticamente la canción actual al usar el atajo de teclado Ctrl+Derecha para pasar a la siguiente pista",SETTINGS_REMOTE_CONTROL:"Control remoto",SETTINGS_REMOTE_TOGGLE:"Habilitar alternancia remota",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Toque dos veces reproducir/pausa desde el móvil para activar o desactivar el salto remoto de pistas. Un salto de pista confirma el cambio.",SETTINGS_REMOTE_SKIPPING:"Omitido remoto activo",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Cuando está activado, omitir la papelera funciona incluso cuando se controla Spotify desde otro dispositivo (por ejemplo, móvil)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Omisión remota habilitada",MESSAGE_REMOTE_SKIPPING_DISABLED:"Salto remoto desactivado",MESSAGE_SONG_ADDED_REMOTE:"Canción eliminada mediante control remoto",SETTINGS_TRASH_VIA_LIKE:"Basura a través de Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:'Como una canción desde el móvil hasta la papelera. Automáticamente quita el "me gusta" y pasa a la siguiente pista.',SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Ft=K((gS,du)=>{du.exports={TRASHBIN_NAME:"Prügikast+",ACTION_THROW:"Viska prügikasti",ACTION_UNTHROW:"Eemalda prügikastist",ACTION_CLEAR:"Selge",ACTION_COPY:"Kopeeri",ACTION_EXPORT:"Ekspordi",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Kopeeritud lõikelauale",MESSAGE_CLEARED:"Prügikast on edukalt tühjendatud!",MESSAGE_SONG_ADDED:"Laul lisatud prügikasti",MESSAGE_SONG_REMOVED:"Lugu eemaldati prügikastist",MESSAGE_ARTIST_ADDED:"Kunstnik lisatud prügikasti",MESSAGE_ARTIST_REMOVED:"Kunstnik eemaldati prügikastist",BACKUP_SAVE_SUCCESS:"Varundus edukalt salvestatud.",BACKUP_SAVE_FAILED:"Varunduse salvestamine ebaõnnestus, proovige prügikasti sisu kopeerimist lõikelauale ja varunduse käsitsi loomist.",BACKUP_RESTORE_SUCCESS:"Varundus taastati edukalt.",BACKUP_FILE_READ_FAILED:"Faili lugemine ebaõnnestus, veenduge, et see oleks sobiv JSON-fail.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Prügikasti+ seadistused",SETTINGS_OPTIONS:"Valikud",SETTINGS_FEATURES:"Omadused",SETTINGS_LOCAL_STORAGE:"Kohalik salvestus",SETTINGS_ENABLED:"Lubatud",SETTINGS_SHOW_WIDGET:"Kuva vidina ikoon",SETTINGS_AUTOPLAY:"Automaatne esitus käivitamisel",SETTINGS_QUEUE_TRASHBIN:"Luba järjekorra prügikast",SETTINGS_TRACKLIST_TRASHBIN:"Luba trellide korvi prügikast",SETTINGS_PLAYLIST_MONITOR:"Esitusloendi jälgija",ITEMS_TITLE:"Prügikasti+ esemed",ITEMS_EMPTY_SONGS:"<strong>Ühtegi prakskirjutatud laulu!</strong><br/>Lood, mille prakskasti lisad, ilmuvad siia.",ITEMS_EMPTY_ARTISTS:"<strong>Ära viska kunstnikke prügikasti!</strong><br/>Prügikasti lisatud kunstnikud ilmuvad siin.",ITEMS_TAB_SONGS:"Laulud",ITEMS_TAB_ARTISTS:"Kunstnikud",ITEMS_LOADED_COUNT:"{{loaded}} / {{total}} {{type}} laaditud",DESCRIPTION_COPY:"Kopeeri prügikasti kõik elemendid lõikepuhvrisse.",DESCRIPTION_EXPORT:"Salvesta kõik prügikasti asjad .json-faili.",DESCRIPTION_IMPORT:"Kirjuta kõik prügikasti üksused üle .json-faili kaudu.",DESCRIPTION_CLEAR:"Tühjenda prügikast täielikult (tegevust ei saa tagasi võtta).",ITEMS_EMPTY_SONGS_TITLE:"Mitte ühtegi räpust laulu!",ITEMS_EMPTY_ARTISTS_TITLE:"Mitte ühtegi prügikasti visatud kunstnikku!",DESCRIPTION_SETTINGS_ENABLED:"Lüliti kogu prügikasti+ funktsionaalsuse lubamiseks või keelamiseks",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Kuvage esitusribal praegu mängiva loo kõrval kiirjuurdepääsuks prügikasti ikoon",DESCRIPTION_SETTINGS_AUTOPLAY:"Alusta muusika esitamist automaatselt, kui Spotify avaneb või laiendus laaditakse",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Lisa igale järgmisele loosse kuulule prügikasti ikoonid mugava haldamise jaoks",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Lisa albumi ja esitusloendi vaadetes laulude kõrvale prügikasti ikoonid kiireks filtreerimiseks",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Taasta Spotify esitus automaatselt, jätkates viimast esitusloendit",SETTINGS_SKIP_TRASHED_TRACKS:"Jäta vahele prügikasti visatud lood",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Jäta automaatselt vahele prügikasti saatud lood ja leia esitamise ajal järgmine lubatud loend.",SETTINGS_AUTO_CLEAN_QUEUE:"Automaatne puhastusjärjekord",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Eemalda automaatselt prügikasti visatud lood oma nutikast juhuslikust esitusloendist",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Prügi järgmisel kiirklahvil",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Kohe prügikasti käesolev laul, kui järgmise loo juurde liikumiseks kasutada klaviatuuril Ctrl+parem",SETTINGS_REMOTE_CONTROL:"Kaugarvesti",SETTINGS_REMOTE_TOGGLE:"Luba kauglülitus",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Puudutage mobiilis kaks korda mängimise ja peatamise nuppu, et lülitada kaugel hüppe sisse/välja. Loendi järgmisele loole üleminek kinnitab lülitamise.",SETTINGS_REMOTE_SKIPPING:"Kaugarvatamine aktiivne",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Kui see on lubatud, töötab prügikasti vahelejätmine isegi siis, kui Spotifyd juhitakse mõnest teisest seadmest (nt mobiiltelefonist)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Kaugarajatusega jätkamine lubatud",MESSAGE_REMOTE_SKIPPING_DISABLED:"Kaugaraldus keelatud",MESSAGE_SONG_ADDED_REMOTE:"Lugu kustutati kaugjuhtimisega",SETTINGS_TRASH_VIA_LIKE:"Tähtajaline prügi",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Nagu laul mobiilist prügikasti. Eemaldab meeldimise automaatselt ja liigub järgmisele loole.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Zt=K((sS,vu)=>{vu.exports={TRASHBIN_NAME:"Trashbin+",ACTION_THROW:"Jarri zakarrontzian",ACTION_UNTHROW:"Ezabatu zakarrontzitik",ACTION_CLEAR:"Garbi",ACTION_COPY:"Kopiatu",ACTION_EXPORT:"Esportatu",ACTION_IMPORT:"Inportatu",MESSAGE_COPIED:"Arbelean kopiatua",MESSAGE_CLEARED:"Zaborra ontzia ondo garbitu da!",MESSAGE_SONG_ADDED:"Abestia zakarrontzira gehitu da",MESSAGE_SONG_REMOVED:"Abestia zakarrontzitik kendu da",MESSAGE_ARTIST_ADDED:"Artist-a zakarrontzira gehitu da",MESSAGE_ARTIST_REMOVED:"Artistak zakarrontzitik kendua izan da",BACKUP_SAVE_SUCCESS:"Gehiegizko kopia ondo gorde da.",BACKUP_SAVE_FAILED:"Ezin izan da babeskopia gorde, saiatu zakarrontziko edukia arbelera kopiatzen eta babeskopia eskuz sortzen.",BACKUP_RESTORE_SUCCESS:"Backupa ondo berreskuratu da.",BACKUP_FILE_READ_FAILED:"Ezin izan da fitxategia irakurri, ziurtatu baliozko JSON fitxategia dela.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Trashbin+ ezarpenak",SETTINGS_OPTIONS:"Aukerak",SETTINGS_FEATURES:"Ezaugarriak",SETTINGS_LOCAL_STORAGE:"Gordetze lokala",SETTINGS_ENABLED:"Gaituta",SETTINGS_SHOW_WIDGET:"Erakutsi widgetaren ikonoa",SETTINGS_AUTOPLAY:"Hasi ber automatikoki",SETTINGS_QUEUE_TRASHBIN:"Gaitu ilararen zakarrontzia",SETTINGS_TRACKLIST_TRASHBIN:"Gaitu erreprodukzio-zerrendaren zakarrontzia",SETTINGS_PLAYLIST_MONITOR:"Playlist Monitorra",ITEMS_TITLE:"Trashbin+ elementuak",ITEMS_EMPTY_SONGS:"<strong>Ez da abestirik zakarrontzian!</strong><br/>Zakarrontzira gehitutako abestiak hemen agertuko dira.",ITEMS_EMPTY_ARTISTS:"<strong>Ez ezabatutako artista!</strong><br/>Zakarrontzira gehitutako artistak hemen agertuko dira.",ITEMS_TAB_SONGS:"Abestiak",ITEMS_TAB_ARTISTS:"Artistak",ITEMS_LOADED_COUNT:"{{total}}tik {{loaded}} {{type}} kargatu da",DESCRIPTION_COPY:"Kopiatu zakarrontziko elementu guztiak arbelean.",DESCRIPTION_EXPORT:"Gordetxo guztiak zakarrontzitik .json fitxategi batean gorde.",DESCRIPTION_IMPORT:"Ordezkatu zaborrontziko elementu guztiak .json fitxategiaren bidez.",DESCRIPTION_CLEAR:"Ezabatu zaborrontziko elementu guztiak (ezin da desegin).",ITEMS_EMPTY_SONGS_TITLE:"Ez da abestirik ezabatu!",ITEMS_EMPTY_ARTISTS_TITLE:"Ez zaborraturiko artista!",DESCRIPTION_SETTINGS_ENABLED:"Gaitu edo desgaitu zakarrontzi+ funtzionaltasun guztia duen botoi nagusia",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Erakutsi zakarrontzi ikonoa erreproduzitzen ari den pista alboan dagoen erreproduzio-barran, lasterbide gisa",DESCRIPTION_SETTINGS_AUTOPLAY:"Abestien erreproduzioa automatikoki hasi Spotify irekitzen denean edo luzapena kargatzen denean",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Gehitu zakarrontzi ikonoak zure hurrengo ilaran dauden abesti bakoitzaren ondoan kudeatzeko errazteko",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Gehitu zakarrontzi ikonoak albumen eta erreproduzio-zerrenden ikuspegietan abestien ondoan filtro azkarra egiteko",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Berreskuratu automatikoki Spotifyren erreproduzitze arazoak zure azken erreproduzio-zerrenda berrekin",SETTINGS_SKIP_TRASHED_TRACKS:"Saltatu Ezabatutako Pista",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Ezabatutako abestiak automatikoki saltatu eta erreproduzitzean ondorengo pista baimendua aurkitu",SETTINGS_AUTO_CLEAN_QUEUE:"Auto garbitu ilara",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Kendu automatikoki zakarreratuak izan diren abestiak zure ausazko iraultza-ilaratik",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Hurrengo laster-tekla erabiliz zakarreratua",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Erabili Ctrl+Eskuina teklatu lasterbidea hurrengo pista bat pasa eta uneko kanta automatikoki zakarrontzian jartzeko",SETTINGS_REMOTE_CONTROL:"Urruneko kontrola",SETTINGS_REMOTE_TOGGLE:"Gaitu urruneko txandakaketa",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Ukitu bikoitza play/pausa mugikorrean urruneko saltaketa gaitzeko/desgaitzeko. Pista bat saltatzeak eragiketa berretsi egiten du.",SETTINGS_REMOTE_SKIPPING:"Urruneko saltatzea aktibatuta",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Gaituta dagoenean, zakarrira bidaltzea saltatzea beste gailu batetik (adibidez, mugikorra) Spotify kontrolatzean ere funtzionatzen du",MESSAGE_REMOTE_SKIPPING_ENABLED:"Urruneko saltatzea gaituta",MESSAGE_REMOTE_SKIPPING_DISABLED:"Urruneko saltatzea desgaituta",MESSAGE_SONG_ADDED_REMOTE:"Kanta hondatua urruneko bidez",SETTINGS_TRASH_VIA_LIKE:"Zaborra nahi bezala",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Abestia bezala mugikidetik zakarrerako. Bere kabuz ezabesten du eta hurrengo pista pasatzen da.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var yt=K((pS,uu)=>{uu.exports={TRASHBIN_NAME:"سطل زباله+",ACTION_THROW:"در سطل زباله قرار بده",ACTION_UNTHROW:"حذف از سطل آشغال",ACTION_CLEAR:"شفاف",ACTION_COPY:"کپی",ACTION_EXPORT:"صادرات",ACTION_IMPORT:"وارد کردن",MESSAGE_COPIED:"کپی شد در کلیپ‌بورد",MESSAGE_CLEARED:"سطل آشغال با موفقیت خالی شد!",MESSAGE_SONG_ADDED:"آهنگ به سطل آشغال اضافه شد",MESSAGE_SONG_REMOVED:"آهنگ از زباله‌دان حذف شد",MESSAGE_ARTIST_ADDED:"هنرمند به سطل زباله اضافه شد",MESSAGE_ARTIST_REMOVED:"هنرمند از سطل زباله حذف شد",BACKUP_SAVE_SUCCESS:"پشتیبان با موفقیت ذخیره شد.",BACKUP_SAVE_FAILED:"ذخیره پشتیبان ناموفق بود، سعی کنید محتوای سطل زباله را کپی کرده و به صورت دستی یک پشتیبان ایجاد کنید.",BACKUP_RESTORE_SUCCESS:"پشتیبان با موفقیت بازیابی شد.",BACKUP_FILE_READ_FAILED:"خواندن فایل ناموفق بود، لطفاً مطمئن شوید که یک فایل JSON معتبر است.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"تنظیمات سطل زباله+",SETTINGS_OPTIONS:"گزینه‌ها",SETTINGS_FEATURES:"ویژگی‌ها",SETTINGS_LOCAL_STORAGE:"ذخیره‌سازی محلی",SETTINGS_ENABLED:"فعال شده",SETTINGS_SHOW_WIDGET:"نمایش آیکون ویجت",SETTINGS_AUTOPLAY:"پخش خودکار هنگام شروع",SETTINGS_QUEUE_TRASHBIN:"فعال‌سازی سطل آشغال صف",SETTINGS_TRACKLIST_TRASHBIN:"فعال‌سازی سطل زباله فهرست قطعات",SETTINGS_PLAYLIST_MONITOR:"مانیتور لیست پخش",ITEMS_TITLE:"موارد سطل زباله+",ITEMS_EMPTY_SONGS:"<strongهیچ آهنگ حذف‌شده‌ای وجود ندارد!</strong><br/>آهنگ‌هایی که به سطل زباله اضافه می‌کنید اینجا نمایش داده می‌شوند.",ITEMS_EMPTY_ARTISTS:"<strong>هیچ هنرمند حذف‌شده‌ای وجود ندارد!</strong><br/>هنرمندانی که به سطل زباله اضافه می‌کنید اینجا نمایش داده می‌شوند.",ITEMS_TAB_SONGS:"ترانه‌ها",ITEMS_TAB_ARTISTS:"هنرمندان",ITEMS_LOADED_COUNT:"{{loaded}} از {{total}} {{type}} بارگذاری شد",DESCRIPTION_COPY:"همهٔ موارد موجود در سطل آشغال را به کلیپ‌بورد کپی کنید.",DESCRIPTION_EXPORT:"ذخیره تمام موارد در سطل آشغال به یک فایل .json",DESCRIPTION_IMPORT:"جایگزینی تمام موارد در سطل زباله از طریق فایل .json",DESCRIPTION_CLEAR:"تمام موارد را از سطل آشغال حذف کنید (قابل بازگشت نیست).",ITEMS_EMPTY_SONGS_TITLE:"هیچ آهنگ حذف شده‌ای وجود ندارد!",ITEMS_EMPTY_ARTISTS_TITLE:"هیچ هنرمند حذف شدهای!",DESCRIPTION_SETTINGS_ENABLED:"کلید اصلی برای فعال یا غیرفعال کردن تمام عملکردهای Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"نمایش یک آیکون سطل آشغال در نوار پخش کنار قطعه‌ای که در حال پخش است، برای دسترسی سریع",DESCRIPTION_SETTINGS_AUTOPLAY:"پخش خودکار موسیقی هنگام باز شدن اسپاتیفای یا بارگذاری افزونه",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"آیکون‌های سطل آشغال را کنار هر آهنگ در صف آینده‌تان اضافه کنید تا مدیریت آسان‌تری داشته باشید",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"آیکون‌های سطل آشغال را کنار آهنگ‌ها در نمای آلبوم و فهرست پخش اضافه کنید تا فیلتر سریع امکان‌پذیر شود",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"بازیابی خودکار از مشکلات پخش اسپاتیفای با ادامه دادن آخرین لیست پخش شما",SETTINGS_SKIP_TRASHED_TRACKS:"رد کردن مسیرهای حذف‌شده",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"به‌طور خودکار آهنگ‌های حذف‌شده را رد کنید و در هنگام پخش، قطعه بعدی مجاز را پیدا کنید",SETTINGS_AUTO_CLEAN_QUEUE:"صف خالی کردن خودکار",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"حذف خودکار آهنگ‌های سطل آشغال از صف پخش تصادفی هوشمند شما",SETTINGS_TRASH_ON_NEXT_HOTKEY:"زباله در هات‌کی بعدی",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"هنگام استفاده از میانبر کیبوردی Ctrl+راست برای پرش به قطعه بعدی، قطعه فعلی به‌طور خودکار به سطل زباله منتقل شود",SETTINGS_REMOTE_CONTROL:"کنترل از راه دور",SETTINGS_REMOTE_TOGGLE:"فعال‌سازی تغییر از راه دور",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"دو بار لمس کردن دکمه پخش/مکث از موبایل برای فعال یا غیرفعال کردن رد کردن از راه دور. رد شدن از یک قطعه، تغییر حالت را تأیید می‌کند.",SETTINGS_REMOTE_SKIPPING:"پرش از راه دور فعال است",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"هنگامی که فعال است، رد کردن موزیک‌های سطل آشغال حتی هنگام کنترل اسپاتیفای از دستگاه دیگری (مثلاً تلفن همراه) نیز کار می‌کند",MESSAGE_REMOTE_SKIPPING_ENABLED:"پرش از راه دور فعال شد",MESSAGE_REMOTE_SKIPPING_DISABLED:"پرش از راه دور غیرفعال شده است",MESSAGE_SONG_ADDED_REMOTE:"آهنگ از راه دور حذف شد",SETTINGS_TRASH_VIA_LIKE:"زباله از طریق لایک",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"مثل یک آهنگ از موبایل به سطل زباله. به صورت خودکار لایک را پس می‌گیرد و به موسیقی بعدی می‌رود.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var bt=K((SS,gu)=>{gu.exports={TRASHBIN_NAME:"Roskakori+",ACTION_THROW:"Laita roskakoriin",ACTION_UNTHROW:"Poista roskakorista",ACTION_CLEAR:"Selkeä",ACTION_COPY:"Kopioi",ACTION_EXPORT:"Vie",ACTION_IMPORT:"Tuo",MESSAGE_COPIED:"Kopioitu leikepöydälle",MESSAGE_CLEARED:"Roskakori tyhjennetty onnistuneesti!",MESSAGE_SONG_ADDED:"Kappale lisätty roskakoriin",MESSAGE_SONG_REMOVED:"Kappale poistettu roskakorista",MESSAGE_ARTIST_ADDED:"Taiteilija lisätty roskakoriin",MESSAGE_ARTIST_REMOVED:"Taiteilija poistettu roskakorista",BACKUP_SAVE_SUCCESS:"Varmuuskopio tallennettu onnistuneesti.",BACKUP_SAVE_FAILED:"Varmuuskopiota ei voitu tallentaa, yritä kopioida roskakorin sisältö leikepöydälle ja luo varmuuskopio manuaalisesti.",BACKUP_RESTORE_SUCCESS:"Varmuuskopio palautettu onnistuneesti.",BACKUP_FILE_READ_FAILED:"Tiedoston lukeminen epäonnistui, varmista että se on kelvollinen JSON-tiedosto.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Roskakori+ -asetukset",SETTINGS_OPTIONS:"Asetukset",SETTINGS_FEATURES:"Ominaisuudet",SETTINGS_LOCAL_STORAGE:"Paikallinen tallennus",SETTINGS_ENABLED:"Käytössä",SETTINGS_SHOW_WIDGET:"Näytä widgetin kuvake",SETTINGS_AUTOPLAY:"Käynnistä automaattitoisto käynnistyksen yhteydessä",SETTINGS_QUEUE_TRASHBIN:"Ota käyttöön jonon roskakori",SETTINGS_TRACKLIST_TRASHBIN:"Ota käyttöön soittolistan roskakori",SETTINGS_PLAYLIST_MONITOR:"Soittolistan valvoja",ITEMS_TITLE:"Roskakori+ -tuotteet",ITEMS_EMPTY_SONGS:"<strong>Ei roskikseen laitettuja kappaleita!</strong><br/>Kappaleet, jotka lisäät roskikseen, ilmestyvät tähän.",ITEMS_EMPTY_ARTISTS:"<strong>Ei roskakoriin laitettuja artisteja!</strong><br/>Roskakoriin lisäämäsi artistit ilmestyvät tähän.",ITEMS_TAB_SONGS:"Laulut",ITEMS_TAB_ARTISTS:"Taiteilijat",ITEMS_LOADED_COUNT:"{{loaded}} / {{total}} {{type}} ladattu",DESCRIPTION_COPY:"Kopioi kaikki roskakorissa olevat kohteet leikepöydälle.",DESCRIPTION_EXPORT:"Tallenna kaikki roskakorissa olevat kohteet .json-tiedostoon.",DESCRIPTION_IMPORT:"Korvaa kaikki roskakorin kohteet .json-tiedostolla.",DESCRIPTION_CLEAR:"Tyhjennä kaikki kohteet roskakorista (toimintoa ei voi kumota).",ITEMS_EMPTY_SONGS_TITLE:"Ei hävitettyjä kappaleita!",ITEMS_EMPTY_ARTISTS_TITLE:"Ei roskaa taideteoksia!",DESCRIPTION_SETTINGS_ENABLED:"Pääkytkin kaikkien Roskakori+-toimintojen käyttöön ottamiseksi tai poistamiseksi",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Näytä roskakorikuvake toistopalkissa pariksi toistettavan kappaleen viereen nopeaa käyttöä varten",DESCRIPTION_SETTINGS_AUTOPLAY:"Käynnistä musiikin toisto automaattisesti, kun Spotify avataan tai laajennus latautuu",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Lisää roskakorikuvakkeet jokaisen kappaleen viereen tulevassa soittolistassasi helpompaa hallintaa varten",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Lisää roskakorikuvakkeet kappaleiden viereen albumi- ja soittolista-näkymissä nopeaa suodatusta varten",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Palautuu automaattisesti Spotify-soittovirheistä jatkamalla viimeistä soittolistaa",SETTINGS_SKIP_TRASHED_TRACKS:"Ohita poistetut kappaleet",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Ohita automaattisesti roskakoriin siirretyt kappaleet ja etsi seuraava sallittu kappale toiston aikana",SETTINGS_AUTO_CLEAN_QUEUE:"Automaattinen siivousjono",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Poista roskakoriin siirretyt kappaleet automaattisesti Smart Shuffle -jonostasi",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Roska seuraavalla pikakäskyllä",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Siirrä nykyinen kappale roskakoriin automaattisesti, kun seuraavaan kappaleeseen siirrytään näppäinyhdistelmällä Ctrl+Oikea",SETTINGS_REMOTE_CONTROL:"Kauko-ohjain",SETTINGS_REMOTE_TOGGLE:"Ota etäkytkin käyttöön",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Kaksoisnapauta toisto/tauko matkapuhelimessa vaihtaaksesi etäohjauksen ohituksen päälle/pois. Kappaleen ohitus vahvistaa vaihtoehdon.",SETTINGS_REMOTE_SKIPPING:"Etäohjattu ohitus aktiivinen",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Kun tämä on käytössä, roskakori ohitetaan myös, kun Spotifya ohjataan toisesta laitteesta (esim. mobiililaitteesta)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Etäohjattu ohitus käytössä",MESSAGE_REMOTE_SKIPPING_DISABLED:"Etäohjauksella ohittaminen poistettu käytöstä",MESSAGE_SONG_ADDED_REMOTE:"Kappale tuhottu kauko-ohjauksella",SETTINGS_TRASH_VIA_LIKE:"Roska via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Kuten kappale, joka siirtyy kännykästä roskikseen. Poistaa tykkäyksen automaattisesti ja siirtyy seuraavaan kappaleeseen.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var jt=K((MS,su)=>{su.exports={TRASHBIN_NAME:"Basurahan+",ACTION_THROW:"Ilagay sa Trashbin",ACTION_UNTHROW:"Alisin mula sa Basurahan",ACTION_CLEAR:"Malinaw",ACTION_COPY:"Kopyahin",ACTION_EXPORT:"I-export",ACTION_IMPORT:"I-import",MESSAGE_COPIED:"Kinopya sa clipboard",MESSAGE_CLEARED:"Matagumpay na inalis ang basura sa basurahan!",MESSAGE_SONG_ADDED:"Idinagdag ang kanta sa basurahan",MESSAGE_SONG_REMOVED:"Inalis ang kanta mula sa basurahan",MESSAGE_ARTIST_ADDED:"Idinagdag ang artista sa basurahan",MESSAGE_ARTIST_REMOVED:"Artistang inalis mula sa basurahan",BACKUP_SAVE_SUCCESS:"Matagumpay na nai-save ang backup.",BACKUP_SAVE_FAILED:"Hindi na-save ang backup, subukang kopyahin ang nilalaman ng trashbin sa clipboard at gumawa ng backup nang manu-mano.",BACKUP_RESTORE_SUCCESS:"Matagumpay na naibalik ang backup.",BACKUP_FILE_READ_FAILED:"Hindi mabasa ang file, mangyaring tiyakin na ito ay isang wastong JSON file.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Mga Setting ng Trashbin+",SETTINGS_OPTIONS:"Mga Pagpipilian",SETTINGS_FEATURES:"Mga Tampok",SETTINGS_LOCAL_STORAGE:"Lokal na Imbakan",SETTINGS_ENABLED:"Naka-enable",SETTINGS_SHOW_WIDGET:"Ipakita ang Icon ng Widget",SETTINGS_AUTOPLAY:"I-play nang awtomatiko sa Pagbubukod",SETTINGS_QUEUE_TRASHBIN:"I-enable ang Queue Trashbin",SETTINGS_TRACKLIST_TRASHBIN:"I-enable ang Tracklist Trashbin",SETTINGS_PLAYLIST_MONITOR:"Playlist Monitor",ITEMS_TITLE:"Mga Item sa Basurahan+",ITEMS_EMPTY_SONGS:"<strong>Walang mga itinapon na kanta!</strong><br/>Ang mga kantang idinagdag mo sa trashbin ay lilitaw dito.",ITEMS_EMPTY_ARTISTS:"<strong>Walang mga itinapon na artista!</strong><br/>Ang mga artista na idinagdag mo sa trashbin ay lilitaw dito.",ITEMS_TAB_SONGS:"Mga kanta",ITEMS_TAB_ARTISTS:"Mga Artista",ITEMS_LOADED_COUNT:"{{loaded}} ng {{total}} {{type}} na-load",DESCRIPTION_COPY:"Kopyahin ang lahat ng item sa trashbin sa clipboard.",DESCRIPTION_EXPORT:"I-save ang lahat ng mga item sa trashbin sa isang file na .json.",DESCRIPTION_IMPORT:"Isulat muli ang lahat ng mga item sa trashbin gamit ang .json file.",DESCRIPTION_CLEAR:"Tanggalin ang lahat ng mga item mula sa basurahan (hindi ito maibabalik).",ITEMS_EMPTY_SONGS_TITLE:"Walang mga itinapong kanta!",ITEMS_EMPTY_ARTISTS_TITLE:"Walang mga nasirang artista!",DESCRIPTION_SETTINGS_ENABLED:"Pangunahing toggle para paganahin o i-disable ang lahat ng mga tungkulin ng Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Ipakita ang icon ng basurahan sa playback bar sa tabi ng kasalukuyang nagpe-play na track para sa mabilis na pag-access",DESCRIPTION_SETTINGS_AUTOPLAY:"Awtomatikong maglalaro ng musika kapag binuksan ang Spotify o nai-load ang extension",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Magdagdag ng mga icon ng basura sa tabi ng bawat kanta sa iyong susunod na queue para sa madaling pamamahala",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Magdagdag ng mga icon ng basura sa tabi ng mga kanta sa mga view ng album at playlist para sa mabilis na pag-filter",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Awtomatikong makabawi mula sa mga glitch sa pag-playback ng Spotify sa pamamagitan ng pagpapatuloy sa iyong huling playlist",SETTINGS_SKIP_TRASHED_TRACKS:"Laktawan ang mga Nasirang Track",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Awtomatikong laktawan ang mga itinapon na kanta at hanapin ang susunod na pinapayagang track habang nagpe-play",SETTINGS_AUTO_CLEAN_QUEUE:"Awtomatikong Linisin ang Queue",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Awtomatikong alisin ang mga itinapon na kanta mula sa iyong Smart Shuffle na pila",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Basura sa Susunod na Hotkey",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Awtomatikong itapon ang kasalukuyang kanta kapag gumagamit ng Ctrl+Right na shortcut sa keyboard upang laktawan patungo sa susunod na track",SETTINGS_REMOTE_CONTROL:"Remote Control",SETTINGS_REMOTE_TOGGLE:"Paganahin ang Remote Toggle",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"I-doble i-tap ang play/pause mula sa mobile para i-on o i-off ang remote skipping. Ang pag-skip ng track ay nagko-confirm sa toggle.",SETTINGS_REMOTE_SKIPPING:"Aktibong Paglilipat sa Remote",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Kapag pinagana, gumagana ang pag-skip sa basura kahit na kinokontrol ang Spotify mula sa ibang device (hal., mobile)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Pinagana ang remote skipping",MESSAGE_REMOTE_SKIPPING_DISABLED:"Hindi pinagana ang remote skipping",MESSAGE_SONG_ADDED_REMOTE:"Sinira ang kanta sa pamamagitan ng remote",SETTINGS_TRASH_VIA_LIKE:"Basura sa pamamagitan ng Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Tulad ng isang kanta mula sa mobile na itinapon. Awtomatikong inu-unlike at lumilipat sa susunod na track.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Ut=K((AS,pu)=>{pu.exports={TRASHBIN_NAME:"Corbeille+",ACTION_THROW:"Placer dans la corbeille",ACTION_UNTHROW:"Supprimer de la Corbeille",ACTION_CLEAR:"Clair",ACTION_COPY:"Copier",ACTION_EXPORT:"Exporter",ACTION_IMPORT:"Importer",MESSAGE_COPIED:"Copié dans le presse-papiers",MESSAGE_CLEARED:"Corbeille vidée avec succès !",MESSAGE_SONG_ADDED:"Chanson ajoutée à la corbeille",MESSAGE_SONG_REMOVED:"Chanson supprimée de la corbeille",MESSAGE_ARTIST_ADDED:"Artiste ajouté à la corbeille",MESSAGE_ARTIST_REMOVED:"Artiste retiré de la corbeille",BACKUP_SAVE_SUCCESS:"Sauvegarde effectuée avec succès.",BACKUP_SAVE_FAILED:"Échec de la sauvegarde. Essayez de copier le contenu de la corbeille dans le presse-papiers et de créer une sauvegarde manuellement.",BACKUP_RESTORE_SUCCESS:"Sauvegarde restaurée avec succès.",BACKUP_FILE_READ_FAILED:"Échec de la lecture du fichier, veuillez vous assurer qu'il s'agit d'un fichier JSON valide.",BACKUP_SUGGESTED_FILENAME:"spicetify-poubelle.json",SETTINGS_TITLE:"Paramètres de Trashbin+",SETTINGS_OPTIONS:"Options",SETTINGS_FEATURES:"Fonctionnalités",SETTINGS_LOCAL_STORAGE:"Stockage local",SETTINGS_ENABLED:"Activé",SETTINGS_SHOW_WIDGET:"Afficher l'icône du widget",SETTINGS_AUTOPLAY:"Lecture automatique au démarrage",SETTINGS_QUEUE_TRASHBIN:"Activer la corbeille de la file d'attente",SETTINGS_TRACKLIST_TRASHBIN:"Activer la corbeille de la liste de pistes",SETTINGS_PLAYLIST_MONITOR:"Moniteur de liste de lecture",ITEMS_TITLE:"Éléments de la corbeille+",ITEMS_EMPTY_SONGS:"<strong>Aucune chanson dans la corbeille !</strong><br/>Les chansons que vous ajoutez à la corbeille apparaîtront ici.",ITEMS_EMPTY_ARTISTS:"<strong>Aucun artiste dans la corbeille !</strong><br/>Les artistes que vous ajoutez à la corbeille apparaîtront ici.",ITEMS_TAB_SONGS:"Chansons",ITEMS_TAB_ARTISTS:"Artistes",ITEMS_LOADED_COUNT:"{{loaded}} sur {{total}} {{type}} chargé(s)",DESCRIPTION_COPY:"Copier tous les éléments de la corbeille dans le presse-papiers.",DESCRIPTION_EXPORT:"Enregistrer tous les éléments de la corbeille dans un fichier .json.",DESCRIPTION_IMPORT:"Remplacer tous les éléments de la corbeille via le fichier .json.",DESCRIPTION_CLEAR:"Effacer tous les éléments de la corbeille (impossible à annuler).",ITEMS_EMPTY_SONGS_TITLE:"Aucune chanson supprimée !",ITEMS_EMPTY_ARTISTS_TITLE:"Aucun artiste supprimé !",DESCRIPTION_SETTINGS_ENABLED:"Commande principale pour activer ou désactiver toutes les fonctionnalités de Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Afficher une icône de corbeille dans la barre de lecture à côté de la piste en cours de lecture pour un accès rapide",DESCRIPTION_SETTINGS_AUTOPLAY:"Lancer automatiquement la lecture de musique lorsque Spotify s'ouvre ou que l'extension se charge",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Ajoutez des icônes de corbeille à côté de chaque chanson dans votre file d'attente à venir pour une gestion facile",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Ajouter des icônes de corbeille à côté des chansons dans les vues d'album et de liste de lecture pour un filtrage rapide",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Récupérez automatiquement des problèmes de lecture sur Spotify en reprenant votre dernière playlist",SETTINGS_SKIP_TRASHED_TRACKS:"Ignorer les pistes supprimées",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Passer automatiquement les chansons supprimées et trouver la piste autorisée suivante pendant la lecture",SETTINGS_AUTO_CLEAN_QUEUE:"File d'attente de nettoyage automatique",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Supprimer automatiquement les chansons supprimées de votre file d'attente Smart Shuffle",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Corbeille à la prochaine touche de raccourci",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Placer automatiquement la chanson actuelle dans la corbeille lors de l'utilisation du raccourci clavier Ctrl+Flèche droite pour passer au morceau suivant",SETTINGS_REMOTE_CONTROL:"Télécommande",SETTINGS_REMOTE_TOGGLE:"Activer la bascule à distance",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Appuyez deux fois sur lecture/pause depuis votre mobile pour activer ou désactiver la fonction de saut de piste à distance. Le saut d'une piste confirme le changement d'état.",SETTINGS_REMOTE_SKIPPING:"Passage à distance activé",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Lorsqu'elle est activée, la fonction de saut de la corbeille fonctionne même lorsque vous contrôlez Spotify à partir d'un autre appareil (par exemple, un appareil mobile).",MESSAGE_REMOTE_SKIPPING_ENABLED:"Ignorer à distance activé",MESSAGE_REMOTE_SKIPPING_DISABLED:"Saut à distance désactivé",MESSAGE_SONG_ADDED_REMOTE:"Chanson supprimée à distance",SETTINGS_TRASH_VIA_LIKE:"Déchets via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Comme une chanson provenant d'un mobile à supprimer. Supprime automatiquement le « j'aime » et passe au morceau suivant.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Wt=K((TS,Su)=>{Su.exports={TRASHBIN_NAME:"Corbeille+",ACTION_THROW:"Placer dans la corbeille",ACTION_UNTHROW:"Supprimer de la corbeille",ACTION_CLEAR:"Clair",ACTION_COPY:"Copier",ACTION_EXPORT:"Exporter",ACTION_IMPORT:"Importer",MESSAGE_COPIED:"Copié dans le presse-papiers",MESSAGE_CLEARED:"Corbeille vidée avec succès !",MESSAGE_SONG_ADDED:"Chanson ajoutée à la corbeille",MESSAGE_SONG_REMOVED:"Chanson supprimée de la corbeille",MESSAGE_ARTIST_ADDED:"Artiste ajouté à la corbeille",MESSAGE_ARTIST_REMOVED:"Artiste supprimé de la corbeille",BACKUP_SAVE_SUCCESS:"Sauvegarde effectuée avec succès.",BACKUP_SAVE_FAILED:"Échec de la sauvegarde, essayez de copier le contenu de la corbeille dans le presse-papiers et de créer une sauvegarde manuellement.",BACKUP_RESTORE_SUCCESS:"Sauvegarde restaurée avec succès.",BACKUP_FILE_READ_FAILED:"Échec de la lecture du fichier, veuillez vous assurer qu'il s'agit d'un fichier JSON valide.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Paramètres de Trashbin+",SETTINGS_OPTIONS:"Options",SETTINGS_FEATURES:"Caractéristiques",SETTINGS_LOCAL_STORAGE:"Stockage local",SETTINGS_ENABLED:"Activé",SETTINGS_SHOW_WIDGET:"Afficher l'icône du widget",SETTINGS_AUTOPLAY:"Lecture automatique au démarrage",SETTINGS_QUEUE_TRASHBIN:"Activer la corbeille de la file d'attente",SETTINGS_TRACKLIST_TRASHBIN:"Activer la corbeille de la liste de lecture",SETTINGS_PLAYLIST_MONITOR:"Moniteur de playlist",ITEMS_TITLE:"Éléments de la corbeille+",ITEMS_EMPTY_SONGS:"<strong>Aucune chanson dans la corbeille !</strong><br/>Les chansons que vous ajoutez à la corbeille apparaîtront ici.",ITEMS_EMPTY_ARTISTS:"<strong>Aucun artiste supprimé !</strong><br/>Les artistes que vous ajoutez à la corbeille apparaîtront ici.",ITEMS_TAB_SONGS:"Chansons",ITEMS_TAB_ARTISTS:"Artistes",ITEMS_LOADED_COUNT:"{{loaded}} sur {{total}} {{type}} chargés",DESCRIPTION_COPY:"Copier tous les éléments de la corbeille dans le presse-papiers.",DESCRIPTION_EXPORT:"Enregistrer tous les éléments de la corbeille dans un fichier .json.",DESCRIPTION_IMPORT:"Écraser tous les éléments de la corbeille via le fichier .json.",DESCRIPTION_CLEAR:"Effacer tous les éléments de la corbeille (action irréversible).",ITEMS_EMPTY_SONGS_TITLE:"Pas de chansons supprimées !",ITEMS_EMPTY_ARTISTS_TITLE:"Pas d'artistes jetés !",DESCRIPTION_SETTINGS_ENABLED:"Commutateur principal pour activer ou désactiver toutes les fonctionnalités de Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Afficher une icône de corbeille dans la barre de lecture à côté de la piste en cours de lecture pour un accès rapide",DESCRIPTION_SETTINGS_AUTOPLAY:"Lancer automatiquement la lecture de musique lorsque Spotify s'ouvre ou que l'extension se charge",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Ajoutez des icônes de corbeille à côté de chaque chanson dans votre file d'attente à venir pour une gestion facile",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Ajouter des icônes de corbeille à côté des chansons dans les vues album et playlist pour un filtrage rapide",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Récupération automatique des problèmes de lecture sur Spotify en reprenant votre dernière playlist",SETTINGS_SKIP_TRASHED_TRACKS:"Ignorer les pistes supprimées",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Ignorer automatiquement les chansons supprimées et trouver la prochaine piste autorisée pendant la lecture",SETTINGS_AUTO_CLEAN_QUEUE:"File de nettoyage automatique",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Supprimer automatiquement les chansons supprimées de votre file d'attente Smart Shuffle",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Poubelle sur le prochain raccourci clavier",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Supprimer automatiquement la chanson en cours lors de l'utilisation du raccourci clavier Ctrl+Flèche droite pour passer au morceau suivant",SETTINGS_REMOTE_CONTROL:"Télécommande",SETTINGS_REMOTE_TOGGLE:"Activer la bascule à distance",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Appuyez deux fois sur lecture/pause depuis le mobile pour activer ou désactiver la fonction de saut de piste à distance. Le saut d'une piste confirme le changement d'état.",SETTINGS_REMOTE_SKIPPING:"Passage à distance actif",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Lorsqu'elle est activée, la fonction de saut de la corbeille fonctionne même lorsqu'on contrôle Spotify depuis un autre appareil (par exemple, un téléphone mobile).",MESSAGE_REMOTE_SKIPPING_ENABLED:"Saut à distance activé",MESSAGE_REMOTE_SKIPPING_DISABLED:"Saut à distance désactivé",MESSAGE_SONG_ADDED_REMOTE:"Chanson supprimée à distance",SETTINGS_TRASH_VIA_LIKE:"Poubelle via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:`Comme une chanson provenant d'un mobile à supprimer. Supprime automatiquement le "like" et passe au morceau suivant.`,SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Kt=K((ES,Mu)=>{Mu.exports={TRASHBIN_NAME:"Lixo+",ACTION_THROW:"Colocar no lixo",ACTION_UNTHROW:"Eliminar da lixeira",ACTION_CLEAR:"Claro",ACTION_COPY:"Copiar",ACTION_EXPORT:"Exportar",ACTION_IMPORT:"Importar",MESSAGE_COPIED:"Copiado no portapapeis",MESSAGE_CLEARED:"Papeleira baleirada satisfactoriamente!",MESSAGE_SONG_ADDED:"Canción engadida á lixeira",MESSAGE_SONG_REMOVED:"Canción eliminada do lixo",MESSAGE_ARTIST_ADDED:"Artista engadido á lixeira",MESSAGE_ARTIST_REMOVED:"Artista eliminado do lixo",BACKUP_SAVE_SUCCESS:"Copia de seguridade gardada satisfactoriamente.",BACKUP_SAVE_FAILED:"Non foi posíbel gardar a copia de seguridade, probe copiar o contido do lixo no portapapeis e crear unha copia de seguridade manualmente.",BACKUP_RESTORE_SUCCESS:"Copia de seguridade restaurada correctamente.",BACKUP_FILE_READ_FAILED:"Non foi posíbel ler o ficheiro, asegúrese de que é un ficheiro JSON válido.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Configuración de Trashbin+",SETTINGS_OPTIONS:"Opcións",SETTINGS_FEATURES:"Características",SETTINGS_LOCAL_STORAGE:"Almacenamento local",SETTINGS_ENABLED:"Activado",SETTINGS_SHOW_WIDGET:"Amosar icona do widget",SETTINGS_AUTOPLAY:"Reprodución automática ao iniciar",SETTINGS_QUEUE_TRASHBIN:"Activar a lixeira da cola",SETTINGS_TRACKLIST_TRASHBIN:"Activar o lixo da lista de pistas",SETTINGS_PLAYLIST_MONITOR:"Monitor de listas de reprodución",ITEMS_TITLE:"Elementos de Lixo+",ITEMS_EMPTY_SONGS:"<strong>Sen cancións no lixo!</strong><br/>As cancións que engadas ao lixo aparecerán aquí.",ITEMS_EMPTY_ARTISTS:"<strong>Sen artistas na lixeira!</strong><br/>Os artistas que engadas á lixeira aparecerán aquí.",ITEMS_TAB_SONGS:"Cancións",ITEMS_TAB_ARTISTS:"Artistas",ITEMS_LOADED_COUNT:"{{loaded}} de {{total}} {{type}} cargados",DESCRIPTION_COPY:"Copiar todos os elementos do lixo no portapapeis.",DESCRIPTION_EXPORT:"Gardar todos os elementos no lixo nun ficheiro .json.",DESCRIPTION_IMPORT:"Substituír todos os elementos no lixo mediante ficheiro .json.",DESCRIPTION_CLEAR:"Borrar todos os elementos da lixeira (non se pode desfacer).",ITEMS_EMPTY_SONGS_TITLE:"Sen cancións eliminadas!",ITEMS_EMPTY_ARTISTS_TITLE:"Ningún artista eliminado!",DESCRIPTION_SETTINGS_ENABLED:"Interruptor principal para activar ou desactivar todas as funcións de Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Amosar unha icona de lixo na barra de reprodución xunto á pista que se está reproducindo para un acceso rápido",DESCRIPTION_SETTINGS_AUTOPLAY:"Iniciar automaticamente a reprodución de música cando se abra Spotify ou cargue a extensión",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Engadir iconas de lixo ao carón de cada canción na cola próxima para unha xestión sinxela",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Engadir iconas de lixo ao lado das cancións nas vistas de álbum e lista de reprodución para un filtrado rápido",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recupera automaticamente dos fallos de reprodución de Spotify retomando a túa última lista de reprodución",SETTINGS_SKIP_TRASHED_TRACKS:"Omitir pistas eliminadas",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Saltar automaticamente as cancións eliminadas e atopar a seguinte pista permitida durante a reprodución",SETTINGS_AUTO_CLEAN_QUEUE:"Cola de limpeza automática",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Elimina automaticamente as cancións eliminadas da cola de reproducción aleatoria intelixente",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Lixeira na seguinte tecla rápida",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Eliminar automaticamente a canción actual cando se usa o atallo de teclado Ctrl+Dereita para pasar á seguinte pista",SETTINGS_REMOTE_CONTROL:"Control remoto",SETTINGS_REMOTE_TOGGLE:"Activar interruptor remoto",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Toque dúas veces en reproducir/pausa desde o móbil para activar/desactivar o salto remoto. Un salto de pista confirma o cambio.",SETTINGS_REMOTE_SKIPPING:"Omitido remoto activo",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Cando está activado, omitir a lixeira funciona incluso cando se controla Spotify desde outro dispositivo (por exemplo, móbil)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Omitido remoto activado",MESSAGE_REMOTE_SKIPPING_DISABLED:"O salto remoto está desactivado",MESSAGE_SONG_ADDED_REMOTE:"Canción eliminada á distancia",SETTINGS_TRASH_VIA_LIKE:"Lixo vía Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:'Como unha canción do móbil a bórlaa. Elimina o "gústame" e pasa automaticamente á seguinte pista.',SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var qt=K((IS,Au)=>{Au.exports={TRASHBIN_NAME:"ટ્રાશબિન+",ACTION_THROW:"ટ્રાશબિનમાં મૂકો",ACTION_UNTHROW:"કચરાપેટીમાંથી દૂર કરો",ACTION_CLEAR:"સ્પષ્ટ",ACTION_COPY:"નકલ કરો",ACTION_EXPORT:"નિકાસ",ACTION_IMPORT:"આયાત",MESSAGE_COPIED:"ક્લિપબોર્ડ પર કૉપિ કર્યું",MESSAGE_CLEARED:"ટ્રાશબિન સફળતાપૂર્વક સાફ કરવામાં આવી!",MESSAGE_SONG_ADDED:"ગીત કચરાપેટીમાં ઉમેરાયું",MESSAGE_SONG_REMOVED:"ગીત કચરાપેટીમાંથી દૂર કરાયું",MESSAGE_ARTIST_ADDED:"કલાકારને કચરાપેટીમાં ઉમેરાયો",MESSAGE_ARTIST_REMOVED:"કલાકારને કચરાપેટીમાંથી દૂર કરવામાં આવ્યો",BACKUP_SAVE_SUCCESS:"બેકઅપ સફળતાપૂર્વક સાચવાયું.",BACKUP_SAVE_FAILED:"બેકઅપ સેવ કરવામાં નિષ્ફળ, ત્રાશબિનની સામગ્રીને ક્લિપબોર્ડ પર કૉપિ કરીને મેન્યુઅલ રીતે બેકઅપ બનાવવાનો પ્રયત્ન કરો.",BACKUP_RESTORE_SUCCESS:"બેકઅપ સફળતાપૂર્વક પુનઃસ્થાપિત થયું.",BACKUP_FILE_READ_FAILED:"ફાઇલ વાંચવામાં નિષ્ફળ, કૃપા કરીને ખાતરી કરો કે તે માન્ય JSON ફાઇલ છે.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ટ્રાશબિન+ સેટિંગ્સ",SETTINGS_OPTIONS:"વિકલ્પો",SETTINGS_FEATURES:"સુવિધાઓ",SETTINGS_LOCAL_STORAGE:"સ્થાનિક સંગ્રહ",SETTINGS_ENABLED:"સક્ષમ",SETTINGS_SHOW_WIDGET:"વિજેટ આઇકન બતાવો",SETTINGS_AUTOPLAY:"શરૂઆતમાં ઓટોપ્લે",SETTINGS_QUEUE_TRASHBIN:"ક્યૂ ટ્રાશબિન સક્ષમ કરો",SETTINGS_TRACKLIST_TRASHBIN:"ટ્રેકલિસ્ટ કચરાપેટી સક્ષમ કરો",SETTINGS_PLAYLIST_MONITOR:"પ્લેલિસ્ટ મોનિટર",ITEMS_TITLE:"ટ્રાશબિન+ આઇટમ્સ",ITEMS_EMPTY_SONGS:"<strong>કોઈ ફેંકાયેલા ગીતો નથી!</strong><br/>તમે કચરાપેટીમાં ઉમેરેલા ગીતો અહીં દેખાશે.",ITEMS_EMPTY_ARTISTS:"<strong>કોઈ કચરો કલાકારો નહીં!</strong><br/>તમે કચરાપેટીમાં ઉમેરેલા કલાકારો અહીં દેખાશે.",ITEMS_TAB_SONGS:"ગીતો",ITEMS_TAB_ARTISTS:"કલાકારો",ITEMS_LOADED_COUNT:"{{total}} માંથી {{loaded}} {{type}} લોડ થયેલ છે",DESCRIPTION_COPY:"ટ્રાશબિનમાં બધી વસ્તુઓની ક્લિપબોર્ડ પર નકલ કરો.",DESCRIPTION_EXPORT:"કચરાપેટીમાં બધી વસ્તુઓને .json ફાઇલમાં સેવ કરો.",DESCRIPTION_IMPORT:"કચરાપેટીમાં બધી વસ્તુઓને .json ફાઇલ દ્વારા ઓવરરાઇટ કરો.",DESCRIPTION_CLEAR:"બિનાશક કચરાપેટીમાંથી બધી વસ્તુઓ કાઢી નાખો (પાછી ખેંચી શકાશે નહીં).",ITEMS_EMPTY_SONGS_TITLE:"કોઈ ફેંકાયેલા ગીતો નહીં!",ITEMS_EMPTY_ARTISTS_TITLE:"કોઈ ફેંકાયેલ કલાકાર નહીં!",DESCRIPTION_SETTINGS_ENABLED:"ટ્રાશબિન+ ની બધી કાર્યક્ષમતા સક્ષમ અથવા અક્ષમ કરવા માટર ટોગલ",DESCRIPTION_SETTINGS_SHOW_WIDGET:"ચાલુ પ્લેબેક ટ્રેકની બાજુમાં ઝડપી ઍક્સેસ માટે પ્લેબેક બારમાં એક કચરો આઇકોન પ્રદર્શિત કરો",DESCRIPTION_SETTINGS_AUTOPLAY:"સ્પોટિફાય ખુલે અથવા એક્સટેન્શન લોડ થાય ત્યારે સ્વચાલિત રીતે સંગીત વગાડવાનું શરૂ કરો",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"તમારી આગામી ક્યૂમાં દરેક ગીત પાસે કચરો આઇકોન ઉમેરો તેનું સરળ સંચાલન કરવા માટે",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"એલ્બમ અને પ્લેલિસ્ટ દૃશ્યોમાં ગીતોની બાજુમાં કચરો આઇકોન ઉમેરો ઝડપી ફિલ્ટરિંગ માટે",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"સ્પોટિફાઇ પ્લેબેક ગડબડથી આપમેળે રિકવર કરો તમારી છેલ્લી પ્લેલિસ્ટ ફરીથી શરૂ કરીને",SETTINGS_SKIP_TRASHED_TRACKS:"ટ્રાશ કરેલ ટ્રેક છોડો",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"ઑટોમેટિક રીતે કચરો કરેલા ગીતોને છોડી દો અને પ્લેબેક દરમિયાન આગળની મંજૂર ટ્રેક શોધો",SETTINGS_AUTO_CLEAN_QUEUE:"ઓટો ક્લીન કતાર",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"તમારી સ્માર્ટ શફલ કતારમાંથી કચરો ગીતો સ્વચાલિત રીતે દૂર કરો",SETTINGS_TRASH_ON_NEXT_HOTKEY:"નેક્સ્ટ હોટકી પર કચરો",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"જ્યારે આગામી ટ્રેક પર જવા માટે Ctrl+Right કીબોર્ડ શૉર્ટકટનો ઉપયોગ કરી રહ્યાં હોય ત્યારે વર્તમાન ગીતને સ્વચાલિત રીતે ત્યાજ્ય કરો",SETTINGS_REMOTE_CONTROL:"રિમોટ કંટ્રોલ",SETTINGS_REMOTE_TOGGLE:"રિમોટ ટૉગલ સક્ષમ કરો",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"મોબાઇલ પરથી પ્લે/પૉઝ પર બે વખત ટૅપ કરીને રિમોટ સ્કિપિંગ ચાલુ/બંધ કરો. ટ્રૅક સ્કિપ કરવાથી ટૉગલ પુષ્ટિ થશે.",SETTINGS_REMOTE_SKIPPING:"દૂરસ્થ સ્કિપિંગ સક્રિય",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"સક્ષમ હોય ત્યારે, કચરો છોડવાનું બીજા ઉપકરણ (ઉદાહરણ તરીકે, મોબાઇલ) માંથી સ્પોટિફાય પર નિયંત્રણ કરતી વખતે પણ કામ કરે છે",MESSAGE_REMOTE_SKIPPING_ENABLED:"દૂરસ્થ સ્કિપિંગ સક્ષમ છે",MESSAGE_REMOTE_SKIPPING_DISABLED:"દૂરસ્થ સ્કિપિંગ અક્ષમ",MESSAGE_SONG_ADDED_REMOTE:"ગીત રિમોટ દ્વારા નષ્ટ કરાયું",SETTINGS_TRASH_VIA_LIKE:"લાઇક દ્વારા કચરો",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"મોબાઇલમાંથી ટ્રશ માટેનું ગીત જેવું. આપમેળે અનલાઇક કરે છે અને આગલા ટ્રેક પર જાય છે.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Yt=K((mS,Tu)=>{Tu.exports={TRASHBIN_NAME:"פח האשפה+",ACTION_THROW:"הצב באשפה",ACTION_UNTHROW:"הסר מהסל למחוק",ACTION_CLEAR:"ברור",ACTION_COPY:"העתק",ACTION_EXPORT:"ייצוא",ACTION_IMPORT:"ייבוא",MESSAGE_COPIED:"הועתק ללוח剪贴板",MESSAGE_CLEARED:"אשפה נוקתה בהצלחה!",MESSAGE_SONG_ADDED:"השיר נוסף לסל האשפה",MESSAGE_SONG_REMOVED:"השיר הוסר מהסל המנוקה",MESSAGE_ARTIST_ADDED:"אמן נוסף לסל האשפה",MESSAGE_ARTIST_REMOVED:"האמן הוסר מהפח",BACKUP_SAVE_SUCCESS:"הגיבוי נשמר בהצלחה",BACKUP_SAVE_FAILED:"שמירת הגיבוי נכשלה, נסה להעתיק את תוכן סל המיחזור ללוח העריכה וליצור גיבוי ידנית.",BACKUP_RESTORE_SUCCESS:"הגיבוי שוחזר בהצלחה",BACKUP_FILE_READ_FAILED:"נכשל בקריאת הקובץ, אנא ודא שמדובר בקובץ JSON תקין.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"הגדרות סל האשפה+",SETTINGS_OPTIONS:"אפשרויות",SETTINGS_FEATURES:"תכונות",SETTINGS_LOCAL_STORAGE:"אחסון מקומי",SETTINGS_ENABLED:"מופעל",SETTINGS_SHOW_WIDGET:"הצג סמל ווידג'ט",SETTINGS_AUTOPLAY:"הפעלה אוטומטית בהתחלה",SETTINGS_QUEUE_TRASHBIN:"הפעלת אסלה של תור",SETTINGS_TRACKLIST_TRASHBIN:"הפעלת אסלה לרשימת רצועות",SETTINGS_PLAYLIST_MONITOR:"מוניטור רשימת ניגון",ITEMS_TITLE:"פריטים של סל האשפה+",ITEMS_EMPTY_SONGS:"<strong>אין שירים באשפה!</strong><br/>שירים שתשימו לפח יופיעו כאן.",ITEMS_EMPTY_ARTISTS:"<strong>אין אמנים באשפה!</strong><br/>אמנים שתקלטו לסל האשפה יופיעו כאן.",ITEMS_TAB_SONGS:"שירים",ITEMS_TAB_ARTISTS:"אמנים",ITEMS_LOADED_COUNT:"{{loaded}} מתוך {{total}} {{type}} נטענו",DESCRIPTION_COPY:"העתק את כל הפריטים באסלה ללוח.",DESCRIPTION_EXPORT:"שמור את כל הפריטים בסל המיחזור לקובץ .json.",DESCRIPTION_IMPORT:"החלף את כל הפריטים בסל המיחזור דרך קובץ .json.",DESCRIPTION_CLEAR:"לנקות את כל הפריטים מהפח (לא ניתן לבטל)",ITEMS_EMPTY_SONGS_TITLE:"אין שירים מחוקים!",ITEMS_EMPTY_ARTISTS_TITLE:"אין אמנים מושלכים!",DESCRIPTION_SETTINGS_ENABLED:"כיבוי/הפעלה עיקרי להפעלת או השבתת כל תכונות האשפה+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"הצגת סמל פח האשפה בסרגל השמעה ליד הרצועה הניגנת כרגע להגעה מהירה",DESCRIPTION_SETTINGS_AUTOPLAY:"הפעלת מוזיקה אוטומטית בעת פתיחת Spotify או טעינת ההרחבה",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"הוסיפו סמלי פח אשפה ליד כל שיר בתור ההשמעה הבא לניהול קל יותר",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"הוספת סמלי אשפה ליד שירים בתצוגות של אלבום ורשימת נגינה לצורך סינון מהיר",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"שחזור אוטומטי מתקלות ניגון ב-Spotify על ידי המשך ניגון רשימת ההשמעה האחרונה שלך",SETTINGS_SKIP_TRASHED_TRACKS:"דלג על רצועות שנמחקו",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"דלג אוטומטית על שירים שנמחקו ומצא את הרצועה המותרת הבאה במהלך הנגינה",SETTINGS_AUTO_CLEAN_QUEUE:"תור ניקוי אוטומטי",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"הסרה אוטומטית של שירים שנמחקו מהתור של הסדר המעורבב החכם שלך",SETTINGS_TRASH_ON_NEXT_HOTKEY:"אשפה במקש החם הבא",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"למחוק אוטומטית את השיר הנוכחי בעת שימוש בקיצור דרך Ctrl+ימין כדי לדלג לרצועה הבאה",SETTINGS_REMOTE_CONTROL:"שלט רחוק",SETTINGS_REMOTE_TOGGLE:"הפעלת החלפה מרחוק",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"הקשה פעמיתים על lecture/השהיה מהמכשיר הנייד כדי להחליף בין מצבים של דילוג מרחוק. דילוג על שיר מאשר את המעבר בין המצבים.",SETTINGS_REMOTE_SKIPPING:"דילוג מרחוק פעיל",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"כאשר מופעל, דילוג על מחזור works גם כששולטים בספוטיפי ממכשיר אחר (למשל, סלולרי)",MESSAGE_REMOTE_SKIPPING_ENABLED:"דילוג מרחוק מופעל",MESSAGE_REMOTE_SKIPPING_DISABLED:"דילוג מרחוק מבוטל",MESSAGE_SONG_ADDED_REMOTE:"שיר נהרס מרחוק",SETTINGS_TRASH_VIA_LIKE:"זבל דרך לייק",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"כמו שיר מהנייד לסל האשפה. מבטל לייק אוטומטית ומדלג לרצועה הבאה.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Qt=K((fS,Eu)=>{Eu.exports={TRASHBIN_NAME:"ट्रैशबिन+",ACTION_THROW:"कचरा डिब्बे में रखें",ACTION_UNTHROW:"ट्रैशबिन से हटाएं",ACTION_CLEAR:"स्पष्ट",ACTION_COPY:"कॉपी",ACTION_EXPORT:"निर्यात",ACTION_IMPORT:"आयात",MESSAGE_COPIED:"क्लिपबोर्ड पर कॉपी किया गया",MESSAGE_CLEARED:"ट्रैशबिन सफलतापूर्वक साफ किया गया!",MESSAGE_SONG_ADDED:"गाना ट्रैशबिन में जोड़ा गया",MESSAGE_SONG_REMOVED:"गाना रद्दी डिब्बे से हटा दिया गया",MESSAGE_ARTIST_ADDED:"कलाकार को ट्रैशबिन में जोड़ा गया",MESSAGE_ARTIST_REMOVED:"कलाकार को ट्रैशबिन से हटा दिया गया",BACKUP_SAVE_SUCCESS:"बैकअप सफलतापूर्वक सहेजा गया।",BACKUP_SAVE_FAILED:"बैकअप सहेजने में विफल, कृपया रद्दी डिब्बे की सामग्री को क्लिपबोर्ड पर कॉपी करने और मैन्युअल रूप से बैकअप बनाने का प्रयास करें।",BACKUP_RESTORE_SUCCESS:"बैकअप सफलतापूर्वक बहाल किया गया।",BACKUP_FILE_READ_FAILED:"फ़ाइल पढ़ने में विफल, कृपया सुनिश्चित करें कि यह एक मान्य JSON फ़ाइल है।",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ट्रैशबिन+ सेटिंग्स",SETTINGS_OPTIONS:"विकल्प",SETTINGS_FEATURES:"विशेषताएँ",SETTINGS_LOCAL_STORAGE:"स्थानीय भंडारण",SETTINGS_ENABLED:"सक्षम",SETTINGS_SHOW_WIDGET:"विजेट आइकन दिखाएं",SETTINGS_AUTOPLAY:"प्रारंभ में स्वत: चलाएं",SETTINGS_QUEUE_TRASHBIN:"कतार महसूरदान सक्षम करें",SETTINGS_TRACKLIST_TRASHBIN:"ट्रैकलिस्ट ट्रैशबिन सक्षम करें",SETTINGS_PLAYLIST_MONITOR:"प्लेलिस्ट मॉनिटर",ITEMS_TITLE:"ट्रैशबिन+ आइटम",ITEMS_EMPTY_SONGS:"<strong>कोई नष्ट किए गए गाने नहीं!</strong><br/>गाने जो आप रद्दी डिब्बे में डालते हैं वे यहां दिखाई देंगे।",ITEMS_EMPTY_ARTISTS:"<strong>कोई अपशिष्ट कलाकार नहीं!</strong><br/>कलाकार जिन्हें आप ट्रैशबिन में डालते हैं वे यहां दिखाई देंगे।",ITEMS_TAB_SONGS:"गाने",ITEMS_TAB_ARTISTS:"कलाकार",ITEMS_LOADED_COUNT:"{{total}} में से {{loaded}} {{type}} लोड हुआ",DESCRIPTION_COPY:"ट्रेशबिन में सभी आइटम को क्लिपबोर्ड पर कॉपी करें।",DESCRIPTION_EXPORT:"ट्रैशबिन में सभी आइटम को एक .json फ़ाइल में सहेजें।",DESCRIPTION_IMPORT:"कचरा बक्से में सभी आइटम को .json फ़ाइल के माध्यम से ओवरराइट करें।",DESCRIPTION_CLEAR:"ट्रैशबिन से सभी आइटम हटाएं (वापस नहीं किया जा सकता)।",ITEMS_EMPTY_SONGS_TITLE:"कोई हटाए गए गाने नहीं!",ITEMS_EMPTY_ARTISTS_TITLE:"कोई नष्ट कलाकार नहीं!",DESCRIPTION_SETTINGS_ENABLED:"सभी ट्रैशबिन+ कार्यक्षमता को सक्षम या अक्षम करने के लिए मास्टर टॉगल",DESCRIPTION_SETTINGS_SHOW_WIDGET:"प्लेबैक बार में वर्तमान में चल रहे ट्रैक के बगल में त्वरित पहुंच के लिए एक ट्रैश आइकन प्रदर्शित करें",DESCRIPTION_SETTINGS_AUTOPLAY:"स्पॉटिफाई खुलते ही या एक्सटेंशन लोड होते ही स्वचालित रूप से संगीत चलाना शुरू करें",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"अपने आगामी कतार में प्रत्येक गीत के बगल में कचरा आइकन जोड़ें ताकि आसान प्रबंधन हो सके",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"एल्बम और प्लेलिस्ट दृश्यों में गानों के बगल में ट्रैश आइकन जोड़ें ताकि त्वरित फ़िल्टरिंग की जा सके",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"स्पॉटिफाई प्लेबैक त्रुटियों से अपनी अंतिम प्लेलिस्ट को फिर से शुरू करके स्वचालित रूप से ठीक करें",SETTINGS_SKIP_TRASHED_TRACKS:"हटाए गए ट्रैक्स को छोड़ें",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"प्लेबैक के दौरान स्वचालित रूप से हटाए गए गानों को छोड़ें और अगला अनुमत ट्रैक ढूंढें",SETTINGS_AUTO_CLEAN_QUEUE:"स्वचालित सफाई कतार",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"अपने स्मार्ट शफल कतार से ट्रैश किए गए गाने स्वचालित रूप से हटा दें",SETTINGS_TRASH_ON_NEXT_HOTKEY:"अगले हॉटकी पर ट्रैश",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"वर्तमान गीत को स्वचालित रूप से ट्रैश करें जब अगले ट्रैक पर जाने के लिए Ctrl+Right कीबोर्ड शॉर्टकट का उपयोग कर रहे हों",SETTINGS_REMOTE_CONTROL:"रिमोट कंट्रोल",SETTINGS_REMOTE_TOGGLE:"दूरस्थ टॉगल सक्षम करें",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"मोबाइल से रिमोट स्किपिंग को चालू/बंद करने के लिए दो बार टैप करें। ट्रैक स्किप करने से टॉगल की पुष्टि हो जाएगी।",SETTINGS_REMOTE_SKIPPING:"दूरस्थ छलांग सक्रिय",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"जब सक्षम किया जाता है, तो कचरा-छोड़ना दूसरे उपकरण (उदाहरण के लिए, मोबाइल) से स्पॉटिफाई को नियंत्रित करते समय भी काम करता है",MESSAGE_REMOTE_SKIPPING_ENABLED:"दूरस्थ छलांग लगाना सक्षम है",MESSAGE_REMOTE_SKIPPING_DISABLED:"दूरस्थ छलांग अक्षम",MESSAGE_SONG_ADDED_REMOTE:"गाना रिमोट के माध्यम से नष्ट कर दिया गया",SETTINGS_TRASH_VIA_LIKE:"लाइक के माध्यम से कचरा",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"मोबाइल से ट्रैश करने के लिए एक गाने की तरह। स्वचालित रूप से अनलाइक करता है और अगले ट्रैक पर जाता है।",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Xt=K((xS,Iu)=>{Iu.exports={TRASHBIN_NAME:"Smeće+",ACTION_THROW:"Stavi u kantu za smeće",ACTION_UNTHROW:"Ukloni iz kante za smeće",ACTION_CLEAR:"Jasno",ACTION_COPY:"Kopiraj",ACTION_EXPORT:"Izvoz",ACTION_IMPORT:"Uvoz",MESSAGE_COPIED:"Kopirano u međuspremnik",MESSAGE_CLEARED:"Smeće uspješno obrisano!",MESSAGE_SONG_ADDED:"Pjesma dodana u smeće",MESSAGE_SONG_REMOVED:"Pjesma uklonjena iz smeća",MESSAGE_ARTIST_ADDED:"Umjetnik dodan u smeće",MESSAGE_ARTIST_REMOVED:"Umjetnik uklonjen iz smeća",BACKUP_SAVE_SUCCESS:"Sigurnosna kopija je uspješno spremljena.",BACKUP_SAVE_FAILED:"Nije uspjelo spremanje sigurnosne kopije, pokušajte kopirati sadržaj kante za smeće u međuspremnik i ručno kreirati sigurnosnu kopiju.",BACKUP_RESTORE_SUCCESS:"Sigurnosna kopija je uspješno vraćena.",BACKUP_FILE_READ_FAILED:"Neuspjelo čitanje datoteke, molimo provjerite je li ispravna JSON datoteka.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Postavke kantu za smeće+",SETTINGS_OPTIONS:"Mogućnosti",SETTINGS_FEATURES:"Značajke",SETTINGS_LOCAL_STORAGE:"Lokalno pohranjivanje",SETTINGS_ENABLED:"Omogućeno",SETTINGS_SHOW_WIDGET:"Prikaži ikonu widgeta",SETTINGS_AUTOPLAY:"Automatsko pokretanje pri pokretanju",SETTINGS_QUEUE_TRASHBIN:"Omogući red za smeće",SETTINGS_TRACKLIST_TRASHBIN:"Omogući kantu za otpatke popisa pjesama",SETTINGS_PLAYLIST_MONITOR:"Playlist Monitor",ITEMS_TITLE:"Stavke u kantu za smeće+",ITEMS_EMPTY_SONGS:"<strong>Nema pjesama u smeću!</strong><br/>Pjesme koje dodate u kantu za smeće pojaviti će se ovdje.",ITEMS_EMPTY_ARTISTS:"<strong>Nema umjetnika u smeću!</strong><br/>Umjetnici koje dodate u kantu za smeće pojaviti će se ovdje.",ITEMS_TAB_SONGS:"Pjesme",ITEMS_TAB_ARTISTS:"Umjetnici",ITEMS_LOADED_COUNT:"{{loaded}} od {{total}} {{type}} učitano",DESCRIPTION_COPY:"Kopiraj sve stavke u mape za smeće u međuspremnik.",DESCRIPTION_EXPORT:"Spremi sve stavke u kantu za smeće u .json datoteku.",DESCRIPTION_IMPORT:"Pregazite sve stavke u kanti za smeće putem .json datoteke.",DESCRIPTION_CLEAR:"Obriši sve stavke iz kante za smeće (ne može se poništiti).",ITEMS_EMPTY_SONGS_TITLE:"Nema izbrisanih pjesama!",ITEMS_EMPTY_ARTISTS_TITLE:"Nema odbačenih umjetnika!",DESCRIPTION_SETTINGS_ENABLED:"Glavni prekidač za omogućavanje ili onemogućavanje svih funkcija Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Prikaži ikonu kante za smeće na traci za reprodukciju pokraj trenutno sviranog zapisivanja radi brzog pristupa",DESCRIPTION_SETTINGS_AUTOPLAY:"Automatski pokreni sviranje glazbe kada se Spotify otvori ili kada se proširenje učita",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Dodajte ikone za brisanje pored svake pjesme u vašem nadolazećem redu za jednostavno upravljanje",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Dodajte ikone za brisanje pored pjesama u prikazima albuma i popisa pjesama za brzo filtriranje",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatski se oporavite od poteškoća pri reprodukciji na Spotifyju tako što ćete nastaviti s posljednjom reprodukcijom",SETTINGS_SKIP_TRASHED_TRACKS:"Preskoči obrisane pjesme",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Automatski preskoči izbrisane pjesme i pronađi sljedeću dopuštenu pjesmu tijekom reprodukcije",SETTINGS_AUTO_CLEAN_QUEUE:"Red za automatsko čišćenje",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Automatski uklonite pjesme u kantu za smeće iz svoje pametne redoslijed za reprodukciju",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Smeće na sljedećem tipu za brzo izvođenje",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Automatski premjesti trenutačnu pjesmu u smeće kada koristite tipkovni prečac Ctrl+Desno za preskakanje na sljedeću pjesmu",SETTINGS_REMOTE_CONTROL:"Dalekovodno upravljanje",SETTINGS_REMOTE_TOGGLE:"Omogući daljinsko prebacivanje",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dvaput dodirnite reprodukciju/pauzu na mobilnom uređaju da biste uključili ili isključili preskakanje putem daljinskog upravljača. Preskakanje pjesme potvrđuje uključivanje ili isključivanje.",SETTINGS_REMOTE_SKIPPING:"Udaljeno preskakanje aktivno",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Kada je omogućeno, preskakanje otpada funkcionira čak i kada upravljate Spotifyjem s drugog uređaja (npr. mobitela)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Udaljeno preskakanje omogućeno",MESSAGE_REMOTE_SKIPPING_DISABLED:"Prelazak na daljinu onemogućen",MESSAGE_SONG_ADDED_REMOTE:"Pjesma uništena na daljinu",SETTINGS_TRASH_VIA_LIKE:"Smeće putem Lajk",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Poput pjesme s mobitela koju bacaš u smeće. Automatski uklanja lajk i prelazi na sljedeću pjesmu.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var Jt=K((CS,mu)=>{mu.exports={TRASHBIN_NAME:"Kuka+",ACTION_THROW:"Helyezze a kukába",ACTION_UNTHROW:"Eltávolítás a Kuka mappából",ACTION_CLEAR:"Tiszta",ACTION_COPY:"Másolás",ACTION_EXPORT:"Export",ACTION_IMPORT:"Importálás",MESSAGE_COPIED:"Vágólapra másolva",MESSAGE_CLEARED:"A kukát sikeresen kiürítették!",MESSAGE_SONG_ADDED:"Zene a kukába helyezve",MESSAGE_SONG_REMOVED:"A dalat törölték a kukából",MESSAGE_ARTIST_ADDED:"Művész hozzáadva a kukához",MESSAGE_ARTIST_REMOVED:"Művész eltávolítva a kukából",BACKUP_SAVE_SUCCESS:"A biztonsági mentés sikeresen elmentve.",BACKUP_SAVE_FAILED:"Nem sikerült menteni a biztonsági másolatot, próbálja meg a kukában lévő tartalmat a vágólapra másolni, és manuálisan készíteni egy biztonsági másolatot.",BACKUP_RESTORE_SUCCESS:"A biztonsági mentés sikeresen visszaállítva.",BACKUP_FILE_READ_FAILED:"Nem sikerült beolvasni a fájlt, kérjük, győződjön meg róla, hogy érvényes JSON fájl.",BACKUP_SUGGESTED_FILENAME:"spicetify-kuka.json",SETTINGS_TITLE:"Kuka+ beállítások",SETTINGS_OPTIONS:"Beállítások",SETTINGS_FEATURES:"Jellemzők",SETTINGS_LOCAL_STORAGE:"Helyi tárhely",SETTINGS_ENABLED:"Engedélyezve",SETTINGS_SHOW_WIDGET:"Widget ikon megjelenítése",SETTINGS_AUTOPLAY:"Automatikus lejátszás indításkor",SETTINGS_QUEUE_TRASHBIN:"Kukás sor engedélyezése",SETTINGS_TRACKLIST_TRASHBIN:"Engedélyezze a lejátszási lista-kuka funkciót",SETTINGS_PLAYLIST_MONITOR:"Lejátszáslista-figyelő",ITEMS_TITLE:"Kuka+ elemek",ITEMS_EMPTY_SONGS:"<strong>Nincsenek törölt dalok!</strong><br/>A kukába helyezett dalok itt jelennek meg.",ITEMS_EMPTY_ARTISTS:"<strong>Nincsenek törölt előadók!</strong><br/>Az előadók, akiket a kukába helyezel, itt fognak megjelenni.",ITEMS_TAB_SONGS:"Dalok",ITEMS_TAB_ARTISTS:"Művészek",ITEMS_LOADED_COUNT:"{{loaded}} / {{total}} {{type}} betöltve",DESCRIPTION_COPY:"Minden elem másolása a törölt elemek gyűjtőjéből a vágólapra.",DESCRIPTION_EXPORT:"Minden elem mentése a törölt elemek között egy .json fájlba.",DESCRIPTION_IMPORT:"Az összes elem felülírása a kukában .json fájllal.",DESCRIPTION_CLEAR:"Az összes elem törlése a kukából (nem vonható vissza).",ITEMS_EMPTY_SONGS_TITLE:"Nincsenek törölt dalok!",ITEMS_EMPTY_ARTISTS_TITLE:"Nem kidobott művészek!",DESCRIPTION_SETTINGS_ENABLED:"Főkapcsoló a Kuka+ összes funkciójának engedélyezéséhez vagy letiltásához",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Kuka ikon megjelenítése a lejátszás sávban a jelenleg játszó szám mellett gyors hozzáférés érdekében",DESCRIPTION_SETTINGS_AUTOPLAY:"Automatikus zenelejátszás, amikor a Spotify megnyílik vagy a bővítmény betöltődik",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Kukára dobás ikonok hozzáadása az előre beütemezett számok mellé könnyű kezelésért",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Kukával jelölje meg a számokat az album- és lejátszáslistanézetekben a gyors szűréshez",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatikus helyreállítás a Spotify lejátszásának hibáiból az utolsó lejátszólista folytatásával",SETTINGS_SKIP_TRASHED_TRACKS:"Kihagyás törölt számoknál",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"A törölt számok automatikus kihagyása és a következő engedélyezett szám keresése lejátszás közben",SETTINGS_AUTO_CLEAN_QUEUE:"Automatikus tisztítási sor",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"A törölt számok automatikus eltávolítása a Smart Shuffle-listáról",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Kuka a következő gyorsbillentyűn",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Az aktuális szám automatikus törlése a Ctrl+Jobbra billentyűkombináció használatakor a következő számra ugráshoz",SETTINGS_REMOTE_CONTROL:"Távirányító",SETTINGS_REMOTE_TOGGLE:"Távoli kapcsoló engedélyezése",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Kétszeres érintés a lejátszás/szünet gombra a mobilról a távoli átugrás be- és kikapcsolásához. Az átugrott szám megerősíti a beállítást.",SETTINGS_REMOTE_SKIPPING:"Távoli kihagyás aktív",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Ha engedélyezve van, a kihagyás a kukában akkor is működik, ha egy másik eszközről (például mobilról) vezéreljük a Spotifyot",MESSAGE_REMOTE_SKIPPING_ENABLED:"Távoli kihagyás engedélyezve",MESSAGE_REMOTE_SKIPPING_DISABLED:"Távoli kihagyás letiltva",MESSAGE_SONG_ADDED_REMOTE:"Dal törölve távolról",SETTINGS_TRASH_VIA_LIKE:"Szemét Like-on keresztül",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Mint egy dalt, amit a telefonról a kukába küld. Automatikusan visszavonja a kedvelést, és átugrik a következő számra.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var $t=K((_S,fu)=>{fu.exports={TRASHBIN_NAME:"Tempat Sampah+",ACTION_THROW:"Masukkan ke Tempat Sampah",ACTION_UNTHROW:"Hapus dari Tempat Sampah",ACTION_CLEAR:"Jelas",ACTION_COPY:"Salin",ACTION_EXPORT:"Ekspor",ACTION_IMPORT:"Impor",MESSAGE_COPIED:"Disalin ke clipboard",MESSAGE_CLEARED:"Tempat sampah berhasil dikosongkan!",MESSAGE_SONG_ADDED:"Lagu ditambahkan ke tempat sampah",MESSAGE_SONG_REMOVED:"Lagu dihapus dari tempat sampah",MESSAGE_ARTIST_ADDED:"Artis ditambahkan ke tempat sampah",MESSAGE_ARTIST_REMOVED:"Artis dihapus dari tempat sampah",BACKUP_SAVE_SUCCESS:"Cadangan berhasil disimpan.",BACKUP_SAVE_FAILED:"Gagal menyimpan cadangan, coba salin isi tempat sampah ke clipboard dan buat cadangan secara manual.",BACKUP_RESTORE_SUCCESS:"Cadangan berhasil dipulihkan.",BACKUP_FILE_READ_FAILED:"Gagal membaca file, pastikan file tersebut adalah file JSON yang valid.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Pengaturan Trashbin+",SETTINGS_OPTIONS:"Opsi",SETTINGS_FEATURES:"Fitur",SETTINGS_LOCAL_STORAGE:"Penyimpanan Lokal",SETTINGS_ENABLED:"Diaktifkan",SETTINGS_SHOW_WIDGET:"Tampilkan Ikon Widget",SETTINGS_AUTOPLAY:"Putar otomatis saat Mulai",SETTINGS_QUEUE_TRASHBIN:"Aktifkan Tempat Sampah Antrian",SETTINGS_TRACKLIST_TRASHBIN:"Aktifkan Tempat Sampah Daftar Lacak",SETTINGS_PLAYLIST_MONITOR:"Pemantau Daftar Putar",ITEMS_TITLE:"Item Tempat Sampah+",ITEMS_EMPTY_SONGS:"<strong>Tidak ada lagu yang dihapus!</strong><br/>Lagu yang Anda tambahkan ke tempat sampah akan muncul di sini.",ITEMS_EMPTY_ARTISTS:"<strong>Tidak ada artis yang dihapus!</strong><br/>Artis yang Anda tambahkan ke tempat sampah akan muncul di sini.",ITEMS_TAB_SONGS:"Lagu-lagu",ITEMS_TAB_ARTISTS:"Artis",ITEMS_LOADED_COUNT:"{{loaded}} dari {{total}} {{type}} telah dimuat",DESCRIPTION_COPY:"Salin semua item di tempat sampah ke papan klip.",DESCRIPTION_EXPORT:"Simpan semua item di tempat sampah ke file .json.",DESCRIPTION_IMPORT:"Timpa semua item di tempat sampah melalui file .json.",DESCRIPTION_CLEAR:"Hapus semua item dari tempat sampah (tidak dapat dikembalikan).",ITEMS_EMPTY_SONGS_TITLE:"Tidak ada lagu yang dihapus!",ITEMS_EMPTY_ARTISTS_TITLE:"Tidak ada seniman yang dibuang!",DESCRIPTION_SETTINGS_ENABLED:"Tombol utama untuk mengaktifkan atau menonaktifkan semua fungsi Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Tampilkan ikon tempat sampah di bilah pemutaran di sebelah trek yang sedang diputar untuk akses cepat",DESCRIPTION_SETTINGS_AUTOPLAY:"Secara otomatis memutar musik saat Spotify dibuka atau ekstensi dimuat",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Tambahkan ikon tempat sampah di sebelah setiap lagu dalam antrian Anda yang akan datang untuk memudahkan pengelolaan",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Tambahkan ikon tempat sampah di sebelah lagu dalam tampilan album dan daftar putar untuk penyaringan cepat",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Pulihkan secara otomatis dari gangguan pemutaran Spotify dengan melanjutkan daftar putar terakhir Anda",SETTINGS_SKIP_TRASHED_TRACKS:"Lewati Lagu yang Dihapus",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Melewati lagu yang dihapus secara otomatis dan menemukan trek berikutnya yang diizinkan selama pemutaran",SETTINGS_AUTO_CLEAN_QUEUE:"Antrian Pembersihan Otomatis",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Hapus secara otomatis lagu yang dihapus dari antrian Smart Shuffle Anda",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Sampah pada Tombol Pintas Berikutnya",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Hapus otomatis lagu saat ini saat menggunakan pintasan keyboard Ctrl+Kanan untuk melewati ke lagu berikutnya",SETTINGS_REMOTE_CONTROL:"Kontrol Jarak Jauh",SETTINGS_REMOTE_TOGGLE:"Aktifkan Sakelar Jarak Jauh",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Ketuk dua kali putar/jeda dari perangkat seluler untuk mengaktifkan/nonaktifkan lewatan jarak jauh. Melewatkan lagu mengonfirmasi pengaktifan.",SETTINGS_REMOTE_SKIPPING:"Melewati dari Jarak Jauh Aktif",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Ketika diaktifkan, fitur melewatkan sampah tetap berfungsi meskipun mengendalikan Spotify dari perangkat lain (misalnya, ponsel)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Melompati jarak jauh diaktifkan",MESSAGE_REMOTE_SKIPPING_DISABLED:"Melompat jarak jauh dinonaktifkan",MESSAGE_SONG_ADDED_REMOTE:"Lagu dihapus melalui jarak jauh",SETTINGS_TRASH_VIA_LIKE:"Sampah melalui Suka",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Seperti lagu dari ponsel yang dibuang. Secara otomatis menghapus suka dan melompat ke lagu berikutnya.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var a8=K((BS,xu)=>{xu.exports={TRASHBIN_NAME:"Ruslið+",ACTION_THROW:"Setja í ruslið",ACTION_UNTHROW:"Fjarlægja úr rusli",ACTION_CLEAR:"Klár",ACTION_COPY:"Afrita",ACTION_EXPORT:"Útflutningur",ACTION_IMPORT:"Framleiðsla",MESSAGE_COPIED:"Afritað í klippispjald",MESSAGE_CLEARED:"Pappírskarfan tæmd!",MESSAGE_SONG_ADDED:"Lag bætt í ruslið",MESSAGE_SONG_REMOVED:"Lag fjarlægt úr rusli",MESSAGE_ARTIST_ADDED:"Listamaður bættur við ruslið",MESSAGE_ARTIST_REMOVED:"Listamaður fjarlægður úr ruslaföllu",BACKUP_SAVE_SUCCESS:"Afrit vistað.",BACKUP_SAVE_FAILED:"Gat ekki vistað öryggisafrit, reyndu að afrita innihald ruslafótsins á klippispjald og búa til öryggisafrit handvirkt.",BACKUP_RESTORE_SUCCESS:"Afurðarupplýsingar endurheimtar.",BACKUP_FILE_READ_FAILED:"Gat ekki lesið skrá, vinsamlegast gangið úr skugga um að hún sé gild JSON skrá.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Stillingar fyrir rusli+",SETTINGS_OPTIONS:"Valkostir",SETTINGS_FEATURES:"Eiginleikar",SETTINGS_LOCAL_STORAGE:"Staðbundin geymsla",SETTINGS_ENABLED:"Virkjað",SETTINGS_SHOW_WIDGET:"Sýna stikuhlutatákn",SETTINGS_AUTOPLAY:"Sjálfvirk spilun við rás",SETTINGS_QUEUE_TRASHBIN:"Virkja biðröð rusliðkarans",SETTINGS_TRACKLIST_TRASHBIN:"Virkja ruslið fyrir lagalista",SETTINGS_PLAYLIST_MONITOR:"Spilunarlista fylgjendur",ITEMS_TITLE:"Ruslið+ Vörur",ITEMS_EMPTY_SONGS:"<strong>Engar ruslóður!</strong><br/>Lög sem þú bætir við rusliðkassann birtast hér.",ITEMS_EMPTY_ARTISTS:"<strong>Engir ruslaðir listamenn!</strong><br/>Listamenn sem þú bætir við rusliðkassann birtast hér.",ITEMS_TAB_SONGS:"Lög",ITEMS_TAB_ARTISTS:"Listarar",ITEMS_LOADED_COUNT:"{{loaded}} af {{total}} {{type}} hlaðið",DESCRIPTION_COPY:"Afritaðu öll atriði í ruslið til klippispjalds.",DESCRIPTION_EXPORT:"Vista öll föll í ruslið í .json skrá.",DESCRIPTION_IMPORT:"Skrifa yfir öllum atriðum í rusliði með .json skrá.",DESCRIPTION_CLEAR:"Hreinsa allar atriði úr rusli (getur ekki verið afturkallað).",ITEMS_EMPTY_SONGS_TITLE:"Engar ruslóttar lög!",ITEMS_EMPTY_ARTISTS_TITLE:"Engir ruslsmunir!",DESCRIPTION_SETTINGS_ENABLED:"Aðalkippa til að virkja eða gera óvirkt allar aukin virkni ruslafóts",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Birta ruslpípu í spilunarstikunni við hliðina við núverandi lag fyrir fljótan aðgang",DESCRIPTION_SETTINGS_AUTOPLAY:"Byrja að spila tónlist sjálfkrafa þegar Spotify er opnað eða viðbótin hleðst",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Bættu við ruslpunktum við hvern lagalista í komandi röðinni til auðveldri stjórnunar",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Bæta við ruslpunktum við lag í úrvali og spilunarlistum fyrir fljóta síun",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Endurlæs síðustu spilunarlista sjálfkrafa til að endurheimta eftir bil í Spotify spilun",SETTINGS_SKIP_TRASHED_TRACKS:"Hoppa yfir ruslslóðir",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Sleppa sjálfkrafa eyddum lögu og finna næsta leyfða lagalista í spilun",SETTINGS_AUTO_CLEAN_QUEUE:"Hreinsunarað rafbíla",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Fjarlægja lag sem er í rusli sjálfkrafa úr Smart Shuffle biðröðinni",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Rusl á næsta flýtileið lyklaborðs",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Fleyg núverandi lagi sjálfkrafa þegar notað er Ctrl+Hægri sniðmát til að hoppa á næsta lag",SETTINGS_REMOTE_CONTROL:"Fjarstýring",SETTINGS_REMOTE_TOGGLE:"Virkja fjarstýringu",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Tvísmelltu á spilun/í bið til að kveikja/slökkva á fjarstýringu fyrir sleppingu á lagalista. Slepping á lag staðfestir valmöguleikann.",SETTINGS_REMOTE_SKIPPING:"Fjartengt slepping virkt",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Þegar virkt, virkar ruslið-perlan erfiðleikar jafnvel þegar Spotify er stjórnað frá öðru tæki (t.d. síma)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Fjartengt sleppingu virkt",MESSAGE_REMOTE_SKIPPING_DISABLED:"Fjarvirkt sleppingu óvirkjað",MESSAGE_SONG_ADDED_REMOTE:"Lag eytt á fjarstýringu",SETTINGS_TRASH_VIA_LIKE:"Rusl í gegnum Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Eins og lag frá síma til að eyða því. Felur sjálfkrafa og hoppar á næsta lag.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var t8=K((zS,Cu)=>{Cu.exports={TRASHBIN_NAME:"Cestino+",ACTION_THROW:"Metti nel Cestino",ACTION_UNTHROW:"Rimuovi dal Cestino",ACTION_CLEAR:"Chiaro",ACTION_COPY:"Copia",ACTION_EXPORT:"Esporta",ACTION_IMPORT:"Importa",MESSAGE_COPIED:"Copiato negli appunti",MESSAGE_CLEARED:"Cestino svuotato con successo!",MESSAGE_SONG_ADDED:"Canzone aggiunta al cestino",MESSAGE_SONG_REMOVED:"Canzone rimossa dal cestino",MESSAGE_ARTIST_ADDED:"Artista aggiunto al cestino",MESSAGE_ARTIST_REMOVED:"Artista rimosso dal cestino",BACKUP_SAVE_SUCCESS:"Backup salvato con successo.",BACKUP_SAVE_FAILED:"Impossibile salvare il backup, prova a copiare il contenuto del cestino negli appunti e crea un backup manualmente.",BACKUP_RESTORE_SUCCESS:"Backup ripristinato con successo.",BACKUP_FILE_READ_FAILED:"Impossibile leggere il file, assicurarsi che sia un file JSON valido.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Impostazioni del Cestino+",SETTINGS_OPTIONS:"Opzioni",SETTINGS_FEATURES:"Caratteristiche",SETTINGS_LOCAL_STORAGE:"Archiviazione locale",SETTINGS_ENABLED:"Abilitato",SETTINGS_SHOW_WIDGET:"Mostra icona widget",SETTINGS_AUTOPLAY:"Riproduzione automatica all'avvio",SETTINGS_QUEUE_TRASHBIN:"Abilita Cestino della Coda",SETTINGS_TRACKLIST_TRASHBIN:"Abilita Cestino della Playlist",SETTINGS_PLAYLIST_MONITOR:"Monitor della playlist",ITEMS_TITLE:"Elementi del Cestino+",ITEMS_EMPTY_SONGS:"<strong>Nessuna canzone nel cestino!</strong><br/>Le canzoni che aggiungi nel cestino appariranno qui.",ITEMS_EMPTY_ARTISTS:"<strong>Nessun artista nel cestino!</strong><br/>Gli artisti che aggiungi al cestino appariranno qui.",ITEMS_TAB_SONGS:"Canzoni",ITEMS_TAB_ARTISTS:"Artisti",ITEMS_LOADED_COUNT:"{{loaded}} di {{total}} {{type}} caricati",DESCRIPTION_COPY:"Copia tutti gli elementi nel cestino negli appunti.",DESCRIPTION_EXPORT:"Salva tutti gli elementi nel cestino in un file .json.",DESCRIPTION_IMPORT:"Sovrascrivi tutti gli elementi nel cestino tramite file .json.",DESCRIPTION_CLEAR:"Elimina tutti gli elementi dal cestino (operazione non reversibile).",ITEMS_EMPTY_SONGS_TITLE:"Nessuna canzone cestinata!",ITEMS_EMPTY_ARTISTS_TITLE:"Nessun artista scartato!",DESCRIPTION_SETTINGS_ENABLED:"Interruttore principale per abilitare o disabilitare tutte le funzionalità di Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Visualizza un'icona del cestino nella barra di riproduzione accanto alla traccia in riproduzione per un accesso rapido",DESCRIPTION_SETTINGS_AUTOPLAY:"Avvia automaticamente la riproduzione della musica quando Spotify si apre o quando l'estensione viene caricata",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Aggiungi icone del cestino accanto a ogni canzone nella tua coda imminente per una gestione più semplice",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Aggiungi icone del cestino accanto alle canzoni nelle visualizzazioni di album e playlist per un filtraggio rapido",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recupera automaticamente dai problemi di riproduzione di Spotify riprendendo l'ultima playlist",SETTINGS_SKIP_TRASHED_TRACKS:"Ignora le tracce eliminate",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Salta automaticamente le canzoni eliminate e trova la traccia successiva consentita durante la riproduzione",SETTINGS_AUTO_CLEAN_QUEUE:"Coda pulizia automatica",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Rimuovi automaticamente le canzoni eliminate dalla tua coda di riproduzione casuale intelligente",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Cestino sul prossimo tasto di scelta rapida",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Sposta automaticamente la canzone corrente nel cestino quando si utilizza la scorciatoia da tastiera Ctrl+Destra per passare alla traccia successiva",SETTINGS_REMOTE_CONTROL:"Controllo remoto",SETTINGS_REMOTE_TOGGLE:"Abilita interruttore remoto",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Tocca due volte riproduci/pausa dal dispositivo mobile per attivare/disattivare il salto remoto delle tracce. Il salto di una traccia conferma l'attivazione/disattivazione.",SETTINGS_REMOTE_SKIPPING:"Salto remoto attivo",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Quando abilitata, la funzione di saltare i brani funziona anche quando si controlla Spotify da un altro dispositivo (ad esempio, da un cellulare)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Salto remoto abilitato",MESSAGE_REMOTE_SKIPPING_DISABLED:"Salto remoto disabilitato",MESSAGE_SONG_ADDED_REMOTE:"Canzone eliminata a distanza",SETTINGS_TRASH_VIA_LIKE:"Rifiuti tramite Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Come una canzone da mobile a cestinarla. Annulla automaticamente il like e passa alla traccia successiva.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var r8=K((LS,_u)=>{_u.exports={TRASHBIN_NAME:"ゴミ箱+",ACTION_THROW:"ゴミ箱に入れる",ACTION_UNTHROW:"ゴミ箱から削除",ACTION_CLEAR:"クリア",ACTION_COPY:"コピー",ACTION_EXPORT:"エクスポート",ACTION_IMPORT:"インポート",MESSAGE_COPIED:"クリップボードにコピーされました",MESSAGE_CLEARED:"ゴミ箱を正常に空にしました！",MESSAGE_SONG_ADDED:"曲がゴミ箱に追加されました",MESSAGE_SONG_REMOVED:"ゴミ箱から曲を削除しました",MESSAGE_ARTIST_ADDED:"アーティストがゴミ箱に追加されました",MESSAGE_ARTIST_REMOVED:"アーティストがゴミ箱から削除されました",BACKUP_SAVE_SUCCESS:"バックアップが正常に保存されました。",BACKUP_SAVE_FAILED:"バックアップの保存に失敗しました。ごみ箱の内容をクリップボードにコピーして、手動でバックアップを作成してみてください。",BACKUP_RESTORE_SUCCESS:"バックアップの復元が正常に完了しました。",BACKUP_FILE_READ_FAILED:"ファイルの読み取りに失敗しました。有効なJSONファイルであることを確認してください。",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ごみ箱+ 設定",SETTINGS_OPTIONS:"オプション",SETTINGS_FEATURES:"機能",SETTINGS_LOCAL_STORAGE:"ローカルストレージ",SETTINGS_ENABLED:"有効",SETTINGS_SHOW_WIDGET:"ウィジェットアイコンを表示",SETTINGS_AUTOPLAY:"起動時に自動再生",SETTINGS_QUEUE_TRASHBIN:"キューごみ箱を有効にする",SETTINGS_TRACKLIST_TRASHBIN:"トラックリストのゴミ箱を有効にする",SETTINGS_PLAYLIST_MONITOR:"プレイリストモニター",ITEMS_TITLE:"ゴミ箱+ アイテム",ITEMS_EMPTY_SONGS:"<strong>ゴミ箱の曲はありません！</strong><br/>ゴミ箱に入れた曲がここに表示されます。",ITEMS_EMPTY_ARTISTS:"<strong>ゴミ箱のアーティストはありません！</strong><br/>ゴミ箱に追加したアーティストはここに表示されます。",ITEMS_TAB_SONGS:"曲",ITEMS_TAB_ARTISTS:"アーティスト",ITEMS_LOADED_COUNT:"{{total}} 中 {{loaded}} 個の{{type}}を読み込みました",DESCRIPTION_COPY:"ゴミ箱内のすべてのアイテムをクリップボードにコピーします。",DESCRIPTION_EXPORT:"ゴミ箱内のすべてのアイテムを.jsonファイルに保存します。",DESCRIPTION_IMPORT:"ゴミ箱内のすべての項目を.jsonファイルで上書きします。",DESCRIPTION_CLEAR:"ゴミ箱からすべてのアイテムを完全に削除します（元に戻せません）。",ITEMS_EMPTY_SONGS_TITLE:"削除された曲はありません！",ITEMS_EMPTY_ARTISTS_TITLE:"捨てられたアーティストはいらない！",DESCRIPTION_SETTINGS_ENABLED:"すべてのゴミ箱+機能を有効または無効にするメイントグル",DESCRIPTION_SETTINGS_SHOW_WIDGET:"再生中のトラックの横にある再生バーにごみ箱アイコンを表示して、すぐにアクセスできるようにします",DESCRIPTION_SETTINGS_AUTOPLAY:"Spotifyの起動時または拡張機能の読み込み時に自動的に音楽を再生開始します",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"アップカミングキューの各曲の横にゴミ箱アイコンを追加して、簡単に管理できるようにします",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"アルバムビューとプレイリストビューの曲の横にゴミ箱アイコンを追加して、素早いフィルタリングを可能にします",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Spotifyの再生エラーを自動的に回復し、最後のプレイリストを再開します",SETTINGS_SKIP_TRASHED_TRACKS:"削除済みトラックをスキップ",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"削除された曲を自動的にスキップし、再生中に次に許可されたトラックを探します",SETTINGS_AUTO_CLEAN_QUEUE:"自動クリーンキュー",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"スマートシャッフルキューからゴミ箱に入った曲を自動的に削除する",SETTINGS_TRASH_ON_NEXT_HOTKEY:"次のホットキーでゴミ箱に移動",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Ctrl+右キーのショートカットを使用して次のトラックにスキップする際、現在の曲を自動的にゴミ箱に移動します",SETTINGS_REMOTE_CONTROL:"リモートコントロール",SETTINGS_REMOTE_TOGGLE:"リモート切り替えを有効にする",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"モバイル端末で再生/一時停止を2回タップして、リモートスキップのオン/オフを切り替えます。曲のスキップで切り替えが確定します。",SETTINGS_REMOTE_SKIPPING:"リモートスキップが有効です",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"有効にすると、他のデバイス（例：スマートフォン）からSpotifyを操作している場合でも、ゴミ箱スキップ機能が動作します",MESSAGE_REMOTE_SKIPPING_ENABLED:"リモートスキップが有効になっています",MESSAGE_REMOTE_SKIPPING_DISABLED:"リモートスキップは無効です",MESSAGE_SONG_ADDED_REMOTE:"リモートで楽曲が破壊された",SETTINGS_TRASH_VIA_LIKE:"いいね経由でゴミ",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"携帯からゴミ箱へと流れる曲のように。自動で「いいね」を解除し、次の曲にスキップします。",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var l8=K((HS,Bu)=>{Bu.exports={TRASHBIN_NAME:"ಟ್ರಾಶ್‌ಬಿನ್+",ACTION_THROW:"ಅಪಾಯಿಕ ಬುಟ್ಟಿಯಲ್ಲಿ ಇಡಿ",ACTION_UNTHROW:"ಅಳಿಸಿದವುಗಳಿಂದ ತೆಗೆದುಹಾಕಿ",ACTION_CLEAR:"ಸ್ಪಷ್ಟವಾಗಿ",ACTION_COPY:"ಪ್ರತಿರೂಪ",ACTION_EXPORT:"ರಫ್ತು",ACTION_IMPORT:"ಆಮದು",MESSAGE_COPIED:"ಕ್ಲಿಪ್ಬೋರ್ಡ್‌ಗೆ ನಕಲಿಸಲಾಗಿದೆ",MESSAGE_CLEARED:"ಅಳಿಸಿಹಾಕುವ ಬುಟ್ಟಿ ಯಶಸ್ವಿಯಾಗಿ ಖಾಲಿ ಮಾಡಲಾಯಿತು!",MESSAGE_SONG_ADDED:"ಹಾಡನ್ನು ಅಸ್ತಿಪಂಜರಕ್ಕೆ ಸೇರಿಸಲಾಗಿದೆ",MESSAGE_SONG_REMOVED:"ಅಳಿಸಿಹಾಕಿದ ಫೈಲ್‌ಗಳ ಪೆಟ್ಟಿಗೆಯಿಂದ ಹಾಡನ್ನು ತೆಗೆದುಹಾಕಲಾಗಿದೆ",MESSAGE_ARTIST_ADDED:"ಕಲಾವಿದನನ್ನು ಅಸ್ತಿಪಂಜರಕ್ಕೆ ಸೇರಿಸಲಾಗಿದೆ",MESSAGE_ARTIST_REMOVED:"ಕಸದ ಬುಟ್ಟಿಯಿಂದ ಕಲಾವಿದನನ್ನು ತೆಗೆದುಹಾಕಲಾಗಿದೆ",BACKUP_SAVE_SUCCESS:"ಬ್ಯಾಕಪ್ ಯಶಸ್ವಿಯಾಗಿ ಉಳಿಸಲಾಗಿದೆ.",BACKUP_SAVE_FAILED:"ಬ್ಯಾಕಪ್ ಅನ್ನು ಉಳಿಸಲು ವಿಫಲವಾಯಿತು, ಕಸದ ಬುಟ್ಟಿಯ ವಿಷಯಗಳನ್ನು ಕ್ಲಿಪ್‌ಬೋರ್ಡ್‌ಗೆ ನಕಲಿಸಿ ಮತ್ತು ಕೈಯಾರೆ ಬ್ಯಾಕಪ್ ಅನ್ನು ರಚಿಸಲು ಪ್ರಯತ್ನಿಸಿ.",BACKUP_RESTORE_SUCCESS:"ಬ್ಯಾಕಪ್ ಯಶಸ್ವಿಯಾಗಿ ಮರುಸ್ಥಾಪಿಸಲಾಗಿದೆ.",BACKUP_FILE_READ_FAILED:"ಫೈಲ್ ಅನ್ನು ಓದಲು ವಿಫಲವಾಯಿತು, ದಯವಿಟ್ಟು ಅದು ಮಾನ್ಯ JSON ಫೈಲ್ ಆಗಿದೆಯೇ ಎಂದು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳಿ.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ಟ್ರಾಶ್‌ಬಿನ್+ ಸೆಟ್ಟಿಂಗ್ಸ್",SETTINGS_OPTIONS:"ಆಯ್ಕೆಗಳು",SETTINGS_FEATURES:"ವೈಶಿಷ್ಟ್ಯಗಳು",SETTINGS_LOCAL_STORAGE:"ಸ್ಥಳೀಯ ಸಂಗ್ರಹಣೆ",SETTINGS_ENABLED:"ಸಕ್ರಿಯಗೊಳಿಸಲಾಗಿದೆ",SETTINGS_SHOW_WIDGET:"ವಿಜೆಟ್ ಐಕಾನ್ ಅನ್ನು ತೋರಿಸಿ",SETTINGS_AUTOPLAY:"ಪ್ರಾರಂಭದಲ್ಲಿ ಆಟೋಪ್ಲೇ ಮಾಡು",SETTINGS_QUEUE_TRASHBIN:"ಕ್ಯೂ ಟ್ರಾಶ್‌ಬಿನ್ ಅನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಿ",SETTINGS_TRACKLIST_TRASHBIN:"ಟ್ರಾಕ್‌ಲಿಸ್ಟ್ ಕಸದ ಬುಟ್ಟಿಯನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಿ",SETTINGS_PLAYLIST_MONITOR:"ಪ್ಲೇಲಿಸ್ಟ್ ಮಾನಿಟರ್",ITEMS_TITLE:"ಟ್ರಾಶ್‌ಬಿನ್+ ಐಟಂಗಳು",ITEMS_EMPTY_SONGS:"<strong>ಅಳಿಸಿದ ಹಾಡುಗಳಿಲ್ಲ!</strong><br/>ನೀವು ಅಳಿಸುವ ಹಾಡುಗಳು ಇಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುತ್ತವೆ.",ITEMS_EMPTY_ARTISTS:"<strong>ಅಳಿಸಿದ ಕಲಾವಿದರು ಇಲ್ಲ!</strong><br/>ನೀವು ಅಳಿಸುವ ಕಲಾವಿದರು ಇಲ್ಲಿ ಕಾಣಿಸಿಕೊಳ್ಳುತ್ತಾರೆ.",ITEMS_TAB_SONGS:"ಹಾಡುಗಳು",ITEMS_TAB_ARTISTS:"ಕಲಾವಿದರು",ITEMS_LOADED_COUNT:"{{total}} ರ {{type}} ಗಳಲ್ಲಿ {{loaded}} ಲೋಡ್ ಆಗಿದೆ",DESCRIPTION_COPY:"ಅಳಿಸಿದ ಫೈಲ್‌ಗಳ ಪೀಠಿಕೆಯಲ್ಲಿನ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು ಕ್ಲಿಪ್‌ಬೋರ್ಡ್‌ಗೆ ನಕಲಿಸಿ.",DESCRIPTION_EXPORT:"ಅನಾವಶ್ಯಕ ಫೈಲ್‌ಗಳಲ್ಲಿನ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು .json ಫೈಲ್‌ಗೆ ಉಳಿಸಿ.",DESCRIPTION_IMPORT:"ಜೆಸಾನ್ ಕಡತದ ಮೂಲಕ ಅಳಿಸಿದ ಅಂಶಗಳನ್ನು ಬದಲಾಯಿಸಿ.",DESCRIPTION_CLEAR:"ಅಳಿಸಿದ ಫೈಲ್‌ಗಳ ಪೆಟ್ಟಿಗೆಯಿಂದ ಎಲ್ಲಾ ಅಂಶಗಳನ್ನು ತೆಗೆದುಹಾಕಿ (ಹಿಂತಿರುಗಿಸಲಾಗುವುದಿಲ್ಲ).",ITEMS_EMPTY_SONGS_TITLE:"ಯಾವುದೇ ತ್ರಾಶ್ ಮಾಡಿದ ಹಾಡುಗಳಿಲ್ಲ!",ITEMS_EMPTY_ARTISTS_TITLE:"ಯಾವುದೇ ಕಸದ ಕಲಾವಿದರಿಲ್ಲ!",DESCRIPTION_SETTINGS_ENABLED:"ಟ್ರಾಶ್‌ಬಿನ್+ ಕಾರ್ಯಗಳನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಲು ಅಥವಾ ನಿಷ್ಕ್ರಿಯಗೊಳಿಸಲು ಮಾಸ್ಟರ್ ಟಾಗಲ್",DESCRIPTION_SETTINGS_SHOW_WIDGET:"ಪ್ರಸ್ತುತ ವಹಿಸುತ್ತಿರುವ ಟ್ರಾಕ್ ಬದಿಯಲ್ಲಿ ವಾಡಿಕೆ ಪಟ್ಟಿಯಲ್ಲಿ ತ್ವರಿತ ಪ್ರವೇಶಕ್ಕಾಗಿ ಅಪಾಯಿಕ ಚಿಹ್ನೆಯನ್ನು ಪ್ರದರ್ಶಿಸಿ",DESCRIPTION_SETTINGS_AUTOPLAY:"ಸ್ಪಾಟಿಫೈ ತೆರೆಯುವಾಗ ಅಥವಾ ವಿಸ್ತರಣೆ ಲೋಡ್ ಆಗುವಾಗ ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಸಂಗೀತವನ್ನು ಪ್ಲೇ ಮಾಡಲು ಪ್ರಾರಂಭಿಸಿ",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"ನಿಮ್ಮ ಬರುವ ಸಂಗೀತದ ಸರದಿಯಲ್ಲಿರುವ ಪ್ರತಿಯೊಂದು ಹಾಡಿನ ಪಕ್ಕೆ ಅಸ್ತಿಕೆ ಐಕಾನ್‌ಗಳನ್ನು ಸುಲಭ ನಿರ್ವಹಣೆಗಾಗಿ ಸೇರಿಸಿ",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"ಆಲ್ಬಂ ಮತ್ತು ಪ್ಲೇಪಟ್ಟಿ ವೀಕ್ಷಣೆಗಳಲ್ಲಿ ಹಾಡುಗಳ ಪಕ್ಕದಲ್ಲಿ ಕಸದ ಐಕಾನ್‌ಗಳನ್ನು ಸೇರಿಸಿ ತ್ವರಿತ ಫಿಲ್ಟರಿಂಗ್ ಮಾಡಿ",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"ನಿಮ್ಮ ಕೊನೆಯ ಪ್ಲೇಲಿಸ್ಟ್ ಅನ್ನು ಮತ್ತೆ ಪ್ರಾರಂಭಿಸುವ ಮೂಲಕ ಸ್ಪಾಟಿಫೈ ಪ್ಲೇಬ್ಯಾಕ್ ತೊಂದರೆಗಳಿಂದ ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಚೇತರಿಸಿಕೊಳ್ಳಿ",SETTINGS_SKIP_TRASHED_TRACKS:"ಅಳಿಸಿಹಾಕಿದ ಟ್ರ್ಯಾಕ್‌ಗಳನ್ನು ಬಿಟ್ಟುಬಿಡಿ",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಅಳಿಸಿಹಾಕಿದ ಹಾಡುಗಳನ್ನು ತಪ್ಪಿಸಿ ಮತ್ತು ಪ್ಲೇಬ್ಯಾಕ್ ಸಮಯದಲ್ಲಿ ಮುಂದಿನ ಅನುಮತಿಸಲಾದ ಟ್ರ್ಯಾಕ್ ಅನ್ನು ಹುಡುಕಿ",SETTINGS_AUTO_CLEAN_QUEUE:"ಆಟೋ ಕ್ಲೀನ್ ಕ್ಯೂ",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"ನಿಮ್ಮ ಸ್ಮಾರ್ಟ್ ಶಫಲ್ ಸರದಿಯಿಂದ ಅಳಿಸಿಹಾಕಿದ ಹಾಡುಗಳನ್ನು ಸ್ವಯಂಚಾಲಿತವಾಗಿ ತೆಗೆದುಹಾಕಿ",SETTINGS_TRASH_ON_NEXT_HOTKEY:"ಮುಂದಿನ ಹಾಟ್‌ಕೀಗಾಗಿ ಅಪಾಯಿತ್ಯ",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Ctrl+ಬಲಕ್ಕೆ ಕೀಲಿಮಣೆ ಸಂಕ್ಷಿಪ್ತವಾಕ್ಯವನ್ನು ಬಳಸಿ ಮುಂದಿನ ಟ್ರಾಕ್‌ಗೆ ಹಾದುಹೋಗುವಾಗ ಪ್ರಸ್ತುತ ಹಾಡನ್ನು ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಅಳಿಸಿ",SETTINGS_REMOTE_CONTROL:"ರಿಮೋಟ್ ಕಂಟ್ರೋಲ್",SETTINGS_REMOTE_TOGGLE:"ದೂರದ ಟಾಗಲ್ ಅನ್ನು ಸಕ್ರಿಯಗೊಳಿಸು",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"ಮೊಬೈಲ್‌ನಿಂದ ಪ್ಲೇ/ಪಾಸ್ ಮಾಡಲು ಎರಡು ಬಾರಿ ಟ್ಯಾಪ್ ಮಾಡಿ ರಿಮೋಟ್ ಸ್ಕಿಪ್ಪಿಂಗ್ ಅನ್ನು ಆನ್/ಆಫ್ ಮಾಡಿ. ಟ್ರಾಕ್ ಸ್ಕಿಪ್ ಟಾಗಲ್ ಅನ್ನು ದೃಢೀಕರಿಸುತ್ತದೆ.",SETTINGS_REMOTE_SKIPPING:"ದೂರದ ಬೆಳಕಿನ ಚಟುವಟಿಕೆ",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"ಸಕ್ರಿಯಗೊಳಿಸಿದಾಗ, ಇನ್ನೊಂದು ಸಾಧನದಿಂದ (ಉದಾಹರಣೆಗೆ, ಮೊಬೈಲ್) ಸ್ಪಾಟಿಫೈ ಅನ್ನು ನಿಯಂತ್ರಿಸುವಾಗಲೂ ಕಸವನ್ನು ಬೈಪಾಸ್ ಮಾಡುವುದು ಕೆಲಸ ಮಾಡುತ್ತದೆ",MESSAGE_REMOTE_SKIPPING_ENABLED:"ದೂರದಲ್ಲಿರುವ ಸ್ಕಿಪ್ಪಿಂಗ್ ಸಕ್ರಿಯಗೊಳಿಸಲಾಗಿದೆ",MESSAGE_REMOTE_SKIPPING_DISABLED:"ದೂರದಲ್ಲಿರುವ ಕಿರುಹಾದು ನಿಷ್ಕ್ರಿಯಗೊಳಿಸಲಾಗಿದೆ",MESSAGE_SONG_ADDED_REMOTE:"ದೂರದಿಂದಲೇ ಹಾಡನ್ನು ನಾಶಪಡಿಸಲಾಯಿತು",SETTINGS_TRASH_VIA_LIKE:"ಲೈಕ್ ಮೂಲಕ ತ್ಯಾಜ್ಯ",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"ಮೊಬೈಲ್‌ನಿಂದ ಹಾಡಿನಂತೆ ಅದನ್ನು ತ್ಯಜಿಸಿ. ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಅನ್‌ಲೈಕ್ ಮಾಡಿ ಮುಂದಿನ ಟ್ರ್ಯಾಕ್‌ಗೆ ಹೋಗಿ.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var i8=K((VS,zu)=>{zu.exports={TRASHBIN_NAME:"쓰레기통+",ACTION_THROW:"휴지통에 넣기",ACTION_UNTHROW:"휴지통에서 제거",ACTION_CLEAR:"명확함",ACTION_COPY:"복사",ACTION_EXPORT:"내보내기",ACTION_IMPORT:"가져오기",MESSAGE_COPIED:"클립보드에 복사되었습니다",MESSAGE_CLEARED:"휴지통이 성공적으로 비워졌습니다!",MESSAGE_SONG_ADDED:"노래가 휴지통에 추가되었습니다",MESSAGE_SONG_REMOVED:"휴지통에서 곡 삭제됨",MESSAGE_ARTIST_ADDED:"아티스트가 휴지통에 추가되었습니다",MESSAGE_ARTIST_REMOVED:"아티스트가 휴지통에서 제거되었습니다",BACKUP_SAVE_SUCCESS:"백업이 성공적으로 저장되었습니다.",BACKUP_SAVE_FAILED:"백업 저장에 실패했습니다. 휴지통 내용을 클립보드에 복사하여 수동으로 백업을 생성해 보세요.",BACKUP_RESTORE_SUCCESS:"백업이 성공적으로 복원되었습니다.",BACKUP_FILE_READ_FAILED:"파일을 읽지 못했습니다. 올바른 JSON 파일인지 확인해 주세요.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"쓰레기통+ 설정",SETTINGS_OPTIONS:"옵션",SETTINGS_FEATURES:"기능",SETTINGS_LOCAL_STORAGE:"로컬 스토리지",SETTINGS_ENABLED:"활성화됨",SETTINGS_SHOW_WIDGET:"위젯 아이콘 표시",SETTINGS_AUTOPLAY:"시작 시 자동 재생",SETTINGS_QUEUE_TRASHBIN:"큐 휴지통 사용 가능",SETTINGS_TRACKLIST_TRASHBIN:"트랙리스트 휴지통 활성화",SETTINGS_PLAYLIST_MONITOR:"재생 목록 모니터",ITEMS_TITLE:"쓰레기통+ 항목",ITEMS_EMPTY_SONGS:"<strong>휴지통에 있는 곡 없음!</strong><br/>휴지통에 추가한 곡들이 여기에 표시됩니다.",ITEMS_EMPTY_ARTISTS:"<strong>휴지통에 있는 아티스트 없음!</strong><br/>휴지통에 추가한 아티스트가 여기에 표시됩니다.",ITEMS_TAB_SONGS:"노래",ITEMS_TAB_ARTISTS:"아티스트",ITEMS_LOADED_COUNT:"{{total}}개 중 {{loaded}}개의 {{type}}이(가) 로드되었습니다",DESCRIPTION_COPY:"휴지통의 모든 항목을 클립보드에 복사합니다.",DESCRIPTION_EXPORT:"휴지통의 모든 항목을 .json 파일로 저장합니다.",DESCRIPTION_IMPORT:".json 파일을 통해 휴지통의 모든 항목을 덮어씁니다.",DESCRIPTION_CLEAR:"휴지통의 모든 항목을 삭제합니다(되돌릴 수 없음).",ITEMS_EMPTY_SONGS_TITLE:"삭제된 곡 없음!",ITEMS_EMPTY_ARTISTS_TITLE:"삭제된 아티스트 없음!",DESCRIPTION_SETTINGS_ENABLED:"모든 휴지통+ 기능을 사용하거나 비활성화하는 메인 토글",DESCRIPTION_SETTINGS_SHOW_WIDGET:"재생 중인 곡 옆의 재생 바에 휴지통 아이콘을 표시하여 빠르게 접근할 수 있도록 함",DESCRIPTION_SETTINGS_AUTOPLAY:"Spotify가 열리거나 확장 프로그램이 로드될 때 자동으로 음악 재생 시작",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"대기 중인 재생 목록의 각 곡 옆에 휴지통 아이콘을 추가하여 쉽게 관리할 수 있습니다",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"앨범 및 재생목록 보기에서 곡 옆에 휴지통 아이콘을 추가하여 빠른 필터링을 가능하게 함",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Spotify 재생 오류 발생 시 마지막 재생 목록을 자동으로 이어 재생하여 복구합니다",SETTINGS_SKIP_TRASHED_TRACKS:"삭제된 트랙 건너뛰기",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"재생 중에 휴지통으로 이동한 곡을 자동으로 건너뛰고 다음에 재생 가능한 트랙을 찾습니다.",SETTINGS_AUTO_CLEAN_QUEUE:"자동 정리 대기열",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"휴지통에 있는 곡을 스마트 셔플 큐에서 자동으로 제거합니다",SETTINGS_TRASH_ON_NEXT_HOTKEY:"다음 단축키로 휴지통으로 이동",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Ctrl+오른쪽 키보드 단축키를 사용하여 다음 곡으로 건너뛸 때 현재 곡을 자동으로 휴지통으로 이동",SETTINGS_REMOTE_CONTROL:"리모컨",SETTINGS_REMOTE_TOGGLE:"원격 토글 사용 가능",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"모바일에서 재생/일시정지 버튼을 두 번 탭하여 원격 건너뛰기 켜기/끄기 전환. 곡 건너뛰기로 전환이 확인됨.",SETTINGS_REMOTE_SKIPPING:"원격 건너뛰기 활성화됨",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"활성화하면 다른 기기(예: 모바일)에서 Spotify를 제어할 때에도 휴지통 건너뛰기가 작동합니다.",MESSAGE_REMOTE_SKIPPING_ENABLED:"원격 건너뛰기 활성화됨",MESSAGE_REMOTE_SKIPPING_DISABLED:"원격 건너뛰기 비활성화됨",MESSAGE_SONG_ADDED_REMOTE:"원격으로 곡 폐기됨",SETTINGS_TRASH_VIA_LIKE:"좋아요를 통한 쓰레기",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"휴대폰에서 재생 중인 곡을 삭제하듯이 자동으로 좋아요를 취소하고 다음 곡으로 건너뜁니다.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var e8=K((kS,Lu)=>{Lu.exports={TRASHBIN_NAME:"Šiukšlinė+",ACTION_THROW:"Įdėti į šiukšliadėžę",ACTION_UNTHROW:"Pašalinti iš šiukšlinės",ACTION_CLEAR:"Aišku",ACTION_COPY:"Kopijuoti",ACTION_EXPORT:"Eksportuoti",ACTION_IMPORT:"Importuoti",MESSAGE_COPIED:"Nukopijuota į iškarpinę",MESSAGE_CLEARED:"Šiukšlinė sėkmingai išvalyta!",MESSAGE_SONG_ADDED:"Daina pridėta į šiukšlinę",MESSAGE_SONG_REMOVED:"Daina pašalinta iš šiukšlinės",MESSAGE_ARTIST_ADDED:"Dailininkas pridėtas į šiukšlinę",MESSAGE_ARTIST_REMOVED:"Dailininkas pašalintas iš šiukšlinės",BACKUP_SAVE_SUCCESS:"Atsarginė kopija sėkmingai išsaugota.",BACKUP_SAVE_FAILED:"Nepavyko išsaugoti atsarginės kopijos, pabandykite nukopijuoti šiukšlinės turinį į iškarpinę ir rankiniu būdu sukurti atsarginę kopiją.",BACKUP_RESTORE_SUCCESS:"Atsarginė kopija sėkmingai atkurta.",BACKUP_FILE_READ_FAILED:"Nepavyko perskaityti failo, įsitikinkite, kad tai yra galiojantis JSON failas.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Šiukšlinės+ nustatymai",SETTINGS_OPTIONS:"Parinktys",SETTINGS_FEATURES:"Funkcijos",SETTINGS_LOCAL_STORAGE:"Vietinis saugojimas",SETTINGS_ENABLED:"Įjungta",SETTINGS_SHOW_WIDGET:"Rodyti valdiklio piktogramą",SETTINGS_AUTOPLAY:"Automatinis paleidimas paleidžiant",SETTINGS_QUEUE_TRASHBIN:"Įgalinti eilės šiukšlinę",SETTINGS_TRACKLIST_TRASHBIN:"Įgalinti takelių sąrašo šiukšlinę",SETTINGS_PLAYLIST_MONITOR:"Grojaraščių monitorius",ITEMS_TITLE:"Šiukšlinės+ elementai",ITEMS_EMPTY_SONGS:"<strong>Jokių išmestų dainų!</strong><br/>Dainos, kurias sudėjote į šiukšlinę, bus rodomos čia.",ITEMS_EMPTY_ARTISTS:"<strong>Jokio šiukšlinamo meno kūrėjo!</strong><br/>Meno kūrėjai, kuriuos sudėjote į šiukšlinę, pasirodys čia.",ITEMS_TAB_SONGS:"Dainos",ITEMS_TAB_ARTISTS:"Dailininkai",ITEMS_LOADED_COUNT:"{{loaded}} iš {{total}} {{type}} įkelta",DESCRIPTION_COPY:"Kopijuoti visus šiukšlinėje esančius elementus į iškarpinę.",DESCRIPTION_EXPORT:"Išsaugoti visus šiukšlinės elementus į .json failą.",DESCRIPTION_IMPORT:"Perrašyti visus šiukšlinės elementus naudojant .json failą.",DESCRIPTION_CLEAR:"Išvalyti visus elementus iš šiukšlinės (negalima atšaukti).",ITEMS_EMPTY_SONGS_TITLE:"Nėra ištrintų dainų!",ITEMS_EMPTY_ARTISTS_TITLE:"Jokių išmestų dailininkų!",DESCRIPTION_SETTINGS_ENABLED:"Pagrindinis jungiklis įgalinti arba išjungti visą Šiukšlinės+ funkcionalumą",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Rodyti šiukšliadėžės piktogramą paleidimo juostoje šalia dabar grojamo takelio, kad būtų greitas prieiga",DESCRIPTION_SETTINGS_AUTOPLAY:"Automatiškai paleisti muziką, kai atsidaro „Spotify“ arba įkeliama plėtinys",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Pridėkite šiukšlių dėžės piktogramas šalia kiekvienos dainos eilėje, kad būtų lengviau tvarkyti",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Pridėkite šiukšlių piktogramas šalia dainų albumų ir grojaraščių rodiniuose, kad būtų galima greitai filtruoti",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatiškai atkurti iš „Spotify“ grojimo sutrikimų, vėl paleidus paskutinį grojaraštį",SETTINGS_SKIP_TRASHED_TRACKS:"Praleisti ištrintus takelius",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Automatiškai praleisti ištrintas dainas ir grojant rasti kitą leistiną takelį",SETTINGS_AUTO_CLEAN_QUEUE:"Automatinio valymo eilė",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Automatiškai šalinkite ištrintas dainas iš savo išmaniųjų maišymo eilės",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Šiukšlės kitam karščiajam klavišui",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Automatiškai išmesti dabartinę dainą, naudojant Ctrl+dešinėn klavišų kombinaciją, kad pereitumėte prie kito takelio",SETTINGS_REMOTE_CONTROL:"Nuotolinis valdymas",SETTINGS_REMOTE_TOGGLE:"Įgalinti nuotolinį perjungimą",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Du kartus bakstelėkite paleisti / praleisti, kad iš mobilaus įjungtumėte nuotolinio praleidimo funkciją. Takelio praleidimas patvirtina šią funkciją.",SETTINGS_REMOTE_SKIPPING:"Nutolęs praleidimas aktyvus",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Įjungus šią funkciją, dainų praleidimas veikia net tada, kai „Spotify“ valdote iš kito įrenginio (pvz., iš mobilaus telefono)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Nuotolinis praleidimas įjungtas",MESSAGE_REMOTE_SKIPPING_DISABLED:"Nuotolinis praleidimas išjungtas",MESSAGE_SONG_ADDED_REMOTE:"Daina ištrinta iš toli",SETTINGS_TRASH_VIA_LIKE:"Šiukšlės per Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Kaip daina iš mobilaus į šiukšlyną. Automatiškai pašalina patiktuką ir pereina prie kito takelio.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var o8=K((NS,Hu)=>{Hu.exports={TRASHBIN_NAME:"Atkritumu tvertne+",ACTION_THROW:"Ievietot atkritnos",ACTION_UNTHROW:"Izņemt no miskastes",ACTION_CLEAR:"Skaidrs",ACTION_COPY:"Kopēt",ACTION_EXPORT:"Eksports",ACTION_IMPORT:"Importēt",MESSAGE_COPIED:"Kopēts starpliktuvē",MESSAGE_CLEARED:"Atkritumu kaste veiksmīgi iztīrīta!",MESSAGE_SONG_ADDED:"Dziesma pievienota atkritni",MESSAGE_SONG_REMOVED:"Dziesma noņemta no miskastes",MESSAGE_ARTIST_ADDED:"Mākslinieks pievienots atkritne",MESSAGE_ARTIST_REMOVED:"Mākslinieks noņemts no atkritumu kastes",BACKUP_SAVE_SUCCESS:"Rezerves kopija veiksmīgi saglabāta.",BACKUP_SAVE_FAILED:"Neizdevās saglabāt rezerves kopiju, mēģiniet kopēt miskastes saturu starpliktuvē un manuāli izveidot rezerves kopiju.",BACKUP_RESTORE_SUCCESS:"Rezerves kopija veiksmīgi atjaunota.",BACKUP_FILE_READ_FAILED:"Neizdevās nolasīt failu, lūdzu, pārliecinieties, ka tas ir derīgs JSON fails.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Trashbin+ iestatījumi",SETTINGS_OPTIONS:"Iespējas",SETTINGS_FEATURES:"Iezīmes",SETTINGS_LOCAL_STORAGE:"Vietējā krātuve",SETTINGS_ENABLED:"Ieslēgts",SETTINGS_SHOW_WIDGET:"Rādīt logrīka ikonu",SETTINGS_AUTOPLAY:"Automātiska atskaņošana startējot",SETTINGS_QUEUE_TRASHBIN:"Iespējot rindas miskasti",SETTINGS_TRACKLIST_TRASHBIN:"Ieslēgt dziesmu saraksta miskasti",SETTINGS_PLAYLIST_MONITOR:"Reprodukcijas sarakstu pārvaldnieks",ITEMS_TITLE:"Priekšmeti no miskastes+",ITEMS_EMPTY_SONGS:"<strong>Nav dzēstas dziesmas!</strong><br/>Dziesmas, kuras jūs iemetīsiet atkritnos, parādīsies šeit.",ITEMS_EMPTY_ARTISTS:"<strong>Nav izmestu mākslinieku!</strong><br/>Mākslinieki, kurus jūs iemetīsiet atkritnos, parādīsies šeit.",ITEMS_TAB_SONGS:"Dziesmas",ITEMS_TAB_ARTISTS:"Mākslinieki",ITEMS_LOADED_COUNT:"Ielādēti {{loaded}} no {{total}} {{type}}",DESCRIPTION_COPY:"Kopēt visus atkritnumešā esošos vienumus starpliktuvē.",DESCRIPTION_EXPORT:"Saglabāt visus elementus atkritnes kastē .json failā.",DESCRIPTION_IMPORT:"Pārrakstīt visus elementus miskastē, izmantojot .json failu.",DESCRIPTION_CLEAR:"Notīrīt visus vienumus no miskastes (nevar atsaukt).",ITEMS_EMPTY_SONGS_TITLE:"Nav izdzēstu dziesmu!",ITEMS_EMPTY_ARTISTS_TITLE:"Nē, izmestajiem māksliniekiem!",DESCRIPTION_SETTINGS_ENABLED:"Galvenais slēdzis, lai ieslēgtu vai izslēgtu visas miskastītes+ funkcijas",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Attēlot atkritumu ikonu atskaņošanas joslā blakus pašreizējai atskaņošanas kompilācijai ātrai piekļuvei",DESCRIPTION_SETTINGS_AUTOPLAY:"Automātiski sākt mūziku, kad atveras Spotify vai tiek ielādēts paplašinājums",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Pievienojiet atkritumu ikonas katram dziesmai jūsu tuvojo rindā, lai būtu vieglāk pārvaldīt",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Albumu un atskaņošanas sarakstu skatos pie dziesmām pievienot miskastīšu ikonas ātrai filtrēšanai",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automātiski atgūstieties no Spotify atskaņošanas problēmām, atsākot pēdējo sarakstu",SETTINGS_SKIP_TRASHED_TRACKS:"Izlaidt izdzēstos trakus",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Automātiski izlaist dziesmas, kas pārvietotas atkritnēs, un atskaņošanas laikā atrast nākamo atļauto kompozīciju",SETTINGS_AUTO_CLEAN_QUEUE:"Automātiskās tīrīšanas rinda",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Automātiski noņemt izdzēstās dziesmas no jūsu gudrās jaukto saraksta rindas",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Miskaste uz nākamo karstās taustiņa kombinācijas",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Automātiski izmest pašreizējo dziesmu, izmantojot taustiņu kombināciju Ctrl+pa labi, lai pārietu uz nākamo kompozīciju",SETTINGS_REMOTE_CONTROL:"Tālvadības pulti",SETTINGS_REMOTE_TOGGLE:"Iespējot attālo slēdzi",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dubultklikšķis uz atskaņošanas/pauzes mobilajā, lai ieslēgtu/izslēgtu attālinātu pārslēgšanu. Trases pārslēgšana apstiprina ieslēgšanu.",SETTINGS_REMOTE_SKIPPING:"Attālināta izlaišana aktīva",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Ieslēdzot, miskastē nelikšana darbojas pat tad, ja Spotify tiek kontrolēts no cita ierīces (piemēram, mobilā tālruņa)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Attālināta pārlēkšana iespējota",MESSAGE_REMOTE_SKIPPING_DISABLED:"Attālināta izlaišana atspējota",MESSAGE_SONG_ADDED_REMOTE:"Dziesma iznīcināta attālināti",SETTINGS_TRASH_VIA_LIKE:"Miskaste, izmantojot Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Kā dziesmu no mobilā, lai to izmestu. Automātiski noņem patīk un pāriet uz nākamo kompozīciju.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var n8=K((OS,Vu)=>{Vu.exports={TRASHBIN_NAME:"Канта за отпадоци+",ACTION_THROW:"Стави во кофата за отпадоци",ACTION_UNTHROW:"Отстрани од кофата за отпадоци",ACTION_CLEAR:"Јасно",ACTION_COPY:"Копирај",ACTION_EXPORT:"Извоз",ACTION_IMPORT:"Увоз",MESSAGE_COPIED:"Копирано во таблата",MESSAGE_CLEARED:"Канчето за отпадоци е успешно исчистено!",MESSAGE_SONG_ADDED:"Песната е додадена во кофата за отпад",MESSAGE_SONG_REMOVED:"Песната е отстранета од кофата за отпад",MESSAGE_ARTIST_ADDED:"Уметникот е додаден во корпата за отпадоци",MESSAGE_ARTIST_REMOVED:"Уметникот е отстранет од сандучето за отпадоци",BACKUP_SAVE_SUCCESS:"Резервното копирање е успешно зачувано.",BACKUP_SAVE_FAILED:"Неуспешно зачувување на резервна копија, обидете се со копирање на содржината на кофата за ѓубре во таблата и рачно креирање на резервна копија.",BACKUP_RESTORE_SUCCESS:"Резервното копие е успешно вратено.",BACKUP_FILE_READ_FAILED:"Неуспешно читање на датотеката, ве молиме уверете се дека е валидна JSON датотека.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Поставувања за Trashbin+",SETTINGS_OPTIONS:"Опции",SETTINGS_FEATURES:"Карактеристики",SETTINGS_LOCAL_STORAGE:"Локален мемориски простор",SETTINGS_ENABLED:"Овозможено",SETTINGS_SHOW_WIDGET:"Прикажи икона на додатокот",SETTINGS_AUTOPLAY:"Автоматско пуштање при стартување",SETTINGS_QUEUE_TRASHBIN:"Овозможи кош за отпадоци од редоследот",SETTINGS_TRACKLIST_TRASHBIN:"Овозможи кошче за листата на нумери",SETTINGS_PLAYLIST_MONITOR:"Плејлиста Монитор",ITEMS_TITLE:"Предмети од кофата за отпадоци+",ITEMS_EMPTY_SONGS:"<strong>Нема избришани песни!</strong><br/>Песните што ги додавате во кошчето за отпад ќе се појават овде.",ITEMS_EMPTY_ARTISTS:"<strong>Нема избришани уметници!</strong><br/>Уметниците што ги додавате во кошчето за отпад ќе се појават овде.",ITEMS_TAB_SONGS:"Песни",ITEMS_TAB_ARTISTS:"Уметници",ITEMS_LOADED_COUNT:"{{loaded}} од {{total}} {{type}} вчитани",DESCRIPTION_COPY:"Копирај ги сите ставки во кошчето за отпад во клипборд.",DESCRIPTION_EXPORT:"Зачувај ги сите ставки во кошчето за отпад во .json датотека.",DESCRIPTION_IMPORT:"Препиши ги сите ставки во кошчето преку .json датотека.",DESCRIPTION_CLEAR:"Исчисти ги сите ставки од кошчето за отпадоци (не може да се врати).",ITEMS_EMPTY_SONGS_TITLE:"Без избришани песни!",ITEMS_EMPTY_ARTISTS_TITLE:"Без уништени уметници!",DESCRIPTION_SETTINGS_ENABLED:"Главно преклопување за овозможување или оневозможување на сите функции на Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Прикажи икона за корпа за отпадоци на лентата за пуштање до трекот кој се пушта за брз пристап",DESCRIPTION_SETTINGS_AUTOPLAY:"Автоматски започни со пуштање музика кога Спотифај ќе се отвори или кога ќе се вчита проширувањето",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Додај икони за браќе до секоја песна во редицата за следно пуштање за полесно управување",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Додај икони за браќе до песните во албумите и листите за свирење за брзо филтрирање",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Автоматско враќање од грешките при репродуцирањето на Spotify со продолжување на вашата последна плејлиста",SETTINGS_SKIP_TRASHED_TRACKS:"Прескокни избришани песни",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Автоматски прескокни ги избришаните песни и пронајди ја следната дозволена песна за време на репродукцијата",SETTINGS_AUTO_CLEAN_QUEUE:"Автоматска чистачка редица",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Автоматски отстрани ги избришаните песни од редицата за паметно мешање",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Смрдот на следната копка за брз пристап",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Автоматски испраќај ја тековната песна во корпа кога користиш ја комбинацијата Ctrl+Десно за прескокнување на следната песна",SETTINGS_REMOTE_CONTROL:"Далечинско управување",SETTINGS_REMOTE_TOGGLE:"Овозможи промена од далечина",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Два пати допрете ја иконата за пуштање/пауза од мобилното за да вклучите/исклучите прескокнување на далечинска. Прескокнувањето на песна ја потврдува промената.",SETTINGS_REMOTE_SKIPPING:"Активно далечинско прескокнување",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Кога е овозможено, прескокнувањето на отпадот функционира дури и кога управувате со Spotify од друг уред (на пр., мобилен телефон)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Овозможено е прескокнување од далечина",MESSAGE_REMOTE_SKIPPING_DISABLED:"Оддалеченото прескокнување е оневозможено",MESSAGE_SONG_ADDED_REMOTE:"Песната уништена преку далечинско управување",SETTINGS_TRASH_VIA_LIKE:"Сметче преку Сакам",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Како песна од мобилно до корпа за отпад. Автоматски ја откажува и преминува на следната песна.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var h8=K((RS,ku)=>{ku.exports={TRASHBIN_NAME:"ട്രാഷ്ബിൻ+",ACTION_THROW:"അപായ ബിന്നിൽ ഇടുക",ACTION_UNTHROW:"ട്രഷ്ബിനിൽ നിന്ന് നീക്കം ചെയ്യുക",ACTION_CLEAR:"വ്യക്തമായ",ACTION_COPY:"പകർപ്പ്",ACTION_EXPORT:"കയറ്റുമതി ചെയ്യുക",ACTION_IMPORT:"ഇറക്കുമതി ചെയ്യുക",MESSAGE_COPIED:"ക്ലിപ്പ്ബോർഡിലേക്ക് പകർത്തി",MESSAGE_CLEARED:"ചവറ്റുകൊട്ട വിജയകരമായി ശൂന്യമാക്കി!",MESSAGE_SONG_ADDED:"ഗാനം ചവറ്റുകൊട്ടയിലേക്ക് ചേർത്തു",MESSAGE_SONG_REMOVED:"ട്രാഷ്ബിനിൽ നിന്ന് പാട്ട് നീക്കം ചെയ്തു",MESSAGE_ARTIST_ADDED:"ആർട്ടിസ്റ്റ് ട്രാഷ്ബിനിലേക്ക് ചേർത്തു",MESSAGE_ARTIST_REMOVED:"അവശിഷ്ടങ്ങളുടെ പെട്ടിയിൽ നിന്ന് ആർട്ടിസ്റ്റിനെ നീക്കം ചെയ്തു",BACKUP_SAVE_SUCCESS:"ബാക്കപ്പ് വിജയകരമായി സേവ് ചെയ്തു.",BACKUP_SAVE_FAILED:"ബാക്കപ്പ് സംരക്ഷിക്കുന്നതിൽ പരാജയപ്പെട്ടു, ത്രാഷ്ബിന്റെ ഉള്ളടക്കങ്ങൾ ക്ലിപ്പ്ബോർഡിലേക്ക് പകർത്തി ഒരു ബാക്കപ്പ് കൈമുതലായി സൃഷ്ടിക്കാൻ ശ്രമിക്കുക.",BACKUP_RESTORE_SUCCESS:"ബാക്കപ്പ് വിജയകരമായി പുനഃസ്ഥാപിച്ചു.",BACKUP_FILE_READ_FAILED:"ഫയൽ വായിക്കുന്നതിൽ പരാജയപ്പെട്ടു, ദയവായി അത് ഒരു സാധുവായ JSON ഫയലാണെന്ന് ഉറപ്പാക്കുക.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ട്രാഷ്ബിൻ+ ക്രമീകരണങ്ങൾ",SETTINGS_OPTIONS:"ഓപ്ഷനുകൾ",SETTINGS_FEATURES:"സവിശേഷതകൾ",SETTINGS_LOCAL_STORAGE:"സ്ഥാനിക സംഭരണം",SETTINGS_ENABLED:"സജീവമാക്കി",SETTINGS_SHOW_WIDGET:"വിജറ്റ് ഐക്കൺ കാണിക്കുക",SETTINGS_AUTOPLAY:"ആരംഭത്തിൽ ഓട്ടോപ്ലേ ചെയ്യുക",SETTINGS_QUEUE_TRASHBIN:"അടുക്കിവയ്ക്കുന്നതിന് ട്രഷ്ബിൻ സജീവമാക്കുക",SETTINGS_TRACKLIST_TRASHBIN:"ട്രാക്ക്‌ലിസ്റ്റ് ട്രഷ്ബിൻ സജീവമാക്കുക",SETTINGS_PLAYLIST_MONITOR:"പ്ലേലിസ്റ്റ് മോണിറ്റർ",ITEMS_TITLE:"ട്രാഷ്ബിൻ+ ഇനങ്ങൾ",ITEMS_EMPTY_SONGS:"<strong>ഒന്നും നശിപ്പിച്ചിട്ടില്ല!</strong><br/>നിങ്ങൾ നശിപ്പിക്കാൻ ചേർത്ത ഗാനങ്ങൾ ഇവിടെ പ്രത്യക്ഷപ്പെടും.",ITEMS_EMPTY_ARTISTS:"<strong>ഒരു കലാകാരനെയും ഒഴിവാക്കരുത്!</strong><br/>നിങ്ങൾ അപ്പായത്തിലേക്ക് ചേർക്കുന്ന കലാകാരന്മാർ ഇവിടെ പ്രത്യക്ഷപ്പെടും.",ITEMS_TAB_SONGS:"ഗാനങ്ങൾ",ITEMS_TAB_ARTISTS:"കലാകാരന്മാർ",ITEMS_LOADED_COUNT:"{{total}} ൽ {{loaded}} {{type}} ലോഡ് ചെയ്തു",DESCRIPTION_COPY:"ലാവണ്യപ്പെട്ട ബിന്നിലെ എല്ലാ ഇനങ്ങളും ക്ലിപ്പ്ബോർഡിലേക്ക് പകർത്തുക.",DESCRIPTION_EXPORT:"ട്രാഷ്ബിനിലെ എല്ലാ ഇനങ്ങളും ഒരു .json ഫയലിൽ സംരക്ഷിക്കുക.",DESCRIPTION_IMPORT:"അവശേഷിക്കുന്ന എല്ലാ ഇനങ്ങളും .json ഫയലിലൂടെ ഓവർറൈറ്റ് ചെയ്യുക.",DESCRIPTION_CLEAR:"ട്രാഷ്ബിനിൽ നിന്ന് എല്ലാ ഇനങ്ങളും നീക്കം ചെയ്യുക (തിരികെ പുനഃസ്ഥാപിക്കാൻ കഴിയില്ല).",ITEMS_EMPTY_SONGS_TITLE:"ഒരു നശിപ്പിച്ച പാട്ടുകളുമില്ല!",ITEMS_EMPTY_ARTISTS_TITLE:"ആരും തള്ളിക്കളയരുത്!",DESCRIPTION_SETTINGS_ENABLED:"എല്ലാ ത്രാഷ്ബിൻ+ പ്രവർത്തനങ്ങളും സജീവമാക്കുന്നതിനോ നിഷ്ക്രിയമാക്കുന്നതിനോ ഉള്ള മാസ്റ്റർ ടോഗിൾ",DESCRIPTION_SETTINGS_SHOW_WIDGET:"നിലവിൽ പ്ലേ ചെയ്യുന്ന ട്രാക്കിന് അടുത്തായി പ്ലേബാക്ക് ബാറിൽ ഒരു ട്രാഷ് ഐക്കൺ പ്രദർശിപ്പിക്കുക",DESCRIPTION_SETTINGS_AUTOPLAY:"സ്പോട്ടിഫൈ തുറക്കുമ്പോഴോ എക്സ്റ്റൻഷൻ ലോഡ് ചെയ്യുമ്പോഴോ സ്വയമേവ സംഗീതം പ്ലേ ചെയ്യാൻ ആരംഭിക്കുക",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"നിങ്ങളുടെ അടുത്തടുത്തുള്ള ക്യൂവിൽ ഓരോ ഗാനത്തിനും അടുത്തായി ത്രാഷ് ഐക്കണുകൾ ചേർക്കുക, എളുപ്പത്തിൽ കൈകാര്യം ചെയ്യാൻ",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"ആൽബം, പ്ലേലിസ്റ്റ് വ്യൂകളിൽ പാട്ടുകൾക്ക് അടുത്ത് ചവറ്റുകുപ്പി ഐക്കണുകൾ ചേർക്കുക, വേഗത്തിലുള്ള ഫിൽട്ടറിംഗിനായി",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"അവസാന പ്ലേലിസ്റ്റ് പുനഃരാരംഭിക്കുന്നതിലൂടെ സ്പോട്ടിഫൈ പ്ലേബാക്ക് പിഴവുകളിൽ നിന്ന് സ്വയമേവ പുനഃസ്ഥാപിക്കുക",SETTINGS_SKIP_TRASHED_TRACKS:"തകരാറിലായ ട്രാക്കുകൾ ഉപേക്ഷിക്കുക",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"തുടച്ചുനീക്കിയ ഗാനങ്ങൾ സ്വയമേവ ഒഴിവാക്കി പ്ലേബാക്കിനിടെ അടുത്തതായി അനുവദിച്ച ട്രാക്ക് കണ്ടെത്തുക",SETTINGS_AUTO_CLEAN_QUEUE:"ഓട്ടോ ക്ലീൻ ക്യൂ",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"നിങ്ങളുടെ സ്മാർട്ട് ഷഫിൾ ക്യൂവിൽ നിന്ന് ത്രാഷ് ചെയ്ത പാട്ടുകൾ സ്വയമേവ നീക്കം ചെയ്യുക",SETTINGS_TRASH_ON_NEXT_HOTKEY:"അടുത്ത ഹോട്ട്കീയിൽ ത്രാഷ്",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"അടുത്ത ട്രാക്കിലേക്ക് ചാടാൻ Ctrl+Right കീബോർഡ് ഷോർട്ട്കട്ട് ഉപയോഗിക്കുമ്പോൾ നിലവിലെ ഗാനം സ്വയമേവ ത്രാഷ് ചെയ്യുക",SETTINGS_REMOTE_CONTROL:"റിമോട്ട് കൺട്രോൾ",SETTINGS_REMOTE_TOGGLE:"റിമോട്ട് ടോഗിൾ സജ്ജമാക്കുക",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"മൊബൈലിൽ നിന്ന് റിമോട്ട് ഉപേക്ഷിക്കുന്നത് ഓണാക്കാനും ഓഫാക്കാനും പ്ലേ/പൗസ് ഡബിൾ-ടാപ്പ് ചെയ്യുക. ഒരു ട്രാക്ക് ഉപേക്ഷിക്കൽ ടോഗിൾ സ്ഥിരീകരിക്കുന്നു.",SETTINGS_REMOTE_SKIPPING:"റിമോട്ട് സ്കിപ്പിംഗ് സജീവമാണ്",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"സക്രിയമാക്കിയാൽ, മറ്റൊരു ഉപകരണത്തിൽ നിന്ന് (ഉദാ: മൊബൈൽ) സ്പോട്ടിഫൈ നിയന്ത്രിക്കുമ്പോൾ പോലും ട്രാഷ് ഒഴിവാക്കൽ പ്രവർത്തിക്കുന്നു",MESSAGE_REMOTE_SKIPPING_ENABLED:"ദൂരെ നിന്നുള്ള തുടര്‍ച്ചയായ ഉപേക്ഷ സജീവമാക്കി",MESSAGE_REMOTE_SKIPPING_DISABLED:"ദൂരെ നിന്നുള്ള ഉപേക്ഷിക്കൽ പ്രവർത്തനരഹിതമാക്കി",MESSAGE_SONG_ADDED_REMOTE:"റിമോട്ട് വഴി പാട്ട് നശിപ്പിച്ചു",SETTINGS_TRASH_VIA_LIKE:"ലൈക്കിലൂടെ ചവറ്",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"മൊബൈലിൽ നിന്ന് ഒരു പാട്ട് തെരഞ്ഞെടുത്ത് അതിനെ ഒഴിവാക്കുന്നത് പോലെ. സ്വയമായി അൺലൈക്ക് ചെയ്ത് അടുത്ത ട്രാക്കിലേക്ക് മാറുന്നു.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var c8=K((wS,Nu)=>{Nu.exports={TRASHBIN_NAME:"कचऱ्याची टोपली+",ACTION_THROW:"कचऱ्याच्या डब्यात ठेवा",ACTION_UNTHROW:"कचऱ्याची टोपलीतून काढा",ACTION_CLEAR:"स्पष्ट",ACTION_COPY:"कॉपी",ACTION_EXPORT:"निर्यात",ACTION_IMPORT:"आयात",MESSAGE_COPIED:"क्लिपबोर्डवर कॉपी केले",MESSAGE_CLEARED:"कचऱ्याची टोपली यशस्वीरित्या स्वच्छ केली!",MESSAGE_SONG_ADDED:"गाणे रद्दीच्या टोपलीत जोडले गेले",MESSAGE_SONG_REMOVED:"गाणे रद्द केलेल्या फाइल्सच्या फोल्डरमधून काढून टाकले",MESSAGE_ARTIST_ADDED:"कलाकाराला ट्रॅशबिनमध्ये जोडले",MESSAGE_ARTIST_REMOVED:"कलाकाराला ट्रॅशबिनमधून काढून टाकले",BACKUP_SAVE_SUCCESS:"बॅकअप यशस्वीरित्या सेव्ह झाले.",BACKUP_SAVE_FAILED:"बॅकअप जतन करण्यात अयशस्वी, ट्रॅशबिनची सामग्री क्लिपबोर्डवर कॉपी करण्याचा प्रयत्न करा आणि स्वतःहून बॅकअप तयार करा.",BACKUP_RESTORE_SUCCESS:"बॅकअप यशस्वीरित्या पुन्हा स्थापित केले.",BACKUP_FILE_READ_FAILED:"फाइल वाचण्यात अयशस्वी, कृपया खात्री करा की ती वैध JSON फाइल आहे.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ट्रॅशबिन+ सेटिंग्ज",SETTINGS_OPTIONS:"पर्याय",SETTINGS_FEATURES:"वैशिष्ट्ये",SETTINGS_LOCAL_STORAGE:"स्थानिक संचय",SETTINGS_ENABLED:"सक्षम केले",SETTINGS_SHOW_WIDGET:"विडगेट आयकॉन दाखवा",SETTINGS_AUTOPLAY:"सुरुवातीला स्वयंचलित प्रारंभ",SETTINGS_QUEUE_TRASHBIN:"कतार ट्रॅशबिन सक्षम करा",SETTINGS_TRACKLIST_TRASHBIN:"ट्रॅकलिस्ट ट्रॅशबिन सक्षम करा",SETTINGS_PLAYLIST_MONITOR:"प्लेलिस्ट मॉनिटर",ITEMS_TITLE:"ट्रॅशबिन+ आयटम्स",ITEMS_EMPTY_SONGS:"<strong>कोणतेही फेकलेले गाणे नाहीत!</strong><br/>तुम्ही रद्दी पेटीमध्ये जोडलेली गाणी येथे दिसतील.",ITEMS_EMPTY_ARTISTS:"<strong>कोणतेही कचऱ्यात टाकलेले कलाकार नाहीत!</strong><br/>तुम्ही कचऱ्याच्या डब्यात जोडलेले कलाकार येथे दिसतील.",ITEMS_TAB_SONGS:"गाणी",ITEMS_TAB_ARTISTS:"कलाकार",ITEMS_LOADED_COUNT:"लोड झालेले {{total}} पैकी {{loaded}} {{type}}",DESCRIPTION_COPY:"ट्रॅशबिनमधील सर्व घटक क्लिपबोर्डवर कॉपी करा.",DESCRIPTION_EXPORT:"त्रष्टबिनमधील सर्व घटक .json फाइलमध्ये जतन करा.",DESCRIPTION_IMPORT:".json फाइलद्वारे ट्रॅशबिनमधील सर्व आयटम ओव्हरराइट करा.",DESCRIPTION_CLEAR:"कचऱ्याच्या डब्यातील सर्व वस्तू स्पष्ट करा (परत करता येणार नाही).",ITEMS_EMPTY_SONGS_TITLE:"कोणतेही फेकलेले गाणे नाहीत!",ITEMS_EMPTY_ARTISTS_TITLE:"कोणतेही फेकलेले कलाकार नाहीत!",DESCRIPTION_SETTINGS_ENABLED:"सर्व ट्रॅशबिन+ कार्यक्षमता सक्षम करण्यासाठी किंवा अक्षम करण्यासाठी मास्टर टॉगल",DESCRIPTION_SETTINGS_SHOW_WIDGET:"सध्या चालणाऱ्या ट्रॅकच्या जवळ प्लेबॅक बारमध्ये जलद प्रवेशासाठी ट्रॅश आयकॉन दाखवा",DESCRIPTION_SETTINGS_AUTOPLAY:"स्पॉटिफाई उघडल्यावर किंवा एक्सटेंशन लोड झाल्यावर स्वयंचलितपणे संगीत वाजवण्यास सुरुवात करा",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"तुमच्या येणार्‍या रांगेतील प्रत्येक गाण्याजवळ सोप्या व्यवस्थापनासाठी घाण कचरा आयकॉन जोडा",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"अल्बम आणि वाजवणीयादीमधील गाण्यांच्या जवळ ट्रॅश आयकॉन्स जोडा जलद फिल्टरिंगसाठी",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"स्पॉटिफाई वरील प्लेबॅकच्या त्रुटींपासून तुमची शेवटची प्लेलिस्ट पुन्हा सुरू करून स्वयंचलितपणे वसूल होणे",SETTINGS_SKIP_TRASHED_TRACKS:"खंडित ट्रॅक्स वर जा",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"स्वयंचलितपणे फेकलेल्या गाण्यांना उल्लंघून प्लेबॅकदरम्यान पुढील परवानगी दिलेले ट्रॅक शोधा",SETTINGS_AUTO_CLEAN_QUEUE:"ऑटो क्लीन कतार",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"तुमच्या स्मार्ट शफल रांगेतून फेकलेल्या गाण्यांचे स्वयंचलितपणे काढून टाका",SETTINGS_TRASH_ON_NEXT_HOTKEY:"पुढील हॉटकीवर ट्रॅश",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Ctrl+Right कीबोर्ड शॉर्टकट वापरून पुढील ट्रॅकवर जाण्यासाठी सध्याचे गाणे स्वयंचलितपणे ट्रॅश करा",SETTINGS_REMOTE_CONTROL:"दूरस्थ नियंत्रण",SETTINGS_REMOTE_TOGGLE:"दूरस्थ टॉगल सक्षम करा",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"मोबाइलवरून रिमोट स्किपिंग चालू/बंद करण्यासाठी दुहेरी टॅप प्ले/थांबवा. ट्रॅक स्किप करणे हे टॉगल पुष्टी करते.",SETTINGS_REMOTE_SKIPPING:"दूरस्थ उद्धृत करणे सक्रिय",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"सक्षम असताना, ट्रॅश-स्किपिंग इतर डिव्हाइसवरून (उदा., मोबाइल) स्पॉटिफाय नियंत्रित करताना देखील काम करते",MESSAGE_REMOTE_SKIPPING_ENABLED:"दूरस्थ स्किपिंग सक्षम केले आहे",MESSAGE_REMOTE_SKIPPING_DISABLED:"दूरस्थ स्किपिंग अक्षम केले आहे",MESSAGE_SONG_ADDED_REMOTE:"गाणे दूरस्थरित्या नष्ट केले",SETTINGS_TRASH_VIA_LIKE:"लायकेसह ट्रॅश",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"मोबाइलमधून ते ट्रॅश करण्यासाठी एक गाणे. स्वयंचलितपणे आवड नाही आणि पुढील ट्रॅकवर जाते.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var d8=K((DS,Ou)=>{Ou.exports={TRASHBIN_NAME:"Tong sampah+",ACTION_THROW:"Letakkan dalam Tong Sampah",ACTION_UNTHROW:"Alih keluar dari Tong Sampah",ACTION_CLEAR:"Jelas",ACTION_COPY:"Salin",ACTION_EXPORT:"Eksport",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Disalin ke papan klip",MESSAGE_CLEARED:"Tong sampah berjaya dikosongkan!",MESSAGE_SONG_ADDED:"Lagu ditambah ke dalam tong sampah",MESSAGE_SONG_REMOVED:"Lagu dikeluarkan dari tong sampah",MESSAGE_ARTIST_ADDED:"Artis ditambah ke tong sampah",MESSAGE_ARTIST_REMOVED:"Artis dikeluarkan dari tong sampah",BACKUP_SAVE_SUCCESS:"Sandaran berjaya disimpan.",BACKUP_SAVE_FAILED:"Gagal menyimpan sandaran, cuba salin kandungan tong sampah ke papan keratan dan cipta sandaran secara manual.",BACKUP_RESTORE_SUCCESS:"Sandaran dipulihkan berjaya.",BACKUP_FILE_READ_FAILED:"Gagal membaca fail, sila pastikan ia adalah fail JSON yang sah.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Tetapan Tong Sampah+",SETTINGS_OPTIONS:"Pilihan",SETTINGS_FEATURES:"Ciri-ciri",SETTINGS_LOCAL_STORAGE:"Storan tempatan",SETTINGS_ENABLED:"Didayakan",SETTINGS_SHOW_WIDGET:"Tunjukkan Ikon Widget",SETTINGS_AUTOPLAY:"Main secara automatik pada permulaan",SETTINGS_QUEUE_TRASHBIN:"Dayakan Tong Sampah Barisan",SETTINGS_TRACKLIST_TRASHBIN:"Dayakan Tong Sampah Senarai Trek",SETTINGS_PLAYLIST_MONITOR:"Pemantau Senarai Main",ITEMS_TITLE:"Barangan Tong Sampah+",ITEMS_EMPTY_SONGS:"<strong>Tiada lagu yang dibuang ke tong sampah!</strong><br/>Lagu yang anda tambah ke tong sampah akan muncul di sini.",ITEMS_EMPTY_ARTISTS:"<strong>Tiada artis yang dibuang!</strong><br/>Artis yang anda tambah ke dalam tong sampah akan muncul di sini.",ITEMS_TAB_SONGS:"Lagu-lagu",ITEMS_TAB_ARTISTS:"Artis",ITEMS_LOADED_COUNT:"{{loaded}} daripada {{total}} {{type}} telah dimuatkan",DESCRIPTION_COPY:"Salin semua item dalam tong sampah ke papan keratan.",DESCRIPTION_EXPORT:"Simpan semua item dalam tong sampah ke fail .json.",DESCRIPTION_IMPORT:"Timpa semua item dalam tong sampah melalui fail .json.",DESCRIPTION_CLEAR:"Padam semua item dari tong sampah (tidak boleh dikembalikan).",ITEMS_EMPTY_SONGS_TITLE:"Tiada lagu yang dibuang ke sampah!",ITEMS_EMPTY_ARTISTS_TITLE:"Tiada artis yang dibuang!",DESCRIPTION_SETTINGS_ENABLED:"Tukar utama untuk mengaktifkan atau menyahaktifkan semua fungsi Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Paparkan ikon tong sampah di bar pemainan bersebelahan trek yang sedang dimainkan untuk akses pantas",DESCRIPTION_SETTINGS_AUTOPLAY:"Mainkan muzik secara automatik apabila Spotify dibuka atau pelanjutan dimuatkan",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Tambah ikon sampah di sebelah setiap lagu dalam barisan anda yang akan datang untuk pengurusan yang mudah",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Tambah ikon sampah di sebelah lagu dalam paparan album dan senarai main untuk penapisan pantas",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Pulih secara automatik daripada masalah pemain Spotify dengan meneruskan senarai main terakhir anda",SETTINGS_SKIP_TRASHED_TRACKS:"Langkau Trek yang Dibuang",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Langkau lagu yang dibuang secara automatik dan cari trek seterusnya yang dibenarkan semasa pemainan",SETTINGS_AUTO_CLEAN_QUEUE:"Barisan Pembersihan Automatik",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Alih keluar secara automatik lagu yang dibuang dari barisan Smart Shuffle anda",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Sampah pada Pintasan Berikutnya",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Buang lagu semasa secara automatik apabila menggunakan pintasan papan kekunci Ctrl+Kanan untuk melangkau ke trek seterusnya",SETTINGS_REMOTE_CONTROL:"Kawalan Jauh",SETTINGS_REMOTE_TOGGLE:"Dayakan Butang Togol Jauh",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Ketik dua kali play/jeda dari peranti mudah alih untuk mengaktifkan atau mematikan lompatan jauh. Lompatan trek mengesahkan pengaktifan tersebut.",SETTINGS_REMOTE_SKIPPING:"Langkau Jauh Aktif",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Apabila didayakan, langkau sampah berfungsi walaupun mengawal Spotify daripada peranti lain (contohnya, telefon bimbit)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Langkahan jauh didayakan",MESSAGE_REMOTE_SKIPPING_DISABLED:"Langkau jauh dilumpuhkan",MESSAGE_SONG_ADDED_REMOTE:"Lagu dimusnahkan melalui jarak jauh",SETTINGS_TRASH_VIA_LIKE:"Sampah melalui Suka",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Seperti lagu dari telefon bimbit ke tempat sampah. Secara automatik batal suka dan terus ke trek seterusnya.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var v8=K((GS,Ru)=>{Ru.exports={TRASHBIN_NAME:"Papirkurv+",ACTION_THROW:"Plasser i søppelkurven",ACTION_UNTHROW:"Fjern fra søppelkassen",ACTION_CLEAR:"Klar",ACTION_COPY:"Kopier",ACTION_EXPORT:"Eksport",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Kopiert til utklippstavlen",MESSAGE_CLEARED:"Papirkurven er tømt!",MESSAGE_SONG_ADDED:"Sang lagt i søppelbøtta",MESSAGE_SONG_REMOVED:"Sang fjernet fra søppelkassen",MESSAGE_ARTIST_ADDED:"Kunstner lagt til søppelbøtta",MESSAGE_ARTIST_REMOVED:"Kunstner fjernet fra søppelkassen",BACKUP_SAVE_SUCCESS:"Sikkerhetskopi lagret vellykket.",BACKUP_SAVE_FAILED:"Kunne ikke lagre sikkerhetskopi, prøv å kopiere innholdet i papirkurven til utklippstavlen og lag en sikkerhetskopi manuelt.",BACKUP_RESTORE_SUCCESS:"Sikkerhetskopi gjenopprettet.",BACKUP_FILE_READ_FAILED:"Kunne ikke lese filen, vær sikker på at det er en gyldig JSON-fil.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Søppelkorg+ innstillinger",SETTINGS_OPTIONS:"Alternativer",SETTINGS_FEATURES:"Funksjoner",SETTINGS_LOCAL_STORAGE:"Lokal lagring",SETTINGS_ENABLED:"Aktivert",SETTINGS_SHOW_WIDGET:"Vis miniprogram-ikon",SETTINGS_AUTOPLAY:"Automatisk avspilling ved oppstart",SETTINGS_QUEUE_TRASHBIN:"Aktiver kø-papirkurv",SETTINGS_TRACKLIST_TRASHBIN:"Aktiver sporliste-søppelkasse",SETTINGS_PLAYLIST_MONITOR:"Spillelisteovervåkning",ITEMS_TITLE:"Papirkurv+-elementer",ITEMS_EMPTY_SONGS:"<strong>Ingen slettede sanger!</strong><br/>Sanger du legger i søppelbøtta vil vises her.",ITEMS_EMPTY_ARTISTS:"<strong>Ingen kunstnere i papirkurven!</strong><br/>Kunstnere du legger i papirkurven vil vises her.",ITEMS_TAB_SONGS:"Sanger",ITEMS_TAB_ARTISTS:"Kunstnere",ITEMS_LOADED_COUNT:"{{loaded}} av {{total}} {{type}} lastet inn",DESCRIPTION_COPY:"Kopier alle elementer i søppelkassen til utklippstavlen.",DESCRIPTION_EXPORT:"Lagre alle elementer i søppelkassen til en .json-fil.",DESCRIPTION_IMPORT:"Overskriv alle elementer i søppelkassen via .json-fil.",DESCRIPTION_CLEAR:"Tøm alle elementer fra søppelbøtta (kan ikke angres).",ITEMS_EMPTY_SONGS_TITLE:"Ingen slettede sanger!",ITEMS_EMPTY_ARTISTS_TITLE:"Ingen søpla med artister!",DESCRIPTION_SETTINGS_ENABLED:"Hovedbryter for å aktivere eller deaktivere all papirkurv+-funksjonalitet",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Vis et søppelikon i avspillingslinjen ved siden av den nåværende sporet for rask tilgang",DESCRIPTION_SETTINGS_AUTOPLAY:"Start automatisk å spille musikk når Spotify åpnes eller utvidelsen lastes",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Legg til søppelikoner ved siden av hver sang i køen din for enkel håndtering",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Legg til søppelkorg-ikoner ved siden av sanger i album- og spillelistevyer for rask filtrering",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatisk gjenoppretting fra Spotify-avspillingsproblemer ved gjenopptakelse av siste spilleliste",SETTINGS_SKIP_TRASHED_TRACKS:"Hopp over slettede spor",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Hopp automatisk over slettede sanger og finn neste tillatte spor under avspilling",SETTINGS_AUTO_CLEAN_QUEUE:"Automatisk rens av kø",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Fjern automatisk slettede sanger fra din Smart Shuffle-kø",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Papirkurv ved neste snarvei",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Legg automatisk gjeldende sang i papirkurven når du bruker Ctrl+Høyre-tastaturhurtigtast for å hoppe til neste spor",SETTINGS_REMOTE_CONTROL:"Fjernkontroll",SETTINGS_REMOTE_TOGGLE:"Aktiver fjernstyring",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dobbelttrykk på spill/pause fra mobil for å slå fjernhopp av/på. Hopping av spor bekrefter valget.",SETTINGS_REMOTE_SKIPPING:"Fjernhopping aktiv",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Når det er aktivert, fungerer hoppe over papirkurv selv når du styrer Spotify fra en annen enhet (for eksempel mobil)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Fjernhopping aktivert",MESSAGE_REMOTE_SKIPPING_DISABLED:"Fjernhopping deaktivert",MESSAGE_SONG_ADDED_REMOTE:"Sang slettet via fjernkontroll",SETTINGS_TRASH_VIA_LIKE:"Søppel via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Som en sang fra mobil til søppelbøtta. Fjerner lik automatisk og hopper til neste spor.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var u8=K((PS,wu)=>{wu.exports={TRASHBIN_NAME:"ट्र्याशबिन+",ACTION_THROW:"त्रशबिनमा राख्नुहोस्",ACTION_UNTHROW:"ट्रासबिनबाट हटाउनुहोस्",ACTION_CLEAR:"स्पष्ट",ACTION_COPY:"प्रतिलिपि",ACTION_EXPORT:"निर्यात",ACTION_IMPORT:"आयात",MESSAGE_COPIED:"क्लिपबोर्डमा प्रतिलिपि गरियो",MESSAGE_CLEARED:"ट्र्यास्बिन सफलतापूर्वक खाली गरियो!",MESSAGE_SONG_ADDED:"गीत ट्र्यास्बिनमा थपियो",MESSAGE_SONG_REMOVED:"ट्र्यासबिनबाट गीत हटाइयो",MESSAGE_ARTIST_ADDED:"कलाकारलाई ट्र्यास्बिनमा थपियो",MESSAGE_ARTIST_REMOVED:"कलाकारलाई फाल्ने डब्बाबाट हटाइयो",BACKUP_SAVE_SUCCESS:"ब्याकअप सफलतापूर्वक सुरक्षित भयो।",BACKUP_SAVE_FAILED:"ब्याकअप बचत गर्न असफल, कृपया ट्र्यासबिनको सामग्री क्लिपबोर्डमा कपि गर्ने र हातले ब्याकअप बनाउने प्रयास गर्नुहोस्।",BACKUP_RESTORE_SUCCESS:"ब्याकअप सफलतापूर्वक पुनर्स्थापित भयो।",BACKUP_FILE_READ_FAILED:"फाइल पढ्न असफल, कृपया सुनिश्चित गर्नुहोस् कि यो वैध जेसन फाइल हो।",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ट्र्यास्बिन+ सेटिङ्हरू",SETTINGS_OPTIONS:"विकल्पहरू",SETTINGS_FEATURES:"विशेषताहरू",SETTINGS_LOCAL_STORAGE:"स्थानीय भण्डारण",SETTINGS_ENABLED:"सक्षम गरिएको",SETTINGS_SHOW_WIDGET:"विजेट आइकन देखाउनुहोस्",SETTINGS_AUTOPLAY:"सुरुमा स्वत: प्ले गर्नुहोस्",SETTINGS_QUEUE_TRASHBIN:"कतार महसुस गर्ने ट्र्यासबिन सक्षम गर्नुहोस्",SETTINGS_TRACKLIST_TRASHBIN:"ट्र्याकलिस्ट ट्र्यास्बिन सक्षम पार्नुहोस्",SETTINGS_PLAYLIST_MONITOR:"प्लेलिस्ट मोनिटर",ITEMS_TITLE:"ट्र्याशबिन+ आइटमहरू",ITEMS_EMPTY_SONGS:"<strong>कुनै मेटिएका गीतहरू छैनन्!</strong><br/>तपाईंले ट्र्यासबिनमा थप्नु भएका गीतहरू यहाँ देखा पर्नेछन्।",ITEMS_EMPTY_ARTISTS:"<strong>कुनै फाल्तु कलाकार छैनन्!</strong><br/>तपाईंले फाल्तुपेटीमा थप्नु भएका कलाकारहरू यहाँ देखा पर्नेछन्।",ITEMS_TAB_SONGS:"गीतहरू",ITEMS_TAB_ARTISTS:"कलाकारहरू",ITEMS_LOADED_COUNT:"{{total}} मध्ये {{loaded}} {{type}} लोड भयो",DESCRIPTION_COPY:"ट्र्यासबिनमा रहेका सबै वस्तुहरू क्लिपबोर्डमा कपि गर्नुहोस्।",DESCRIPTION_EXPORT:"ट्र्यासबिनमा रहेका सबै वस्तुहरूलाई .json फाइलमा सुरक्षित गर्नुहोस्।",DESCRIPTION_IMPORT:"ट्र्यासबिनमा रहेका सबै आइटमहरूलाई .json फाइलबाट ओभरराइट गर्नुहोस्।",DESCRIPTION_CLEAR:"ट्र्यासबिनबाट सबै वस्तुहरू हटाउनुहोस् (फर्काउन सकिँदैन)।",ITEMS_EMPTY_SONGS_TITLE:"कुनै फाल्तु गीतहरू छैनन्!",ITEMS_EMPTY_ARTISTS_TITLE:"कुनै फाल्तु कलाकार छैनन्!",DESCRIPTION_SETTINGS_ENABLED:"सबै ट्र्यास्बिन+ कार्यक्षमता सक्षम वा अक्षम गर्न मास्टर टगल",DESCRIPTION_SETTINGS_SHOW_WIDGET:"हाल चलिरहेको ट्र्याकको प्लेब्याक बारमा छिटो पहुँचका लागि ट्र्यास आइकन प्रदर्शन गर्नुहोस्",DESCRIPTION_SETTINGS_AUTOPLAY:"स्पोटिफाइ खुल्दा वा एक्सटेन्सन लोड हुँदा स्वत: संगीत प्ले गर्न थाल्नुहोस्",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"तपाईंको आगामी कतारमा प्रत्येक गीतको बगैंचा आइकन थप्नुहोस् ताकि सजिलो व्यवस्थापन गर्न सकौं",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"एल्बम र प्लेलिस्टका गीतहरूको बगैचा ट्र्यास आइकनहरू थप्नुहोस् त्वरित फिल्टर गर्नका लागि",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"तपाईंको अन्तिम प्लेलिस्टलाई पुनः सुरु गरेर स्पटिफाइ प्लेब्याकको समस्याबाट स्वतः बरामद गर्नुहोस्",SETTINGS_SKIP_TRASHED_TRACKS:"मेटिएका ट्र्याकहरू छोड्नुहोस्",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"मेटिएका गीतहरूलाई स्वत: छोडेर प्लेब्याकको समयमा अर्को अनुमति प्राप्त ट्र्याक खोज्नुहोस्",SETTINGS_AUTO_CLEAN_QUEUE:"स्वतः सफा कतार",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"तपाईंको स्मार्ट शफल कतारबाट ट्र्यास सङ्गीतहरू स्वतः हटाउनुहोस्",SETTINGS_TRASH_ON_NEXT_HOTKEY:"अर्को हटकि ट्र्यास",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"अर्को ट्र्याकमा जानका लागि Ctrl+Right कीबोर्ड शर्टकट प्रयोग गर्दा स्वचालित रूपमा हालको गीतलाई ट्र्यासमा राख्नुहोस्",SETTINGS_REMOTE_CONTROL:"रिमोट कन्ट्रोल",SETTINGS_REMOTE_TOGGLE:"दूरस्थ टगल सक्षम पार्नुहोस्",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"मोबाइलबाट प्ले/पज दोहोरो ट्याप गरेर रिमोट स्किपिङ स्विच गर्नुहोस्। ट्र्याक स्किपले टगललाई पुष्टि गर्दछ।",SETTINGS_REMOTE_SKIPPING:"दूरस्थ छोड्ने सक्रिय",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"सक्षम गर्दा, अर्को उपकरणबाट (जस्तै, मोबाइल) स्पोटिफाइ नियन्त्रण गर्दा पनि ट्र्यास-छोड्न काम गर्दछ।",MESSAGE_REMOTE_SKIPPING_ENABLED:"दूरस्थ छलाँग लगाउन सक्षम भयो",MESSAGE_REMOTE_SKIPPING_DISABLED:"दूरस्थ स्किपिङ अक्षम गरियो",MESSAGE_SONG_ADDED_REMOTE:"गीत रिमोटबाट नष्ट गरियो",SETTINGS_TRASH_VIA_LIKE:"लाइक मार्फत फाल्तू सामग्री",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"मोबाइलबाट ट्र्यासमा यसलाई लगाउने गीत जस्तै। स्वचालित रूपमा अनलाइक गर्नुहोस् र अर्को ट्र्याकमा जानुहोस्।",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var g8=K((FS,Du)=>{Du.exports={TRASHBIN_NAME:"Prullenbak+",ACTION_THROW:"Plaatsen in prullenbak",ACTION_UNTHROW:"Verwijderen uit prullenbak",ACTION_CLEAR:"Duidelijk",ACTION_COPY:"Kopieer",ACTION_EXPORT:"Export",ACTION_IMPORT:"Importeren",MESSAGE_COPIED:"Gekopieerd naar klembord",MESSAGE_CLEARED:"Prullenbak succesvol geleegd!",MESSAGE_SONG_ADDED:"Nummer toegevoegd aan prullenbak",MESSAGE_SONG_REMOVED:"Nummer verwijderd uit prullenbak",MESSAGE_ARTIST_ADDED:"Artiest toegevoegd aan prullenbak",MESSAGE_ARTIST_REMOVED:"Artiest verwijderd uit prullenbak",BACKUP_SAVE_SUCCESS:"Back-up succesvol opgeslagen.",BACKUP_SAVE_FAILED:"Kon back-up niet opslaan, probeer de inhoud van de prullenbak naar het klembord te kopiëren en handmatig een back-up te maken.",BACKUP_RESTORE_SUCCESS:"Back-up succesvol hersteld.",BACKUP_FILE_READ_FAILED:"Kan het bestand niet lezen, zorg ervoor dat het een geldig JSON-bestand is.",BACKUP_SUGGESTED_FILENAME:"spicetify-prullenbak.json",SETTINGS_TITLE:"Instellingen van Prullenbak+",SETTINGS_OPTIONS:"Opties",SETTINGS_FEATURES:"Kenmerken",SETTINGS_LOCAL_STORAGE:"Lokale opslag",SETTINGS_ENABLED:"Ingeschakeld",SETTINGS_SHOW_WIDGET:"Toon widgetpictogram",SETTINGS_AUTOPLAY:"Automatisch afspelen bij start",SETTINGS_QUEUE_TRASHBIN:"Schakel wachtrijprullenbak in",SETTINGS_TRACKLIST_TRASHBIN:"Schakel Tracklist Prullenbak in",SETTINGS_PLAYLIST_MONITOR:"Afspeellijstmonitor",ITEMS_TITLE:"Prullenbak+ items",ITEMS_EMPTY_SONGS:"<strong>Geen verwijderde nummers!</strong><br/>Nummers die je in de prullenbak plaatst, verschijnen hier.",ITEMS_EMPTY_ARTISTS:"<strong>Geen artiesten verwijderd!</strong><br/>Artiesten die u in de prullenbak plaatst, verschijnen hier.",ITEMS_TAB_SONGS:"Liedjes",ITEMS_TAB_ARTISTS:"Artiesten",ITEMS_LOADED_COUNT:"{{loaded}} van de {{total}} {{type}} geladen",DESCRIPTION_COPY:"Kopieer alle items in de prullenbak naar het klembord.",DESCRIPTION_EXPORT:"Sla alle items in de prullenbak op in een .json-bestand.",DESCRIPTION_IMPORT:"Alle items in de prullenbak overschrijven via .json-bestand.",DESCRIPTION_CLEAR:"Verwijder alle items uit de prullenbak (kan niet ongedaan worden gemaakt).",ITEMS_EMPTY_SONGS_TITLE:"Geen verwijderde nummers!",ITEMS_EMPTY_ARTISTS_TITLE:"Geen afgeschreven artiesten!",DESCRIPTION_SETTINGS_ENABLED:"Hoofdschakelaar om alle prullenbak+-functionaliteit in of uit te schakelen",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Toon een prullenbakpictogram in de afspeelbalk naast het momenteel afgespeelde nummer voor snelle toegang",DESCRIPTION_SETTINGS_AUTOPLAY:"Automatisch muziek afspelen wanneer Spotify opent of de extensie wordt geladen",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Voeg prullenbakpictogrammen toe naast elk nummer in je aankomende wachtrij voor eenvoudig beheer",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Voeg prullenbakpictogrammen toe naast nummers in album- en afspeellijstweergaven voor snel filteren",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Herstel automatisch van problemen met afspelen op Spotify door je laatste afspeellijst te hervatten",SETTINGS_SKIP_TRASHED_TRACKS:"Sla verwijderde nummers over",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Sla automatisch verwijderde nummers over en zoek tijdens het afspelen het volgende toegestane nummer",SETTINGS_AUTO_CLEAN_QUEUE:"Auto Schoonmaak Wachtrij",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Verwijder automatisch verwijderde nummers uit je Smart Shuffle-wachtrij",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Prullenbak bij volgende sneltoets",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Verplaats automatisch het huidige nummer naar de prullenbak wanneer u de toetscombinatie Ctrl+Rechts gebruikt om over te schakelen naar het volgende nummer",SETTINGS_REMOTE_CONTROL:"Afstandsbediening",SETTINGS_REMOTE_TOGGLE:"Schakel externe schakelaar in",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dubbelklik op afspelen/pauzeren vanaf de mobiele telefoon om overgaan op afstand in of uit te schakelen. Het overslaan van een nummer bevestigt de schakeling.",SETTINGS_REMOTE_SKIPPING:"Op afstand overslaan actief",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Wanneer ingeschakeld, werkt het overslaan van prullenbak zelfs wanneer Spotify wordt bediend vanaf een ander apparaat (bijvoorbeeld mobiel)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Afstandsbediening overslaan ingeschakeld",MESSAGE_REMOTE_SKIPPING_DISABLED:"Extern overslaan uitgeschakeld",MESSAGE_SONG_ADDED_REMOTE:"Nummer vernietigd via afstandsbediening",SETTINGS_TRASH_VIA_LIKE:"Afval via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Net als een nummer van mobiel naar prullenbak. Automatisch verwijderd uit de favorieten en overslaan naar het volgende nummer.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var s8=K((ZS,Gu)=>{Gu.exports={TRASHBIN_NAME:"ଟ୍ରାସ୍ବିନ୍+",ACTION_THROW:"କଚଡ଼ା ଡବାରେ ରଖନ୍ତୁ",ACTION_UNTHROW:"ଟ୍ରାସ୍ ବିନରୁ ଅପସାରଣ କରନ୍ତୁ",ACTION_CLEAR:"ସ୍ପଷ୍ଟ",ACTION_COPY:"କପି",ACTION_EXPORT:"ରପ୍ତାନି କରନ୍ତୁ",ACTION_IMPORT:"ଆମଦାନୀ କରନ୍ତୁ",MESSAGE_COPIED:"କ୍ଲିପବୋର୍ଡକୁ କପି କରାଯାଇଛି",MESSAGE_CLEARED:"ଟ୍ରାସ୍ ବିନ୍ ସଫଳତାର ସହ ଖାଲି ହୋଇଗଲା!",MESSAGE_SONG_ADDED:"ଗୀତଟି କଚରାଦାନରେ ଯୋଗ କରାଯାଇଛି",MESSAGE_SONG_REMOVED:"ଟ୍ରାସ୍ବିନରୁ ଗୀତ ଅପସାରଣ କରାଯାଇଛି",MESSAGE_ARTIST_ADDED:"କଳାକାରଙ୍କୁ କଚରା ଡବାରେ ଯୋଗ କରାଯାଇଛି",MESSAGE_ARTIST_REMOVED:"କଳାକାରଙ୍କୁ କଚରା ଡବାରୁ ହଟାଯାଇଛି",BACKUP_SAVE_SUCCESS:"ସଫଳତାର ସହ ବ୍ୟାକଅପ୍ ସଂରକ୍ଷିତ ହୋଇଛି।",BACKUP_SAVE_FAILED:"ବ୍ୟାକଅପ୍ ସେଭ୍ କରିବାରେ ବିଫଳ ହୋଇଛି, ଟ୍ରାସ୍ ବିନ୍‌ର ବିଷୟବସ୍ତୁଗୁଡ଼ିକୁ କ୍ଲିପବୋର୍ଡକୁ କପି କରିବା ଏବଂ ଏକ ବ୍ୟାକଅପ୍ ମ୍ୟାନୁଆଲ୍ ଭାବରେ ତିଆରି କରିବାକୁ ଚେଷ୍ଟା କରନ୍ତୁ।",BACKUP_RESTORE_SUCCESS:"ସଫଳତାର ସହ ବ୍ୟାକଅପ ପୁନର୍ସ୍ଥାପନ କରାଯାଇଛି।",BACKUP_FILE_READ_FAILED:"ଫାଇଲ୍ ପଢିବାରେ ବିଫଳ ହୋଇଛି, ଦୟାକରି ନିଶ୍ଚିତ କରନ୍ତୁ ଏହା ଏକ ବୈଧ JSON ଫାଇଲ୍ ଅଟେ।",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ଟ୍ରାସ୍ବିନ୍+ ସେଟିଂସ୍",SETTINGS_OPTIONS:"ବିକଳ୍ପଗୁଡ଼ିକ",SETTINGS_FEATURES:"ବୈଶିଷ୍ଟ୍ୟଗୁଡ଼ିକ",SETTINGS_LOCAL_STORAGE:"ସ୍ଥାନୀୟ ଷ୍ଟୋରେଜ୍",SETTINGS_ENABLED:"ସକ୍ଷମ କରାଯାଇଛି",SETTINGS_SHOW_WIDGET:"ଉଇଜିଟ୍ ଆଇକନ ଦର୍ଶାନ୍ତୁ",SETTINGS_AUTOPLAY:"ଆରମ୍ଭରେ ସ୍ୱତଃ ପ୍ଲେ ଚାଲୁ କରନ୍ତୁ",SETTINGS_QUEUE_TRASHBIN:"ସ୍ଥଗିତ କରିବା ପାଇଁ କଚରା ଡବା ସକ୍ରିୟ କରନ୍ତୁ",SETTINGS_TRACKLIST_TRASHBIN:"ଟ୍ରାକ୍ଲିଷ୍ଟ କଚରାଦାନୀ ସକ୍ରିୟ କରନ୍ତୁ",SETTINGS_PLAYLIST_MONITOR:"ପ୍ଲେଲିଷ୍ଟ ମନିଟର୍",ITEMS_TITLE:"ଟ୍ରାସ୍‌ବିନ୍+ ଆଇଟମ୍‌ଗୁଡ଼ିକ",ITEMS_EMPTY_SONGS:"<strong>କ no ଟ୍ରାସ୍ କରାଯାଇଥିବା ଗୀତ ନାହିଁ!</strong><br/>ଯେଉଁ ଗୀତଗୁଡ଼ିକୁ ଆପଣ ଟ୍ରାସ୍ ବାକ୍ସରେ ଯୋଗ କରିବେ ସେଗୁଡ଼ିକ ଏଠାରେ ଦେଖାଯିବ।",ITEMS_EMPTY_ARTISTS:"<strong>କୌଣସି ଫୋପାଡ଼ିଦିଆଯାଇଥିବା କଳାକାର ନାହାଁନ୍ତି!</strong><br/>ଯେଉଁ କଳାକାରମାନଙ୍କୁ ଆପଣ କଚାଡ଼ା ଡବାରେ ଯୋଗ କରିବେ, ସେମାନେ ଏଠାରେ ଦେଖାଯିବେ।",ITEMS_TAB_SONGS:"ଗୀତମାନେ",ITEMS_TAB_ARTISTS:"କଳାକାରମାନେ",ITEMS_LOADED_COUNT:"{{total}} ମଧ୍ୟରୁ {{loaded}} {{type}} ଲୋଡ୍ ହୋଇଛି",DESCRIPTION_COPY:"ଅପସାରଣ ପଟ୍ଟିକାରେ ଥିବା ସମସ୍ତ ଆଇଟମକୁ କ୍ଲିପବୋର୍ଡକୁ କପି କରନ୍ତୁ।",DESCRIPTION_EXPORT:"ଟ୍ରାସ୍ବିନରେ ସମସ୍ତ ଆଇଟମଗୁଡ଼ିକୁ ଏକ .json ଫାଇଲରେ ସେଭ୍ କରନ୍ତୁ।",DESCRIPTION_IMPORT:"ଟ୍ରାସ୍ ବିନ୍ ରେ ଥିବା ସମସ୍ତ ଆଇଟମ୍ କୁ .json ଫାଇଲ୍ ଦ୍ୱାରା ଓଭରରାଇଟ୍ କରନ୍ତୁ।",DESCRIPTION_CLEAR:"ଅପସାରଣ ବାକ୍ସରୁ ସମସ୍ତ ଆଇଟମକୁ ହଟାନ୍ତୁ (ପୁନର୍ସ୍ଥାପନ କରାଯାଇପାରିବ ନାହିଁ)।",ITEMS_EMPTY_SONGS_TITLE:"କୌଣସି ଫୋପାଡ଼ି ଦିଆଯାଇଥିବା ଗୀତ ନାହିଁ!",ITEMS_EMPTY_ARTISTS_TITLE:"କୌଣସି ନିର୍ଯ୍ୟାତନା କଳାକାର ନାହିଁ!",DESCRIPTION_SETTINGS_ENABLED:"ସମସ୍ତ ଟ୍ରାସ୍ବିନ୍+ କାର୍ଯ୍ୟକାରିତା ସକ୍ଷମ କରିବା କିମ୍ବା ଅକ୍ଷମ କରିବା ପାଇଁ ମାଷ୍ଟର ଟଗଲ୍",DESCRIPTION_SETTINGS_SHOW_WIDGET:"ଚଳିତ ଟ୍ରାକ୍ ପାଖାପାଖି ପ୍ଲେବ୍ୟାକ୍ ବାରରେ ଏକ କଚରା ଆଇକନ୍ ପ୍ରଦର୍ଶନ କରନ୍ତୁ ଯାହା ଦ୍ରୁତ ପହଞ୍ଚ ପାଇଁ ଅଟେ",DESCRIPTION_SETTINGS_AUTOPLAY:"ସ୍ପଟିଫାଏ ଖୋଲିବା କିମ୍ବା ଏକ୍ସଟେନ୍ସନ୍ ଲୋଡ୍ ହେବା ମାତ୍ରେ ସ୍ୱତଃ ସଙ୍ଗୀତ ଚଳାନ୍ତୁ କରନ୍ତୁ",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"ନିମ୍ନସ୍ଥ ପାଇଁ ଆପଣଙ୍କ ପାଇଁ ପ୍ରତ୍ୟେକ ଗୀତ ପାଖରେ କଚରା ଆଇକନ ଯୋଗ କରନ୍ତୁ ସହଜ ପରିଚାଳନା ପାଇଁ",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"ଆଲବମ୍ ଏବଂ ପ୍ଲେ ଲିଷ୍ଟ୍ ଦୃଶ୍ୟରେ ଗୀତ ପାଖରେ କଚରା ଆଇକନ୍ ଗୁଡ଼ିକୁ ଯୋଗ କରନ୍ତୁ ଯାହା ଦ୍ରୁତ ଫିଲ୍ଟରିଂ ପାଇଁ ସାହାଯ୍ୟ କରିବ।",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"ଶେଷ ପ୍ଲେଲିଷ୍ଟକୁ ପୁନଃସ୍ଥାପନ କରି ସ୍ପଟିଫାଏରେ ପ୍ଲେବ୍ୟାକ୍ ତ୍ରୁଟିରୁ ସ୍ୱତଃ ପୁନରୁଦ୍ଧାର କରନ୍ତୁ",SETTINGS_SKIP_TRASHED_TRACKS:"ଟ୍ରାଷ୍ କରାଯାଇଥିବା ଟ୍ରାକ୍ ଗୁଡ଼ିକ ବାଦ ଦିଅନ୍ତୁ",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"ସ୍ୱତଃ ଫୋପାଡ଼ି ଦିଆଯାଇଥିବା ଗୀତଗୁଡ଼ିକୁ ବାଦ୍ ଦିଅନ୍ତୁ ଏବଂ ପ୍ଲେବ୍ୟାକ୍ ଚାଲିଥିବା ସମୟରେ ପରବର୍ତ୍ତୀ ଅନୁମତିପ୍ରାପ୍ତ ଟ୍ରାକ୍ ଖୋଜନ୍ତୁ",SETTINGS_AUTO_CLEAN_QUEUE:"ସ୍ୱଚାଳିତ ସଫା ପାଇଁ ଅପେକ୍ଷାରତ ତାଲିକା",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"ସ୍ୱଚାଳିତ ଭାବରେ ଆପଣଙ୍କ ସ୍ମାର୍ଟ ଶଫଲ୍ ପାଇଁ ଟ୍ରାସ୍ କରାଯାଇଥିବା ଗୀତଗୁଡ଼ିକୁ ଅପସାରଣ କରନ୍ତୁ",SETTINGS_TRASH_ON_NEXT_HOTKEY:"ପରବର୍ତ୍ତୀ ହଟକିର ଅପଠନୀୟ ତଥ୍ୟ ଉପରେ",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"ଅଗ୍ରଗାମୀ ଟ୍ରାକକୁ ଯିବାକୁ Ctrl+Right କୀବୋର୍ଡ ଶର୍ଟକଟ ବ୍ୟବହାର କରିବା ସମୟରେ ବର୍ତ୍ତମାନ ଗୀତକୁ ସ୍ୱତଃ ଅପସାରଣ କରନ୍ତୁ",SETTINGS_REMOTE_CONTROL:"ଦୂରବର୍ତ୍ତୀ ନିୟନ୍ତ୍ରଣ",SETTINGS_REMOTE_TOGGLE:"ଦୂରବର୍ତ୍ତୀ ଟଗଲ୍ ସକ୍ଷମ କରନ୍ତୁ",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"ମୋବାଇଲରୁ ରିମୋଟ ସ୍କିପିଂକୁ ଚାଲୁ କରିବା କିମ୍ବା ବନ୍ଦ କରିବା ପାଇଁ ପ୍ଲେ/ପଜ ଉପରେ ଦୁଇଥର ଟ୍ୟାପ୍ କରନ୍ତୁ। ଏକ ଟ୍ରାକ୍ ସ୍କିପ୍ ଟଗଲ୍ ପାଇଁ ନିଶ୍ଚିତ କରେ।",SETTINGS_REMOTE_SKIPPING:"ଦୂରବର୍ତ୍ତୀ ଅତିକ୍ରମଣ ସକ୍ରିୟ ଅଛି",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"ସକ୍ଷମ ହେଲେ, ଅନ୍ୟ ଡିଭାଇସ୍ (ଉଦା: ମୋବାଇଲ୍) ରୁ Spotify କୁ ନିୟନ୍ତ୍ରଣ କରିବା ସମୟରେ ମଧ୍ୟ ଟ୍ରାସ୍-ଅତିକ୍ରମଣ କାର୍ଯ୍ୟ କରେ।",MESSAGE_REMOTE_SKIPPING_ENABLED:"ଦୂରବର୍ତ୍ତୀ ଅତିକ୍ରମଣ ସକ୍ଷମ ହୋଇଛି",MESSAGE_REMOTE_SKIPPING_DISABLED:"ଦୂରବର୍ତ୍ତୀ ଅତିକ୍ରମଣ ଅକ୍ଷମ କରାଯାଇଛି",MESSAGE_SONG_ADDED_REMOTE:"ସଙ୍ଗୀତକୁ ଦୂରବର୍ତ୍ତୀ ମାଧ୍ୟମରେ ନଷ୍ଟ କରାଯାଇଛି",SETTINGS_TRASH_VIA_LIKE:"ଲାଇକ୍ ମାଧ୍ୟମରେ କଚରା",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"ଏକ ଗୀତ ଭଳି ମୋବାଇଲରୁ ଏହାକୁ ଫୋପାଡ଼ନ୍ତୁ। ସ୍ୱତଃ ଅସମର୍ଥନ କରି ପରବର୍ତ୍ତୀ ଟ୍ରାକକୁ ଯାଏ।",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var p8=K((yS,Pu)=>{Pu.exports={TRASHBIN_NAME:"ਕਚਰਾ ਬੰਦ+",ACTION_THROW:"ਕੂੜੇਦਾਨ ਵਿੱਚ ਪਾਓ",ACTION_UNTHROW:"ਕੂੜੇਦਾਨ ਤੋਂ ਹਟਾਓ",ACTION_CLEAR:"ਸਪਸ਼ਟ",ACTION_COPY:"ਕਾਪੀ",ACTION_EXPORT:"ਨਿਰਯਾਤ",ACTION_IMPORT:"ਆਯਾਤ ਕਰੋ",MESSAGE_COPIED:"ਕਲਿੱਪਬੋਰਡ 'ਤੇ ਕਾਪੀ ਕੀਤਾ",MESSAGE_CLEARED:"ਕੂੜਾਦਾਨ ਸਫਲਤਾਪੂਰਵਕ ਖਾਲੀ ਕੀਤਾ ਗਿਆ!",MESSAGE_SONG_ADDED:"ਗੀਤ ਨੂੰ ਕੂੜੇਦਾਨ ਵਿੱਚ ਸ਼ਾਮਲ ਕੀਤਾ ਗਿਆ",MESSAGE_SONG_REMOVED:"ਗੀਤ ਨੂੰ ਕੂੜੇਦਾਨ ਤੋਂ ਹਟਾ ਦਿੱਤਾ ਗਿਆ",MESSAGE_ARTIST_ADDED:"ਕਲਾਕਾਰ ਨੂੰ ਕੂੜੇਦਾਨ ਵਿੱਚ ਸ਼ਾਮਲ ਕੀਤਾ ਗਿਆ",MESSAGE_ARTIST_REMOVED:"ਕਲਾਕਾਰ ਨੂੰ ਕੂੜੇਦਾਨ ਤੋਂ ਹਟਾ ਦਿੱਤਾ ਗਿਆ",BACKUP_SAVE_SUCCESS:"ਬੈਕਅੱਪ ਸਫਲਤਾਪੂਰਵਕ ਸੰਭਾਲਿਆ ਗਿਆ।",BACKUP_SAVE_FAILED:"ਬੈਕਅਪ ਸੇਵ ਕਰਨ ਵਿੱਚ ਅਸਫਲ, ਟਰੈਸ਼ਬਿਨ ਦੀ ਸਮੱਗਰੀ ਨੂੰ ਕਲਿੱਪਬੋਰਡ 'ਤੇ ਕਾਪੀ ਕਰਨ ਦੀ ਕੋਸ਼ਿਸ਼ ਕਰੋ ਅਤੇ ਮੈਨੂਅਲ ਤੌਰ 'ਤੇ ਬੈਕਅਪ ਬਣਾਓ।",BACKUP_RESTORE_SUCCESS:"ਬੈਕਅੱਪ ਸਫਲਤਾਪੂਰਵਕ ਬਹਾਲ ਕੀਤਾ ਗਿਆ।",BACKUP_FILE_READ_FAILED:"ਫਾਇਲ ਪੜ੍ਹਨ ਵਿੱਚ ਅਸਫਲ, ਕਿਰਪਾ ਕਰਕੇ ਯਕੀਨੀ ਬਣਾਓ ਕਿ ਇਹ ਇੱਕ ਵੈਧ JSON ਫਾਇਲ ਹੈ।",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ਟਰੈਸ਼ਬਿਨ+ ਸੈਟਿੰਗਸ",SETTINGS_OPTIONS:"ਚੋਣਾਂ",SETTINGS_FEATURES:"ਵਿਸ਼ੇਸ਼ਤਾਵਾਂ",SETTINGS_LOCAL_STORAGE:"ਸਥਾਨਕ ਸਟੋਰੇਜ਼",SETTINGS_ENABLED:"ਸਮਰੱਥ ਕੀਤਾ",SETTINGS_SHOW_WIDGET:"ਵਿਜ਼ੇਟ ਆਈਕਾਨ ਵੇਖਾਓ",SETTINGS_AUTOPLAY:"ਸ਼ੁਰੂਆਤ 'ਤੇ ਆਟੋਪਲੇ ਚਾਲੂ ਕਰੋ",SETTINGS_QUEUE_TRASHBIN:"ਕਤਾਰ ਕੂੜਾਦਾਨ ਸਮਰੱਥ ਕਰੋ",SETTINGS_TRACKLIST_TRASHBIN:"ਟਰੈਕਲਿਸਟ ਟਰੈਸ਼ਬਿਨ ਨੂੰ ਸਮਰੱਥ ਕਰੋ",SETTINGS_PLAYLIST_MONITOR:"ਪਲੇਲਿਸਟ ਮਾਨੀਟਰ",ITEMS_TITLE:"ਕਚਰਾ ਬਕਸਾ+ ਆਈਟਮਾਂ",ITEMS_EMPTY_SONGS:"<strong>ਕੋਈ ਖਾਰਬ ਗੀਤ ਨਹੀਂ!</strong><br/>ਤੁਸੀਂ ਕੂੜੇਦਾਨ ਵਿੱਚ ਸ਼ਾਮਲ ਕੀਤੇ ਗੀਤ ਇੱਥੇ ਦਿਖਾਈ ਦੇਣਗੇ।",ITEMS_EMPTY_ARTISTS:"<strong>ਕੋਈ ਫੇਕੇ ਹੋਏ ਕਲਾਕਾਰ ਨਹੀਂ!</strong><br/>ਕਲਾਕਾਰ ਜਿਨ੍ਹਾਂ ਨੂੰ ਤੁਸੀਂ ਰੱਦੀ ਦੇ ਡੱਬੇ ਵਿੱਚ ਸ਼ਾਮਲ ਕਰਦੇ ਹੋ ਇੱਥੇ ਦਿਖਾਈ ਦੇਣਗੇ।",ITEMS_TAB_SONGS:"ਗੀਤ",ITEMS_TAB_ARTISTS:"ਕਲਾਕਾਰ",ITEMS_LOADED_COUNT:"{{total}} ਵਿੱਚੋਂ {{loaded}} {{type}} ਲੋਡ ਹੋਇਆ",DESCRIPTION_COPY:"ਟਰੈਸ਼ਬਿਨ ਵਿੱਚ ਸਾਰੀਆਂ ਚੀਜ਼ਾਂ ਨੂੰ ਕਲਿੱਪਬੋਰਡ 'ਤੇ ਕਾਪੀ ਕਰੋ।",DESCRIPTION_EXPORT:"ਕੂੜੇਦਾਨ ਵਿੱਚ ਸਾਰੀਆਂ ਚੀਜ਼ਾਂ ਨੂੰ .json ਫਾਇਲ ਵਿੱਚ ਸੰਭਾਲੋ।",DESCRIPTION_IMPORT:"ਕੂੜੇਦਾਨ ਵਿੱਚ ਸਾਰੀਆਂ ਚੀਜ਼ਾਂ ਨੂੰ .json ਫਾਈਲ ਰਾਹੀਂ ਓਵਰਰਾਈਟ ਕਰੋ।",DESCRIPTION_CLEAR:"ਕੂੜੇਦਾਨ ਤੋਂ ਸਾਰੀਆਂ ਚੀਜ਼ਾਂ ਨੂੰ ਹਟਾਓ (ਵਾਪਸ ਨਹੀਂ ਕੀਤਾ ਜਾ ਸਕਦਾ)।",ITEMS_EMPTY_SONGS_TITLE:"ਕੋਈ ਖਰਾਬ ਗੀਤ ਨਹੀਂ!",ITEMS_EMPTY_ARTISTS_TITLE:"ਕੋਈ ਫੇਕੇ ਕਲਾਕਾਰ ਨਹੀਂ!",DESCRIPTION_SETTINGS_ENABLED:"ਸਭ ਟਰੈਸ਼ਬਿਨ + ਕਾਰਜਸ਼ੀਲਤਾ ਨੂੰ ਸਮਰੱਥ ਜਾਂ ਅਯੋਗ ਕਰਨ ਲਈ ਮਾਸਟਰ ਟੌਗਲ",DESCRIPTION_SETTINGS_SHOW_WIDGET:"ਚਲ ਰਹੇ ਟਰੈਕ ਦੇ ਨੇੜੇ ਪਲੇਬੈਕ ਬਾਰ ਵਿੱਚ ਤੇਜ਼ ਪਹੁੰਚ ਲਈ ਇੱਕ ਕੂੜਾ ਆਈਕਾਨ ਵੇਖਾਓ",DESCRIPTION_SETTINGS_AUTOPLAY:"ਸਪਾਟੀਫਾਈ ਖੁੱਲ੍ਹਣ ਜਾਂ ਐਕਸਟੈਂਸ਼ਨ ਲੋਡ ਹੋਣ 'ਤੇ ਆਟੋਮੈਟਿਕ ਤੌਰ 'ਤੇ ਸੰਗੀਤ ਚਲਾਉਣਾ ਸ਼ੁਰੂ ਕਰੋ",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"ਆਪਣੀ ਆਉਣ ਵਾਲੀ ਕਤਾਰ ਵਿੱਚ ਹਰੇਕ ਗੀਤ ਦੇ ਨਾਲ-ਨਾਲ ਕਚਰਾ ਆਈਕਨ ਸ਼ਾਮਲ ਕਰੋ ਤਾਂ ਜੋ ਆਸਾਨੀ ਨਾਲ ਪਰਬੰਧ ਕੀਤਾ ਜਾ ਸਕੇ",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"ਐਲਬਮ ਅਤੇ ਪਲੇਲਿਸਟ ਵਿਊਜ਼ ਵਿੱਚ ਗੀਤਾਂ ਦੇ ਨਾਲ-ਨਾਲ ਕਚਰਾ ਆਈਕਾਨ ਸ਼ਾਮਲ ਕਰੋ ਤਾਂ ਜੋ ਤੁਰੰਤ ਫਿਲਟਰਿੰਗ ਕੀਤੀ ਜਾ ਸਕੇ",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"ਆਪਣੀ ਆਖਰੀ ਪਲੇਲਿਸਟ ਨੂੰ ਦੁਬਾਰਾ ਸ਼ੁਰੂ ਕਰਕੇ ਸਪੌਟੀਫਾਈ ਪਲੇਬੈਕ ਦੀਆਂ ਗਲਤੀਆਂ ਤੋਂ ਆਪਮੁਹਾਰਾ ਠੀਕ ਹੋ ਜਾਓ",SETTINGS_SKIP_TRASHED_TRACKS:"ਖਾਰਬ ਕੀਤੀਆਂ ਟਰੈਕਾਂ ਨੂੰ ਛੱਡੋ",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"ਖੇਡਣ ਦੇ ਦੌਰਾਨ ਮਿਟਾਏ ਗਏ ਗੀਤਾਂ ਨੂੰ ਆਟੋਮੈਟਿਕ ਤੌਰ 'ਤੇ ਛੱਡ ਦਿਓ ਅਤੇ ਅਗਲੀ ਆਗਿਆ ਵਾਲੀ ਟਰੈਕ ਲੱਭੋ",SETTINGS_AUTO_CLEAN_QUEUE:"ਆਟੋ ਸਾਫ਼ ਕਤਾਰ",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"ਆਪਣੀ ਸਮਾਰਟ ਸ਼ਫਲ ਕਤਾਰ ਤੋਂ ਕੂੜੇਦਾਨ ਵਿੱਚ ਪਏ ਗੀਤਾਂ ਨੂੰ ਆਪਮੇਲੇ ਹਟਾਓ",SETTINGS_TRASH_ON_NEXT_HOTKEY:"ਅਗਲੇ ਹੌਟਕੀ 'ਤੇ ਕਚਰਾ",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"ਮੌਜੂਦਾ ਗੀਤ ਨੂੰ ਅਗਲੇ ਟਰੈਕ ਤੇ ਜਾਣ ਲਈ Ctrl+Right ਕੀਬੋਰਡ ਸ਼ਾਰਟਕੱਟ ਵਰਤਦੇ ਹੋਏ ਆਟੋਮੈਟਿਕ ਤੌਰ 'ਤੇ ਤਰੈਸ਼ ਕਰੋ",SETTINGS_REMOTE_CONTROL:"ਰਿਮੋਟ ਕੰਟਰੋਲ",SETTINGS_REMOTE_TOGGLE:"ਰਿਮੋਟ ਟੌਗਲ ਨੂੰ ਸਮਰੱਥ ਕਰੋ",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"ਮੋਬਾਈਲ ਤੋਂ ਪਲੇ/ਰੋਕੋ ਨੂੰ ਟੌਗਲ ਕਰਨ ਲਈ ਡਬਲ-ਟੈਪ ਕਰੋ। ਟਰੈਕ ਸਕਿੱਪ ਕਰਨਾ ਟੌਗਲ ਨੂੰ ਪੁਸ਼ਟੀ ਕਰਦਾ ਹੈ।",SETTINGS_REMOTE_SKIPPING:"ਰਿਮੋਟ ਸਕਿੱਪਿੰਗ ਸਰਗਰਮ",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"ਜਦੋਂ ਚਾਲੂ ਕੀਤਾ ਜਾਂਦਾ ਹੈ, ਤਾਂ ਕਚਰਾ-ਛਾਲ ਕਿਸੇ ਹੋਰ ਡਿਵਾਈਸ (ਉਦਾਹਰਣ ਵਜੋਂ, ਮੋਬਾਈਲ) ਤੋਂ ਸਪੌਟੀਫਾਈ ਨੂੰ ਨਿਯੰਤਰਿਤ ਕਰਨ ਦੇ ਦੌਰਾਨ ਵੀ ਕੰਮ ਕਰਦਾ ਹੈ",MESSAGE_REMOTE_SKIPPING_ENABLED:"ਰਿਮੋਟ ਸਕਿੱਪਿੰਗ ਸਮਰੱਥ ਕੀਤੀ ਗਈ",MESSAGE_REMOTE_SKIPPING_DISABLED:"ਦੂਰਦਰਾਜ਼ ਛਾਲ ਅਯੋਗ ਕੀਤਾ ਗਿਆ",MESSAGE_SONG_ADDED_REMOTE:"ਗੀਤ ਰਿਮੋਟ ਰਾਹੀਂ ਖਰਾਬ ਕੀਤਾ ਗਿਆ",SETTINGS_TRASH_VIA_LIKE:"ਲਾਈਕ ਰਾਹੀਂ ਕਚਰਾ",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"ਮੋਬਾਈਲ ਤੋਂ ਟਰੈਸ਼ ਕਰਨ ਲਈ ਇੱਕ ਗੀਤ ਵਾਂਗ। ਆਪਣੇ ਆਪ ਅਣਲਾਈਕ ਕਰਦਾ ਹੈ ਅਤੇ ਅਗਲੇ ਟਰੈਕ 'ਤੇ ਛਾਲ ਮਾਰਦਾ ਹੈ।",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var S8=K((bS,Fu)=>{Fu.exports={TRASHBIN_NAME:"کوڑا دا ڈبہ+",ACTION_THROW:"کوڑا دان وچ رکھو",ACTION_UNTHROW:"اِس نوں کوڑا دان توں ہٹا دو",ACTION_CLEAR:"صاف",ACTION_COPY:"نقل کرو",ACTION_EXPORT:"برآمد کرو",ACTION_IMPORT:"درآمد کرو",MESSAGE_COPIED:"کاپی کیبورڈ تے کاپی کیتی گئی",MESSAGE_CLEARED:"کوڑا دان کامیابی نال صاف کر دتا گیا!",MESSAGE_SONG_ADDED:"گانا کوڑے دے ڈبے وچ شامل کیتا گیا",MESSAGE_SONG_REMOVED:"گانا کوڑا دان توں ہٹا دتا گیا",MESSAGE_ARTIST_ADDED:"آرٹسٹ نوں کوڑا دان وچ شامل کیتا گیا",MESSAGE_ARTIST_REMOVED:"آرٹسٹ کو کوڑا دان توں ہٹا دتا گیا",BACKUP_SAVE_SUCCESS:"بیک اپ کامیابی نال محفوظ ہو گیا۔",BACKUP_SAVE_FAILED:"بیک اپ نوں محفوظ کرنے وچ ناکامی، ٹریش بین دے مواد نوں کلپ بورڈ اُتے کاپی کرن دی کوشش کرو تے دستی طور اُتے بیک اپ بناؤ۔",BACKUP_RESTORE_SUCCESS:"بیک اپ کامیابی نال بحال کيتا گیا۔",BACKUP_FILE_READ_FAILED:"فائل پڑھن چ فیل، براہ کرم یقینی بنائیں کہ ایہہ درست جے سون فائل اے۔",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ترتھبِن+ سیٹنگز",SETTINGS_OPTIONS:"آپشنز",SETTINGS_FEATURES:"خوبیاں",SETTINGS_LOCAL_STORAGE:"مقامی اسٹوریج",SETTINGS_ENABLED:"چالو کیتہ ہویا",SETTINGS_SHOW_WIDGET:"واجیٹ آئیکن دکھائیں",SETTINGS_AUTOPLAY:"شروع وچ خودکار چلانا",SETTINGS_QUEUE_TRASHBIN:"کیو ٹریش بین چالو کرو",SETTINGS_TRACKLIST_TRASHBIN:"ٹریک لسٹ دا کوڑا دا ڈبہ چالو کرو",SETTINGS_PLAYLIST_MONITOR:"پلی لسٹ مانیٹر",ITEMS_TITLE:"کوڑا دباں + اشیاء",ITEMS_EMPTY_SONGS:"<strong>کوئی وی رَدّ کیتا گیتا گانا نہیں!</strong><br/>جہڑے گانے تساں کوڑا دان وچ ڈالدے ہو، ایتھے دسدے نیں۔",ITEMS_EMPTY_ARTISTS:"<strong>کوئی تباہ شدہ آرٹسٹ نہیں!</strong><br/>جِن آرٹسٹاں نوں تُساں کوڑا دان وچ شامل کرو گے او اِتھے دِسّ جاواں گے۔",ITEMS_TAB_SONGS:"گیت",ITEMS_TAB_ARTISTS:"فنکار",ITEMS_LOADED_COUNT:"{{total}} وچوں {{loaded}} {{type}} لوڈ ہو گیا",DESCRIPTION_COPY:"کوڑا دھکّے وچّ ساریاں چیزاں کلاپ بورڈ تے کاپی کروؤ۔",DESCRIPTION_EXPORT:"کوڑا دھکھیاں وچ تمام اشیاء نوں اک .json فائل وچ سیو کرو۔",DESCRIPTION_IMPORT:"کوڑے دے ڈبے وچ ساریاں چیزاں نوں .json فائل راہیں تبدیل کرو۔",DESCRIPTION_CLEAR:"کوڑا دان توں تمام شےواں کڈو (واپس نہیں کیتی جا سکدی)۔",ITEMS_EMPTY_SONGS_TITLE:"ਕੋਈ ਖਰਾਬ ਗੀਤ ਨਹੀਂ!",ITEMS_EMPTY_ARTISTS_TITLE:"ਕੋਈ ਫੇਹੇ ਹੋਏ ਕਲਾਕਾਰ ਨਹੀਂ!",DESCRIPTION_SETTINGS_ENABLED:"تمام ٹریش بین + کمیتیاں نوں چالو یا بند کرن دے لئی ماسٹر ٹوگل",DESCRIPTION_SETTINGS_SHOW_WIDGET:"موجودہ ویلے وچ چل رہی ٹریک دے نال نال پلی بیک بار وچ ترش آئیکن نوں دکھاؤ تاکہ تیزی توں رسائی ممکن ہو سکے",DESCRIPTION_SETTINGS_AUTOPLAY:"جدوں سپاٹیفائی کھلدا اے جاں ایکਸٹینشن لوڈ ہندا اے تاں خودکار طور تے میوزک چلاوݨا شروع کروؤ",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"اپنی آؤندی قطار وچ ہر گانے دے نال کوڑا دا آئیکن شامل کرو تاکہ آسانی نال انتظام کیتا جا سکے",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"البم اتے پلے لسٹ ویوراں وچ گانویں دے نال کوڑا دا آئیکن شامل کرو تاکہ تیزی نال فلٹرنگ کیتی جا سکے",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"سپاٹیفائی چلاؤن دیاں خرابیاں توں آٹومیٹک طور تے وابستہ ہووو جدوں تک جاری رکھو اوہناں دی آخیری پلے لسٹ",SETTINGS_SKIP_TRASHED_TRACKS:"توڑے ہوئے ٹریکس نوں چھڈو",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"خودکار طور تے تباہ شدہ گانوں نوں چھڈ کے اگلا منظور شدہ ٹریک چلاوݨ دے دوران چلاوݨ لئی تلاش کرو",SETTINGS_AUTO_CLEAN_QUEUE:"ਆਟੋ ਸਾਫ਼ ਕਤਾਰ",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"اپنی اسمارٹ شفل کی کیو توں کوڑا گھٹائی والے گیت خودکار طور تے ہٹا دیؤ",SETTINGS_TRASH_ON_NEXT_HOTKEY:"اگلے ہاٹ کی تے کوڑا کرکٹ",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"موجودہ گانا خود بخود ٹریش کرو جدوں اگلے ٹریک تے جان لئی Ctrl+Right کیبورڈ شارٹ کٹ استعمال کرو",SETTINGS_REMOTE_CONTROL:"دور کنٹرول",SETTINGS_REMOTE_TOGGLE:"دور دراز کنٹرول ٹوگل کریں",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"موبائل توں پلے/روکو نوں ڈبل ٹیپ کرو تاں ریموٹ اُتے سکِپ کرن دی تبدیلی ہووے گی۔ اک ٹریک سکِپ کرنا تبدی�ی نوں تصدیق کرے گا۔",SETTINGS_REMOTE_SKIPPING:"دور دراز عبور کرنا فعال ہے",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"جب چالو ہووے تاں، کوڑا کرکٹ چھڈݨ دا کم کسے وی دوجے آلے توں سپاٹیفائی نوں کنٹرول کردے ہوئے وی کم کردا ہے (مثلاً، موبائل)",MESSAGE_REMOTE_SKIPPING_ENABLED:"دور دراز تون چھلانگ دی اجازت دتی گئی",MESSAGE_REMOTE_SKIPPING_DISABLED:"دور دراز تون چھلانگ دی اجازت منسوخ کر دتی گئی ہے",MESSAGE_SONG_ADDED_REMOTE:"گانا دور درشن توں تباہ کر دتا گیا",SETTINGS_TRASH_VIA_LIKE:"لائیک دے ذریعے کوڑا کرکٹ",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"موبائل توں ٹریش تک اک گانا وانگ جیوہ۔ خودکار طور تے ناپسند کر دے اتے اگلے ٹریک تے چلے جا۔",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var M8=K((jS,Zu)=>{Zu.exports={TRASHBIN_NAME:"Kosz+",ACTION_THROW:"Umieść w koszu na śmieci",ACTION_UNTHROW:"Usuń z kosza na śmieci",ACTION_CLEAR:"Wyczyść",ACTION_COPY:"Kopiuj",ACTION_EXPORT:"Eksport",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Skopiowane do schowka",MESSAGE_CLEARED:"Kosz został pomyślnie opróżniony!",MESSAGE_SONG_ADDED:"Piosenka dodana do kosza",MESSAGE_SONG_REMOVED:"Piosenka usunięta z kosza",MESSAGE_ARTIST_ADDED:"Artysta dodany do kosza",MESSAGE_ARTIST_REMOVED:"Artysta usunięty z kosza na śmieci",BACKUP_SAVE_SUCCESS:"Kopia zapasowa została pomyślnie zapisana.",BACKUP_SAVE_FAILED:"Nie udało się zapisać kopii zapasowej, spróbuj skopiować zawartość kosza do schowka i ręcznie utworzyć kopię zapasową.",BACKUP_RESTORE_SUCCESS:"Kopia zapasowa została pomyślnie przywrócona.",BACKUP_FILE_READ_FAILED:"Nie udało się odczytać pliku, upewnij się, że jest to poprawny plik JSON.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Ustawienia kosza+",SETTINGS_OPTIONS:"Opcje",SETTINGS_FEATURES:"Funkcje",SETTINGS_LOCAL_STORAGE:"Pamięć lokalna",SETTINGS_ENABLED:"Włączone",SETTINGS_SHOW_WIDGET:"Pokaż ikonę widżetu",SETTINGS_AUTOPLAY:"Automatyczne odtwarzanie przy uruchomieniu",SETTINGS_QUEUE_TRASHBIN:"Włącz kosz na kolejkę",SETTINGS_TRACKLIST_TRASHBIN:"Włącz kosz na listę utworów",SETTINGS_PLAYLIST_MONITOR:"Monitor playlist",ITEMS_TITLE:"Przedmioty z kosza na śmieci+",ITEMS_EMPTY_SONGS:"<strong>Brak usuniętych utworów!</strong><br/>Utwory, które dodasz do kosza, pojawią się tutaj.",ITEMS_EMPTY_ARTISTS:"<strong>Brak artystów w koszu!</strong><br/>Artyści, których dodasz do kosza, pojawią się tutaj.",ITEMS_TAB_SONGS:"Piosenki",ITEMS_TAB_ARTISTS:"Artyści",ITEMS_LOADED_COUNT:"{{loaded}} z {{total}} {{type}} załadowane",DESCRIPTION_COPY:"Skopiuj wszystkie elementy w koszu do schowka.",DESCRIPTION_EXPORT:"Zapisz wszystkie elementy w koszu do pliku .json.",DESCRIPTION_IMPORT:"Zastąp wszystkie elementy w koszu za pomocą pliku .json.",DESCRIPTION_CLEAR:"Wyczyść wszystkie elementy z kosza (nie można cofnąć).",ITEMS_EMPTY_SONGS_TITLE:"Brak usuniętych utworów!",ITEMS_EMPTY_ARTISTS_TITLE:"Bez wyrzuconych artystów!",DESCRIPTION_SETTINGS_ENABLED:"Przełącznik główny umożliwiający włączenie lub wyłączenie całej funkcjonalności kosza+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Wyświetl ikonę kosza na pasku odtwarzania obok aktualnie odtwarzanego utworu w celu szybkiego dostępu",DESCRIPTION_SETTINGS_AUTOPLAY:"Automatycznie uruchamiaj muzykę po otwarciu Spotify lub załadowaniu rozszerzenia",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Dodaj ikony kosza obok każdej piosenki w kolejce odtwarzania, aby ułatwić zarządzanie",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Dodaj ikony kosza obok utworów w widokach albumów i playlist, aby umożliwić szybkie filtrowanie",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatycznie odzyskuj po wystąpieniu błędów odtwarzania w Spotify, wznawiając ostatnią playlistę",SETTINGS_SKIP_TRASHED_TRACKS:"Pomiń usunięte utwory",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Automatycznie pomijaj usunięte utwory i znajdź następny dozwolony utwór podczas odtwarzania",SETTINGS_AUTO_CLEAN_QUEUE:"Kolejka automatycznego czyszczenia",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Automatycznie usuwaj usunięte utwory z kolejki inteligentnego odtwarzania w losowej kolejności",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Śmietnik przy następnym klawiszu szybkiego dostępu",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Automatycznie usuwaj aktualną piosenkę do kosza po użyciu skrótu klawiaturowego Ctrl+Strzałka w prawo, aby przejść do następnego utworu",SETTINGS_REMOTE_CONTROL:"Zdalne sterowanie",SETTINGS_REMOTE_TOGGLE:"Włącz zdalne przełączanie",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dotknij dwukrotnie odtwarzanie/pauza z telefonu, aby włączyć/wyłączyć zdalne pomijanie. Pominięcie utworu potwierdza przełączenie.",SETTINGS_REMOTE_SKIPPING:"Zdalne pomijanie aktywne",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Gdy włączone, pomijanie kosza działa nawet podczas sterowania Spotify z innego urządzenia (np. telefonu komórkowego)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Włączone pomijanie zdalne",MESSAGE_REMOTE_SKIPPING_DISABLED:"Pomijanie zdalne wyłączone",MESSAGE_SONG_ADDED_REMOTE:"Piosenka usunięta zdalnie",SETTINGS_TRASH_VIA_LIKE:"Śmieci przez Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Jak utwór z telefonu do kosza. Automatycznie usuwa polubienie i przechodzi do następnego utworu.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var A8=K((US,yu)=>{yu.exports={TRASHBIN_NAME:"Lixeira+",ACTION_THROW:"Colocar na Lixeira",ACTION_UNTHROW:"Remover da lixeira",ACTION_CLEAR:"Claro",ACTION_COPY:"Copiar",ACTION_EXPORT:"Exportar",ACTION_IMPORT:"Importar",MESSAGE_COPIED:"Copiado para a área de transferência",MESSAGE_CLEARED:"Lixeira esvaziada com sucesso!",MESSAGE_SONG_ADDED:"Música adicionada à lixeira",MESSAGE_SONG_REMOVED:"Música removida da lixeira",MESSAGE_ARTIST_ADDED:"Artista adicionado à lixeira",MESSAGE_ARTIST_REMOVED:"Artista removido da lixeira",BACKUP_SAVE_SUCCESS:"Backup salvo com sucesso.",BACKUP_SAVE_FAILED:"Falha ao salvar o backup, tente copiar o conteúdo da lixeira para a área de transferência e criar um backup manualmente.",BACKUP_RESTORE_SUCCESS:"Backup restaurado com sucesso.",BACKUP_FILE_READ_FAILED:"Falha ao ler o arquivo, por favor, certifique-se de que é um arquivo JSON válido.",BACKUP_SUGGESTED_FILENAME:"spicetify-lixeira.json",SETTINGS_TITLE:"Configurações do Lixeira+",SETTINGS_OPTIONS:"Opções",SETTINGS_FEATURES:"Recursos",SETTINGS_LOCAL_STORAGE:"Armazenamento Local",SETTINGS_ENABLED:"Habilitado",SETTINGS_SHOW_WIDGET:"Mostrar Ícone do Widget",SETTINGS_AUTOPLAY:"Reprodução automática ao iniciar",SETTINGS_QUEUE_TRASHBIN:"Habilitar Lixeira da Fila",SETTINGS_TRACKLIST_TRASHBIN:"Habilitar Lixeira da Lista de Faixas",SETTINGS_PLAYLIST_MONITOR:"Monitor de Playlist",ITEMS_TITLE:"Itens da Lixeira+",ITEMS_EMPTY_SONGS:"<strong>Nenhuma música na lixeira!</strong><br/>As músicas que você adicionar à lixeira aparecerão aqui.",ITEMS_EMPTY_ARTISTS:"<strong>Nenhum artista na lixeira!</strong><br/>Artistas que você adicionar à lixeira aparecerão aqui.",ITEMS_TAB_SONGS:"Músicas",ITEMS_TAB_ARTISTS:"Artistas",ITEMS_LOADED_COUNT:"{{loaded}} de {{total}} {{type}} carregados",DESCRIPTION_COPY:"Copiar todos os itens na lixeira para a área de transferência.",DESCRIPTION_EXPORT:"Salvar todos os itens na lixeira em um arquivo .json.",DESCRIPTION_IMPORT:"Substituir todos os itens na lixeira por meio do arquivo .json.",DESCRIPTION_CLEAR:"Limpar todos os itens da lixeira (não pode ser desfeito).",ITEMS_EMPTY_SONGS_TITLE:"Nenhuma música excluída!",ITEMS_EMPTY_ARTISTS_TITLE:"Nenhum artista excluído!",DESCRIPTION_SETTINGS_ENABLED:"Alternar ativação para habilitar ou desabilitar todas as funcionalidades do Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Exibir um ícone de lixeira na barra de reprodução ao lado da faixa que está sendo reproduzida para acesso rápido",DESCRIPTION_SETTINGS_AUTOPLAY:"Iniciar automaticamente a reprodução de música quando o Spotify for aberto ou a extensão for carregada",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Adicione ícones de lixeira ao lado de cada música na sua fila de reprodução para facilitar o gerenciamento",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Adicionar ícones de lixeira ao lado das músicas nas visualizações de álbum e playlist para filtragem rápida",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recupere-se automaticamente de falhas na reprodução do Spotify retomando sua última playlist",SETTINGS_SKIP_TRASHED_TRACKS:"Pular faixas descartadas",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Pular automaticamente músicas excluídas e encontrar a próxima faixa permitida durante a reprodução",SETTINGS_AUTO_CLEAN_QUEUE:"Fila de Limpeza Automática",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Remova automaticamente músicas excluídas da sua fila de reprodução aleatória inteligente",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Lixeira na próxima tecla de atalho",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Mover automaticamente a música atual para a lixeira ao usar o atalho de teclado Ctrl+Direita para pular para a próxima faixa",SETTINGS_REMOTE_CONTROL:"Controle Remoto",SETTINGS_REMOTE_TOGGLE:"Habilitar Alternância Remota",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Toque duas vezes em reproduzir/pausar no celular para ativar/desativar o pulo remoto. Pular uma faixa confirma a alteração.",SETTINGS_REMOTE_SKIPPING:"Pulo Remoto Ativo",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Quando ativado, pular lixo funciona mesmo ao controlar o Spotify de outro dispositivo (por exemplo, celular)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Pular remoto habilitado",MESSAGE_REMOTE_SKIPPING_DISABLED:"Pular remoto desativado",MESSAGE_SONG_ADDED_REMOTE:"Música excluída via controle remoto",SETTINGS_TRASH_VIA_LIKE:"Lixo via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Como uma música do celular para descartá-la. Automaticamente remove o like e pula para a próxima faixa.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var T8=K((WS,bu)=>{bu.exports={TRASHBIN_NAME:"Lixo+",ACTION_THROW:"Colocar na Lixeira",ACTION_UNTHROW:"Remover da Reciclagem",ACTION_CLEAR:"Claro",ACTION_COPY:"Copiar",ACTION_EXPORT:"Exportar",ACTION_IMPORT:"Importar",MESSAGE_COPIED:"Copiado para a área de transferência",MESSAGE_CLEARED:"Lixeira esvaziada com sucesso!",MESSAGE_SONG_ADDED:"Música adicionada à lixeira",MESSAGE_SONG_REMOVED:"Música removida da lixeira",MESSAGE_ARTIST_ADDED:"Artista adicionado ao lixo",MESSAGE_ARTIST_REMOVED:"Artista removido da lixeira",BACKUP_SAVE_SUCCESS:"Cópia de segurança guardada com sucesso.",BACKUP_SAVE_FAILED:"Falha ao guardar a cópia de segurança, tente copiar o conteúdo da lixeira para a área de transferência e criar uma cópia de segurança manualmente.",BACKUP_RESTORE_SUCCESS:"Cópia de segurança restaurada com sucesso.",BACKUP_FILE_READ_FAILED:"Falha ao ler o ficheiro, certifique-se de que é um ficheiro JSON válido.",BACKUP_SUGGESTED_FILENAME:"spicetify-lixeira.json",SETTINGS_TITLE:"Definições da Lixeira+",SETTINGS_OPTIONS:"Opções",SETTINGS_FEATURES:"Funcionalidades",SETTINGS_LOCAL_STORAGE:"Armazenamento local",SETTINGS_ENABLED:"Ativado",SETTINGS_SHOW_WIDGET:"Mostrar Ícone do Widget",SETTINGS_AUTOPLAY:"Reprodução automática ao iniciar",SETTINGS_QUEUE_TRASHBIN:"Ativar a lixeira da fila",SETTINGS_TRACKLIST_TRASHBIN:"Ativar a Lixeira da Lista de Faixas",SETTINGS_PLAYLIST_MONITOR:"Monitor de Playlist",ITEMS_TITLE:"Itens da Lixeira+",ITEMS_EMPTY_SONGS:"<strong>Sem músicas na lixeira!</strong><br/>As músicas que você adicionar à lixeira aparecerão aqui.",ITEMS_EMPTY_ARTISTS:"<strong>Sem artistas na lixeira!</strong><br/>Os artistas que adicionar à lixeira aparecerão aqui.",ITEMS_TAB_SONGS:"Canções",ITEMS_TAB_ARTISTS:"Artistas",ITEMS_LOADED_COUNT:"{{loaded}} de {{total}} {{type}} carregado",DESCRIPTION_COPY:"Copiar todos os itens na lixeira para a área de transferência.",DESCRIPTION_EXPORT:"Guardar todos os itens na lixeira num ficheiro .json.",DESCRIPTION_IMPORT:"Substituir todos os itens na lixeira através do ficheiro .json.",DESCRIPTION_CLEAR:"Limpar todos os itens da lixeira (não pode ser revertido).",ITEMS_EMPTY_SONGS_TITLE:"Sem músicas eliminadas!",ITEMS_EMPTY_ARTISTS_TITLE:"Nenhum artista eliminado!",DESCRIPTION_SETTINGS_ENABLED:"Comutador principal para ativar ou desativar todas as funcionalidades do Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Exibir um ícone de lixeira na barra de reprodução ao lado da faixa atualmente em reprodução para acesso rápido",DESCRIPTION_SETTINGS_AUTOPLAY:"Iniciar automaticamente a reprodução de música quando o Spotify for aberto ou a extensão for carregada",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Adicione ícones de lixo junto a cada música na sua fila de reprodução para facilitar a gestão",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Adicionar ícones de lixo junto às músicas nas visualizações de álbuns e playlists para filtragem rápida",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recupere automaticamente de falhas na reprodução do Spotify retomando a sua última playlist",SETTINGS_SKIP_TRASHED_TRACKS:"Ignorar faixas eliminadas",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Ignorar automaticamente músicas eliminadas e encontrar a próxima faixa permitida durante a reprodução",SETTINGS_AUTO_CLEAN_QUEUE:"Fila de Limpeza Automática",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Remover automaticamente músicas eliminadas da sua fila de reprodução aleatória inteligente",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Lixo na próxima tecla de atalho",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Colocar automaticamente a música atual na lixeira ao usar o atalho de teclado Ctrl+Direita para avançar para a faixa seguinte",SETTINGS_REMOTE_CONTROL:"Controlo Remoto",SETTINGS_REMOTE_TOGGLE:"Ativar Alternância Remota",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Toque duas vezes em reproduzir/pausar a partir do dispositivo móvel para ativar/desativar a passagem de faixas remota. A passagem de uma faixa confirma a alteração.",SETTINGS_REMOTE_SKIPPING:"Pulsação remota ativa",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Quando ativado, a função de ignorar faixas funciona mesmo ao controlar o Spotify a partir de outro dispositivo (por exemplo, telemóvel)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Avanço remoto ativado",MESSAGE_REMOTE_SKIPPING_DISABLED:"A passagem remota foi desativada",MESSAGE_SONG_ADDED_REMOTE:"Música eliminada à distância",SETTINGS_TRASH_VIA_LIKE:"Lixo via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Como uma música do telemóvel para a eliminar. Descurte automaticamente e passa para a faixa seguinte.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var E8=K((KS,ju)=>{ju.exports={TRASHBIN_NAME:"Coș de gunoi+",ACTION_THROW:"Așezați în coșul de gunoi",ACTION_UNTHROW:"Elimină din coșul de gunoi",ACTION_CLEAR:"Clar",ACTION_COPY:"Copiați",ACTION_EXPORT:"Export",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Copiat în clipboard",MESSAGE_CLEARED:"Coșul de gunoi a fost golit cu succes!",MESSAGE_SONG_ADDED:"Cântec adăugat în coșul de gunoi",MESSAGE_SONG_REMOVED:"Cântecul a fost eliminat din coșul de gunoi",MESSAGE_ARTIST_ADDED:"Artist adăugat în coșul de gunoi",MESSAGE_ARTIST_REMOVED:"Artistul a fost eliminat din coșul de gunoi",BACKUP_SAVE_SUCCESS:"Backup salvat cu succes.",BACKUP_SAVE_FAILED:"Nu s-a reușit salvarea copiei de rezervă, încercați să copiați conținutul coșului de gunoi în clipboard și să creați o copie de rezervă manual.",BACKUP_RESTORE_SUCCESS:"Backupul a fost restaurat cu succes.",BACKUP_FILE_READ_FAILED:"Eșec la citirea fișierului, vă rugăm să vă asigurați că este un fișier JSON valid.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Setări coș de gunoi+",SETTINGS_OPTIONS:"Opțiuni",SETTINGS_FEATURES:"Caracteristici",SETTINGS_LOCAL_STORAGE:"Stocare locală",SETTINGS_ENABLED:"Activat",SETTINGS_SHOW_WIDGET:"Afișați pictograma widgetului",SETTINGS_AUTOPLAY:"Redare automată la pornire",SETTINGS_QUEUE_TRASHBIN:"Activați coșul de gunoi al cozii",SETTINGS_TRACKLIST_TRASHBIN:"Activați coșul de gunoi pentru listele de redare",SETTINGS_PLAYLIST_MONITOR:"Monitorul listei de redare",ITEMS_TITLE:"Elemente din coșul de gunoi+",ITEMS_EMPTY_SONGS:"<strong>Niciun cântec tras la gunoi!</strong><br/>Cântecele pe care le adaugi în coșul de gunoi vor apărea aici.",ITEMS_EMPTY_ARTISTS:"<strong>Niciun artist eliminat!</strong><br/>Artiștii pe care îi adăugați la coșul de gunoi vor apărea aici.",ITEMS_TAB_SONGS:"Cântece",ITEMS_TAB_ARTISTS:"Artiști",ITEMS_LOADED_COUNT:"{{loaded}} din {{total}} {{type}} încărcate",DESCRIPTION_COPY:"Copiați toate elementele din coșul de gunoi în clipboard.",DESCRIPTION_EXPORT:"Salvați toate elementele din coșul de gunoi într-un fișier .json.",DESCRIPTION_IMPORT:"Suprascrie toate elementele din coșul de gunoi prin fișierul .json.",DESCRIPTION_CLEAR:"Ștergeți toate elementele din coșul de gunoi (acțiunea nu poate fi anulată).",ITEMS_EMPTY_SONGS_TITLE:"Nicio melodie ștearsă!",ITEMS_EMPTY_ARTISTS_TITLE:"Niciun artist aruncat la gunoi!",DESCRIPTION_SETTINGS_ENABLED:"Comutare principală pentru activarea sau dezactivarea tuturor funcțiilor Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Afișează o pictogramă de coș de gunoi în bara de redare lângă piesa care se redă în prezent pentru acces rapid",DESCRIPTION_SETTINGS_AUTOPLAY:"Pornește automat redarea muzicii când Spotify se deschide sau extensia se încarcă",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Adăugați iconițe de coș de gunoi lângă fiecare melodie din coada viitoare pentru o gestionare ușoară",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Adăugați pictograme de coș de gunoi lângă melodii în vizualizările de album și playlist pentru filtrare rapidă",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Recuperează automat erorile de redare de pe Spotify reluând ultima ta listă de redare",SETTINGS_SKIP_TRASHED_TRACKS:"Ignoră piesele șterse",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Sări automat peste piesele șterse și găsește următorul titlu permis în timpul redării",SETTINGS_AUTO_CLEAN_QUEUE:"Coada de curățare automată",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Eliminați automat piesele șterse din coada dvs. Smart Shuffle",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Gunoi la următoarea tastă rapidă",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Șterge automat piesa curentă când folosești combinația de taste Ctrl+Dreapta pentru a trece la următoarea piesă",SETTINGS_REMOTE_CONTROL:"Control la distanță",SETTINGS_REMOTE_TOGGLE:"Activați comutarea la distanță",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Apăsați de două ori pe redare/pauză de pe mobil pentru a activa/dezactiva săritul de la distanță. Săritul unui titlu confirmă comutarea.",SETTINGS_REMOTE_SKIPPING:"Săritul la distanță activ",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Când este activată, omitearea coșului de gunoi funcționează chiar și atunci când controlați Spotify de pe un alt dispozitiv (de exemplu, mobil)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Săritul la distanță activat",MESSAGE_REMOTE_SKIPPING_DISABLED:"Săritul la distanță dezactivat",MESSAGE_SONG_ADDED_REMOTE:"Melodia distrusă la distanță",SETTINGS_TRASH_VIA_LIKE:"Gunoi prin Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Ca un cântec de la mobil la coșul de gunoi. Dezapreciază automat și trece la următorul cântec.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var I8=K((qS,Uu)=>{Uu.exports={TRASHBIN_NAME:"Корзина+",ACTION_THROW:"Поместить в корзину",ACTION_UNTHROW:"Удалить из корзины",ACTION_CLEAR:"Ясно",ACTION_COPY:"Копировать",ACTION_EXPORT:"Экспорт",ACTION_IMPORT:"Импорт",MESSAGE_COPIED:"Скопировано в буфер обмена",MESSAGE_CLEARED:"Корзина успешно очищена!",MESSAGE_SONG_ADDED:"Песня добавлена в корзину",MESSAGE_SONG_REMOVED:"Песня удалена из корзины",MESSAGE_ARTIST_ADDED:"Художник добавлен в корзину",MESSAGE_ARTIST_REMOVED:"Художник удалён из корзины",BACKUP_SAVE_SUCCESS:"Резервная копия успешно сохранена.",BACKUP_SAVE_FAILED:"Не удалось сохранить резервную копию, попробуйте скопировать содержимое корзины в буфер обмена и создать резервную копию вручную.",BACKUP_RESTORE_SUCCESS:"Резервная копия успешно восстановлена.",BACKUP_FILE_READ_FAILED:"Не удалось прочитать файл, убедитесь, что это корректный файл JSON.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Настройки корзины+",SETTINGS_OPTIONS:"Опции",SETTINGS_FEATURES:"Особенности",SETTINGS_LOCAL_STORAGE:"Локальное хранилище",SETTINGS_ENABLED:"Включено",SETTINGS_SHOW_WIDGET:"Показать значок виджета",SETTINGS_AUTOPLAY:"Автовоспроизведение при запуске",SETTINGS_QUEUE_TRASHBIN:"Включить корзину очереди",SETTINGS_TRACKLIST_TRASHBIN:"Включить корзину для трек-листа",SETTINGS_PLAYLIST_MONITOR:"Монитор плейлистов",ITEMS_TITLE:"Элементы корзины+",ITEMS_EMPTY_SONGS:"<strong>Нет удалённых песен!</strong><br/>Песни, которые вы добавите в корзину, появятся здесь.",ITEMS_EMPTY_ARTISTS:"<strong>Нет артистов в корзине!</strong><br/>Артисты, которых вы добавите в корзину, появятся здесь.",ITEMS_TAB_SONGS:"Песни",ITEMS_TAB_ARTISTS:"Художники",ITEMS_LOADED_COUNT:"Загружено {{loaded}} из {{total}} {{type}}",DESCRIPTION_COPY:"Копировать все элементы в корзине в буфер обмена.",DESCRIPTION_EXPORT:"Сохранить все элементы в корзине в файл .json.",DESCRIPTION_IMPORT:"Перезаписать все элементы в корзине с помощью файла .json.",DESCRIPTION_CLEAR:"Очистить все элементы из корзины (невозможно отменить).",ITEMS_EMPTY_SONGS_TITLE:"Нет удалённых песен!",ITEMS_EMPTY_ARTISTS_TITLE:"Никаких выброшенных художников!",DESCRIPTION_SETTINGS_ENABLED:"Главный переключатель для включения или отключения всех функций корзины+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Отображать значок корзины на панели воспроизведения рядом с текущим треком для быстрого доступа",DESCRIPTION_SETTINGS_AUTOPLAY:"Автоматически начинать воспроизведение музыки при открытии Spotify или загрузке расширения",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Добавьте значки корзины рядом с каждой песней в очереди для удобного управления",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Добавить значки корзины рядом с песнями в альбомах и плейлистах для быстрой фильтрации",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Автоматическое восстановление после сбоев воспроизведения в Spotify путем возобновления последнего плейлиста",SETTINGS_SKIP_TRASHED_TRACKS:"Пропустить удалённые треки",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Автоматически пропускать удалённые песни и находить следующий доступный трек во время воспроизведения",SETTINGS_AUTO_CLEAN_QUEUE:"Очередь автоматической очистки",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Автоматически удалять удалённые песни из очереди умного перемешивания",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Корзина по следующему сочетанию клавиш",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Автоматически удалять текущую песню при использовании сочетания клавиш Ctrl+Вправо для перехода к следующему треку",SETTINGS_REMOTE_CONTROL:"Дистанционное управление",SETTINGS_REMOTE_TOGGLE:"Включить удалённое переключение",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Дважды коснитесь кнопки воспроизведения/паузы на мобильном устройстве, чтобы включить или отключить дистанционное пропускание. Пропуск трека подтверждает переключение.",SETTINGS_REMOTE_SKIPPING:"Пропуск дистанционного доступа активен",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"При включении функция пропуска трека работает даже при управлении Spotify с другого устройства (например, мобильного телефона)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Пропуск на расстоянии включен",MESSAGE_REMOTE_SKIPPING_DISABLED:"Дистанционное пропускание отключено",MESSAGE_SONG_ADDED_REMOTE:"Песня уничтожена на расстоянии",SETTINGS_TRASH_VIA_LIKE:"Мусор через Лайк",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Как песня с мобильного в корзину. Автоматически удаляет лайк и переходит к следующему треку.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var m8=K((YS,Wu)=>{Wu.exports={TRASHBIN_NAME:"Kôš+",ACTION_THROW:"Umiestniť do koša",ACTION_UNTHROW:"Odstrániť z koša",ACTION_CLEAR:"Jasné",ACTION_COPY:"Kopírovať",ACTION_EXPORT:"Export",ACTION_IMPORT:"Import",MESSAGE_COPIED:"Skopírované do schránky",MESSAGE_CLEARED:"Kôš úspešne vyprázdnený!",MESSAGE_SONG_ADDED:"Skomponovaná pieseň odstránená",MESSAGE_SONG_REMOVED:"Skandlba odstránená z koša",MESSAGE_ARTIST_ADDED:"Umelca pridaného do koša",MESSAGE_ARTIST_REMOVED:"Umeniek odstránený z koša",BACKUP_SAVE_SUCCESS:"Záloha bola úspešne uložená.",BACKUP_SAVE_FAILED:"Zálohovanie sa nepodarilo, skúste skopírovať obsah kôša do schránky a vytvoriť zálohu ručne.",BACKUP_RESTORE_SUCCESS:"Záloha bola úspešne obnovená.",BACKUP_FILE_READ_FAILED:"Nepodarilo sa prečítať súbor, uistite sa, že ide o platný súbor JSON.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Nastavenia koša+",SETTINGS_OPTIONS:"Možnosti",SETTINGS_FEATURES:"Funkcie",SETTINGS_LOCAL_STORAGE:"Lokálne úložisko",SETTINGS_ENABLED:"Povolené",SETTINGS_SHOW_WIDGET:"Zobraziť ikonu widgetu",SETTINGS_AUTOPLAY:"Automatické prehrávanie pri štarte",SETTINGS_QUEUE_TRASHBIN:"Povoliť frontu kôša",SETTINGS_TRACKLIST_TRASHBIN:"Povoliť kôš pre zoznam skladieb",SETTINGS_PLAYLIST_MONITOR:"Monitor zoznamu skladieb",ITEMS_TITLE:"Položky v koši+",ITEMS_EMPTY_SONGS:"<strong>Žiadne zmazané skladby!</strong><br/>Skladby, ktoré odstránite do koša, sa objavia tu.",ITEMS_EMPTY_ARTISTS:"<strong>Žiadni umelci v koši!</strong><br/>Umelci, ktorých pridáte do koša, sa objavia tu.",ITEMS_TAB_SONGS:"Pesničky",ITEMS_TAB_ARTISTS:"Umelci",ITEMS_LOADED_COUNT:"Načítaných {{loaded}} z {{total}} položiek typu {{type}}",DESCRIPTION_COPY:"Skopírovať všetky položky v koši do schránky.",DESCRIPTION_EXPORT:"Uložiť všetky položky v koši do súboru .json.",DESCRIPTION_IMPORT:"Prepísať všetky položky v koši pomocou súboru .json.",DESCRIPTION_CLEAR:"Odstrániť všetky položky z koša (nie je možné vrátiť späť).",ITEMS_EMPTY_SONGS_TITLE:"Žiadne zmazané skladby!",ITEMS_EMPTY_ARTISTS_TITLE:"Žiadni zničení umelci!",DESCRIPTION_SETTINGS_ENABLED:"Hlavné prepínanie na povolenie alebo zakázanie všetkých funkcií Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Zobraziť ikonu koša v prehrávacom paneli vedľa práve prehrávanej skladby pre rýchly prístup",DESCRIPTION_SETTINGS_AUTOPLAY:"Automaticky spustiť prehrávanie hudby pri otvorení Spotify alebo pri načítaní rozšírenia",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Pridajte ikony koša vedľa každej skladby vo vašej nadchádzajúcej fronte pre jednoduchú správu",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Pridať ikony koša vedľa skladieb v zobrazeniach albumov a playlistov pre rýchle filtrovanie",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Automatické obnovenie prehrávania na Spotify po výpadkoch obnovením posledného zoznamu skladieb",SETTINGS_SKIP_TRASHED_TRACKS:"Preskočiť odstránené skladby",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Automaticky preskakovať odstránené skladby a nájsť ďalšiu povolenú skladbu počas prehrávania",SETTINGS_AUTO_CLEAN_QUEUE:"Auto čistenie frontu",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Automaticky odstraňujte skladby v koši z fronty Smart Shuffle",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Odpad na ďalšej klávesovej skratke",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Automaticky odstrániť aktuálnu skladbu, keď použijete klávesovú skratku Ctrl+Doprava na preskočenie na ďalšiu skladbu",SETTINGS_REMOTE_CONTROL:"Diaľkové ovládanie",SETTINGS_REMOTE_TOGGLE:"Povoliť vzdialené prepínanie",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dvojitým klepnutím na prehrávanie/pauzu z mobilného zariadenia zapnete alebo vypnete diaľkové preskakovanie. Preskočenie skladby potvrdí prepínanie.",SETTINGS_REMOTE_SKIPPING:"Vzdialené preskakovanie aktívne",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Ak je funkcia povolená, preskakovanie kôša funguje aj pri ovládaní Spotify z iného zariadenia (napr. mobilného).",MESSAGE_REMOTE_SKIPPING_ENABLED:"Vzdialené preskakovanie povolené",MESSAGE_REMOTE_SKIPPING_DISABLED:"Vzdialené preskakovanie je zakázané",MESSAGE_SONG_ADDED_REMOTE:"Skomolená skladba na diaľku",SETTINGS_TRASH_VIA_LIKE:"Odpad cez Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Ako skladba z mobilu do koša. Automaticky odstráni „Páči sa mi“ a prejde na ďalšiu skladbu.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var f8=K((QS,Ku)=>{Ku.exports={TRASHBIN_NAME:"Smetnjak+",ACTION_THROW:"Postavi v koš za smeti",ACTION_UNTHROW:"Odstrani iz koša",ACTION_CLEAR:"Jasno",ACTION_COPY:"Kopiraj",ACTION_EXPORT:"Izvoz",ACTION_IMPORT:"Uvoz",MESSAGE_COPIED:"Kopirano v odložišče",MESSAGE_CLEARED:"Smetnjak uspešno izpraznjen!",MESSAGE_SONG_ADDED:"Pesem dodana v koš za smeti",MESSAGE_SONG_REMOVED:"Pesem odstranjena iz koša",MESSAGE_ARTIST_ADDED:"Umetnik dodan v koš za smeti",MESSAGE_ARTIST_REMOVED:"Umetnik odstranjen iz koša za smeti",BACKUP_SAVE_SUCCESS:"Varnostna kopija je bila uspešno shranjena.",BACKUP_SAVE_FAILED:"Shranjevanje varnostne kopije ni uspelo, poskusite kopirati vsebino koša v odložišče in ročno ustvariti varnostno kopijo.",BACKUP_RESTORE_SUCCESS:"Varnostna kopija je bila uspešno obnovljena.",BACKUP_FILE_READ_FAILED:"Ni bilo mogoče prebrati datoteke, preverite, ali je veljavna datoteka JSON.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Nastavitve koša za smeti+",SETTINGS_OPTIONS:"Možnosti",SETTINGS_FEATURES:"Lastnosti",SETTINGS_LOCAL_STORAGE:"Lokalni pomnilnik",SETTINGS_ENABLED:"Omogočeno",SETTINGS_SHOW_WIDGET:"Prikaži ikono gradnika",SETTINGS_AUTOPLAY:"Samodejno predvajaj ob zagonu",SETTINGS_QUEUE_TRASHBIN:"Omogoči vrsto koša",SETTINGS_TRACKLIST_TRASHBIN:"Omogoči koš za smeti s seznamom skladb",SETTINGS_PLAYLIST_MONITOR:"Sledilnik predvajalnega seznama",ITEMS_TITLE:"Predmeti koša+",ITEMS_EMPTY_SONGS:"<strong>Ni izbrisanih pesmi!</strong><br/>Pesmi, ki jih dodate v koš za smeti, bodo prikazane tukaj.",ITEMS_EMPTY_ARTISTS:"<strong>Brez zavrženih umetnikov!</strong><br/>Umetniki, ki jih dodate v koš za smeti, bodo prikazani tukaj.",ITEMS_TAB_SONGS:"Pesmi",ITEMS_TAB_ARTISTS:"Umjetnici",ITEMS_LOADED_COUNT:"{{loaded}} od {{total}} {{type}} naloženih",DESCRIPTION_COPY:"Kopiraj vse elemente v košu v odložišče.",DESCRIPTION_EXPORT:"Shrani vse elemente v košu v datoteko .json.",DESCRIPTION_IMPORT:"Prepiši vse elemente v košu s .json datoteko.",DESCRIPTION_CLEAR:"Izprazni vse predmete iz koša (ni mogoče razveljaviti).",ITEMS_EMPTY_SONGS_TITLE:"Brez izbrisanih pesmi!",ITEMS_EMPTY_ARTISTS_TITLE:"Brez zavrglih umetnikov!",DESCRIPTION_SETTINGS_ENABLED:"Glavni stikalo za vklop ali izklop vseh funkcij Koša+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Prikaži ikono koša v vrstici predvajanja poleg trenutno predvajane skladbe za hitri dostop",DESCRIPTION_SETTINGS_AUTOPLAY:"Samodejno začni predvajati glasbo, ko se odpre Spotify ali ko se razširitev naloži",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Dodajte ikone za smetnjak poleg vsake pesmi v vaši prihodnji vrstici za enostavno upravljanje",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Dodaj ikone smeti poleg pesmi v pogledih albumov in seznamov predvajanja za hitro filtriranje",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Samodejno obnovite predvajanje v Spotifyju po napakah tako, da znova zaženete zadnji predvajalni seznam",SETTINGS_SKIP_TRASHED_TRACKS:"Preskoči izbrisane skladbe",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Samodejno preskoči izbrisane pesmi in med predvajanjem poišči naslednjo dovoljeno skladbo",SETTINGS_AUTO_CLEAN_QUEUE:"Samodejna čistilna vrsta",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Samodejno odstrani izbrisane pesmi iz čakalne vrste pametnega mešanja",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Smeti na naslednji bližnjici",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Samodejno odstrani trenutno skladbo, ko uporabite tipkovno bližnjico Ctrl+Desno, da preskočite na naslednjo skladbo",SETTINGS_REMOTE_CONTROL:"Daljinski krmilnik",SETTINGS_REMOTE_TOGGLE:"Omogoči oddaljeno preklopno funkcijo",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Dvakrat tapnite predvajaj/pavza na mobilni napravi, da vklopite/izklopite oddaljeno preskakovanie. Preskok skladbe potrdi preklop.",SETTINGS_REMOTE_SKIPPING:"Oddaljeno preskakovanje je aktivno",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Ko je omogočeno, se preskakovanie smetnjaka izvaja tudi ob upravljanju s Spotifyjem z druge naprave (npr. mobilne).",MESSAGE_REMOTE_SKIPPING_ENABLED:"Omogočeno je oddaljeno preskakovanje",MESSAGE_REMOTE_SKIPPING_DISABLED:"Oddaljeno preskakovanie onemogočeno",MESSAGE_SONG_ADDED_REMOTE:"Pesem uničena na daljavo",SETTINGS_TRASH_VIA_LIKE:"Smeti prek Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Kot pesem iz mobilnega v smeti. Samodejno odstrani všeček in preklopi na naslednjo skladbo.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var x8=K((XS,qu)=>{qu.exports={TRASHBIN_NAME:"Канта за смеће+",ACTION_THROW:"Смести у сандуче за отпатке",ACTION_UNTHROW:"Уклони из корпе за смеће",ACTION_CLEAR:"Јасно",ACTION_COPY:"Копирај",ACTION_EXPORT:"Извоз",ACTION_IMPORT:"Увоз",MESSAGE_COPIED:"Копирано у оставу",MESSAGE_CLEARED:"Смеће успешно очишћено!",MESSAGE_SONG_ADDED:"Песма додата у корпу за смеће",MESSAGE_SONG_REMOVED:"Песма је уклоњена из корпе за смеће",MESSAGE_ARTIST_ADDED:"Уметник додат у корпу за смеће",MESSAGE_ARTIST_REMOVED:"Уметник је уклоњен из сандуча за отпатке",BACKUP_SAVE_SUCCESS:"Резервна копија је успешно сачувана.",BACKUP_SAVE_FAILED:"Није успело чување резервне копије, покушајте да копирате садржај корпе за смеће у оставу и да ручно направите резервну копију.",BACKUP_RESTORE_SUCCESS:"Резервна копија је успешно враћена.",BACKUP_FILE_READ_FAILED:"Није успело читање датотеке, молимо проверите да ли је исправна JSON датотека.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Подешавања корпе за отпатке+",SETTINGS_OPTIONS:"Опције",SETTINGS_FEATURES:"Каркаcterистике",SETTINGS_LOCAL_STORAGE:"Локални складиште",SETTINGS_ENABLED:"Омогућено",SETTINGS_SHOW_WIDGET:"Прикажи икону виджета",SETTINGS_AUTOPLAY:"Аутоматско пуштање при покретању",SETTINGS_QUEUE_TRASHBIN:"Омогући корпу за отпатке реда чекања",SETTINGS_TRACKLIST_TRASHBIN:"Омогући корпу за отпатке листе нумера",SETTINGS_PLAYLIST_MONITOR:"Плејлиста монитор",ITEMS_TITLE:"Ставке корпе за смеће+",ITEMS_EMPTY_SONGS:"<strong>Нема избрисаних песама!</strong><br/>Песме које додате у корпу за смеће ће се појавити овде.",ITEMS_EMPTY_ARTISTS:"<strong>Нема избрисаних извођача!</strong><br/>Извођачи које додате у корпу за отпатке појавиће се овде.",ITEMS_TAB_SONGS:"Песме",ITEMS_TAB_ARTISTS:"Уметници",ITEMS_LOADED_COUNT:"Учитано {{loaded}} од {{total}} {{type}}",DESCRIPTION_COPY:"Копирај све ставке из сандучета за отпад у оставу.",DESCRIPTION_EXPORT:"Сачувај све ставке у корпи за смеће у .json датотеку.",DESCRIPTION_IMPORT:"Преписати све ставке у корпи преко .json датотеке.",DESCRIPTION_CLEAR:"Обриши све ставке из сандучета за отпатак (не може се опозвати).",ITEMS_EMPTY_SONGS_TITLE:"Нема избрисаних песама!",ITEMS_EMPTY_ARTISTS_TITLE:"Без уњиштених уметника!",DESCRIPTION_SETTINGS_ENABLED:"Главни прекидач за омогућавање или онемогућавање свих функција Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Прикажи икону корпе за отпад у траци за репродукцију поред тренутно репродукованог нумере за брз приступ",DESCRIPTION_SETTINGS_AUTOPLAY:"Аутоматско покретање музике када се Spotify отвори или када се проширење учита",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Додајте иконице за отпад поред сваке песме у вашој редоследу за лакше управљање",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Додај иконе за бациње поред песама у прегледима албума и листе песама ради брзег филтрирања",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Аутоматско опорављање од грешака при репродукцији на Спотифају настављањем ваше последње плејлисте",SETTINGS_SKIP_TRASHED_TRACKS:"Прескочи оbrisане нумере",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Аутоматско прескачење отпадних песама и проналажење следеће дозвољене нумере током репродукције",SETTINGS_AUTO_CLEAN_QUEUE:"Ред за аутоматско чишћење",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Аутоматски уклони избрисане песме из реда чувања случајног редоследа",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Смеће на следећем тастеру за брзо пребацивање",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Аутоматски баците тренутну песму у корпу за отпатак када користите пречицу на тастатури Ctrl+Десно да бисте прескочили на следећу нумеру",SETTINGS_REMOTE_CONTROL:"Даљинско управљање",SETTINGS_REMOTE_TOGGLE:"Омогући удаљено пребацивање",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Додирните двапут плеј/паузу са мобилног уређаја да бисте укључили или искључили прескакање на даљину. Прескакање нумере потврђује пребацивање.",SETTINGS_REMOTE_SKIPPING:"Даљинско прескачање активно",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Када је омогућено, прескакање отпада функционише чак и када управљате Спотифајом са другог уређаја (нпр. мобилног телефона)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Удаљено прескачање укључено",MESSAGE_REMOTE_SKIPPING_DISABLED:"Даљинско прескачање онемогућено",MESSAGE_SONG_ADDED_REMOTE:"Песма уништена на даљинско",SETTINGS_TRASH_VIA_LIKE:"Смеће преко Лайк-а",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Као песма са мобилног да бациш. Аутоматски престаје да се свиђа и прескаче на следећу нумеру.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var C8=K((JS,Yu)=>{Yu.exports={TRASHBIN_NAME:"Papperskorg+",ACTION_THROW:"Placera i papperskorgen",ACTION_UNTHROW:"Ta bort från papperskorgen",ACTION_CLEAR:"Klart",ACTION_COPY:"Kopiera",ACTION_EXPORT:"Exportera",ACTION_IMPORT:"Importera",MESSAGE_COPIED:"Kopierat till urklipp",MESSAGE_CLEARED:"Papperskorgen tömdes framgångsrikt!",MESSAGE_SONG_ADDED:"Låt tillagd i papperskorgen",MESSAGE_SONG_REMOVED:"Låt borttagen från papperskorgen",MESSAGE_ARTIST_ADDED:"Konstnär tillagd i papperskorgen",MESSAGE_ARTIST_REMOVED:"Konstnär borttagen från papperskorgen",BACKUP_SAVE_SUCCESS:"Säkerhetskopia sparades framgångsrikt.",BACKUP_SAVE_FAILED:"Det gick inte att spara säkerhetskopia, försök att kopiera papperskorgens innehåll till urklipp och skapa en säkerhetskopia manuellt.",BACKUP_RESTORE_SUCCESS:"Säkerhetskopian återställdes framgångsrikt.",BACKUP_FILE_READ_FAILED:"Det gick inte att läsa filen, se till att det är en giltig JSON-fil.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Soptunna+ Inställningar",SETTINGS_OPTIONS:"Alternativ",SETTINGS_FEATURES:"Funktioner",SETTINGS_LOCAL_STORAGE:"Lokalt lagringsutrymme",SETTINGS_ENABLED:"Aktiverad",SETTINGS_SHOW_WIDGET:"Visa widgetikon",SETTINGS_AUTOPLAY:"Automatisk uppspelning vid start",SETTINGS_QUEUE_TRASHBIN:"Aktivera Kö-papperskorg",SETTINGS_TRACKLIST_TRASHBIN:"Aktivera spårlistans papperskorg",SETTINGS_PLAYLIST_MONITOR:"Spellistsövervakning",ITEMS_TITLE:"Papperskorg+ objekt",ITEMS_EMPTY_SONGS:"<strong>Inga sånger i papperskorgen!</strong><br/>Sånger du lägger i papperskorgen kommer att visas här.",ITEMS_EMPTY_ARTISTS:"<strong>Inga artister i papperskorgen!</strong><br/>Artister du lägger i papperskorgen kommer att visas här.",ITEMS_TAB_SONGS:"Låtar",ITEMS_TAB_ARTISTS:"Konstnärer",ITEMS_LOADED_COUNT:"{{loaded}} av {{total}} {{type}} inlästa",DESCRIPTION_COPY:"Kopiera alla objekt i papperskorgen till urklipp.",DESCRIPTION_EXPORT:"Spara alla objekt i papperskorgen till en .json-fil.",DESCRIPTION_IMPORT:"Skriv över alla objekt i papperskorgen via .json-fil.",DESCRIPTION_CLEAR:"Rensa alla objekt från papperskorgen (kan inte ångras).",ITEMS_EMPTY_SONGS_TITLE:"Inga borttagna låtar!",ITEMS_EMPTY_ARTISTS_TITLE:"Inga förstörda artister!",DESCRIPTION_SETTINGS_ENABLED:"Huvudbrytare för att aktivera eller inaktivera all funktionalitet i Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Visa en papperskorgsikon i avspelningsfältet bredvid den spelande låten för snabb åtkomst",DESCRIPTION_SETTINGS_AUTOPLAY:"Starta automatiskt spela musik när Spotify öppnas eller tillägget läses in",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Lägg till papperskorgsikoner bredvid varje låt i din kommande kö för enkel hantering",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Lägg till papperskorgsikoner bredvid låtar i album- och spellistsvyn för snabb filtrering",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Återställ automatiskt från Spotify-uppspelningsfel genom att återuppta din senaste spellista",SETTINGS_SKIP_TRASHED_TRACKS:"Hoppa över borttagna spår",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Hoppa automatiskt över borttagna låtar och hitta nästa tillåtna spår under uppspelning",SETTINGS_AUTO_CLEAN_QUEUE:"Automatisk rensningskö",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Ta automatiskt bort papperskorgsmarkerade låtar från din Smarta Shuffle-kö",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Papperskorg vid nästa snabbtangent",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Flytta automatiskt det aktuella låtet till papperskorgen när du använder kortkommandot Ctrl+Höger för att hoppa till nästa spår",SETTINGS_REMOTE_CONTROL:"Fjärrkontroll",SETTINGS_REMOTE_TOGGLE:"Aktivera fjärrväxling",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Tryck två gånger på play/pause från mobilen för att aktivera/inaktivera fjärrhoppning. Ett spårhopp bekräftar inställningen.",SETTINGS_REMOTE_SKIPPING:"Fjärröverhoppning Aktiv",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"När det är aktiverat fungerar papperskorgsöverhoppning även när Spotify styrs från en annan enhet (t.ex. mobil)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Fjärrhoppning aktiverad",MESSAGE_REMOTE_SKIPPING_DISABLED:"Fjärröversprångning inaktiverad",MESSAGE_SONG_ADDED_REMOTE:"Låt förstörd via fjärrkontroll",SETTINGS_TRASH_VIA_LIKE:"Skräp via Like",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Som en låt från mobil till papperskorgen. Tar automatiskt bort gillandet och hoppar till nästa spår.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var _8=K(($S,Qu)=>{Qu.exports={TRASHBIN_NAME:"Kisanduku cha taka+",ACTION_THROW:"Weka kwenye kisanduku cha taka",ACTION_UNTHROW:"Ondoa kutoka kwenye Kikapu cha Taka",ACTION_CLEAR:"Wazi",ACTION_COPY:"Nakili",ACTION_EXPORT:"Uza nje",ACTION_IMPORT:"Kuletea",MESSAGE_COPIED:"Imekopishwa kwenye ubao",MESSAGE_CLEARED:"Kisanduku cha taka kimefutwa kikweli!",MESSAGE_SONG_ADDED:"Wimbo umewekwa kwenye kisanduku cha taka",MESSAGE_SONG_REMOVED:"Wimbo umefutwa kutoka kwenye kisanduku cha takataka",MESSAGE_ARTIST_ADDED:"Mchezaji amewekwa kwenye kikapu cha taka",MESSAGE_ARTIST_REMOVED:"Mchezaji wa sanaa ameondolewa kutoka kwenye kisanduku cha taka",BACKUP_SAVE_SUCCESS:"Usimamizi umohifadhiwa kikamilifu.",BACKUP_SAVE_FAILED:"Imeshindwa kuhifadhi nakala, jaribu kunakili maudhui ya kisanduku cha takataka kwenye ubao wa kunakili na kuunda nakala kwa mkono.",BACKUP_RESTORE_SUCCESS:"Usalimwengu umerudiwa kikamilifu.",BACKUP_FILE_READ_FAILED:"Imeshindwa kusoma faili, tafadhali hakikisha kwamba ni faili halali ya JSON.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Mipangilio ya Kipande cha Taka+",SETTINGS_OPTIONS:"Chaguzi",SETTINGS_FEATURES:"Vipengele",SETTINGS_LOCAL_STORAGE:"Hifadhi ya Lokali",SETTINGS_ENABLED:"Imewezeshwa",SETTINGS_SHOW_WIDGET:"Onyesha Ikoni ya Kiolesura",SETTINGS_AUTOPLAY:"Kucheza kiotomatiki kuanzia",SETTINGS_QUEUE_TRASHBIN:"Washa Kikapu cha Kuchukua Taka",SETTINGS_TRACKLIST_TRASHBIN:"Washa Kikokotoo cha Orodha ya Nyimbo",SETTINGS_PLAYLIST_MONITOR:"Ombwe la Orodha ya Nyimbo",ITEMS_TITLE:"Vitu vya kisanduku cha taka+",ITEMS_EMPTY_SONGS:"<strong>Hakuna wimbo uliowekwa kwenye kisanduku cha taka!</strong><br/>Wimbo unaoongeza kwenye kisanduku cha taka utaonekana hapa.",ITEMS_EMPTY_ARTISTS:"<strong>Hakuna wasanii wamefukuzwa!</strong><br/>Wasanii ambao utawafukuzia katika kikapu cha taka kitakuwako hapa.",ITEMS_TAB_SONGS:"Nyimbo",ITEMS_TAB_ARTISTS:"Wasanii",ITEMS_LOADED_COUNT:"{{loaded}} ya {{total}} {{type}} imepakia",DESCRIPTION_COPY:"Nakili vitu vyote kwenye kisanduku cha kuchakata kwenye ubao wa kunakili.",DESCRIPTION_EXPORT:"Hifadhi vitu vyote kwenye kisanduku cha kuchakata kwenye faili ya .json.",DESCRIPTION_IMPORT:"Andika upya vitu vyote kwenye kisanduku cha kuchakata kupitia faili ya .json.",DESCRIPTION_CLEAR:"Futa vitu vyote kutoka kwenye kisanduku cha taka (hauwezi kurudishwa).",ITEMS_EMPTY_SONGS_TITLE:"Hakuna wimbo uliowekwa kwenye kisima!",ITEMS_EMPTY_ARTISTS_TITLE:"Hakuna wasanii wamevunjika!",DESCRIPTION_SETTINGS_ENABLED:"Bofya kuu kuwezesha au kuzima uwezo wote wa Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Onyesha ikoni ya kisanduku cha taka kwenye kivinjari cha kucheza kando ya kipande kinachotamasha sasa kwa ajili ya upatikanaji wa haraka",DESCRIPTION_SETTINGS_AUTOPLAY:"Anza kucheza muziki kiotomatiki unapofungua Spotify au unapofungua extension",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Ongeza alama za kahawa kila wimbo kwenye orodha yako inayofuata kwa usimamizi rahisi",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Ongeza alama za kahawa karibu na nyimbo katika maoni ya kikosoa na orodha ya kikosoa kwa ajili ya kuchuja kwa haraka",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Rejesha kiotomatiki kutoka kwa hitilafu za kucheza kwenye Spotify kwa kurudia orodha ya nyimbo yako ya mwisho",SETTINGS_SKIP_TRASHED_TRACKS:"Sautisha Nyimbo Zilizoharibiwa",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Rukisha otomatiki nyimbo zilizofutwa na tafuta kipande kifuatacho kinachoruhusiwa wakati wa kucheza",SETTINGS_AUTO_CLEAN_QUEUE:"Ondoa Safu ya Usafi",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Ondoa kiotomatiki nyimbo zilizotupwa kutoka kwenye safu yako ya Smart Shuffle",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Taka kwenye Kitufe cha Joto cha Kifupi",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Ondoa kiotomatiki nyimbo ya sasa wakati wa kutumia快捷键 Ctrl+Right kupitia kwa nyimbo inayofuata",SETTINGS_REMOTE_CONTROL:"Kudhibiti mbali",SETTINGS_REMOTE_TOGGLE:"Washa Mgawanyiko wa Mbali",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Bonyeza mara mbili kucheza/kukataza kutoka kwa simu ili kugeuza kusonga mbele/kurekebisha. Kusonga mbele kwenye nyimbo hushtaki kugeuzwa.",SETTINGS_REMOTE_SKIPPING:"Ukipinga Mbali Umeanzishwa",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Unapotumia, kuzuia kufuta kinafanya kazi hata unapowatibu Spotify kutoka kifaa kingine (k.m., simu ya mkononi)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Ukomo wa mbali umewezeshwa",MESSAGE_REMOTE_SKIPPING_DISABLED:"Kusuka mbali kimezimwa",MESSAGE_SONG_ADDED_REMOTE:"Wimbo umefukuzwa kwa mbali",SETTINGS_TRASH_VIA_LIKE:"Taka kupitia Kama",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Kama wimbo kutoka kwenye simu kwenda kwenye kisima. Inatondoa kama kiotomatoma na kuenda moja kwa moja kwenye wimbo ujao.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var B8=K((aM,Xu)=>{Xu.exports={TRASHBIN_NAME:"குப்பைத் தொட்டி+",ACTION_THROW:"குப்பைத் தொட்டியில் போடுக",ACTION_UNTHROW:"குப்பைத் தொட்டியிலிருந்து நீக்கு",ACTION_CLEAR:"தெளிவான",ACTION_COPY:"நகலெடுக்கவும்",ACTION_EXPORT:"ஏற்றுமதி",ACTION_IMPORT:"இறக்குமதி",MESSAGE_COPIED:"கிளிப்போர்டுக்கு நகலெடுக்கப்பட்டது",MESSAGE_CLEARED:"நெடுவரிசை வெற்றிகரமாக அழிக்கப்பட்டது!",MESSAGE_SONG_ADDED:"பாடல் குப்பைத் தொட்டியில் சேர்க்கப்பட்டது",MESSAGE_SONG_REMOVED:"பாடல் குப்பைத் தொட்டியிலிருந்து நீக்கப்பட்டது",MESSAGE_ARTIST_ADDED:"கலைஞர் குப்பைத் தொட்டியில் சேர்க்கப்பட்டார்",MESSAGE_ARTIST_REMOVED:"கலைஞர் குப்பைத் தொட்டியிலிருந்து நீக்கப்பட்டார்",BACKUP_SAVE_SUCCESS:"காப்பு நிகழ்த்தி சேமிப்பு வெற்றிகரமாக முடிந்தது.",BACKUP_SAVE_FAILED:"காப்பு நகலைச் சேமிக்க முடியவில்லை, குப்பைத் தொட்டியின் உள்ளடக்கங்களை கிளிப்போர்டுக்கு நகலெடுத்து கையேடாக ஒரு காப்பு நகலை உருவாக்க முயற்சிக்கவும்.",BACKUP_RESTORE_SUCCESS:"காப்பு நிலை வெற்றிகரமாக மீட்டெடுக்கப்பட்டது.",BACKUP_FILE_READ_FAILED:"கோப்பைப் படிக்க முடியவில்லை, தயவுசெய்து அது செல்லுபடியான JSON கோப்பா என்பதை உறுதிப்படுத்திக் கொள்ளவும்.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"குப்பைத் தொட்டி+ அமைப்புகள்",SETTINGS_OPTIONS:"விருப்பங்கள்",SETTINGS_FEATURES:"அம்சங்கள்",SETTINGS_LOCAL_STORAGE:"உள்ளூர் சேமிப்பு",SETTINGS_ENABLED:"செயல்படுத்தப்பட்டது",SETTINGS_SHOW_WIDGET:"விட்ஜெட் ஐகானைக் காட்டு",SETTINGS_AUTOPLAY:"தொடக்கத்தில் தானியங்கி இயக்கம்",SETTINGS_QUEUE_TRASHBIN:"கியூ குப்பைத் தொட்டியை இயக்கு",SETTINGS_TRACKLIST_TRASHBIN:"டிராக்லிஸ்ட் குப்பைத் தொட்டியை இயக்கு",SETTINGS_PLAYLIST_MONITOR:"பிளேலிஸ்ட் கண்காணிப்பு",ITEMS_TITLE:"குப்பைத் தொட்டி+ பொருட்கள்",ITEMS_EMPTY_SONGS:"<strong>நீக்கப்பட்ட பாடல்கள் இல்லை!</strong><br/>நீங்கள் குப்பைத் தொட்டியில் சேர்த்த பாடல்கள் இங்கே தோன்றும்.",ITEMS_EMPTY_ARTISTS:"<strong>நீக்கப்பட்ட கலைஞர்கள் இல்லை!</strong><br/>நீங்கள் குப்பைத் தொட்டியில் சேர்த்த கலைஞர்கள் இங்கே தோன்றும்.",ITEMS_TAB_SONGS:"பாடல்கள்",ITEMS_TAB_ARTISTS:"கலைஞர்கள்",ITEMS_LOADED_COUNT:"{{total}} இல் {{loaded}} {{type}} ஏற்றப்பட்டது",DESCRIPTION_COPY:"குப்பைத் தொட்டியில் உள்ள அனைத்து உருப்படிகளையும் கிளிப்போர்டுக்கு நகலெடுக்கவும்.",DESCRIPTION_EXPORT:"குப்பைத் தொட்டியில் உள்ள அனைத்து பொருட்களையும் .json கோப்பில் சேமிக்கவும்.",DESCRIPTION_IMPORT:"குப்பைத் தொட்டியில் உள்ள அனைத்து உருப்படிகளையும் .json கோப்பு மூலம் மேலெழுதுக.",DESCRIPTION_CLEAR:"அழிக்கப்பட்டவை கூட்டில் உள்ள அனைத்து உருப்படிகளையும் நீக்கு (மீட்டெடுக்க முடியாது).",ITEMS_EMPTY_SONGS_TITLE:"நீக்கப்பட்ட பாடல்கள் இல்லை!",ITEMS_EMPTY_ARTISTS_TITLE:"ஒரு குப்பையான கலைஞர்களும் இல்லை!",DESCRIPTION_SETTINGS_ENABLED:"அனைத்து குப்பைத் தொட்டி+ செயல்பாடுகளையும் இயல்பாக்கவோ அல்லது முடக்கவோ செய்யும் முதன்மை மாற்றி",DESCRIPTION_SETTINGS_SHOW_WIDGET:"தற்போது இயங்கும் தடத்திற்கு அருகில் இயக்குதல் பட்டியில் குப்பை ஐகானை காட்டி, விரைவான அணுகலை வழங்குங்கள்",DESCRIPTION_SETTINGS_AUTOPLAY:"ஸ்பாடிபை திறக்கும்போது அல்லது நீட்டிப்பு ஏற்றப்படும்போது தானியங்கியாக இசையை இயக்கவும்",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"உங்கள் வரவிருக்கும் வரிசையில் உள்ள ஒவ்வொரு பாடலுக்கும் அருகில் குப்பைத் தொட்டி ஐகான்களைச் சேர்த்து, எளிதாக நிர்வகிக்கவும்",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"ஆல்பம் மற்றும் பிளேலிஸ்ட் காட்சிகளில் பாடல்களுக்கு அருகில் குப்பைத் தொட்டி ஐகான்களைச் சேர்த்து, விரைவான வடிகட்டலுக்காக அனுமதிக்கவும்",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"ஸ்பாடிபை இசை இடைவெளி பிழைகளிலிருந்து உங்கள் கடைசி பிளேலிஸ்ட்டை மீண்டும் தொடங்குவதன் மூலம் தானியங்கியாக மீட்டெடுக்கவும்",SETTINGS_SKIP_TRASHED_TRACKS:"நழுவும் தடம் செய்யப்பட்ட தடங்கள்",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"குப்பையில் போடப்பட்ட பாடல்களை தானியங்கியாக தவிர்த்து, இசைப்பதின்போது அடுத்து இசைக்க அனுமதிக்கப்பட்ட பாடலை கண்டுபிடி",SETTINGS_AUTO_CLEAN_QUEUE:"ஆட்டோ கிளீன் கியூ",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"உங்கள் ஸ்மார்ட் ஷஃபுல் குவியலிலிருந்து தவறான பாடல்களை தானியங்கியாக நீக்கவும்",SETTINGS_TRASH_ON_NEXT_HOTKEY:"அடுத்த குறுக்குவழி விசையில் குப்பை",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"அடுத்த பாடலுக்கு தாவ Ctrl+வலது கீபோர்டு குறுக்குவழியைப் பயன்படுத்தும்போது தற்போதைய பாடலை தானாகவே குப்பைத் தொட்டியில் போடு",SETTINGS_REMOTE_CONTROL:"தொலை கட்டுப்பாடு",SETTINGS_REMOTE_TOGGLE:"தொலைநிலை மாற்றுதலை இயக்கு",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"மொபைலிலிருந்து இருமுறை தட்டி இயக்கு/நிறுத்து என அமைக்கவும். ஒரு பாடலைத் தாண்டுவது மாற்றத்தை உறுதிப்படுத்தும்.",SETTINGS_REMOTE_SKIPPING:"தொலைநிலை தவிர்ப்பு செயலில் உள்ளது",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"இது இயக்கப்பட்டால், மற்ற சாதனத்திலிருந்து (எ.கா., மொபைல்) ஸ்பாடிஃபையைக் கட்டுப்படுத்தும்போது கூட குப்பைத் தூரம் தவிர்ப்பது செயல்படும்",MESSAGE_REMOTE_SKIPPING_ENABLED:"தொலைநிலை தவிர்ப்பு இயக்கப்பட்டது",MESSAGE_REMOTE_SKIPPING_DISABLED:"தொலைநிலை தவிர்ப்பு முடக்கப்பட்டது",MESSAGE_SONG_ADDED_REMOTE:"பாடல் தொலைதூரத்திலிருந்தே அழிக்கப்பட்டது",SETTINGS_TRASH_VIA_LIKE:"லைக் மூலம் குப்பை",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"மொபைலிலிருந்து ஒரு பாடலை தூக்கிப்போடுவது போல, தானாகவே லைக் நீக்கி அடுத்த பாடலுக்கு செல்கிறது.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var z8=K((tM,Ju)=>{Ju.exports={TRASHBIN_NAME:"చెత్తబుట్ట+",ACTION_THROW:"చెత్తబుట్టలో ఉంచండి",ACTION_UNTHROW:"చెత్తబుట్ట నుండి తొలగించు",ACTION_CLEAR:"స్పష్టంగా",ACTION_COPY:"కాపీ",ACTION_EXPORT:"ఎగుమతి",ACTION_IMPORT:"దిగుమతి",MESSAGE_COPIED:"క్లిప్‌బోర్డ్‌కు కాపీ చేయబడింది",MESSAGE_CLEARED:"ట్రాష్ బిన్ విజయవంతంగా క్లియర్ చేయబడింది!",MESSAGE_SONG_ADDED:"పాట చెత్తబుట్టలో కలిపారు",MESSAGE_SONG_REMOVED:"పాటను చెత్తబుట్ట నుండి తీసివేశారు",MESSAGE_ARTIST_ADDED:"చెత్తబుట్టలో కళాకారుడు జోడించబడ్డాడు",MESSAGE_ARTIST_REMOVED:"చెత్తబుట్ట నుండి కళాకారుడు తొలగించబడ్డాడు",BACKUP_SAVE_SUCCESS:"బ్యాకప్ విజయవంతంగా సేవ్ చేయబడింది.",BACKUP_SAVE_FAILED:"బ్యాకప్ నిల్వ చేయడం విఫలమైంది, త్రాష్ బిన్ కంటెంట్స్ ని క్లిప్ బోర్డుకు కాపీ చేసి బ్యాకప్ ని మాన్యువల్ గా సృష్టించడానికి ప్రయత్నించండి.",BACKUP_RESTORE_SUCCESS:"బ్యాకప్ విజయవంతంగా పునరుద్ధరించబడింది.",BACKUP_FILE_READ_FAILED:"ఫైల్ చదవడం విఫలమైంది, దయచేసి అది సరైన JSON ఫైల్ అని నిర్ధారించుకోండి.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ట్రాష్‌బిన్+ సెట్టింగ్స్",SETTINGS_OPTIONS:"ఎంపికలు",SETTINGS_FEATURES:"లక్షణాలు",SETTINGS_LOCAL_STORAGE:"స్థానిక నిల్వ",SETTINGS_ENABLED:"సక్రియం చేయబడింది",SETTINGS_SHOW_WIDGET:"విడ్జెట్ ఐకాన్‌ను చూపించండి",SETTINGS_AUTOPLAY:"ప్రారంభంలో ఆటోప్లే చేయి",SETTINGS_QUEUE_TRASHBIN:"క్యూ ట్రాష్‌బిన్‌ను సక్రియం చేయండి",SETTINGS_TRACKLIST_TRASHBIN:"ట్రాక్ లిస్ట్ చెత్తబుట్టను సక్రియం చేయండి",SETTINGS_PLAYLIST_MONITOR:"ప్లేలిస్ట్ మానిటర్",ITEMS_TITLE:"ట్రాష్‌బిన్+ అంశాలు",ITEMS_EMPTY_SONGS:"<strong>ఏ పాడిన పాటలు లేవు!</strong><br/>మీరు చెత్తబుట్టలో జోడించిన పాటలు ఇక్కడ కనిపిస్తాయి.",ITEMS_EMPTY_ARTISTS:"<strong>ఏ కార్టూన్ కళాకారులు లేరు!</strong><br/>మీరు చెత్తబుట్టలో చేర్చిన కళాకారులు ఇక్కడ కనిపిస్తారు.",ITEMS_TAB_SONGS:"పాటలు",ITEMS_TAB_ARTISTS:"కళాకారులు",ITEMS_LOADED_COUNT:"{{total}} లో {{loaded}} {{type}} లోడ్ అయ్యాయి",DESCRIPTION_COPY:"పారవేసిన అంశాల పెట్టెలోని అన్ని అంశాలను క్లిప్‌బోర్డుకు కాపీ చేయండి.",DESCRIPTION_EXPORT:"పారవేసిన అన్ని అంశాలను .json ఫైల్‌లో సేవ్ చేయండి.",DESCRIPTION_IMPORT:"ట్రాష్ బిన్ లోని అన్ని అంశాలను .json ఫైల్ ద్వారా ఓవర్ రైట్ చేయండి.",DESCRIPTION_CLEAR:"పాతర నుండి అన్ని అంశాలను తొలగించండి (తిరిగి చేయలేరు).",ITEMS_EMPTY_SONGS_TITLE:"ఏ పాటలను పాడకండి!",ITEMS_EMPTY_ARTISTS_TITLE:"ఏ విస్మరించబడిన కళాకారులు లేరు!",DESCRIPTION_SETTINGS_ENABLED:"ట్రాష్‌బిన్+ యొక్క అన్ని పనితీరును ప్రారంభించడానికి లేదా నిలిపివేయడానికి మాస్టర్ టాగుల్",DESCRIPTION_SETTINGS_SHOW_WIDGET:"ప్రస్తుతం ప్లే అవుతున్న ట్రాక్ పక్కన ప్లేబ్యాక్ బార్‌లో త్వరగా యాక్సెస్ కోసం చెత్త ఐకాన్‌ను చూపించండి",DESCRIPTION_SETTINGS_AUTOPLAY:"స్పాటిఫై తెరిచినప్పుడు లేదా ఎక్స్టెన్షన్ లోడ్ అయినప్పుడు స్వయంచాలకంగా సంగీతాన్ని ప్లే చేయడం ప్రారంభించండి",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"మీ త్వరలో ఉండే క్యూలోని ప్రతి పాటకు సమీపంలో చెత్త ఐకాన్లను జోడించండి, సులభమైన నిర్వహణ కోసం",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"ఆల్బమ్ మరియు ప్లే లిస్ట్ వీక్షణలలో పాటల పక్కన చెత్త ఐకాన్లను జోడించండి, త్వరిత ఫిల్టరింగ్ కోసం",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"మీ చివరి ప్లేలిస్ట్‌ను తిరిగి ప్రారంభించడం ద్వారా స్పాటిఫై ప్లేబ్యాక్ లోపాల నుండి స్వయంచాలకంగా పునరుద్ధరించుకోండి",SETTINGS_SKIP_TRASHED_TRACKS:"త్రోసిపుచ్చిన ట్రాక్‌లను తప్పించుకోండి",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"ప్లేబ్యాక్ సమయంలో తొలగించబడిన పాటలను స్వయంచాలకంగా దాటి, తదుపరి అనుమతించబడిన ట్రాక్‌ను కనుగొనండి",SETTINGS_AUTO_CLEAN_QUEUE:"ఆటో క్లీన్ క్యూ",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"మీ స్మార్ట్ షఫుల్ క్యూ నుండి పాడుచేసిన పాటలను స్వయంచాలకంగా తొలగించండి",SETTINGS_TRASH_ON_NEXT_HOTKEY:"తదుపరి హాట్‌కీపై చెత్త",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Ctrl+రైట్ కీబోర్డ్ షార్ట్‌కట్ ఉపయోగించి తదుపరి ట్రాక్‌కు దాటినప్పుడు ప్రస్తుత పాటను స్వయంచాలకంగా పారవేయండి",SETTINGS_REMOTE_CONTROL:"రిమోట్ కంట్రోల్",SETTINGS_REMOTE_TOGGLE:"రిమోట్ టాగుల్ ని సక్రియం చేయండి",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"మొబైల్ నుండి రిమోట్ స్కిప్పింగ్‌ను ఆన్/ఆఫ్ చేయడానికి ప్లే/పాజ్ కోసం రెండుసార్లు నొక్కండి. ట్రాక్ స్కిప్ టాగుల్‌ను ధృవీకరిస్తుంది.",SETTINGS_REMOTE_SKIPPING:"రిమోట్ స్కిప్పింగ్ సక్రియంగా ఉంది",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"సక్రియం చేసినప్పుడు, మరొక పరికరం (ఉదా: మొబైల్) నుండి స్పాటిఫైని నియంత్రించినప్పటికీ ట్రాష్-స్కిప్పింగ్ పనిచేస్తుంది",MESSAGE_REMOTE_SKIPPING_ENABLED:"దూరం నుండి స్కిప్ చేయడం సక్రియం చేయబడింది",MESSAGE_REMOTE_SKIPPING_DISABLED:"రిమోట్ స్కిప్పింగ్ నిలిపివేయబడింది",MESSAGE_SONG_ADDED_REMOTE:"రిమోట్ ద్వారా పాటను పాడాడు",SETTINGS_TRASH_VIA_LIKE:"లైక్ ద్వారా చెత్త",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"మొబైల్ నుండి ట్రాష్ కు ఒక పాట లాగా. స్వయంచాలకంగా డిస్లైక్ చేసి తదుపరి ట్రాక్ కు దూకుతుంది.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var L8=K((rM,$u)=>{$u.exports={TRASHBIN_NAME:"ถังขยะ+",ACTION_THROW:"วางในถังขยะ",ACTION_UNTHROW:"ลบออกจากถังขยะ",ACTION_CLEAR:"ชัดเจน",ACTION_COPY:"คัดลอก",ACTION_EXPORT:"ส่งออก",ACTION_IMPORT:"นำเข้า",MESSAGE_COPIED:"คัดลอกไปยังคลิปบอร์ดแล้ว",MESSAGE_CLEARED:"ล้างถังขยะเรียบร้อยแล้ว!",MESSAGE_SONG_ADDED:"เพลงถูกลบลงถังขยะ",MESSAGE_SONG_REMOVED:"ลบเพลงออกจากถังขยะแล้ว",MESSAGE_ARTIST_ADDED:"ศิลปินถูกเพิ่มไปยังถังขยะ",MESSAGE_ARTIST_REMOVED:"ศิลปินถูกลบออกจากถังขยะ",BACKUP_SAVE_SUCCESS:"สำรองข้อมูลเรียบร้อยแล้ว",BACKUP_SAVE_FAILED:"ไม่สามารถบันทึกการสำรองข้อมูลได้ โปรดลองคัดลอกเนื้อหาจากถังขยะไปยังคลิปบอร์ดแล้วสร้างการสำรองข้อมูลด้วยตนเอง",BACKUP_RESTORE_SUCCESS:"กู้คืนข้อมูลสำรองเรียบร้อยแล้ว",BACKUP_FILE_READ_FAILED:"ไม่สามารถอ่านไฟล์ได้ กรุณาตรวจสอบว่าเป็นไฟล์ JSON ที่ถูกต้อง",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"การตั้งค่า Trashbin+",SETTINGS_OPTIONS:"ตัวเลือก",SETTINGS_FEATURES:"คุณสมบัติ",SETTINGS_LOCAL_STORAGE:"พื้นที่จัดเก็บข้อมูลในเครื่อง",SETTINGS_ENABLED:"เปิดใช้งาน",SETTINGS_SHOW_WIDGET:"แสดงไอคอนวิดเจ็ต",SETTINGS_AUTOPLAY:"เปิดใช้งานการเล่นอัตโนมัติเมื่อเริ่มต้น",SETTINGS_QUEUE_TRASHBIN:"เปิดใช้งานถังขยะของคิว",SETTINGS_TRACKLIST_TRASHBIN:"เปิดใช้งานถังขยะรายการแทร็ก",SETTINGS_PLAYLIST_MONITOR:"ตัวตรวจสอบเพลย์ลิสต์",ITEMS_TITLE:"รายการถังขยะ+",ITEMS_EMPTY_SONGS:"<strong>ไม่มีเพลงที่ถังขยะ!</strong><br/>เพลงที่คุณเพิ่มไปยังถังขยะจะแสดงที่นี่",ITEMS_EMPTY_ARTISTS:"<strong>ไม่มีศิลปินที่ถูกลบ!</strong><br/>ศิลปินที่คุณเพิ่มไปยังถังขยะจะแสดงที่นี่",ITEMS_TAB_SONGS:"เพลง",ITEMS_TAB_ARTISTS:"ศิลปิน",ITEMS_LOADED_COUNT:"โหลดแล้ว {{loaded}} จากทั้งหมด {{total}} {{type}}",DESCRIPTION_COPY:"คัดลอกรายการทั้งหมดในถังขยะไปยังคลิปบอร์ด",DESCRIPTION_EXPORT:"บันทึกรายการทั้งหมดในถังขยะเป็นไฟล์ .json",DESCRIPTION_IMPORT:"เขียนทับรายการทั้งหมดในถังขยะผ่านไฟล์ .json",DESCRIPTION_CLEAR:"ลบทุกรายการออกจากถังขยะ (ไม่สามารถย้อนกลับได้)",ITEMS_EMPTY_SONGS_TITLE:"ไม่มีเพลงที่ถูกลบ!",ITEMS_EMPTY_ARTISTS_TITLE:"ไม่มีศิลปินที่ไร้ค่า!",DESCRIPTION_SETTINGS_ENABLED:"ตัวสลับหลักเพื่อเปิดหรือปิดการใช้งานฟังก์ชันทั้งหมดของ Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"แสดงไอคอนถังขยะในแถบการเล่นถัดจากแทร็กที่กำลังเล่นอยู่เพื่อเข้าถึงอย่างรวดเร็ว",DESCRIPTION_SETTINGS_AUTOPLAY:"เริ่มเล่นเพลงโดยอัตโนมัติเมื่อเปิด Spotify หรือเมื่อส่วนขยายโหลดเสร็จ",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"เพิ่มไอคอนถังขยะถัดจากแต่ละเพลงในคิวที่กำลังจะเล่นของคุณเพื่อการจัดการที่ง่ายขึ้น",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"เพิ่มไอคอนถังขยะถัดจากเพลงในมุมมองอัลบั้มและเพลย์ลิสต์เพื่อการกรองอย่างรวดเร็ว",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"กู้คืนอัตโนมัติจากปัญหาการเล่นเพลงบน Spotify โดยการกลับมาเล่นเพลย์ลิสต์ล่าสุดของคุณอีกครั้ง",SETTINGS_SKIP_TRASHED_TRACKS:"ข้ามแทร็กที่ถูกลบ",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"ข้ามเพลงที่ถูกลบโดยอัตโนมัติ และค้นหาแทร็กถัดไปที่อนุญาตระหว่างการเล่น",SETTINGS_AUTO_CLEAN_QUEUE:"คิวทำความสะอาดอัตโนมัติ",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"ลบเพลงที่ถูกลบแล้วออกจากคิวสุ่มอัจฉริยะของคุณโดยอัตโนมัติ",SETTINGS_TRASH_ON_NEXT_HOTKEY:"ขยะในปุ่มลัดถัดไป",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"ลบเพลงปัจจุบันโดยอัตโนมัติเมื่อใช้แป้นพิมพ์ลัด Ctrl+ขวา เพื่อข้ามไปยังแทร็กถัดไป",SETTINGS_REMOTE_CONTROL:"รีโมทคอนโทรล",SETTINGS_REMOTE_TOGGLE:"เปิดใช้งานการสลับระยะไกล",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"แตะที่ปุ่มเล่น/หยุดสองครั้งจากมือถือเพื่อเปิดหรือปิดการข้ามแทร็กจากระยะไกล การข้ามแทร็กหนึ่งครั้งจะยืนยันการตั้งค่านี้",SETTINGS_REMOTE_SKIPPING:"การข้ามระยะไกลใช้งานอยู่",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"เมื่อเปิดใช้งาน ฟีเจอร์ข้ามถังขยะจะทำงานแม้คุณกำลังควบคุม Spotify จากอุปกรณ์อื่น (เช่น มือถือ)",MESSAGE_REMOTE_SKIPPING_ENABLED:"เปิดใช้งานการข้ามระยะไกลแล้ว",MESSAGE_REMOTE_SKIPPING_DISABLED:"ปิดการข้ามระยะไกลแล้ว",MESSAGE_SONG_ADDED_REMOTE:"เพลงถูกลบผ่านระยะไกล",SETTINGS_TRASH_VIA_LIKE:"ขยะผ่านไลค์",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"เหมือนเพลงจากมือถือไปยังถังขยะ มันจะยกเลิกการถูกใจและข้ามไปยังแทร็กถัดไปโดยอัตโนมัติ",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var H8=K((lM,ag)=>{ag.exports={TRASHBIN_NAME:"Çöp Kutusu+",ACTION_THROW:"Çöp kutusuna yerleştir",ACTION_UNTHROW:"Çöp Kutusundan Kaldır",ACTION_CLEAR:"Açık",ACTION_COPY:"Kopyala",ACTION_EXPORT:"Dışa aktar",ACTION_IMPORT:"İçe aktar",MESSAGE_COPIED:"Panoya kopyalandı",MESSAGE_CLEARED:"Çöp kutusu başarıyla temizlendi!",MESSAGE_SONG_ADDED:"Şarkı çöp kutusuna eklendi",MESSAGE_SONG_REMOVED:"Şarkı çöp kutusundan kaldırıldı",MESSAGE_ARTIST_ADDED:"Sanatçı çöp kutusuna eklendi",MESSAGE_ARTIST_REMOVED:"Sanatçı çöp kutusundan kaldırıldı",BACKUP_SAVE_SUCCESS:"Yedek başarıyla kaydedildi.",BACKUP_SAVE_FAILED:"Yedek kaydedilemedi, çöp kutusu içeriğini panoya kopyalamayı ve yedeği elle oluşturmayı deneyin.",BACKUP_RESTORE_SUCCESS:"Yedek başarıyla geri yüklendi.",BACKUP_FILE_READ_FAILED:"Dosya okunamadı, lütfen geçerli bir JSON dosyası olduğundan emin olun.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Çöp Kutusu+ Ayarları",SETTINGS_OPTIONS:"Seçenekler",SETTINGS_FEATURES:"Özellikler",SETTINGS_LOCAL_STORAGE:"Yerel Depolama",SETTINGS_ENABLED:"Etkinleştirildi",SETTINGS_SHOW_WIDGET:"Widget Simgesini Göster",SETTINGS_AUTOPLAY:"Başlangıçta Otomatik Oynatma",SETTINGS_QUEUE_TRASHBIN:"Kuyruk Çöp Kutusunu Etkinleştir",SETTINGS_TRACKLIST_TRASHBIN:"Parça Listesi Çöp Kutusunu Etkinleştir",SETTINGS_PLAYLIST_MONITOR:"Oynatma Listesi İzleyici",ITEMS_TITLE:"Çöp Kutusu+ Öğeleri",ITEMS_EMPTY_SONGS:"<strong>Çöpe atılmış şarkı yok!</strong><br/>Çöp kutusuna eklediğiniz şarkılar burada görünecek.",ITEMS_EMPTY_ARTISTS:"<strong>Çöpe atılmış sanatçı yok!</strong><br/>Çöp kutusuna eklediğiniz sanatçılar burada görünecek.",ITEMS_TAB_SONGS:"Şarkılar",ITEMS_TAB_ARTISTS:"Sanatçılar",ITEMS_LOADED_COUNT:"Yüklenen {{loaded}} / {{total}} {{type}}",DESCRIPTION_COPY:"Çöp kutusundaki tüm öğeleri panoya kopyala.",DESCRIPTION_EXPORT:"Çöp kutusundaki tüm öğeleri bir .json dosyasına kaydedin.",DESCRIPTION_IMPORT:"Çöp kutusundaki tüm öğeleri .json dosyası ile değiştirin.",DESCRIPTION_CLEAR:"Çöp kutusundaki tüm öğeleri sil (geri alınamaz).",ITEMS_EMPTY_SONGS_TITLE:"Hiçbir şarkı çöpe atılmadı!",ITEMS_EMPTY_ARTISTS_TITLE:"Hiçbir sanatçıyı çöpe atmayın!",DESCRIPTION_SETTINGS_ENABLED:"Tüm Çöp Kutusu+ işlevselliğini etkinleştirmek veya devre dışı bırakmak için ana anahtar",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Çalınan parça yanında hızlı erişim için oynatma çubuğunda bir çöp ikonu görüntüleyin",DESCRIPTION_SETTINGS_AUTOPLAY:"Spotify açıldığında veya eklenti yüklendiğinde otomatik olarak müzik çalmaya başlayın",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Sıradaki çalma listesindeki her şarkıya kolay yönetim için çöp ikonları ekleyin",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Albüm ve çalma listesi görünümlerinde hızlı filtreleme için şarkıların yanına çöp ikonları ekleyin",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Spotify oynatma hatalarından son oynatma listenizi devam ettirerek otomatik olarak kurtulun",SETTINGS_SKIP_TRASHED_TRACKS:"Çöpe Atılan Parçaları Atla",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Oynatma sırasında çöpe atılan şarkıları otomatik olarak atlayarak bir sonraki izin verilen parçayı bulun",SETTINGS_AUTO_CLEAN_QUEUE:"Otomatik Temizleme Sırası",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Çöpe atılmış şarkıları Akıllı Karışık Kuyruğunuzdan otomatik olarak kaldırın",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Bir Sonraki Hızlı Erişim Tuşuyla Çöp",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Bir sonraki parçaya geçmek için Ctrl+Sağ klavye kısayolunu kullandığınızda geçerli şarkıyı otomatik olarak çöpe at",SETTINGS_REMOTE_CONTROL:"Uzaktan kumanda",SETTINGS_REMOTE_TOGGLE:"Uzaktan Geçişi Etkinleştir",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Mobil cihazdan oynat/duraklat için iki kez dokunarak uzaktan atlama özelliğini aç/kapat. Bir parça atlaması, geçişi onaylar.",SETTINGS_REMOTE_SKIPPING:"Uzaktan Atlatma Etkin",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Etkinleştirildiğinde çöp kutusu atlaması, Spotify'ı başka bir cihazdan (örneğin mobil) kontrol ederken bile çalışır",MESSAGE_REMOTE_SKIPPING_ENABLED:"Uzaktan atlama etkinleştirildi",MESSAGE_REMOTE_SKIPPING_DISABLED:"Uzaktan atlama devre dışı",MESSAGE_SONG_ADDED_REMOTE:"Şarkı uzaktan yok edildi",SETTINGS_TRASH_VIA_LIKE:"Like ile çöp",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Bir şarkı gibi cep telefonundan çöpe atar. Otomatik olarak beğenisini kaldırır ve bir sonraki parçaya geçer.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var V8=K((iM,tg)=>{tg.exports={TRASHBIN_NAME:"Смітник+",ACTION_THROW:"Помістити в кошик для сміття",ACTION_UNTHROW:"Видалити з кошика",ACTION_CLEAR:"Чітко",ACTION_COPY:"Копіювати",ACTION_EXPORT:"Експорт",ACTION_IMPORT:"Імпорт",MESSAGE_COPIED:"Скопійовано в буфер обміну",MESSAGE_CLEARED:"Смітник успішно очищено!",MESSAGE_SONG_ADDED:"Пісню додано до кошика для сміття",MESSAGE_SONG_REMOVED:"Пісню видалено з кошика",MESSAGE_ARTIST_ADDED:"Художника додано до кошика для сміття",MESSAGE_ARTIST_REMOVED:"Художника видалено з кошика для сміття",BACKUP_SAVE_SUCCESS:"Резервну копію успішно збережено.",BACKUP_SAVE_FAILED:"Не вдалося зберегти резервну копію, спробуйте скопіювати вміст кошика у буфер обміну та створити резервну копію вручну.",BACKUP_RESTORE_SUCCESS:"Резервну копію успішно відновлено.",BACKUP_FILE_READ_FAILED:"Не вдалося прочитати файл, переконайтеся, що це дійсний файл JSON.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Налаштування кошика+",SETTINGS_OPTIONS:"Параметри",SETTINGS_FEATURES:"Особливості",SETTINGS_LOCAL_STORAGE:"Локальне сховище",SETTINGS_ENABLED:"Увімкнено",SETTINGS_SHOW_WIDGET:"Показати піктограму віджета",SETTINGS_AUTOPLAY:"Автоматичний запуск при старті",SETTINGS_QUEUE_TRASHBIN:"Увімкнути чергу кошика для сміття",SETTINGS_TRACKLIST_TRASHBIN:"Увімкнути кошик для трек-листа",SETTINGS_PLAYLIST_MONITOR:"Монітор плейлистів",ITEMS_TITLE:"Предмети смітника+",ITEMS_EMPTY_SONGS:"<strong>Немає видалених пісень!</strong><br/>Пісні, які ви додаєте у кошик для сміття, з’являться тут.",ITEMS_EMPTY_ARTISTS:"<strong>Немає вилучених виконавців!</strong><br/>Виконавці, яких ви додали до кошика, з’являться тут.",ITEMS_TAB_SONGS:"Пісні",ITEMS_TAB_ARTISTS:"Художники",ITEMS_LOADED_COUNT:"Завантажено {{loaded}} із {{total}} {{type}}",DESCRIPTION_COPY:"Копіювати всі елементи у кошику в буфер обміну.",DESCRIPTION_EXPORT:"Зберегти всі елементи в кошику у файл .json.",DESCRIPTION_IMPORT:"Перезаписати всі елементи в кошику за допомогою файлу .json.",DESCRIPTION_CLEAR:"Очистити всі елементи з кошика (не можна скасувати).",ITEMS_EMPTY_SONGS_TITLE:"Жодних вилучених пісень!",ITEMS_EMPTY_ARTISTS_TITLE:"Жодного викинутого артиста!",DESCRIPTION_SETTINGS_ENABLED:"Головний перемикач для ввімкнення або вимкнення всієї функціональності смітника+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Показувати значок кошика на панелі відтворення поруч із поточним треком для швидкого доступу",DESCRIPTION_SETTINGS_AUTOPLAY:"Автоматичне відтворення музики під час відкриття Spotify або завантаження розширення",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Додайте піктограми смітника поруч із кожною піснею у вашому майбутньому черзі для легкого управління",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Додайте піктограми смітника біля пісень у перегляді альбомів і плейлистів для швидкого фільтрування",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Автоматичне відновлення після збоїв відтворення в Spotify шляхом відновлення останнього плейлиста",SETTINGS_SKIP_TRASHED_TRACKS:"Пропустити видалені треки",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Автоматично пропускати видалені пісні та знаходити наступний доступний трек під час відтворення",SETTINGS_AUTO_CLEAN_QUEUE:"Черга автоматичного очищення",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Автоматично видаляти видалені пісні з черги розумного перемішування",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Сміття на наступному гарячому клавіші",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Автоматично видаляти поточну пісню, коли використовується комбінація клавіш Ctrl+Right для переходу до наступного треку",SETTINGS_REMOTE_CONTROL:"Пульт дистанційного керування",SETTINGS_REMOTE_TOGGLE:"Увімкнути віддалене перемикання",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Двічі торкніться кнопки відтворення/паузи на мобільному пристрої, щоб увімкнути або вимкнути дистанційне перемотування. Пропуск треку підтверджує перемикання.",SETTINGS_REMOTE_SKIPPING:"Пропуск на відстані активний",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Коли ця функція увімкнена, пропуск треків працює навіть при керуванні Spotify з іншого пристрою (наприклад, мобільного)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Увімкнено віддалене пропускання",MESSAGE_REMOTE_SKIPPING_DISABLED:"Віддалене пропускання вимкнено",MESSAGE_SONG_ADDED_REMOTE:"Пісню видалено на відстані",SETTINGS_TRASH_VIA_LIKE:"Сміття через Лайк",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Як пісню з мобільного до смітника. Автоматично відміняє вподобання та переходить до наступної композиції.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var k8=K((eM,rg)=>{rg.exports={TRASHBIN_NAME:"کوڑا دان+",ACTION_THROW:"کوڑے دان میں ڈالیں",ACTION_UNTHROW:"کوڑے دان سے ہٹائیں",ACTION_CLEAR:"صاف",ACTION_COPY:"نقل کریں",ACTION_EXPORT:"برآمد کریں",ACTION_IMPORT:"درآمد",MESSAGE_COPIED:"کاپی کلپ بورڈ پر کر دی گئی",MESSAGE_CLEARED:"کوڑا دان کامیابی سے خالی کر دیا گیا!",MESSAGE_SONG_ADDED:"گانا کوڑے دان میں شامل کر دیا گیا",MESSAGE_SONG_REMOVED:"گانا کو صفائی کے ڈبے سے ہٹا دیا گیا",MESSAGE_ARTIST_ADDED:"آرٹسٹ کو کوڑے دان میں شامل کیا گیا",MESSAGE_ARTIST_REMOVED:"آرٹسٹ کو کوڑے دان سے ہٹا دیا گیا",BACKUP_SAVE_SUCCESS:"بیک اپ کامیابی سے محفوظ ہو گیا۔",BACKUP_SAVE_FAILED:"بیک اپ محفوظ کرنے میں ناکامی، کچرے کے ڈبے کی معلومات کو کلپ بورڈ پر کاپی کرنے اور دستی طور پر بیک اپ بنانے کی کوشش کریں۔",BACKUP_RESTORE_SUCCESS:"بیک اپ کامیابی سے بحال کر دیا گیا۔",BACKUP_FILE_READ_FAILED:"فائل پڑھنے میں ناکام، براہ کرم یقینی بنائیں کہ یہ ایک درست JSON فائل ہے۔",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"ٹریش بین + سیٹنگز",SETTINGS_OPTIONS:"اختیارات",SETTINGS_FEATURES:"خصوصیات",SETTINGS_LOCAL_STORAGE:"مقامی اسٹوریج",SETTINGS_ENABLED:"فعال",SETTINGS_SHOW_WIDGET:"وِجیٹ آئیکن دکھائیں",SETTINGS_AUTOPLAY:"شروع میں خودکار چلائیں",SETTINGS_QUEUE_TRASHBIN:"کیو ٹریش بین کو فعال کریں",SETTINGS_TRACKLIST_TRASHBIN:"ٹریکلسٹ کوڑا دان کو فعال کریں",SETTINGS_PLAYLIST_MONITOR:"پلے لسٹ مانیٹر",ITEMS_TITLE:"ٹریش بین + اشیاء",ITEMS_EMPTY_SONGS:"<strong>کوئی حذف شدہ گانے نہیں!</strong><br/>جتنے گانے آپ ریسی وین میں ڈالیں گے وہ یہاں ظاہر ہوں گے۔",ITEMS_EMPTY_ARTISTS:"<strong>کوئی فنکار کوڑے دان میں نہیں!</strong><br/>فنکار جنہیں آپ کوڑے دان میں شامل کریں گے وہ یہاں ظاہر ہوں گے۔",ITEMS_TAB_SONGS:"گانے",ITEMS_TAB_ARTISTS:"فنکار",ITEMS_LOADED_COUNT:"{{total}} میں سے {{loaded}} {{type}} لوڈ ہو چکا ہے",DESCRIPTION_COPY:"کوڑے دان میں تمام اشیاء کو کلپ بورڈ پر کاپی کریں۔",DESCRIPTION_EXPORT:"تمام اشیاء کو کوڑے دان میں ایک .json فائل میں محفوظ کریں۔",DESCRIPTION_IMPORT:"کچرے کے ڈبے میں تمام اشیاء کو .json فائل کے ذریعے اوور رائٹ کریں۔",DESCRIPTION_CLEAR:"کچرے کے ڈبے سے تمام اشیاء کو صاف کریں (واپس نہیں کیا جا سکتا)۔",ITEMS_EMPTY_SONGS_TITLE:"کوئی حذف شدہ گانے نہیں!",ITEMS_EMPTY_ARTISTS_TITLE:"کوئی تباہ شدہ فنکار نہیں!",DESCRIPTION_SETTINGS_ENABLED:"تمام ٹریش بین + فعالیت کو چالو یا بند کرنے کے لیے ماسٹر ٹوگل",DESCRIPTION_SETTINGS_SHOW_WIDGET:"موجودہ چل رہے ٹریک کے قریب پلے بیک بار میں تیزی سے رسائی کے لیے ایک کوڑا دان کا آئیکن ظاہر کریں",DESCRIPTION_SETTINGS_AUTOPLAY:"جب سپاٹیفائی کھلتا ہے یا ایکسٹینشن لوڈ ہوتا ہے تو خود بخود موسیقی چلانا شروع کریں",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"اپنی آنے والی قطار میں ہر گانے کے ساتھ کوڑا دان کے آئیکن شامل کریں تاکہ آسانی سے انتظام ہو سکے",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"البم اور پلے لسٹ کے مناظر میں گانوں کے قریب کوڑا کرکٹ کے آئیکن شامل کریں تاکہ تیزی سے فلٹر کیا جا سکے",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"اسپاٹی فائی کی چلانے میں آنے والی خرابیوں سے خودکار طور پر اپنی آخری پلے لسٹ دوبارہ چلا کر بحال ہو جائیں",SETTINGS_SKIP_TRASHED_TRACKS:"کھوئے ہوئے ٹریکس کو چھوڑ دیں",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"خود بخود ڈسکارڈ کیے گئے گانوں کو چھوڑ دیں اور چلانے کے دوران اگلا منظور شدہ ٹریک تلاش کریں",SETTINGS_AUTO_CLEAN_QUEUE:"خودکار صفائی کی قطار",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"اپنی اسمارٹ شفل کی قطار سے خودکار طور پر ڈسکارڈ کیے گئے گانے ہٹا دیں",SETTINGS_TRASH_ON_NEXT_HOTKEY:"اگلی ہاٹ کی پر کوڑا کرکٹ",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"موجودہ گانا خود بخود ٹریش کریں جب اگلے ٹریک پر جانے کے لیے Ctrl+Right کی بورڈ شارٹ کٹ استعمال کی جائے",SETTINGS_REMOTE_CONTROL:"دور دراز کنٹرول",SETTINGS_REMOTE_TOGGLE:"دور دراز کنٹرول کے لیے ٹوگل آن کریں",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"موبائل سے پلے/روک تھام کے لیے ڈبل ٹیپ کریں تاکہ دور دراز کی چھلانگ کو آن/آف کیا جا سکے۔ ٹریک چھلانگ تبدیلی کی تصدیق کرتی ہے۔",SETTINGS_REMOTE_SKIPPING:"دور دراز مقام سے سکیپ کرنا فعال ہے",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"جب چالو ہو، تو ٹریش کو چھوڑنا دوسرے ڈیوائس (مثلاً موبائل) سے سپاٹیفائی کو کنٹرول کرتے وقت بھی کام کرتا ہے۔",MESSAGE_REMOTE_SKIPPING_ENABLED:"دور دراز سے چھلانگ لگانا فعال ہے",MESSAGE_REMOTE_SKIPPING_DISABLED:"دور دراز کا اسکیپ کرنا غیر فعال ہے",MESSAGE_SONG_ADDED_REMOTE:"گانا دور دراز کے ذریعے تباہ کر دیا گیا",SETTINGS_TRASH_VIA_LIKE:"لائک کے ذریعے کوڑا کرکٹ",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"موبائل سے تراش کی طرح ایک گانا۔ خود بخود ناپسند کرتا ہے اور اگلے ٹریک پر جا تا ہے۔",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var N8=K((oM,lg)=>{lg.exports={TRASHBIN_NAME:"Thùng rác+",ACTION_THROW:"Đặt vào thùng rác",ACTION_UNTHROW:"Xóa khỏi Thùng rác",ACTION_CLEAR:"Rõ ràng",ACTION_COPY:"Sao chép",ACTION_EXPORT:"Xuất khẩu",ACTION_IMPORT:"Nhập khẩu",MESSAGE_COPIED:"Đã sao chép vào bộ nhớ tạm",MESSAGE_CLEARED:"Đã xóa thùng rác thành công!",MESSAGE_SONG_ADDED:"Bài hát đã được thêm vào thùng rác",MESSAGE_SONG_REMOVED:"Bài hát đã được xóa khỏi thùng rác",MESSAGE_ARTIST_ADDED:"Họa sĩ đã được thêm vào thùng rác",MESSAGE_ARTIST_REMOVED:"Nghệ sĩ đã bị xóa khỏi thùng rác",BACKUP_SAVE_SUCCESS:"Sao lưu đã được lưu thành công.",BACKUP_SAVE_FAILED:"Không thể lưu bản sao lưu, hãy thử sao chép nội dung thùng rác vào bộ nhớ tạm và tạo bản sao lưu thủ công.",BACKUP_RESTORE_SUCCESS:"Sao lưu đã được khôi phục thành công.",BACKUP_FILE_READ_FAILED:"Không thể đọc tệp, vui lòng đảm bảo rằng đây là tệp JSON hợp lệ.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Cài đặt Trashbin+",SETTINGS_OPTIONS:"Tùy chọn",SETTINGS_FEATURES:"Tính năng",SETTINGS_LOCAL_STORAGE:"Lưu trữ cục bộ",SETTINGS_ENABLED:"Đã bật",SETTINGS_SHOW_WIDGET:"Hiển thị biểu tượng tiện ích",SETTINGS_AUTOPLAY:"Tự động phát khi khởi động",SETTINGS_QUEUE_TRASHBIN:"Bật thùng rác hàng đợi",SETTINGS_TRACKLIST_TRASHBIN:"Bật thùng rác danh sách phát",SETTINGS_PLAYLIST_MONITOR:"Trình theo dõi danh sách phát",ITEMS_TITLE:"Các mục Thùng rác+",ITEMS_EMPTY_SONGS:"<strong>Không có bài hát nào bị xóa!</strong><br/>Các bài hát bạn thêm vào thùng rác sẽ hiển thị ở đây.",ITEMS_EMPTY_ARTISTS:"<strong>Không có nghệ sĩ nào bị xóa!</strong><br/>Các nghệ sĩ bạn thêm vào thùng rác sẽ hiển thị ở đây.",ITEMS_TAB_SONGS:"Bài hát",ITEMS_TAB_ARTISTS:"Nghệ sĩ",ITEMS_LOADED_COUNT:"{{loaded}} trong số {{total}} {{type}} đã được tải",DESCRIPTION_COPY:"Sao chép tất cả các mục trong thùng rác vào bộ nhớ tạm.",DESCRIPTION_EXPORT:"Lưu tất cả các mục trong thùng rác vào một tệp .json.",DESCRIPTION_IMPORT:"Ghi đè tất cả các mục trong thùng rác thông qua tệp .json.",DESCRIPTION_CLEAR:"Xóa tất cả mục khỏi thùng rác (không thể hoàn tác).",ITEMS_EMPTY_SONGS_TITLE:"Không có bài hát nào bị xóa!",ITEMS_EMPTY_ARTISTS_TITLE:"Không có nghệ sĩ nào bị xóa!",DESCRIPTION_SETTINGS_ENABLED:"Công tắc chính để bật hoặc tắt mọi chức năng của Trashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Hiển thị biểu tượng thùng rác trên thanh phát nhạc, bên cạnh bản nhạc đang phát để truy cập nhanh",DESCRIPTION_SETTINGS_AUTOPLAY:"Tự động phát nhạc khi Spotify mở hoặc tiện ích được tải",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Thêm biểu tượng thùng rác bên cạnh mỗi bài hát trong hàng đợi sắp tới của bạn để dễ quản lý",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Thêm biểu tượng thùng rác bên cạnh các bài hát trong chế độ xem album và danh sách phát để lọc nhanh",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Tự động khôi phục khi xảy ra lỗi phát nhạc trên Spotify bằng cách tiếp tục phát lại danh sách phát gần nhất của bạn",SETTINGS_SKIP_TRASHED_TRACKS:"Bỏ qua các bản nhạc đã xóa",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Tự động bỏ qua các bài hát đã xóa và tìm bài hát tiếp theo được phép phát trong quá trình phát nhạc",SETTINGS_AUTO_CLEAN_QUEUE:"Hàng đợi làm sạch tự động",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Tự động xóa các bài hát đã xóa khỏi hàng đợi Smart Shuffle của bạn",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Rác trên phím tắt tiếp theo",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Tự động xóa bài hát hiện tại khi sử dụng phím tắt Ctrl+Phải để chuyển sang bài tiếp theo",SETTINGS_REMOTE_CONTROL:"Điều khiển từ xa",SETTINGS_REMOTE_TOGGLE:"Bật tắt từ xa",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Nhấn đúp nút phát/tạm dừng trên thiết bị di động để bật/tắt tính năng bỏ qua từ xa. Việc bỏ qua một bản nhạc sẽ xác nhận thao tác bật/tắt.",SETTINGS_REMOTE_SKIPPING:"Bỏ qua từ xa đang hoạt động",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Khi được bật, chức năng bỏ qua bài hát trong thùng rác vẫn hoạt động ngay cả khi điều khiển Spotify từ thiết bị khác (ví dụ: điện thoại di động)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Đã bật bỏ qua từ xa",MESSAGE_REMOTE_SKIPPING_DISABLED:"Đã tắt bỏ qua từ xa",MESSAGE_SONG_ADDED_REMOTE:"Bài hát bị xóa từ xa",SETTINGS_TRASH_VIA_LIKE:"Rác qua Thích",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Giống như một bài hát từ điện thoại di động chuyển vào thùng rác. Tự động bỏ thích và chuyển sang bài tiếp theo.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var O8=K((nM,ig)=>{ig.exports={TRASHBIN_NAME:"垃圾桶+",ACTION_THROW:"放入回收站",ACTION_UNTHROW:"从回收站中移除",ACTION_CLEAR:"清晰",ACTION_COPY:"复制",ACTION_EXPORT:"导出",ACTION_IMPORT:"导入",MESSAGE_COPIED:"已复制到剪贴板",MESSAGE_CLEARED:"垃圾桶已成功清空！",MESSAGE_SONG_ADDED:"歌曲已添加到回收站",MESSAGE_SONG_REMOVED:"歌曲已从回收站移除",MESSAGE_ARTIST_ADDED:"艺术家已添加到回收站",MESSAGE_ARTIST_REMOVED:"艺术家已从回收站移除",BACKUP_SAVE_SUCCESS:"备份保存成功。",BACKUP_SAVE_FAILED:"备份保存失败，请尝试将回收站内容复制到剪贴板并手动创建备份。",BACKUP_RESTORE_SUCCESS:"备份恢复成功。",BACKUP_FILE_READ_FAILED:"读取文件失败，请确保它是一个有效的JSON文件。",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"垃圾桶+ 设置",SETTINGS_OPTIONS:"选项",SETTINGS_FEATURES:"功能",SETTINGS_LOCAL_STORAGE:"本地存储",SETTINGS_ENABLED:"已启用",SETTINGS_SHOW_WIDGET:"显示小部件图标",SETTINGS_AUTOPLAY:"启动时自动播放",SETTINGS_QUEUE_TRASHBIN:"启用队列回收站",SETTINGS_TRACKLIST_TRASHBIN:"启用曲目列表回收站",SETTINGS_PLAYLIST_MONITOR:"播放列表监控",ITEMS_TITLE:"回收站+ 项目",ITEMS_EMPTY_SONGS:"<strong>没有已删除的歌曲！</strong><br/>您添加到回收站的歌曲将显示在此处。",ITEMS_EMPTY_ARTISTS:"<strong>没有已删除的艺术家！</strong><br/>您添加到回收站的艺术家将显示在这里。",ITEMS_TAB_SONGS:"歌曲",ITEMS_TAB_ARTISTS:"艺术家",ITEMS_LOADED_COUNT:"已加载 {{loaded}} / {{total}} 个 {{type}}",DESCRIPTION_COPY:"将回收站中的所有项目复制到剪贴板。",DESCRIPTION_EXPORT:"将回收站中的所有项目保存到 .json 文件中。",DESCRIPTION_IMPORT:"通过.json文件覆盖回收站中的所有项目。",DESCRIPTION_CLEAR:"清空回收站中的所有项目（无法恢复）。",ITEMS_EMPTY_SONGS_TITLE:"没有已删除的歌曲！",ITEMS_EMPTY_ARTISTS_TITLE:"没有被贬低的艺术家！",DESCRIPTION_SETTINGS_ENABLED:"主开关，用于启用或禁用所有回收站+功能",DESCRIPTION_SETTINGS_SHOW_WIDGET:"在播放栏中当前播放曲目的旁边显示一个垃圾桶图标，以便快速访问",DESCRIPTION_SETTINGS_AUTOPLAY:"当 Spotify 打开或扩展程序加载时自动开始播放音乐",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"在即将播放的队列中，为每首歌曲添加垃圾箱图标，以便轻松管理",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"在专辑和播放列表视图中的歌曲旁添加垃圾桶图标，以便快速筛选",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"通过恢复上一个播放列表，自动修复 Spotify 播放故障",SETTINGS_SKIP_TRASHED_TRACKS:"跳过已删除的曲目",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"自动跳过已删除的歌曲，并在播放期间找到下一个允许播放的曲目",SETTINGS_AUTO_CLEAN_QUEUE:"自动清理队列",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"自动从智能随机播放队列中移除已删除的歌曲",SETTINGS_TRASH_ON_NEXT_HOTKEY:"下一个快捷键清空回收站",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"使用 Ctrl+右箭头键盘快捷键跳到下一首时，自动将当前歌曲移至回收站",SETTINGS_REMOTE_CONTROL:"遥控器",SETTINGS_REMOTE_TOGGLE:"启用远程切换",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"从手机上双击播放/暂停以切换远程跳过功能的开启/关闭。跳过一首歌曲即可确认切换状态。",SETTINGS_REMOTE_SKIPPING:"远程跳过已激活",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"启用后，即使从其他设备（例如手机）控制 Spotify，跳过垃圾功能仍然有效",MESSAGE_REMOTE_SKIPPING_ENABLED:"已启用远程跳过",MESSAGE_REMOTE_SKIPPING_DISABLED:"已禁用远程跳过",MESSAGE_SONG_ADDED_REMOTE:"歌曲被远程删除",SETTINGS_TRASH_VIA_LIKE:"通过点赞清理垃圾",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"就像一首从手机传到垃圾桶的歌。自动取消喜欢并跳到下一首。",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var R8=K((hM,eg)=>{eg.exports={TRASHBIN_NAME:"垃圾桶+",ACTION_THROW:"放入垃圾桶",ACTION_UNTHROW:"從垃圾桶移除",ACTION_CLEAR:"清除",ACTION_COPY:"複製",ACTION_EXPORT:"匯出",ACTION_IMPORT:"匯入",MESSAGE_COPIED:"已複製到剪貼簿",MESSAGE_CLEARED:"垃圾桶已成功清空！",MESSAGE_SONG_ADDED:"歌曲已加入垃圾桶",MESSAGE_SONG_REMOVED:"歌曲已從垃圾桶移除",MESSAGE_ARTIST_ADDED:"藝術家已加入垃圾桶",MESSAGE_ARTIST_REMOVED:"藝術家已從垃圾桶中移除",BACKUP_SAVE_SUCCESS:"備份已成功儲存。",BACKUP_SAVE_FAILED:"未能儲存備份，請嘗試將垃圾桶內容複製到剪貼簿並手動建立備份。",BACKUP_RESTORE_SUCCESS:"備份已成功還原。",BACKUP_FILE_READ_FAILED:"無法讀取檔案，請確保它是一個有效的 JSON 檔案。",BACKUP_SUGGESTED_FILENAME:"spicetify-垃圾桶.json",SETTINGS_TITLE:"垃圾桶+ 設定",SETTINGS_OPTIONS:"選項",SETTINGS_FEATURES:"功能",SETTINGS_LOCAL_STORAGE:"本地儲存",SETTINGS_ENABLED:"已啟用",SETTINGS_SHOW_WIDGET:"顯示小工具圖示",SETTINGS_AUTOPLAY:"啟動時自動播放",SETTINGS_QUEUE_TRASHBIN:"啟用佇列回收箱",SETTINGS_TRACKLIST_TRASHBIN:"啟用播放清單回收筒",SETTINGS_PLAYLIST_MONITOR:"播放清單監控",ITEMS_TITLE:"垃圾筒+ 項目",ITEMS_EMPTY_SONGS:"<strong>沒有已刪除的歌曲！</strong><br/>你加入垃圾桶的歌曲將會出現在這裡。",ITEMS_EMPTY_ARTISTS:"<strong>沒有已刪除的藝術家！</strong><br/>你加入回收箱的藝術家將會出現在這裡。",ITEMS_TAB_SONGS:"歌曲",ITEMS_TAB_ARTISTS:"藝術家",ITEMS_LOADED_COUNT:"已載入 {{loaded}} 個中的 {{total}} 個 {{type}}",DESCRIPTION_COPY:"將垃圾筒內的所有項目複製到剪貼簿。",DESCRIPTION_EXPORT:"將回收箱中的所有項目儲存至 .json 檔案。",DESCRIPTION_IMPORT:"透過 .json 檔案覆蓋垃圾桶中的所有項目。",DESCRIPTION_CLEAR:"清除回收箱內的所有項目（不能還原）。",ITEMS_EMPTY_SONGS_TITLE:"沒有已刪除的歌曲！",ITEMS_EMPTY_ARTISTS_TITLE:"沒有被糟蹋的藝術家！",DESCRIPTION_SETTINGS_ENABLED:"主切換以啟用或停用所有回收桶+功能",DESCRIPTION_SETTINGS_SHOW_WIDGET:"在播放列中，於正在播放的項目旁顯示垃圾桶圖示，以便快速存取",DESCRIPTION_SETTINGS_AUTOPLAY:"當 Spotify 開啟或擴充功能載入時，自動開始播放音樂",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"在播放隊列中的每首歌曲旁邊添加垃圾桶圖示，以便輕鬆管理",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"在專輯和播放清單中，於歌曲旁邊加入垃圾桶圖示，以便快速篩選",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"自動從 Spotify 播放故障中恢復，繼續播放你最後的播放清單",SETTINGS_SKIP_TRASHED_TRACKS:"跳過已刪除的音軌",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"自動跳過已刪除的歌曲，並在播放期間尋找下一首允許的音軌",SETTINGS_AUTO_CLEAN_QUEUE:"自動清除隊列",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"自動從您的智能隨機播放清單中移除已刪除的歌曲",SETTINGS_TRASH_ON_NEXT_HOTKEY:"下一個快速鍵清除垃圾",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"使用 Ctrl+右箭頭鍵盤快速鍵跳至下一首歌曲時，自動將當前歌曲移至垃圾桶",SETTINGS_REMOTE_CONTROL:"遙控器",SETTINGS_REMOTE_TOGGLE:"啟用遠端切換",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"從流動裝置連按兩下播放/暫停以切換遙控跳過功能。跳過一首歌曲即可確認切換。",SETTINGS_REMOTE_SKIPPING:"遠程跳過已啟用",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"啟用後，即使從其他裝置（例如流動裝置）控制 Spotify，亦可跳過垃圾桶",MESSAGE_REMOTE_SKIPPING_ENABLED:"已啟用遠端跳過",MESSAGE_REMOTE_SKIPPING_DISABLED:"已停用遠端跳過功能",MESSAGE_SONG_ADDED_REMOTE:"歌曲被遠程刪除",SETTINGS_TRASH_VIA_LIKE:"透過按讚來丟垃圾",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"就像一首歌從手機傳送到垃圾桶一樣。自動取消喜歡並跳到下一首。",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var w8=K((cM,og)=>{og.exports={TRASHBIN_NAME:"垃圾桶+",ACTION_THROW:"放入垃圾桶",ACTION_UNTHROW:"從垃圾桶移除",ACTION_CLEAR:"清楚",ACTION_COPY:"複製",ACTION_EXPORT:"匯出",ACTION_IMPORT:"導入",MESSAGE_COPIED:"已複製到剪貼簿",MESSAGE_CLEARED:"垃圾桶已成功清空！",MESSAGE_SONG_ADDED:"歌曲已加入垃圾桶",MESSAGE_SONG_REMOVED:"歌曲已從垃圾桶移除",MESSAGE_ARTIST_ADDED:"藝術家已加入垃圾桶",MESSAGE_ARTIST_REMOVED:"藝術家已從垃圾桶中移除",BACKUP_SAVE_SUCCESS:"備份已成功儲存。",BACKUP_SAVE_FAILED:"備份儲存失敗，請嘗試將垃圾桶內容複製到剪貼簿並手動建立備份。",BACKUP_RESTORE_SUCCESS:"備份還原成功。",BACKUP_FILE_READ_FAILED:"讀取檔案失敗，請確保它是一個有效的 JSON 檔案。",BACKUP_SUGGESTED_FILENAME:"spicetify-垃圾桶.json",SETTINGS_TITLE:"垃圾桶+ 設定",SETTINGS_OPTIONS:"選項",SETTINGS_FEATURES:"功能",SETTINGS_LOCAL_STORAGE:"本地儲存",SETTINGS_ENABLED:"已啟用",SETTINGS_SHOW_WIDGET:"顯示小工具圖示",SETTINGS_AUTOPLAY:"啟動時自動播放",SETTINGS_QUEUE_TRASHBIN:"啟用佇列回收桶",SETTINGS_TRACKLIST_TRASHBIN:"啟用播放清單回收桶",SETTINGS_PLAYLIST_MONITOR:"播放清單監控",ITEMS_TITLE:"垃圾桶+ 項目",ITEMS_EMPTY_SONGS:"<strong>沒有已刪除的歌曲！</strong><br/>您加入垃圾桶的歌曲將會出現在這裡。",ITEMS_EMPTY_ARTISTS:"<strong>沒有已刪除的藝術家！</strong><br/>您加入回收筒的藝術家將會出現在這裡。",ITEMS_TAB_SONGS:"歌曲",ITEMS_TAB_ARTISTS:"藝術家",ITEMS_LOADED_COUNT:"已載入 {{loaded}} / {{total}} {{type}}",DESCRIPTION_COPY:"將垃圾桶中的所有項目複製到剪貼簿。",DESCRIPTION_EXPORT:"將回收筒中的所有項目儲存至 .json 檔案。",DESCRIPTION_IMPORT:"透過 .json 檔案覆寫垃圾桶中的所有項目。",DESCRIPTION_CLEAR:"清空回收筒中的所有項目（無法復原）。",ITEMS_EMPTY_SONGS_TITLE:"沒有被刪除的歌曲！",ITEMS_EMPTY_ARTISTS_TITLE:"沒有被拋棄的藝術家！",DESCRIPTION_SETTINGS_ENABLED:"主要切換開關，用於啟用或停用所有垃圾桶+功能",DESCRIPTION_SETTINGS_SHOW_WIDGET:"在播放列中，於正在播放的歌曲旁顯示垃圾桶圖示，以便快速存取",DESCRIPTION_SETTINGS_AUTOPLAY:"當 Spotify 開啟或擴充功能載入時，自動開始播放音樂",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"在您即將播放的歌曲隊列中，於每首歌曲旁新增垃圾桶圖示，以便輕鬆管理",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"在專輯和播放清單檢視中，於歌曲旁新增垃圾桶圖示，以便快速篩選",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"自動從 Spotify 播放故障中恢復，繼續播放您最後的播放清單",SETTINGS_SKIP_TRASHED_TRACKS:"跳過已刪除的音軌",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"自動跳過已刪除的歌曲，並在播放期間尋找下一首允許的曲目",SETTINGS_AUTO_CLEAN_QUEUE:"自動清除佇列",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"自動從您的智慧隨機播放佇列中移除已刪除的歌曲",SETTINGS_TRASH_ON_NEXT_HOTKEY:"下一個快速鍵為垃圾桶",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"使用 Ctrl+右鍵盤快速鍵跳至下一首時，自動將目前歌曲移至垃圾桶",SETTINGS_REMOTE_CONTROL:"遙控器",SETTINGS_REMOTE_TOGGLE:"啟用遠端切換",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"從手機上連按兩下播放/暫停以切換遠端跳過功能的開關。跳過一首歌曲即可確認切換。",SETTINGS_REMOTE_SKIPPING:"遠端跳過已啟用",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"啟用後，即使從其他裝置（例如手機）控制 Spotify，也能跳過垃圾桶。",MESSAGE_REMOTE_SKIPPING_ENABLED:"已啟用遠端跳過",MESSAGE_REMOTE_SKIPPING_DISABLED:"已停用遠端跳過功能",MESSAGE_SONG_ADDED_REMOTE:"歌曲透過遠端刪除",SETTINGS_TRASH_VIA_LIKE:"垃圾透過按讚",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"就像一首從手機傳送到垃圾桶的歌曲。自動取消喜歡並跳到下一首。",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var D8=K((dM,ng)=>{ng.exports={TRASHBIN_NAME:"Trashbin+",ACTION_THROW:"Faka esikhenkathini",ACTION_UNTHROW:"Susa kusindvo yesitsha",ACTION_CLEAR:"Vula",ACTION_COPY:"Kopisha",ACTION_EXPORT:"Thumela kuwandle",ACTION_IMPORT:"Ngenisa",MESSAGE_COPIED:"Kukhopyiwe kubhodi yokhokha",MESSAGE_CLEARED:"Inkunkuma yasuswa ngempumelelo!",MESSAGE_SONG_ADDED:"Umusi wongezwe kususini",MESSAGE_SONG_REMOVED:"Umbhali wususwe kususini",MESSAGE_ARTIST_ADDED:"Umculo wengezwe kususini",MESSAGE_ARTIST_REMOVED:"Umdlali wususwe kususini",BACKUP_SAVE_SUCCESS:"Gcwaliswe kabusha ngempumelelo.",BACKUP_SAVE_FAILED:"Akuphumelela ukugcina kopi yokuphinda, uzame ukukopisha okwakhiwe kikhweli futhi ukudala ikopi yokuphinda ngendlela yokuphawula.",BACKUP_RESTORE_SUCCESS:"Kuvuselelwe kahle kubeka-phambili.",BACKUP_FILE_READ_FAILED:"Ayikwazi ukufunda ifayela, sicela uqiniseke ukuthi yifayela efanayo ye-JSON.",BACKUP_SUGGESTED_FILENAME:"spicetify-trashbin.json",SETTINGS_TITLE:"Izilungiselelo zeTrashbin+",SETTINGS_OPTIONS:"Izinketho",SETTINGS_FEATURES:"Izinto ezikhethekileyo",SETTINGS_LOCAL_STORAGE:"Isitroli seNdawonye",SETTINGS_ENABLED:"Kuvulwe",SETTINGS_SHOW_WIDGET:"Bonisa Isithonjana Sekhona",SETTINGS_AUTOPLAY:"Ukudlala Ngokuzenzakalela Ekuvuleni",SETTINGS_QUEUE_TRASHBIN:"Vula I-Queue Trashbin",SETTINGS_TRACKLIST_TRASHBIN:"Vula Isithuthi seTrashbin ye-Tracklist",SETTINGS_PLAYLIST_MONITOR:"Umlayizi we-Playlist",ITEMS_TITLE:"Izinto ze-Trashbin+",ITEMS_EMPTY_SONGS:"<strong>Azikho izinhloso ezilahliwe!</strong><br/>Izinhloso ozodinga kuzilahla kuzovela lapha.",ITEMS_EMPTY_ARTISTS:"<strong>Azikho abagciniwe!</strong><br/>Abagcini bageza lapha.",ITEMS_TAB_SONGS:"Izindima",ITEMS_TAB_ARTISTS:"Abakhetha umfanekiso",ITEMS_LOADED_COUNT:"{{loaded}} kwe {{total}} {{type}} ekulandelwe",DESCRIPTION_COPY:"Kopisha konke okungeni isikhwama esibhetshe klayiphebholide.",DESCRIPTION_EXPORT:"Londoloza konke okwakhiweni kufayela .json.",DESCRIPTION_IMPORT:"Bekephetha konke okungeni ibhethi ngendlela ye-.json.",DESCRIPTION_CLEAR:"Susa konke okhokhelwe ku-trashbin (akukwenzekanga ukubuyisela).",ITEMS_EMPTY_SONGS_TITLE:"Akukho lolizo elidotiwe!",ITEMS_EMPTY_ARTISTS_TITLE:"Akukho zokwakha izithombe zilahlekile!",DESCRIPTION_SETTINGS_ENABLED:"Isilungiso esigcwele sokuvula noma kuvimba wonke umsebenzi kaTrashbin+",DESCRIPTION_SETTINGS_SHOW_WIDGET:"Bonisa ikhona yekhobhotho ekhesheji yokuqhubeka ngasekhohlo kwegama eliqhubekayo ukuze kube lula ukufinyelela",DESCRIPTION_SETTINGS_AUTOPLAY:"Qala ngokuzenzakalelayo ukudlala imiziki xa i-Spotify ivulwe noma isiphindezelo sifaka",DESCRIPTION_SETTINGS_QUEUE_TRASHBIN:"Faka izithombe zedolobha ezinguqulunga ngasinye kusihlalo sakho esizofika ukuze kube lula ukuphatha",DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN:"Faka izithombe zedolobha ezizungezile kumabhasi kumzobo nomhala wokudlala ukuze ukhethwe ngokushesha",DESCRIPTION_SETTINGS_PLAYLIST_MONITOR:"Duthukutshela ngokuzenzakalelayo kusindiswa kukaSpotify ngokubuyisela kusihloko sakho esisendulo",SETTINGS_SKIP_TRASHED_TRACKS:"Yeqela Izindimana Ezilahlekile",DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS:"Yeqeda ngokuzenzakalelayo izindima ezithunyelwe kususini bese uthola indima engavunyelwa elandelayo ngexesha lokudlala",SETTINGS_AUTO_CLEAN_QUEUE:"Gcina ukuqeda umgwaqo",DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE:"Susa ngokuzenzakalelayo izindima ezithunyelwe ku-inthanethi kusikhwama sakho se-Shuffle esinamandla",SETTINGS_TRASH_ON_NEXT_HOTKEY:"Trash kwi-Hotkey elandelayo",DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY:"Cima ngokuzenzakalelayo iminikelo yamanje uma usebenzisa i-Ctrl+Right ukuthi uthule kumunye umgaga",SETTINGS_REMOTE_CONTROL:"Isivumelwano esingaphandle",SETTINGS_REMOTE_TOGGLE:"Vula Ukumisa Kude",DESCRIPTION_SETTINGS_REMOTE_TOGGLE:"Cindezela kabombindlela ukudlala/ukumisa ukumisa kuselulekini ukuze uguqule ukukhuphaza kude kuvule/ukuvula. Ukukhuphaza kwe-trakhu kuyavikela ukuguquleka.",SETTINGS_REMOTE_SKIPPING:"Ukuphazamisa Kude Kusebenza",DESCRIPTION_SETTINGS_REMOTE_SKIPPING:"Xa kusekelwe, ukubuyisela kususwa kusebenza noma kube wasebenzisa i-Spotify kusihlangothini esinye (umzekelo, ihhandi)",MESSAGE_REMOTE_SKIPPING_ENABLED:"Ukuzoshaya kude kuvuselelwe",MESSAGE_REMOTE_SKIPPING_DISABLED:"Ukungena kude kuvivinyelwe",MESSAGE_SONG_ADDED_REMOTE:"Umusi wadiliselwe ngaphandle",SETTINGS_TRASH_VIA_LIKE:"Trash ngaphandle kukaLike",DESCRIPTION_SETTINGS_TRASH_VIA_LIKE:"Njengomculo ukusuka kumobile ukususa kususini. Ukucima okungafani kusenzo futhi ukhupha kumculo ongemuva.",SETTINGS_AI_DETECTION:"AI Detection",SETTINGS_AI_DETECTION_ENABLED:"AI Song Detection",DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED:"Detect AI-generated songs using the SONICS model and show a probability indicator. Downloads ~50MB model on first enable.",AI_ASSETS_DOWNLOADING:"Downloading AI model...",AI_ASSETS_READY:"AI model ready",AI_ASSETS_NOT_READY:"AI model not available"}});var y1=Z(B1(),1),w6=Z(N7(),1);var I0=Z(B1(),1);var v5=Z(B1(),1);var x4=Z(B1(),1),C4={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},_4=x4.default.createContext&&x4.default.createContext(C4);var cv=["attr","size","title"];function dv(a,t){if(a==null)return{};var r=vv(a,t),l,i;if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(a);for(i=0;i<e.length;i++){if(l=e[i],t.indexOf(l)>=0)continue;if(!Object.prototype.propertyIsEnumerable.call(a,l))continue;r[l]=a[l]}}return r}function vv(a,t){if(a==null)return{};var r={};for(var l in a)if(Object.prototype.hasOwnProperty.call(a,l)){if(t.indexOf(l)>=0)continue;r[l]=a[l]}return r}function s2(){return s2=Object.assign?Object.assign.bind():function(a){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var l in r)if(Object.prototype.hasOwnProperty.call(r,l))a[l]=r[l]}return a},s2.apply(this,arguments)}function O7(a,t){var r=Object.keys(a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(a);t&&(l=l.filter(function(i){return Object.getOwnPropertyDescriptor(a,i).enumerable})),r.push.apply(r,l)}return r}function p2(a){for(var t=1;t<arguments.length;t++){var r=arguments[t]!=null?arguments[t]:{};t%2?O7(Object(r),!0).forEach(function(l){uv(a,l,r[l])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(r)):O7(Object(r)).forEach(function(l){Object.defineProperty(a,l,Object.getOwnPropertyDescriptor(r,l))})}return a}function uv(a,t,r){if(t=gv(t),t in a)Object.defineProperty(a,t,{value:r,enumerable:!0,configurable:!0,writable:!0});else a[t]=r;return a}function gv(a){var t=sv(a,"string");return typeof t=="symbol"?t:t+""}function sv(a,t){if(typeof a!="object"||!a)return a;var r=a[Symbol.toPrimitive];if(r!==void 0){var l=r.call(a,t||"default");if(typeof l!="object")return l;throw TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(a)}function R7(a){return a&&a.map((t,r)=>v5.default.createElement(t.tag,p2({key:r},t.attr),R7(t.child)))}function A0(a){return(t)=>v5.default.createElement(pv,s2({attr:p2({},a.attr)},t),R7(a.child))}function pv(a){var t=(r)=>{var{attr:l,size:i,title:e}=a,o=dv(a,cv),n=i||r.size||"1em",c;if(r.className)c=r.className;if(a.className)c=(c?c+" ":"")+a.className;return v5.default.createElement("svg",s2({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},r.attr,l,o,{className:c,style:p2(p2({color:a.color||r.color},r.style),a.style),height:n,width:n,xmlns:"http://www.w3.org/2000/svg"}),e&&v5.default.createElement("title",null,e),a.children)};return _4!==void 0?v5.default.createElement(_4.Consumer,null,(r)=>t(r)):t(C4)}function w7(a){return A0({tag:"svg",attr:{fill:"currentColor",viewBox:"0 0 16 16"},child:[{tag:"path",attr:{d:"M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5m5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5"},child:[]}]})(a)}function D7(a){return A0({tag:"svg",attr:{fill:"currentColor",viewBox:"0 0 16 16"},child:[{tag:"path",attr:{d:"m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393"},child:[]}]})(a)}function G7(a){return A0({tag:"svg",attr:{fill:"currentColor",viewBox:"0 0 16 16"},child:[{tag:"path",attr:{d:"M9 13c0 1.105-1.12 2-2.5 2S4 14.105 4 13s1.12-2 2.5-2 2.5.895 2.5 2"},child:[]},{tag:"path",attr:{fillRule:"evenodd",d:"M9 3v10H8V3z"},child:[]},{tag:"path",attr:{d:"M8 2.82a1 1 0 0 1 .804-.98l3-.6A1 1 0 0 1 13 2.22V4L8 5z"},child:[]}]})(a)}function P7(a){return A0({tag:"svg",attr:{fill:"currentColor",viewBox:"0 0 16 16"},child:[{tag:"path",attr:{d:"M8 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6m2-3a2 2 0 1 1-4 0 2 2 0 0 1 4 0m4 8c0 1-1 1-1 1H3s-1 0-1-1 1-4 6-4 6 3 6 4m-1-.004c-.001-.246-.154-.986-.832-1.664C11.516 10.68 10.289 10 8 10s-3.516.68-4.168 1.332c-.678.678-.83 1.418-.832 1.664z"},child:[]}]})(a)}function u5(a){return A0({tag:"svg",attr:{fill:"currentColor",viewBox:"0 0 16 16"},child:[{tag:"path",attr:{d:"M6.5 1h3a.5.5 0 0 1 .5.5v1H6v-1a.5.5 0 0 1 .5-.5M11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3A1.5 1.5 0 0 0 5 1.5v1H1.5a.5.5 0 0 0 0 1h.538l.853 10.66A2 2 0 0 0 4.885 16h6.23a2 2 0 0 0 1.994-1.84l.853-10.66h.538a.5.5 0 0 0 0-1zm1.958 1-.846 10.58a1 1 0 0 1-.997.92h-6.23a1 1 0 0 1-.997-.92L3.042 3.5zm-7.487 1a.5.5 0 0 1 .528.47l.5 8.5a.5.5 0 0 1-.998.06L5 5.03a.5.5 0 0 1 .47-.53Zm5.058 0a.5.5 0 0 1 .47.53l-.5 8.5a.5.5 0 1 1-.998-.06l.5-8.5a.5.5 0 0 1 .528-.47M8 4.5a.5.5 0 0 1 .5.5v8.5a.5.5 0 0 1-1 0V5a.5.5 0 0 1 .5-.5"},child:[]}]})(a)}var t0={SKIP_BACK_BUTTON:".main-skipBackButton-button",SKIP_BACK_BUTTON_ALT:".player-controls__left > button[data-encore-id='buttonTertiary']",ARTIST_LINK:'a[href*="/artist/"]',TRACK_CREDITS_MODAL:".main-trackCreditsModal-mainSection",TRACK_CREDITS_MODAL_CONTAINER:".main-trackCreditsModal-container",SMART_SHUFFLE_BUTTON:'button svg path[d^="M4.502 0a.637"]'},F7={containerSelector:"main",buttonSelector:".trashbin-tracklist-btn",rowSelector:".main-trackList-trackListRow",moreButtonSelector:"button[aria-haspopup='menu'], button[data-testid='add-to-playlist-button']",buttonClassName:"trashbin-tracklist-btn"},Z7={containerSelector:"#Desktop_PanelContainer_Id",buttonSelector:".trashbin-queue-btn",rowSelector:'[role="row"]',moreButtonSelector:'button[aria-haspopup="menu"]',buttonClassName:"trashbin-queue-btn"},T0={gridSelector:'[aria-label^="Recommended based on"]',rowSelector:'[role="row"]',trashButtonSelector:".trashbin-tracklist-btn",addButtonSelector:'button[data-testid="add-to-playlist-button"]',autoAddButtonClassName:"trashbin-auto-add-btn"};var y7=(a)=>{let t,r=new Set,l=(d,u)=>{let g=typeof d==="function"?d(t):d;if(!Object.is(g,t)){let s=t;t=(u!=null?u:typeof g!=="object"||g===null)?g:Object.assign({},t,g),r.forEach((M)=>M(t,s))}},i=()=>t,n={setState:l,getState:i,getInitialState:()=>c,subscribe:(d)=>{return r.add(d),()=>r.delete(d)}},c=t=a(l,i,n);return n},b7=(a)=>a?y7(a):y7;var B5=Z(B1(),1);var Sv=(a)=>a;function Mv(a,t=Sv){let r=B5.default.useSyncExternalStore(a.subscribe,B5.default.useCallback(()=>t(a.getState()),[a,t]),B5.default.useCallback(()=>t(a.getInitialState()),[a,t]));return B5.default.useDebugValue(r),r}var j7=(a)=>{let t=b7(a),r=(l)=>Mv(t,l);return Object.assign(r,t),r},U7=(a)=>a?j7(a):j7;var n1=(a)=>typeof a==="string",z5=()=>{let a,t,r=new Promise((l,i)=>{a=l,t=i});return r.resolve=a,r.reject=t,r},W7=(a)=>{if(a==null)return"";return""+a},Av=(a,t,r)=>{a.forEach((l)=>{if(t[l])r[l]=t[l]})},Tv=/###/g,K7=(a)=>a&&a.indexOf("###")>-1?a.replace(Tv,"."):a,q7=(a)=>!a||n1(a),L5=(a,t,r)=>{let l=!n1(t)?t:t.split("."),i=0;while(i<l.length-1){if(q7(a))return{};let e=K7(l[i]);if(!a[e]&&r)a[e]=new r;if(Object.prototype.hasOwnProperty.call(a,e))a=a[e];else a={};++i}if(q7(a))return{};return{obj:a,k:K7(l[i])}},Y7=(a,t,r)=>{let{obj:l,k:i}=L5(a,t,Object);if(l!==void 0||t.length===1){l[i]=r;return}let e=t[t.length-1],o=t.slice(0,t.length-1),n=L5(a,o,Object);while(n.obj===void 0&&o.length)if(e=`${o[o.length-1]}.${e}`,o=o.slice(0,o.length-1),n=L5(a,o,Object),n?.obj&&typeof n.obj[`${n.k}.${e}`]<"u")n.obj=void 0;n.obj[`${n.k}.${e}`]=r},Ev=(a,t,r,l)=>{let{obj:i,k:e}=L5(a,t,Object);i[e]=i[e]||[],i[e].push(r)},M2=(a,t)=>{let{obj:r,k:l}=L5(a,t);if(!r)return;if(!Object.prototype.hasOwnProperty.call(r,l))return;return r[l]},Iv=(a,t,r)=>{let l=M2(a,r);if(l!==void 0)return l;return M2(t,r)},rt=(a,t,r)=>{for(let l in t)if(l!=="__proto__"&&l!=="constructor")if(l in a)if(n1(a[l])||a[l]instanceof String||n1(t[l])||t[l]instanceof String){if(r)a[l]=t[l]}else rt(a[l],t[l],r);else a[l]=t[l];return a},g5=(a)=>a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&"),mv={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"},fv=(a)=>{if(n1(a))return a.replace(/[&<>"'\/]/g,(t)=>mv[t]);return a};class lt{constructor(a){this.capacity=a,this.regExpMap=new Map,this.regExpQueue=[]}getRegExp(a){let t=this.regExpMap.get(a);if(t!==void 0)return t;let r=new RegExp(a);if(this.regExpQueue.length===this.capacity)this.regExpMap.delete(this.regExpQueue.shift());return this.regExpMap.set(a,r),this.regExpQueue.push(a),r}}var xv=[" ",",","?","!",";"],Cv=new lt(20),_v=(a,t,r)=>{t=t||"",r=r||"";let l=xv.filter((o)=>t.indexOf(o)<0&&r.indexOf(o)<0);if(l.length===0)return!0;let i=Cv.getRegExp(`(${l.map((o)=>o==="?"?"\\?":o).join("|")})`),e=!i.test(a);if(!e){let o=a.indexOf(r);if(o>0&&!i.test(a.substring(0,o)))e=!0}return e},H4=(a,t,r=".")=>{if(!a)return;if(a[t]){if(!Object.prototype.hasOwnProperty.call(a,t))return;return a[t]}let l=t.split(r),i=a;for(let e=0;e<l.length;){if(!i||typeof i!=="object")return;let o,n="";for(let c=e;c<l.length;++c){if(c!==e)n+=r;if(n+=l[c],o=i[n],o!==void 0){if(["string","number","boolean"].indexOf(typeof o)>-1&&c<l.length-1)continue;e+=c-e+1;break}}i=o}return i},V5=(a)=>a?.replace("_","-"),Bv={type:"logger",log(a){this.output("log",a)},warn(a){this.output("warn",a)},error(a){this.output("error",a)},output(a,t){console?.[a]?.apply?.(console,t)}};class A2{constructor(a,t={}){this.init(a,t)}init(a,t={}){this.prefix=t.prefix||"i18next:",this.logger=a||Bv,this.options=t,this.debug=t.debug}log(...a){return this.forward(a,"log","",!0)}warn(...a){return this.forward(a,"warn","",!0)}error(...a){return this.forward(a,"error","")}deprecate(...a){return this.forward(a,"warn","WARNING DEPRECATED: ",!0)}forward(a,t,r,l){if(l&&!this.debug)return null;if(n1(a[0]))a[0]=`${r}${this.prefix} ${a[0]}`;return this.logger[t](a)}create(a){return new A2(this.logger,{...{prefix:`${this.prefix}:${a}:`},...this.options})}clone(a){return a=a||this.options,a.prefix=a.prefix||this.prefix,new A2(this.logger,a)}}var E0=new A2;class k5{constructor(){this.observers={}}on(a,t){return a.split(" ").forEach((r)=>{if(!this.observers[r])this.observers[r]=new Map;let l=this.observers[r].get(t)||0;this.observers[r].set(t,l+1)}),this}off(a,t){if(!this.observers[a])return;if(!t){delete this.observers[a];return}this.observers[a].delete(t)}emit(a,...t){if(this.observers[a])Array.from(this.observers[a].entries()).forEach(([l,i])=>{for(let e=0;e<i;e++)l(...t)});if(this.observers["*"])Array.from(this.observers["*"].entries()).forEach(([l,i])=>{for(let e=0;e<i;e++)l.apply(l,[a,...t])})}}class V4 extends k5{constructor(a,t={ns:["translation"],defaultNS:"translation"}){super();if(this.data=a||{},this.options=t,this.options.keySeparator===void 0)this.options.keySeparator=".";if(this.options.ignoreJSONStructure===void 0)this.options.ignoreJSONStructure=!0}addNamespaces(a){if(this.options.ns.indexOf(a)<0)this.options.ns.push(a)}removeNamespaces(a){let t=this.options.ns.indexOf(a);if(t>-1)this.options.ns.splice(t,1)}getResource(a,t,r,l={}){let i=l.keySeparator!==void 0?l.keySeparator:this.options.keySeparator,e=l.ignoreJSONStructure!==void 0?l.ignoreJSONStructure:this.options.ignoreJSONStructure,o;if(a.indexOf(".")>-1)o=a.split(".");else if(o=[a,t],r)if(Array.isArray(r))o.push(...r);else if(n1(r)&&i)o.push(...r.split(i));else o.push(r);let n=M2(this.data,o);if(!n&&!t&&!r&&a.indexOf(".")>-1)a=o[0],t=o[1],r=o.slice(2).join(".");if(n||!e||!n1(r))return n;return H4(this.data?.[a]?.[t],r,i)}addResource(a,t,r,l,i={silent:!1}){let e=i.keySeparator!==void 0?i.keySeparator:this.options.keySeparator,o=[a,t];if(r)o=o.concat(e?r.split(e):r);if(a.indexOf(".")>-1)o=a.split("."),l=t,t=o[1];if(this.addNamespaces(t),Y7(this.data,o,l),!i.silent)this.emit("added",a,t,r,l)}addResources(a,t,r,l={silent:!1}){for(let i in r)if(n1(r[i])||Array.isArray(r[i]))this.addResource(a,t,i,r[i],{silent:!0});if(!l.silent)this.emit("added",a,t,r)}addResourceBundle(a,t,r,l,i,e={silent:!1,skipCopy:!1}){let o=[a,t];if(a.indexOf(".")>-1)o=a.split("."),l=r,r=t,t=o[1];this.addNamespaces(t);let n=M2(this.data,o)||{};if(!e.skipCopy)r=JSON.parse(JSON.stringify(r));if(l)rt(n,r,i);else n={...n,...r};if(Y7(this.data,o,n),!e.silent)this.emit("added",a,t,r)}removeResourceBundle(a,t){if(this.hasResourceBundle(a,t))delete this.data[a][t];this.removeNamespaces(t),this.emit("removed",a,t)}hasResourceBundle(a,t){return this.getResource(a,t)!==void 0}getResourceBundle(a,t){if(!t)t=this.options.defaultNS;return this.getResource(a,t)}getDataByLanguage(a){return this.data[a]}hasLanguageSomeTranslations(a){let t=this.getDataByLanguage(a);return!!(t&&Object.keys(t)||[]).find((l)=>t[l]&&Object.keys(t[l]).length>0)}toJSON(){return this.data}}var it={processors:{},addPostProcessor(a){this.processors[a.name]=a},handle(a,t,r,l,i){return a.forEach((e)=>{t=this.processors[e]?.process(t,r,l,i)??t}),t}},et=Symbol("i18next/PATH_KEY");function zv(){let a=[],t=Object.create(null),r;return t.get=(l,i)=>{if(r?.revoke?.(),i===et)return a;return a.push(i),r=Proxy.revocable(l,t),r.proxy},Proxy.revocable(Object.create(null),t).proxy}function k4(a,t){let{[et]:r}=a(zv());return r.join(t?.keySeparator??".")}var Q7={},B4=(a)=>!n1(a)&&typeof a!=="boolean"&&typeof a!=="number";class T2 extends k5{constructor(a,t={}){super();if(Av(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],a,this),this.options=t,this.options.keySeparator===void 0)this.options.keySeparator=".";this.logger=E0.create("translator")}changeLanguage(a){if(a)this.language=a}exists(a,t={interpolation:{}}){let r={...t};if(a==null)return!1;let l=this.resolve(a,r);if(l?.res===void 0)return!1;let i=B4(l.res);if(r.returnObjects===!1&&i)return!1;return!0}extractFromKey(a,t){let r=t.nsSeparator!==void 0?t.nsSeparator:this.options.nsSeparator;if(r===void 0)r=":";let l=t.keySeparator!==void 0?t.keySeparator:this.options.keySeparator,i=t.ns||this.options.defaultNS||[],e=r&&a.indexOf(r)>-1,o=!this.options.userDefinedKeySeparator&&!t.keySeparator&&!this.options.userDefinedNsSeparator&&!t.nsSeparator&&!_v(a,r,l);if(e&&!o){let n=a.match(this.interpolator.nestingRegexp);if(n&&n.length>0)return{key:a,namespaces:n1(i)?[i]:i};let c=a.split(r);if(r!==l||r===l&&this.options.ns.indexOf(c[0])>-1)i=c.shift();a=c.join(l)}return{key:a,namespaces:n1(i)?[i]:i}}translate(a,t,r){let l=typeof t==="object"?{...t}:t;if(typeof l!=="object"&&this.options.overloadTranslationOptionHandler)l=this.options.overloadTranslationOptionHandler(arguments);if(typeof l==="object")l={...l};if(!l)l={};if(a==null)return"";if(typeof a==="function")a=k4(a,{...this.options,...l});if(!Array.isArray(a))a=[String(a)];let i=l.returnDetails!==void 0?l.returnDetails:this.options.returnDetails,e=l.keySeparator!==void 0?l.keySeparator:this.options.keySeparator,{key:o,namespaces:n}=this.extractFromKey(a[a.length-1],l),c=n[n.length-1],d=l.nsSeparator!==void 0?l.nsSeparator:this.options.nsSeparator;if(d===void 0)d=":";let u=l.lng||this.language,g=l.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(u?.toLowerCase()==="cimode"){if(g){if(i)return{res:`${c}${d}${o}`,usedKey:o,exactUsedKey:o,usedLng:u,usedNS:c,usedParams:this.getUsedParamsDetails(l)};return`${c}${d}${o}`}if(i)return{res:o,usedKey:o,exactUsedKey:o,usedLng:u,usedNS:c,usedParams:this.getUsedParamsDetails(l)};return o}let s=this.resolve(a,l),M=s?.res,A=s?.usedKey||o,E=s?.exactUsedKey||o,x=["[object Number]","[object Function]","[object RegExp]"],m=l.joinArrays!==void 0?l.joinArrays:this.options.joinArrays,T=!this.i18nFormat||this.i18nFormat.handleAsObject,_=l.count!==void 0&&!n1(l.count),C=T2.hasDefaultValue(l),z=_?this.pluralResolver.getSuffix(u,l.count,l):"",L=l.ordinal&&_?this.pluralResolver.getSuffix(u,l.count,{ordinal:!1}):"",H=_&&!l.ordinal&&l.count===0,I=H&&l[`defaultValue${this.options.pluralSeparator}zero`]||l[`defaultValue${z}`]||l[`defaultValue${L}`]||l.defaultValue,N=M;if(T&&!M&&C)N=I;let P=B4(N),b=Object.prototype.toString.apply(N);if(T&&N&&P&&x.indexOf(b)<0&&!(n1(m)&&Array.isArray(N))){if(!l.returnObjects&&!this.options.returnObjects){if(!this.options.returnedObjectHandler)this.logger.warn("accessing an object - but returnObjects options is not enabled!");let G=this.options.returnedObjectHandler?this.options.returnedObjectHandler(A,N,{...l,ns:n}):`key '${o} (${this.language})' returned an object instead of string.`;if(i)return s.res=G,s.usedParams=this.getUsedParamsDetails(l),s;return G}if(e){let G=Array.isArray(N),j=G?[]:{},e1=G?E:A;for(let V in N)if(Object.prototype.hasOwnProperty.call(N,V)){let F=`${e1}${e}${V}`;if(C&&!M)j[V]=this.translate(F,{...l,defaultValue:B4(I)?I[V]:void 0,...{joinArrays:!1,ns:n}});else j[V]=this.translate(F,{...l,...{joinArrays:!1,ns:n}});if(j[V]===F)j[V]=N[V]}M=j}}else if(T&&n1(m)&&Array.isArray(M)){if(M=M.join(m),M)M=this.extendTranslation(M,a,l,r)}else{let G=!1,j=!1;if(!this.isValidLookup(M)&&C)G=!0,M=I;if(!this.isValidLookup(M))j=!0,M=o;let V=(l.missingKeyNoValueFallbackToKey||this.options.missingKeyNoValueFallbackToKey)&&j?void 0:M,F=C&&I!==M&&this.options.updateMissing;if(j||G||F){if(this.logger.log(F?"updateKey":"missingKey",u,c,o,F?I:M),e){let i1=this.resolve(o,{...l,keySeparator:!1});if(i1&&i1.res)this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}let a1=[],$=this.languageUtils.getFallbackCodes(this.options.fallbackLng,l.lng||this.language);if(this.options.saveMissingTo==="fallback"&&$&&$[0])for(let i1=0;i1<$.length;i1++)a1.push($[i1]);else if(this.options.saveMissingTo==="all")a1=this.languageUtils.toResolveHierarchy(l.lng||this.language);else a1.push(l.lng||this.language);let Y=(i1,D,W)=>{let t1=C&&W!==M?W:V;if(this.options.missingKeyHandler)this.options.missingKeyHandler(i1,c,D,t1,F,l);else if(this.backendConnector?.saveMissing)this.backendConnector.saveMissing(i1,c,D,t1,F,l);this.emit("missingKey",i1,c,D,M)};if(this.options.saveMissing)if(this.options.saveMissingPlurals&&_)a1.forEach((i1)=>{let D=this.pluralResolver.getSuffixes(i1,l);if(H&&l[`defaultValue${this.options.pluralSeparator}zero`]&&D.indexOf(`${this.options.pluralSeparator}zero`)<0)D.push(`${this.options.pluralSeparator}zero`);D.forEach((W)=>{Y([i1],o+W,l[`defaultValue${W}`]||I)})});else Y(a1,o,I)}if(M=this.extendTranslation(M,a,l,s,r),j&&M===o&&this.options.appendNamespaceToMissingKey)M=`${c}${d}${o}`;if((j||G)&&this.options.parseMissingKeyHandler)M=this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey?`${c}${d}${o}`:o,G?M:void 0,l)}if(i)return s.res=M,s.usedParams=this.getUsedParamsDetails(l),s;return M}extendTranslation(a,t,r,l,i){if(this.i18nFormat?.parse)a=this.i18nFormat.parse(a,{...this.options.interpolation.defaultVariables,...r},r.lng||this.language||l.usedLng,l.usedNS,l.usedKey,{resolved:l});else if(!r.skipInterpolation){if(r.interpolation)this.interpolator.init({...r,...{interpolation:{...this.options.interpolation,...r.interpolation}}});let n=n1(a)&&(r?.interpolation?.skipOnVariables!==void 0?r.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables),c;if(n){let u=a.match(this.interpolator.nestingRegexp);c=u&&u.length}let d=r.replace&&!n1(r.replace)?r.replace:r;if(this.options.interpolation.defaultVariables)d={...this.options.interpolation.defaultVariables,...d};if(a=this.interpolator.interpolate(a,d,r.lng||this.language||l.usedLng,r),n){let u=a.match(this.interpolator.nestingRegexp),g=u&&u.length;if(c<g)r.nest=!1}if(!r.lng&&l&&l.res)r.lng=this.language||l.usedLng;if(r.nest!==!1)a=this.interpolator.nest(a,(...u)=>{if(i?.[0]===u[0]&&!r.context)return this.logger.warn(`It seems you are nesting recursively key: ${u[0]} in key: ${t[0]}`),null;return this.translate(...u,t)},r);if(r.interpolation)this.interpolator.reset()}let e=r.postProcess||this.options.postProcess,o=n1(e)?[e]:e;if(a!=null&&o?.length&&r.applyPostProcessor!==!1)a=it.handle(o,a,t,this.options&&this.options.postProcessPassResolved?{i18nResolved:{...l,usedParams:this.getUsedParamsDetails(r)},...r}:r,this);return a}resolve(a,t={}){let r,l,i,e,o;if(n1(a))a=[a];return a.forEach((n)=>{if(this.isValidLookup(r))return;let c=this.extractFromKey(n,t),d=c.key;l=d;let u=c.namespaces;if(this.options.fallbackNS)u=u.concat(this.options.fallbackNS);let g=t.count!==void 0&&!n1(t.count),s=g&&!t.ordinal&&t.count===0,M=t.context!==void 0&&(n1(t.context)||typeof t.context==="number")&&t.context!=="",A=t.lngs?t.lngs:this.languageUtils.toResolveHierarchy(t.lng||this.language,t.fallbackLng);u.forEach((E)=>{if(this.isValidLookup(r))return;if(o=E,!Q7[`${A[0]}-${E}`]&&this.utils?.hasLoadedNamespace&&!this.utils?.hasLoadedNamespace(o))Q7[`${A[0]}-${E}`]=!0,this.logger.warn(`key "${l}" for languages "${A.join(", ")}" won't get resolved as namespace "${o}" was not yet loaded`,"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");A.forEach((x)=>{if(this.isValidLookup(r))return;e=x;let m=[d];if(this.i18nFormat?.addLookupKeys)this.i18nFormat.addLookupKeys(m,d,x,E,t);else{let _;if(g)_=this.pluralResolver.getSuffix(x,t.count,t);let C=`${this.options.pluralSeparator}zero`,z=`${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;if(g){if(t.ordinal&&_.indexOf(z)===0)m.push(d+_.replace(z,this.options.pluralSeparator));if(m.push(d+_),s)m.push(d+C)}if(M){let L=`${d}${this.options.contextSeparator||"_"}${t.context}`;if(m.push(L),g){if(t.ordinal&&_.indexOf(z)===0)m.push(L+_.replace(z,this.options.pluralSeparator));if(m.push(L+_),s)m.push(L+C)}}}let T;while(T=m.pop())if(!this.isValidLookup(r))i=T,r=this.getResource(x,E,T,t)})})}),{res:r,usedKey:l,exactUsedKey:i,usedLng:e,usedNS:o}}isValidLookup(a){return a!==void 0&&!(!this.options.returnNull&&a===null)&&!(!this.options.returnEmptyString&&a==="")}getResource(a,t,r,l={}){if(this.i18nFormat?.getResource)return this.i18nFormat.getResource(a,t,r,l);return this.resourceStore.getResource(a,t,r,l)}getUsedParamsDetails(a={}){let t=["defaultValue","ordinal","context","replace","lng","lngs","fallbackLng","ns","keySeparator","nsSeparator","returnObjects","returnDetails","joinArrays","postProcess","interpolation"],r=a.replace&&!n1(a.replace),l=r?a.replace:a;if(r&&typeof a.count<"u")l.count=a.count;if(this.options.interpolation.defaultVariables)l={...this.options.interpolation.defaultVariables,...l};if(!r){l={...l};for(let i of t)delete l[i]}return l}static hasDefaultValue(a){for(let r in a)if(Object.prototype.hasOwnProperty.call(a,r)&&r.substring(0,12)==="defaultValue"&&a[r]!==void 0)return!0;return!1}}class N4{constructor(a){this.options=a,this.supportedLngs=this.options.supportedLngs||!1,this.logger=E0.create("languageUtils")}getScriptPartFromCode(a){if(a=V5(a),!a||a.indexOf("-")<0)return null;let t=a.split("-");if(t.length===2)return null;if(t.pop(),t[t.length-1].toLowerCase()==="x")return null;return this.formatLanguageCode(t.join("-"))}getLanguagePartFromCode(a){if(a=V5(a),!a||a.indexOf("-")<0)return a;let t=a.split("-");return this.formatLanguageCode(t[0])}formatLanguageCode(a){if(n1(a)&&a.indexOf("-")>-1){let t;try{t=Intl.getCanonicalLocales(a)[0]}catch(r){}if(t&&this.options.lowerCaseLng)t=t.toLowerCase();if(t)return t;if(this.options.lowerCaseLng)return a.toLowerCase();return a}return this.options.cleanCode||this.options.lowerCaseLng?a.toLowerCase():a}isSupportedCode(a){if(this.options.load==="languageOnly"||this.options.nonExplicitSupportedLngs)a=this.getLanguagePartFromCode(a);return!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(a)>-1}getBestMatchFromCodes(a){if(!a)return null;let t;if(a.forEach((r)=>{if(t)return;let l=this.formatLanguageCode(r);if(!this.options.supportedLngs||this.isSupportedCode(l))t=l}),!t&&this.options.supportedLngs)a.forEach((r)=>{if(t)return;let l=this.getScriptPartFromCode(r);if(this.isSupportedCode(l))return t=l;let i=this.getLanguagePartFromCode(r);if(this.isSupportedCode(i))return t=i;t=this.options.supportedLngs.find((e)=>{if(e===i)return e;if(e.indexOf("-")<0&&i.indexOf("-")<0)return;if(e.indexOf("-")>0&&i.indexOf("-")<0&&e.substring(0,e.indexOf("-"))===i)return e;if(e.indexOf(i)===0&&i.length>1)return e})});if(!t)t=this.getFallbackCodes(this.options.fallbackLng)[0];return t}getFallbackCodes(a,t){if(!a)return[];if(typeof a==="function")a=a(t);if(n1(a))a=[a];if(Array.isArray(a))return a;if(!t)return a.default||[];let r=a[t];if(!r)r=a[this.getScriptPartFromCode(t)];if(!r)r=a[this.formatLanguageCode(t)];if(!r)r=a[this.getLanguagePartFromCode(t)];if(!r)r=a.default;return r||[]}toResolveHierarchy(a,t){let r=this.getFallbackCodes((t===!1?[]:t)||this.options.fallbackLng||[],a),l=[],i=(e)=>{if(!e)return;if(this.isSupportedCode(e))l.push(e);else this.logger.warn(`rejecting language code not found in supportedLngs: ${e}`)};if(n1(a)&&(a.indexOf("-")>-1||a.indexOf("_")>-1)){if(this.options.load!=="languageOnly")i(this.formatLanguageCode(a));if(this.options.load!=="languageOnly"&&this.options.load!=="currentOnly")i(this.getScriptPartFromCode(a));if(this.options.load!=="currentOnly")i(this.getLanguagePartFromCode(a))}else if(n1(a))i(this.formatLanguageCode(a));return r.forEach((e)=>{if(l.indexOf(e)<0)i(this.formatLanguageCode(e))}),l}}var X7={zero:0,one:1,two:2,few:3,many:4,other:5},J7={select:(a)=>a===1?"one":"other",resolvedOptions:()=>({pluralCategories:["one","other"]})};class ot{constructor(a,t={}){this.languageUtils=a,this.options=t,this.logger=E0.create("pluralResolver"),this.pluralRulesCache={}}clearCache(){this.pluralRulesCache={}}getRule(a,t={}){let r=V5(a==="dev"?"en":a),l=t.ordinal?"ordinal":"cardinal",i=JSON.stringify({cleanedCode:r,type:l});if(i in this.pluralRulesCache)return this.pluralRulesCache[i];let e;try{e=new Intl.PluralRules(r,{type:l})}catch(o){if(!Intl)return this.logger.error("No Intl support, please use an Intl polyfill!"),J7;if(!a.match(/-|_/))return J7;let n=this.languageUtils.getLanguagePartFromCode(a);e=this.getRule(n,t)}return this.pluralRulesCache[i]=e,e}needsPlural(a,t={}){let r=this.getRule(a,t);if(!r)r=this.getRule("dev",t);return r?.resolvedOptions().pluralCategories.length>1}getPluralFormsOfKey(a,t,r={}){return this.getSuffixes(a,r).map((l)=>`${t}${l}`)}getSuffixes(a,t={}){let r=this.getRule(a,t);if(!r)r=this.getRule("dev",t);if(!r)return[];return r.resolvedOptions().pluralCategories.sort((l,i)=>X7[l]-X7[i]).map((l)=>`${this.options.prepend}${t.ordinal?`ordinal${this.options.prepend}`:""}${l}`)}getSuffix(a,t,r={}){let l=this.getRule(a,r);if(l)return`${this.options.prepend}${r.ordinal?`ordinal${this.options.prepend}`:""}${l.select(t)}`;return this.logger.warn(`no plural rule found for: ${a}`),this.getSuffix("dev",t,r)}}var $7=(a,t,r,l=".",i=!0)=>{let e=Iv(a,t,r);if(!e&&i&&n1(r)){if(e=H4(a,r,l),e===void 0)e=H4(t,r,l)}return e},z4=(a)=>a.replace(/\$/g,"$$$$");class O4{constructor(a={}){this.logger=E0.create("interpolator"),this.options=a,this.format=a?.interpolation?.format||((t)=>t),this.init(a)}init(a={}){if(!a.interpolation)a.interpolation={escapeValue:!0};let{escape:t,escapeValue:r,useRawValueToEscape:l,prefix:i,prefixEscaped:e,suffix:o,suffixEscaped:n,formatSeparator:c,unescapeSuffix:d,unescapePrefix:u,nestingPrefix:g,nestingPrefixEscaped:s,nestingSuffix:M,nestingSuffixEscaped:A,nestingOptionsSeparator:E,maxReplaces:x,alwaysFormat:m}=a.interpolation;this.escape=t!==void 0?t:fv,this.escapeValue=r!==void 0?r:!0,this.useRawValueToEscape=l!==void 0?l:!1,this.prefix=i?g5(i):e||"{{",this.suffix=o?g5(o):n||"}}",this.formatSeparator=c||",",this.unescapePrefix=d?"":u||"-",this.unescapeSuffix=this.unescapePrefix?"":d||"",this.nestingPrefix=g?g5(g):s||g5("$t("),this.nestingSuffix=M?g5(M):A||g5(")"),this.nestingOptionsSeparator=E||",",this.maxReplaces=x||1000,this.alwaysFormat=m!==void 0?m:!1,this.resetRegExp()}reset(){if(this.options)this.init(this.options)}resetRegExp(){let a=(t,r)=>{if(t?.source===r)return t.lastIndex=0,t;return new RegExp(r,"g")};this.regexp=a(this.regexp,`${this.prefix}(.+?)${this.suffix}`),this.regexpUnescape=a(this.regexpUnescape,`${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`),this.nestingRegexp=a(this.nestingRegexp,`${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`)}interpolate(a,t,r,l){let i,e,o,n=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{},c=(s)=>{if(s.indexOf(this.formatSeparator)<0){let x=$7(t,n,s,this.options.keySeparator,this.options.ignoreJSONStructure);return this.alwaysFormat?this.format(x,void 0,r,{...l,...t,interpolationkey:s}):x}let M=s.split(this.formatSeparator),A=M.shift().trim(),E=M.join(this.formatSeparator).trim();return this.format($7(t,n,A,this.options.keySeparator,this.options.ignoreJSONStructure),E,r,{...l,...t,interpolationkey:A})};this.resetRegExp();let d=l?.missingInterpolationHandler||this.options.missingInterpolationHandler,u=l?.interpolation?.skipOnVariables!==void 0?l.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:(s)=>z4(s)},{regex:this.regexp,safeValue:(s)=>this.escapeValue?z4(this.escape(s)):z4(s)}].forEach((s)=>{o=0;while(i=s.regex.exec(a)){let M=i[1].trim();if(e=c(M),e===void 0)if(typeof d==="function"){let E=d(a,i,l);e=n1(E)?E:""}else if(l&&Object.prototype.hasOwnProperty.call(l,M))e="";else if(u){e=i[0];continue}else this.logger.warn(`missed to pass in variable ${M} for interpolating ${a}`),e="";else if(!n1(e)&&!this.useRawValueToEscape)e=W7(e);let A=s.safeValue(e);if(a=a.replace(i[0],A),u)s.regex.lastIndex+=e.length,s.regex.lastIndex-=i[0].length;else s.regex.lastIndex=0;if(o++,o>=this.maxReplaces)break}}),a}nest(a,t,r={}){let l,i,e,o=(n,c)=>{let d=this.nestingOptionsSeparator;if(n.indexOf(d)<0)return n;let u=n.split(new RegExp(`${d}[ ]*{`)),g=`{${u[1]}`;n=u[0],g=this.interpolate(g,e);let s=g.match(/'/g),M=g.match(/"/g);if((s?.length??0)%2===0&&!M||M.length%2!==0)g=g.replace(/'/g,'"');try{if(e=JSON.parse(g),c)e={...c,...e}}catch(A){return this.logger.warn(`failed parsing options string in nesting for key ${n}`,A),`${n}${d}${g}`}if(e.defaultValue&&e.defaultValue.indexOf(this.prefix)>-1)delete e.defaultValue;return n};while(l=this.nestingRegexp.exec(a)){let n=[];e={...r},e=e.replace&&!n1(e.replace)?e.replace:e,e.applyPostProcessor=!1,delete e.defaultValue;let c=/{.*}/.test(l[1])?l[1].lastIndexOf("}")+1:l[1].indexOf(this.formatSeparator);if(c!==-1)n=l[1].slice(c).split(this.formatSeparator).map((d)=>d.trim()).filter(Boolean),l[1]=l[1].slice(0,c);if(i=t(o.call(this,l[1].trim(),e),e),i&&l[0]===a&&!n1(i))return i;if(!n1(i))i=W7(i);if(!i)this.logger.warn(`missed to resolve ${l[1]} for nesting ${a}`),i="";if(n.length)i=n.reduce((d,u)=>this.format(d,u,r.lng,{...r,interpolationkey:l[1].trim()}),i.trim());a=a.replace(l[0],i),this.regexp.lastIndex=0}return a}}var Lv=(a)=>{let t=a.toLowerCase().trim(),r={};if(a.indexOf("(")>-1){let l=a.split("(");t=l[0].toLowerCase().trim();let i=l[1].substring(0,l[1].length-1);if(t==="currency"&&i.indexOf(":")<0){if(!r.currency)r.currency=i.trim()}else if(t==="relativetime"&&i.indexOf(":")<0){if(!r.range)r.range=i.trim()}else i.split(";").forEach((o)=>{if(o){let[n,...c]=o.split(":"),d=c.join(":").trim().replace(/^'+|'+$/g,""),u=n.trim();if(!r[u])r[u]=d;if(d==="false")r[u]=!1;if(d==="true")r[u]=!0;if(!isNaN(d))r[u]=parseInt(d,10)}})}return{formatName:t,formatOptions:r}},at=(a)=>{let t={};return(r,l,i)=>{let e=i;if(i&&i.interpolationkey&&i.formatParams&&i.formatParams[i.interpolationkey]&&i[i.interpolationkey])e={...e,[i.interpolationkey]:void 0};let o=l+JSON.stringify(e),n=t[o];if(!n)n=a(V5(l),i),t[o]=n;return n(r)}},Hv=(a)=>(t,r,l)=>a(V5(r),l)(t);class nt{constructor(a={}){this.logger=E0.create("formatter"),this.options=a,this.init(a)}init(a,t={interpolation:{}}){this.formatSeparator=t.interpolation.formatSeparator||",";let r=t.cacheInBuiltFormats?at:Hv;this.formats={number:r((l,i)=>{let e=new Intl.NumberFormat(l,{...i});return(o)=>e.format(o)}),currency:r((l,i)=>{let e=new Intl.NumberFormat(l,{...i,style:"currency"});return(o)=>e.format(o)}),datetime:r((l,i)=>{let e=new Intl.DateTimeFormat(l,{...i});return(o)=>e.format(o)}),relativetime:r((l,i)=>{let e=new Intl.RelativeTimeFormat(l,{...i});return(o)=>e.format(o,i.range||"day")}),list:r((l,i)=>{let e=new Intl.ListFormat(l,{...i});return(o)=>e.format(o)})}}add(a,t){this.formats[a.toLowerCase().trim()]=t}addCached(a,t){this.formats[a.toLowerCase().trim()]=at(t)}format(a,t,r,l={}){let i=t.split(this.formatSeparator);if(i.length>1&&i[0].indexOf("(")>1&&i[0].indexOf(")")<0&&i.find((o)=>o.indexOf(")")>-1)){let o=i.findIndex((n)=>n.indexOf(")")>-1);i[0]=[i[0],...i.splice(1,o)].join(this.formatSeparator)}return i.reduce((o,n)=>{let{formatName:c,formatOptions:d}=Lv(n);if(this.formats[c]){let u=o;try{let g=l?.formatParams?.[l.interpolationkey]||{},s=g.locale||g.lng||l.locale||l.lng||r;u=this.formats[c](o,s,{...d,...l,...g})}catch(g){this.logger.warn(g)}return u}else this.logger.warn(`there was no format function for ${c}`);return o},a)}}var Vv=(a,t)=>{if(a.pending[t]!==void 0)delete a.pending[t],a.pendingCount--};class ht extends k5{constructor(a,t,r,l={}){super();this.backend=a,this.store=t,this.services=r,this.languageUtils=r.languageUtils,this.options=l,this.logger=E0.create("backendConnector"),this.waitingReads=[],this.maxParallelReads=l.maxParallelReads||10,this.readingCalls=0,this.maxRetries=l.maxRetries>=0?l.maxRetries:5,this.retryTimeout=l.retryTimeout>=1?l.retryTimeout:350,this.state={},this.queue=[],this.backend?.init?.(r,l.backend,l)}queueLoad(a,t,r,l){let i={},e={},o={},n={};if(a.forEach((c)=>{let d=!0;if(t.forEach((u)=>{let g=`${c}|${u}`;if(!r.reload&&this.store.hasResourceBundle(c,u))this.state[g]=2;else if(this.state[g]<0);else if(this.state[g]===1){if(e[g]===void 0)e[g]=!0}else{if(this.state[g]=1,d=!1,e[g]===void 0)e[g]=!0;if(i[g]===void 0)i[g]=!0;if(n[u]===void 0)n[u]=!0}}),!d)o[c]=!0}),Object.keys(i).length||Object.keys(e).length)this.queue.push({pending:e,pendingCount:Object.keys(e).length,loaded:{},errors:[],callback:l});return{toLoad:Object.keys(i),pending:Object.keys(e),toLoadLanguages:Object.keys(o),toLoadNamespaces:Object.keys(n)}}loaded(a,t,r){let l=a.split("|"),i=l[0],e=l[1];if(t)this.emit("failedLoading",i,e,t);if(!t&&r)this.store.addResourceBundle(i,e,r,void 0,void 0,{skipCopy:!0});if(this.state[a]=t?-1:2,t&&r)this.state[a]=0;let o={};this.queue.forEach((n)=>{if(Ev(n.loaded,[i],e),Vv(n,a),t)n.errors.push(t);if(n.pendingCount===0&&!n.done)if(Object.keys(n.loaded).forEach((c)=>{if(!o[c])o[c]={};let d=n.loaded[c];if(d.length)d.forEach((u)=>{if(o[c][u]===void 0)o[c][u]=!0})}),n.done=!0,n.errors.length)n.callback(n.errors);else n.callback()}),this.emit("loaded",o),this.queue=this.queue.filter((n)=>!n.done)}read(a,t,r,l=0,i=this.retryTimeout,e){if(!a.length)return e(null,{});if(this.readingCalls>=this.maxParallelReads){this.waitingReads.push({lng:a,ns:t,fcName:r,tried:l,wait:i,callback:e});return}this.readingCalls++;let o=(c,d)=>{if(this.readingCalls--,this.waitingReads.length>0){let u=this.waitingReads.shift();this.read(u.lng,u.ns,u.fcName,u.tried,u.wait,u.callback)}if(c&&d&&l<this.maxRetries){setTimeout(()=>{this.read.call(this,a,t,r,l+1,i*2,e)},i);return}e(c,d)},n=this.backend[r].bind(this.backend);if(n.length===2){try{let c=n(a,t);if(c&&typeof c.then==="function")c.then((d)=>o(null,d)).catch(o);else o(null,c)}catch(c){o(c)}return}return n(a,t,o)}prepareLoading(a,t,r={},l){if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),l&&l();if(n1(a))a=this.languageUtils.toResolveHierarchy(a);if(n1(t))t=[t];let i=this.queueLoad(a,t,r,l);if(!i.toLoad.length){if(!i.pending.length)l();return null}i.toLoad.forEach((e)=>{this.loadOne(e)})}load(a,t,r){this.prepareLoading(a,t,{},r)}reload(a,t,r){this.prepareLoading(a,t,{reload:!0},r)}loadOne(a,t=""){let r=a.split("|"),l=r[0],i=r[1];this.read(l,i,"read",void 0,void 0,(e,o)=>{if(e)this.logger.warn(`${t}loading namespace ${i} for language ${l} failed`,e);if(!e&&o)this.logger.log(`${t}loaded namespace ${i} for language ${l}`,o);this.loaded(a,e,o)})}saveMissing(a,t,r,l,i,e={},o=()=>{}){if(this.services?.utils?.hasLoadedNamespace&&!this.services?.utils?.hasLoadedNamespace(t)){this.logger.warn(`did not save key "${r}" as the namespace "${t}" was not yet loaded`,"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");return}if(r===void 0||r===null||r==="")return;if(this.backend?.create){let n={...e,isUpdate:i},c=this.backend.create.bind(this.backend);if(c.length<6)try{let d;if(c.length===5)d=c(a,t,r,l,n);else d=c(a,t,r,l);if(d&&typeof d.then==="function")d.then((u)=>o(null,u)).catch(o);else o(null,d)}catch(d){o(d)}else c(a,t,r,l,o,n)}if(!a||!a[0])return;this.store.addResource(a[0],t,r,l)}}var L4=()=>({debug:!1,initAsync:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!1,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:(a)=>{let t={};if(typeof a[1]==="object")t=a[1];if(n1(a[1]))t.defaultValue=a[1];if(n1(a[2]))t.tDescription=a[2];if(typeof a[2]==="object"||typeof a[3]==="object"){let r=a[3]||a[2];Object.keys(r).forEach((l)=>{t[l]=r[l]})}return t},interpolation:{escapeValue:!0,format:(a)=>a,prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1000,skipOnVariables:!0},cacheInBuiltFormats:!0}),tt=(a)=>{if(n1(a.ns))a.ns=[a.ns];if(n1(a.fallbackLng))a.fallbackLng=[a.fallbackLng];if(n1(a.fallbackNS))a.fallbackNS=[a.fallbackNS];if(a.supportedLngs?.indexOf?.("cimode")<0)a.supportedLngs=a.supportedLngs.concat(["cimode"]);if(typeof a.initImmediate==="boolean")a.initAsync=a.initImmediate;return a},S2=()=>{},kv=(a)=>{Object.getOwnPropertyNames(Object.getPrototypeOf(a)).forEach((r)=>{if(typeof a[r]==="function")a[r]=a[r].bind(a)})},Nv=(a)=>{if(a?.modules?.backend?.name?.indexOf("Locize")>0)return!0;if(a?.modules?.backend?.constructor?.name?.indexOf("Locize")>0)return!0;if(a?.options?.backend?.backends){if(a.options.backend.backends.some((t)=>t?.name?.indexOf("Locize")>0||t?.constructor?.name?.indexOf("Locize")>0))return!0}return!1};class H5 extends k5{constructor(a={},t){super();if(this.options=tt(a),this.services={},this.logger=E0,this.modules={external:[]},kv(this),t&&!this.isInitialized&&!a.isClone){if(!this.options.initAsync)return this.init(a,t),this;setTimeout(()=>{this.init(a,t)},0)}}init(a={},t){if(this.isInitializing=!0,typeof a==="function")t=a,a={};if(a.defaultNS==null&&a.ns){if(n1(a.ns))a.defaultNS=a.ns;else if(a.ns.indexOf("translation")<0)a.defaultNS=a.ns[0]}let r=L4();if(this.options={...r,...this.options,...tt(a)},this.options.interpolation={...r.interpolation,...this.options.interpolation},a.keySeparator!==void 0)this.options.userDefinedKeySeparator=a.keySeparator;if(a.nsSeparator!==void 0)this.options.userDefinedNsSeparator=a.nsSeparator;if(typeof this.options.overloadTranslationOptionHandler!=="function")this.options.overloadTranslationOptionHandler=r.overloadTranslationOptionHandler;if(this.options.showSupportNotice!==!1&&!Nv(this)){if(typeof console<"u"&&typeof console.info<"u")console.info("\uD83C\uDF10 i18next is maintained with support from locize.com — consider powering your project with managed localization (AI, CDN, integrations): https://locize.com \uD83D\uDC99")}let l=(c)=>{if(!c)return null;if(typeof c==="function")return new c;return c};if(!this.options.isClone){if(this.modules.logger)E0.init(l(this.modules.logger),this.options);else E0.init(null,this.options);let c;if(this.modules.formatter)c=this.modules.formatter;else c=nt;let d=new N4(this.options);this.store=new V4(this.options.resources,this.options);let u=this.services;if(u.logger=E0,u.resourceStore=this.store,u.languageUtils=d,u.pluralResolver=new ot(d,{prepend:this.options.pluralSeparator,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),this.options.interpolation.format&&this.options.interpolation.format!==r.interpolation.format)this.logger.deprecate("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting");if(c&&(!this.options.interpolation.format||this.options.interpolation.format===r.interpolation.format)){if(u.formatter=l(c),u.formatter.init)u.formatter.init(u,this.options);this.options.interpolation.format=u.formatter.format.bind(u.formatter)}if(u.interpolator=new O4(this.options),u.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},u.backendConnector=new ht(l(this.modules.backend),u.resourceStore,u,this.options),u.backendConnector.on("*",(s,...M)=>{this.emit(s,...M)}),this.modules.languageDetector){if(u.languageDetector=l(this.modules.languageDetector),u.languageDetector.init)u.languageDetector.init(u,this.options.detection,this.options)}if(this.modules.i18nFormat){if(u.i18nFormat=l(this.modules.i18nFormat),u.i18nFormat.init)u.i18nFormat.init(this)}this.translator=new T2(this.services,this.options),this.translator.on("*",(s,...M)=>{this.emit(s,...M)}),this.modules.external.forEach((s)=>{if(s.init)s.init(this)})}if(this.format=this.options.interpolation.format,!t)t=S2;if(this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){let c=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);if(c.length>0&&c[0]!=="dev")this.options.lng=c[0]}if(!this.services.languageDetector&&!this.options.lng)this.logger.warn("init: no languageDetector is used and no lng is defined");["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"].forEach((c)=>{this[c]=(...d)=>this.store[c](...d)}),["addResource","addResources","addResourceBundle","removeResourceBundle"].forEach((c)=>{this[c]=(...d)=>{return this.store[c](...d),this}});let o=z5(),n=()=>{let c=(d,u)=>{if(this.isInitializing=!1,this.isInitialized&&!this.initializedStoreOnce)this.logger.warn("init: i18next is already initialized. You should call init just once!");if(this.isInitialized=!0,!this.options.isClone)this.logger.log("initialized",this.options);this.emit("initialized",this.options),o.resolve(u),t(d,u)};if(this.languages&&!this.isInitialized)return c(null,this.t.bind(this));this.changeLanguage(this.options.lng,c)};if(this.options.resources||!this.options.initAsync)n();else setTimeout(n,0);return o}loadResources(a,t=S2){let r=t,l=n1(a)?a:this.language;if(typeof a==="function")r=a;if(!this.options.resources||this.options.partialBundledLanguages){if(l?.toLowerCase()==="cimode"&&(!this.options.preload||this.options.preload.length===0))return r();let i=[],e=(o)=>{if(!o)return;if(o==="cimode")return;this.services.languageUtils.toResolveHierarchy(o).forEach((c)=>{if(c==="cimode")return;if(i.indexOf(c)<0)i.push(c)})};if(!l)this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((n)=>e(n));else e(l);this.options.preload?.forEach?.((o)=>e(o)),this.services.backendConnector.load(i,this.options.ns,(o)=>{if(!o&&!this.resolvedLanguage&&this.language)this.setResolvedLanguage(this.language);r(o)})}else r(null)}reloadResources(a,t,r){let l=z5();if(typeof a==="function")r=a,a=void 0;if(typeof t==="function")r=t,t=void 0;if(!a)a=this.languages;if(!t)t=this.options.ns;if(!r)r=S2;return this.services.backendConnector.reload(a,t,(i)=>{l.resolve(),r(i)}),l}use(a){if(!a)throw Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!a.type)throw Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");if(a.type==="backend")this.modules.backend=a;if(a.type==="logger"||a.log&&a.warn&&a.error)this.modules.logger=a;if(a.type==="languageDetector")this.modules.languageDetector=a;if(a.type==="i18nFormat")this.modules.i18nFormat=a;if(a.type==="postProcessor")it.addPostProcessor(a);if(a.type==="formatter")this.modules.formatter=a;if(a.type==="3rdParty")this.modules.external.push(a);return this}setResolvedLanguage(a){if(!a||!this.languages)return;if(["cimode","dev"].indexOf(a)>-1)return;for(let t=0;t<this.languages.length;t++){let r=this.languages[t];if(["cimode","dev"].indexOf(r)>-1)continue;if(this.store.hasLanguageSomeTranslations(r)){this.resolvedLanguage=r;break}}if(!this.resolvedLanguage&&this.languages.indexOf(a)<0&&this.store.hasLanguageSomeTranslations(a))this.resolvedLanguage=a,this.languages.unshift(a)}changeLanguage(a,t){this.isLanguageChangingTo=a;let r=z5();this.emit("languageChanging",a);let l=(o)=>{this.language=o,this.languages=this.services.languageUtils.toResolveHierarchy(o),this.resolvedLanguage=void 0,this.setResolvedLanguage(o)},i=(o,n)=>{if(n){if(this.isLanguageChangingTo===a)l(n),this.translator.changeLanguage(n),this.isLanguageChangingTo=void 0,this.emit("languageChanged",n),this.logger.log("languageChanged",n)}else this.isLanguageChangingTo=void 0;if(r.resolve((...c)=>this.t(...c)),t)t(o,(...c)=>this.t(...c))},e=(o)=>{if(!a&&!o&&this.services.languageDetector)o=[];let n=n1(o)?o:o&&o[0],c=this.store.hasLanguageSomeTranslations(n)?n:this.services.languageUtils.getBestMatchFromCodes(n1(o)?[o]:o);if(c){if(!this.language)l(c);if(!this.translator.language)this.translator.changeLanguage(c);this.services.languageDetector?.cacheUserLanguage?.(c)}this.loadResources(c,(d)=>{i(d,c)})};if(!a&&this.services.languageDetector&&!this.services.languageDetector.async)e(this.services.languageDetector.detect());else if(!a&&this.services.languageDetector&&this.services.languageDetector.async)if(this.services.languageDetector.detect.length===0)this.services.languageDetector.detect().then(e);else this.services.languageDetector.detect(e);else e(a);return r}getFixedT(a,t,r){let l=(i,e,...o)=>{let n;if(typeof e!=="object")n=this.options.overloadTranslationOptionHandler([i,e].concat(o));else n={...e};if(n.lng=n.lng||l.lng,n.lngs=n.lngs||l.lngs,n.ns=n.ns||l.ns,n.keyPrefix!=="")n.keyPrefix=n.keyPrefix||r||l.keyPrefix;let c=this.options.keySeparator||".",d;if(n.keyPrefix&&Array.isArray(i))d=i.map((u)=>{if(typeof u==="function")u=k4(u,{...this.options,...e});return`${n.keyPrefix}${c}${u}`});else{if(typeof i==="function")i=k4(i,{...this.options,...e});d=n.keyPrefix?`${n.keyPrefix}${c}${i}`:i}return this.t(d,n)};if(n1(a))l.lng=a;else l.lngs=a;return l.ns=t,l.keyPrefix=r,l}t(...a){return this.translator?.translate(...a)}exists(...a){return this.translator?.exists(...a)}setDefaultNamespace(a){this.options.defaultNS=a}hasLoadedNamespace(a,t={}){if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;let r=t.lng||this.resolvedLanguage||this.languages[0],l=this.options?this.options.fallbackLng:!1,i=this.languages[this.languages.length-1];if(r.toLowerCase()==="cimode")return!0;let e=(o,n)=>{let c=this.services.backendConnector.state[`${o}|${n}`];return c===-1||c===0||c===2};if(t.precheck){let o=t.precheck(this,e);if(o!==void 0)return o}if(this.hasResourceBundle(r,a))return!0;if(!this.services.backendConnector.backend||this.options.resources&&!this.options.partialBundledLanguages)return!0;if(e(r,a)&&(!l||e(i,a)))return!0;return!1}loadNamespaces(a,t){let r=z5();if(!this.options.ns){if(t)t();return Promise.resolve()}if(n1(a))a=[a];return a.forEach((l)=>{if(this.options.ns.indexOf(l)<0)this.options.ns.push(l)}),this.loadResources((l)=>{if(r.resolve(),t)t(l)}),r}loadLanguages(a,t){let r=z5();if(n1(a))a=[a];let l=this.options.preload||[],i=a.filter((e)=>l.indexOf(e)<0&&this.services.languageUtils.isSupportedCode(e));if(!i.length){if(t)t();return Promise.resolve()}return this.options.preload=l.concat(i),this.loadResources((e)=>{if(r.resolve(),t)t(e)}),r}dir(a){if(!a)a=this.resolvedLanguage||(this.languages?.length>0?this.languages[0]:this.language);if(!a)return"rtl";try{let l=new Intl.Locale(a);if(l&&l.getTextInfo){let i=l.getTextInfo();if(i&&i.direction)return i.direction}}catch(l){}let t=["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam","ckb"],r=this.services?.languageUtils||new N4(L4());if(a.toLowerCase().indexOf("-latn")>1)return"ltr";return t.indexOf(r.getLanguagePartFromCode(a))>-1||a.toLowerCase().indexOf("-arab")>1?"rtl":"ltr"}static createInstance(a={},t){let r=new H5(a,t);return r.createInstance=H5.createInstance,r}cloneInstance(a={},t=S2){let r=a.forkResourceStore;if(r)delete a.forkResourceStore;let l={...this.options,...a,...{isClone:!0}},i=new H5(l);if(a.debug!==void 0||a.prefix!==void 0)i.logger=i.logger.clone(a);if(["store","services","language"].forEach((o)=>{i[o]=this[o]}),i.services={...this.services},i.services.utils={hasLoadedNamespace:i.hasLoadedNamespace.bind(i)},r){let o=Object.keys(this.store.data).reduce((n,c)=>{return n[c]={...this.store.data[c]},n[c]=Object.keys(n[c]).reduce((d,u)=>{return d[u]={...n[c][u]},d},n[c]),n},{});i.store=new V4(o,l),i.services.resourceStore=i.store}if(a.interpolation){let n={...L4().interpolation,...this.options.interpolation,...a.interpolation},c={...l,interpolation:n};i.services.interpolator=new O4(c)}return i.translator=new T2(i.services,l),i.translator.on("*",(o,...n)=>{i.emit(o,...n)}),i.init(l,t),i.translator.options=l,i.translator.backendConnector.services.utils={hasLoadedNamespace:i.hasLoadedNamespace.bind(i)},i}toJSON(){return{options:this.options,store:this.store,language:this.language,languages:this.languages,resolvedLanguage:this.resolvedLanguage}}}var C1=H5.createInstance(),np=C1.createInstance,hp=C1.dir,cp=C1.init,dp=C1.loadResources,vp=C1.reloadResources,up=C1.use,gp=C1.changeLanguage,sp=C1.getFixedT,pp=C1.t,Sp=C1.exists,Mp=C1.setDefaultNamespace,Ap=C1.hasLoadedNamespace,Tp=C1.loadNamespaces,Ep=C1.loadLanguages;var q0=Z(B1(),1);var Ov=(a,t,r,l)=>{let i=[r,{code:t,...l||{}}];if(a?.services?.logger?.forward)return a.services.logger.forward(i,"warn","react-i18next::",!0);if(D0(i[0]))i[0]=`react-i18next:: ${i[0]}`;if(a?.services?.logger?.warn)a.services.logger.warn(...i);else if(console?.warn)console.warn(...i)},ct={},R4=(a,t,r,l)=>{if(D0(r)&&ct[r])return;if(D0(r))ct[r]=new Date;Ov(a,t,r,l)},dt=(a,t)=>()=>{if(a.isInitialized)t();else{let r=()=>{setTimeout(()=>{a.off("initialized",r)},0),t()};a.on("initialized",r)}},E2=(a,t,r)=>{a.loadNamespaces(t,dt(a,r))},w4=(a,t,r,l)=>{if(D0(r))r=[r];if(a.options.preload&&a.options.preload.indexOf(t)>-1)return E2(a,r,l);r.forEach((i)=>{if(a.options.ns.indexOf(i)<0)a.options.ns.push(i)}),a.loadLanguages(t,dt(a,l))},vt=(a,t,r={})=>{if(!t.languages||!t.languages.length)return R4(t,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:t.languages}),!0;return t.hasLoadedNamespace(a,{lng:r.lng,precheck:(l,i)=>{if(r.bindI18n&&r.bindI18n.indexOf("languageChanging")>-1&&l.services.backendConnector.backend&&l.isLanguageChangingTo&&!i(l.isLanguageChangingTo,a))return!1}})};var D0=(a)=>typeof a==="string",ut=(a)=>typeof a==="object"&&a!==null;var Rv=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,wv={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"©","&#169;":"©","&reg;":"®","&#174;":"®","&hellip;":"…","&#8230;":"…","&#x2F;":"/","&#47;":"/"},Dv=(a)=>wv[a],gt=(a)=>a.replace(Rv,Dv);var D4={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:gt,transDefaultProps:void 0},G4=(a={})=>{D4={...D4,...a}},P4=()=>D4;var st,F4=(a)=>{st=a},Z4=()=>st;var pt=Z(B1(),1);var y4={type:"3rdParty",init(a){G4(a.options.react),F4(a)}};var I2=pt.createContext();class b4{constructor(){this.usedNamespaces={}}addUsedNamespaces(a){a.forEach((t)=>{if(!this.usedNamespaces[t])this.usedNamespaces[t]=!0})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}var D1=Z(B1(),1),Mt=Z(St(),1);var Pv=(a,t)=>{if(D0(t))return t;if(ut(t)&&D0(t.defaultValue))return t.defaultValue;return Array.isArray(a)?a[a.length-1]:a},Fv={t:Pv,ready:!1},Zv=()=>()=>{},G1=(a,t={})=>{let{i18n:r}=t,{i18n:l,defaultNS:i}=D1.useContext(I2)||{},e=r||l||Z4();if(e&&!e.reportNamespaces)e.reportNamespaces=new b4;if(!e)R4(e,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");let o=D1.useMemo(()=>({...P4(),...e?.options?.react,...t}),[e,t]),{useSuspense:n,keyPrefix:c}=o,d=a||i||e?.options?.defaultNS,u=D0(d)?[d]:d||["translation"],g=D1.useMemo(()=>u,u);e?.reportNamespaces?.addUsedNamespaces?.(g);let s=D1.useRef(0),M=D1.useCallback((N)=>{if(!e)return Zv;let{bindI18n:P,bindI18nStore:b}=o,G=()=>{s.current+=1,N()};if(P)e.on(P,G);if(b)e.store.on(b,G);return()=>{if(P)P.split(" ").forEach((j)=>e.off(j,G));if(b)b.split(" ").forEach((j)=>e.store.off(j,G))}},[e,o]),A=D1.useRef(),E=D1.useCallback(()=>{if(!e)return Fv;let N=!!(e.isInitialized||e.initializedStoreOnce)&&g.every((V)=>vt(V,e,o)),P=t.lng||e.language,b=s.current,G=A.current;if(G&&G.ready===N&&G.lng===P&&G.keyPrefix===c&&G.revision===b)return G;let e1={t:e.getFixedT(P,o.nsMode==="fallback"?g:g[0],c),ready:N,lng:P,keyPrefix:c,revision:b};return A.current=e1,e1},[e,g,c,o,t.lng]),[x,m]=D1.useState(0),{t:T,ready:_}=Mt.useSyncExternalStore(M,E,E);D1.useEffect(()=>{if(e&&!_&&!n){let N=()=>m((P)=>P+1);if(t.lng)w4(e,t.lng,g,N);else E2(e,g,N)}},[e,t.lng,g,_,n,x]);let C=e||{},z=D1.useRef(null),L=D1.useRef(),H=(N)=>{let P=Object.getOwnPropertyDescriptors(N);if(P.__original)delete P.__original;let b=Object.create(Object.getPrototypeOf(N),P);if(!Object.prototype.hasOwnProperty.call(b,"__original"))try{Object.defineProperty(b,"__original",{value:N,writable:!1,enumerable:!1,configurable:!1})}catch(G){}return b},I=D1.useMemo(()=>{let N=C,P=N?.language,b=N;if(N)if(z.current&&z.current.__original===N)if(L.current!==P)b=H(N),z.current=b,L.current=P;else b=z.current;else b=H(N),z.current=b,L.current=P;let G=[T,b,_];return G.t=T,G.i18n=b,G.ready=_,G},[T,C,_,C.resolvedLanguage,C.language,C.languages]);if(e&&n&&!_)throw new Promise((N)=>{let P=()=>N();if(t.lng)w4(e,t.lng,g,P);else E2(e,g,P)});return I};var m2=Z(B1(),1);function j4({i18n:a,defaultNS:t,children:r}){let l=m2.useMemo(()=>({i18n:a,defaultNS:t}),[a,t]);return m2.createElement(I2.Provider,{value:l},r)}var hg={af:()=>Promise.resolve().then(() => Z(At(),1)),am:()=>Promise.resolve().then(() => Z(Tt(),1)),"ar-EG":()=>Promise.resolve().then(() => Z(Et(),1)),"ar-MA":()=>Promise.resolve().then(() => Z(It(),1)),"ar-SA":()=>Promise.resolve().then(() => Z(mt(),1)),ar:()=>Promise.resolve().then(() => Z(ft(),1)),az:()=>Promise.resolve().then(() => Z(xt(),1)),bg:()=>Promise.resolve().then(() => Z(Ct(),1)),bho:()=>Promise.resolve().then(() => Z(_t(),1)),bn:()=>Promise.resolve().then(() => Z(Bt(),1)),bs:()=>Promise.resolve().then(() => Z(zt(),1)),ca:()=>Promise.resolve().then(() => Z(Lt(),1)),cs:()=>Promise.resolve().then(() => Z(Ht(),1)),da:()=>Promise.resolve().then(() => Z(Vt(),1)),de:()=>Promise.resolve().then(() => Z(kt(),1)),el:()=>Promise.resolve().then(() => Z(Nt(),1)),"en-GB":()=>Promise.resolve().then(() => Z(Ot(),1)),en:()=>Promise.resolve().then(() => Z(Rt(),1)),"es-419":()=>Promise.resolve().then(() => Z(wt(),1)),"es-AR":()=>Promise.resolve().then(() => Z(Dt(),1)),"es-MX":()=>Promise.resolve().then(() => Z(Gt(),1)),es:()=>Promise.resolve().then(() => Z(Pt(),1)),et:()=>Promise.resolve().then(() => Z(Ft(),1)),eu:()=>Promise.resolve().then(() => Z(Zt(),1)),fa:()=>Promise.resolve().then(() => Z(yt(),1)),fi:()=>Promise.resolve().then(() => Z(bt(),1)),fil:()=>Promise.resolve().then(() => Z(jt(),1)),"fr-CA":()=>Promise.resolve().then(() => Z(Ut(),1)),fr:()=>Promise.resolve().then(() => Z(Wt(),1)),gl:()=>Promise.resolve().then(() => Z(Kt(),1)),gu:()=>Promise.resolve().then(() => Z(qt(),1)),he:()=>Promise.resolve().then(() => Z(Yt(),1)),hi:()=>Promise.resolve().then(() => Z(Qt(),1)),hr:()=>Promise.resolve().then(() => Z(Xt(),1)),hu:()=>Promise.resolve().then(() => Z(Jt(),1)),id:()=>Promise.resolve().then(() => Z($t(),1)),is:()=>Promise.resolve().then(() => Z(a8(),1)),it:()=>Promise.resolve().then(() => Z(t8(),1)),ja:()=>Promise.resolve().then(() => Z(r8(),1)),kn:()=>Promise.resolve().then(() => Z(l8(),1)),ko:()=>Promise.resolve().then(() => Z(i8(),1)),lt:()=>Promise.resolve().then(() => Z(e8(),1)),lv:()=>Promise.resolve().then(() => Z(o8(),1)),mk:()=>Promise.resolve().then(() => Z(n8(),1)),ml:()=>Promise.resolve().then(() => Z(h8(),1)),mr:()=>Promise.resolve().then(() => Z(c8(),1)),ms:()=>Promise.resolve().then(() => Z(d8(),1)),nb:()=>Promise.resolve().then(() => Z(v8(),1)),ne:()=>Promise.resolve().then(() => Z(u8(),1)),nl:()=>Promise.resolve().then(() => Z(g8(),1)),or:()=>Promise.resolve().then(() => Z(s8(),1)),"pa-IN":()=>Promise.resolve().then(() => Z(p8(),1)),"pa-PK":()=>Promise.resolve().then(() => Z(S8(),1)),pl:()=>Promise.resolve().then(() => Z(M8(),1)),"pt-BR":()=>Promise.resolve().then(() => Z(A8(),1)),"pt-PT":()=>Promise.resolve().then(() => Z(T8(),1)),ro:()=>Promise.resolve().then(() => Z(E8(),1)),ru:()=>Promise.resolve().then(() => Z(I8(),1)),sk:()=>Promise.resolve().then(() => Z(m8(),1)),sl:()=>Promise.resolve().then(() => Z(f8(),1)),sr:()=>Promise.resolve().then(() => Z(x8(),1)),sv:()=>Promise.resolve().then(() => Z(C8(),1)),sw:()=>Promise.resolve().then(() => Z(_8(),1)),ta:()=>Promise.resolve().then(() => Z(B8(),1)),te:()=>Promise.resolve().then(() => Z(z8(),1)),th:()=>Promise.resolve().then(() => Z(L8(),1)),tr:()=>Promise.resolve().then(() => Z(H8(),1)),uk:()=>Promise.resolve().then(() => Z(V8(),1)),ur:()=>Promise.resolve().then(() => Z(k8(),1)),vi:()=>Promise.resolve().then(() => Z(N8(),1)),"zh-CN":()=>Promise.resolve().then(() => Z(O8(),1)),"zh-HK":()=>Promise.resolve().then(() => Z(R8(),1)),"zh-TW":()=>Promise.resolve().then(() => Z(w8(),1)),zu:()=>Promise.resolve().then(() => Z(D8(),1))},G8=(a)=>{let[t,r]=q0.useState(Spicetify.Locale.getLocale()),[l,i]=q0.useState(!1);if(q0.useEffect(()=>{let e=Spicetify.Locale.getLocale();r(e),(async()=>{let n={};for(let[c,d]of Object.entries(hg)){let u=await d();n[c]={translation:u.default}}await C1.use(y4).init({resources:n,lng:e,fallbackLng:"en",interpolation:{escapeValue:!1}}),i(!0)})()},[Spicetify.Platform.Session.locale,Spicetify.Locale._locale]),!l)return null;return q0.default.createElement(j4,{i18n:C1},a.children)};var cg=/enhanced_recommendation/;function f2(a,t=0,r=10){if(t>r||!a||typeof a!=="object")return null;if(typeof a.uri==="string"&&a.uri.startsWith("spotify:track:"))return a.uri;if(a.props?.uri&&typeof a.props.uri==="string"&&a.props.uri.startsWith("spotify:track:"))return a.props.uri;if(Array.isArray(a.children))for(let l of a.children){let i=f2(l,t+1,r);if(i)return i}if(a.children&&typeof a.children==="object"&&!Array.isArray(a.children)){let l=f2(a.children,t+1,r);if(l)return l}if(a.props?.children){let l=f2(a.props.children,t+1,r);if(l)return l}return null}function P8(){return(Spicetify?.Queue?.nextTracks||[]).filter((a)=>a.contextTrack.uri.includes("track"))}function F8(a){let t=null,r=!1,l=a,i=Object.keys(l).find((o)=>o.toLowerCase().includes("reactFiber".toLowerCase()));if(i){let o=l[i];while(o)try{let n=o.memoizedProps??o.pendingProps??o.props??{};if(n.item&&typeof n.item==="object"){let c=n.item;if(c.uri&&typeof c.uri==="string"&&c.uri.startsWith("spotify:track:"))t=c.uri;if(c.metadata&&typeof c.metadata==="object"){let d=JSON.stringify(c.metadata);if(cg.test(d))r=!0}if(t)break}if(!t){let c=f2(n);if(c){t=c;break}}o=o.return}catch{break}}let e=Array.from(a.querySelectorAll(t0.ARTIST_LINK)).map((o)=>o.href.match(/\/artist\/([a-zA-Z0-9]+)/)?.[1]).filter((o)=>Boolean(o)).map((o)=>`spotify:artist:${o}`);return{trackURI:t,artistURIs:e,isEnhancedRecommendation:r}}function U4(a){let t=A1.getState();if(!a||!a.uri)return!0;if(t.trashSongList[a.uri])return!0;let r=new Set,l=a;for(let e of l?.artists||[])if(e&&e.uri)r.add(e.uri);if(a.metadata?.artist_uri)r.add(a.metadata.artist_uri);let i=1;while(a.metadata?.[`artist_uri:${i}`])r.add(a.metadata[`artist_uri:${i}`]),i++;for(let e of r)if(t.trashArtistList[e])return!0;return!1}async function Z8(){let a=Spicetify.Player.data;if(!a?.context?.uri){Spicetify.Player.next();return}let t=a.context.uri;for(let r of P8())if(!U4(r.contextTrack))try{return await Spicetify.Player.playUri(t,{featureIdentifier:"playlist"},{skipTo:{uri:r.contextTrack.uri}})}catch(l){console.error("Error skipping to next allowed track:",l)}Spicetify.Player.next()}function W4(a,t){let r=Spicetify.Player.data?.item;if(!r)return!1;if(t===Spicetify.URI.Type.TRACK)return a===r.uri;if(t===Spicetify.URI.Type.ARTIST){let l=0,i=r.metadata?.artist_uri;while(i){if(a===i)return!0;l++,i=r.metadata?.[`artist_uri:${l}`]}}return!1}async function y8(){if(!document.querySelector(t0.SMART_SHUFFLE_BUTTON))return;let a=P8();if(a.length===0)return;let t=a.filter((r)=>r?.contextTrack.metadata?.provider==="enhanced_recommendation");if(a.length>4&&a.length>t.length){let r=a.filter((l)=>l.contextTrack.uri&&l.contextTrack.metadata?.provider!=="enhanced_recommendation"&&A1.getState().getTrashStatus(l.contextTrack.uri).isTrashed).map((l)=>({uri:l.contextTrack.uri,uid:l.contextTrack.uid}));if(r.length===0)return;await Spicetify.removeFromQueue(r),await new Promise((l)=>setTimeout(l,1000))}}var S1={ENABLED:"trashbin-enabled",WIDGET:"TrashbinWidgetIcon",SONGS:"TrashSongList",ARTISTS:"TrashArtistList",AUTOPLAY_ON_START:"trashbin-autoplay-on-start",QUEUE_TRASHBIN:"trashbin-queue-enabled",TRACKLIST_TRASHBIN:"trashbin-tracklist-enabled",SKIP_TRASHED_TRACKS:"trashbin-skip-trashed-tracks",AUTO_CLEAN_QUEUE:"trashbin-auto-clean-queue",PLAYLIST_MONITOR:"trashbin-playlist-monitor",TRASH_ON_NEXT_HOTKEY:"trashbin-trash-on-next-hotkey",REMOTE_TOGGLE_ENABLED:"trashbin-remote-toggle-enabled",REMOTE_SKIPPING_ENABLED:"trashbin-remote-skipping-enabled",TRASH_VIA_LIKE:"trashbin-trash-via-like",AI_DETECTION:"trashbin-ai-detection"};function b1(a,t){try{let r=Spicetify.LocalStorage.get(a);return r?JSON.parse(r)??t:t}catch{return t}}var A1=U7((a,t)=>({trashbinEnabled:!0,widgetEnabled:!0,autoplayOnStart:!1,queueTrashbinEnabled:!0,tracklistTrashbinEnabled:!0,skipTrashedTracks:!0,autoCleanQueue:!1,playlistMonitorEnabled:!0,trashOnNextHotkey:!1,trashSongList:{},trashArtistList:{},userHitBack:!1,remoteToggleEnabled:!1,remoteSkippingEnabled:!1,trashViaLikeEnabled:!1,aiDetectionEnabled:!1,aiAssetsReady:!1,aiAssetsDownloading:!1,initializeFromStorage:()=>{a({trashbinEnabled:b1(S1.ENABLED,!0),widgetEnabled:b1(S1.WIDGET,!0),trashSongList:b1(S1.SONGS,{}),trashArtistList:b1(S1.ARTISTS,{}),autoplayOnStart:b1(S1.AUTOPLAY_ON_START,!1),queueTrashbinEnabled:b1(S1.QUEUE_TRASHBIN,!0),tracklistTrashbinEnabled:b1(S1.TRACKLIST_TRASHBIN,!0),skipTrashedTracks:b1(S1.SKIP_TRASHED_TRACKS,!0),autoCleanQueue:b1(S1.AUTO_CLEAN_QUEUE,!1),playlistMonitorEnabled:b1(S1.PLAYLIST_MONITOR,!0),trashOnNextHotkey:b1(S1.TRASH_ON_NEXT_HOTKEY,!1),remoteToggleEnabled:b1(S1.REMOTE_TOGGLE_ENABLED,!1),remoteSkippingEnabled:b1(S1.REMOTE_SKIPPING_ENABLED,!1),trashViaLikeEnabled:b1(S1.TRASH_VIA_LIKE,!1),aiDetectionEnabled:b1(S1.AI_DETECTION,!1)})},setTrashbinEnabled:(r)=>{a({trashbinEnabled:r}),Spicetify.LocalStorage.set(S1.ENABLED,JSON.stringify(r))},setWidgetEnabled:(r)=>{a({widgetEnabled:r}),Spicetify.LocalStorage.set(S1.WIDGET,JSON.stringify(r))},setAutoplayOnStart:(r)=>{a({autoplayOnStart:r}),Spicetify.LocalStorage.set(S1.AUTOPLAY_ON_START,JSON.stringify(r))},setQueueTrashbinEnabled:(r)=>{a({queueTrashbinEnabled:r}),Spicetify.LocalStorage.set(S1.QUEUE_TRASHBIN,JSON.stringify(r))},setTracklistTrashbinEnabled:(r)=>{a({tracklistTrashbinEnabled:r}),Spicetify.LocalStorage.set(S1.TRACKLIST_TRASHBIN,JSON.stringify(r))},setSkipTrashedTracks:(r)=>{a({skipTrashedTracks:r}),Spicetify.LocalStorage.set(S1.SKIP_TRASHED_TRACKS,JSON.stringify(r))},setAutoCleanQueue:(r)=>{a({autoCleanQueue:r}),Spicetify.LocalStorage.set(S1.AUTO_CLEAN_QUEUE,JSON.stringify(r))},setPlaylistMonitorEnabled:(r)=>{a({playlistMonitorEnabled:r}),Spicetify.LocalStorage.set(S1.PLAYLIST_MONITOR,JSON.stringify(r))},setTrashOnNextHotkey:(r)=>{a({trashOnNextHotkey:r}),Spicetify.LocalStorage.set(S1.TRASH_ON_NEXT_HOTKEY,JSON.stringify(r))},setUserHitBack:(r)=>a({userHitBack:r}),setRemoteToggleEnabled:(r)=>{a({remoteToggleEnabled:r}),Spicetify.LocalStorage.set(S1.REMOTE_TOGGLE_ENABLED,JSON.stringify(r))},setRemoteSkippingEnabled:(r)=>{a({remoteSkippingEnabled:r}),Spicetify.LocalStorage.set(S1.REMOTE_SKIPPING_ENABLED,JSON.stringify(r))},toggleRemoteSkipping:()=>{let l=!t().remoteSkippingEnabled;a({remoteSkippingEnabled:l}),Spicetify.LocalStorage.set(S1.REMOTE_SKIPPING_ENABLED,JSON.stringify(l))},setTrashViaLikeEnabled:(r)=>{a({trashViaLikeEnabled:r}),Spicetify.LocalStorage.set(S1.TRASH_VIA_LIKE,JSON.stringify(r))},setAiDetectionEnabled:(r)=>{a({aiDetectionEnabled:r}),Spicetify.LocalStorage.set(S1.AI_DETECTION,JSON.stringify(r))},setAiAssetsReady:(r)=>a({aiAssetsReady:r}),setAiAssetsDownloading:(r)=>a({aiAssetsDownloading:r}),toggleSongTrash:(r,l=!0)=>{let i=t(),e=!!i.trashSongList[r],o={...i.trashSongList};if(e){if(delete o[r],l)Spicetify.showNotification(C1.t("MESSAGE_SONG_REMOVED"))}else{if(o[r]=!0,l)Spicetify.showNotification(C1.t("MESSAGE_SONG_ADDED"));let n=Spicetify.Player.data?.item;if(i.trashbinEnabled&&n&&W4(r,Spicetify.URI.Type.TRACK))Spicetify.Player.next()}a({trashSongList:o}),Spicetify.LocalStorage.set(S1.SONGS,JSON.stringify(o))},toggleArtistTrash:(r,l=!0)=>{let i=t(),e=!!i.trashArtistList[r],o={...i.trashArtistList};if(e){if(delete o[r],l)Spicetify.showNotification(C1.t("MESSAGE_ARTIST_REMOVED"))}else{if(o[r]=!0,l)Spicetify.showNotification(C1.t("MESSAGE_ARTIST_ADDED"));let n=Spicetify.Player.data?.item;if(i.trashbinEnabled&&n&&W4(r,Spicetify.URI.Type.ARTIST))Spicetify.Player.next()}a({trashArtistList:o}),Spicetify.LocalStorage.set(S1.ARTISTS,JSON.stringify(o))},getTrashStatus:(r)=>{let l=t(),i=Spicetify.URI.fromString(r);return{isTrashed:i.type===Spicetify.URI.Type.TRACK?!!l.trashSongList[r]:!!l.trashArtistList[r],type:i.type}},importTrashData:(r,l)=>{a({trashSongList:r,trashArtistList:l}),Spicetify.LocalStorage.set(S1.SONGS,JSON.stringify(r)),Spicetify.LocalStorage.set(S1.ARTISTS,JSON.stringify(l))},clearTrashbin:()=>{let r={};a({trashSongList:r,trashArtistList:r}),Spicetify.LocalStorage.set(S1.SONGS,JSON.stringify(r)),Spicetify.LocalStorage.set(S1.ARTISTS,JSON.stringify(r))},exportData:()=>{let r=t();return{songs:r.trashSongList,artists:r.trashArtistList}}}));var dg=800,vg=3000,K4=1500,ug=2000;function N5(a){return new Promise((t)=>setTimeout(t,a))}var b8=Spicetify.ReactDOMServer.renderToString(I0.default.createElement(D7,{size:26})),j8=Spicetify.ReactDOMServer.renderToString(I0.default.createElement(w7,{size:26}));function U8(){let a=document.querySelector(T0.gridSelector);if(!a)return null;let t=a.parentElement;while(t&&t.tagName!=="MAIN"){let r=t.querySelectorAll("button");for(let l of r)if(l.textContent?.trim()==="Refresh")return l;t=t.parentElement}return null}var W8=()=>{let a=A1(),t=I0.useRef(!1),r=I0.useRef(!1),l=I0.useRef(null),i=()=>{if(l.current)l.current.innerHTML=t.current?j8:b8},e=async()=>{while(t.current&&!r.current){let u=document.querySelector(T0.gridSelector);if(!u){t.current=!1,i();return}let g=u.querySelectorAll(T0.rowSelector);if(g.length===0){await N5(K4);continue}let s=[],M=!0;for(let A of g){let E=A.querySelector(T0.trashButtonSelector);if(!E){M=!1;continue}if(E.dataset.visuallyTrashed!=="true")s.push(A)}if(!M&&s.length===0){await N5(K4);continue}if(s.length>0){for(let A of s){if(!t.current||r.current)return;let E=A.querySelector(T0.addButtonSelector);if(E)E.click(),await N5(dg)}await N5(K4)}else{let A=U8();if(A)A.click(),await N5(vg);else{t.current=!1,i();return}}}},o=()=>{t.current=!0,r.current=!1,i(),e()},n=()=>{t.current=!1,i()},c=()=>{let u=document.querySelector(`.${T0.autoAddButtonClassName}-wrapper`);if(u){let g=u.querySelector(`button:not(.${T0.autoAddButtonClassName})`);if(g)u.parentElement?.insertBefore(g,u);u.remove()}l.current=null},d=()=>{if(!a.trashbinEnabled){c();return}if(l.current?.isConnected)return;let u=U8();if(!u)return;let g=document.createElement("button");g.className=`${u.className} ${T0.autoAddButtonClassName}`,g.title="Auto-add recommendations",g.innerHTML=t.current?j8:b8,g.setAttribute("data-encore-id",u.getAttribute("data-encore-id")||"buttonTertiary"),g.onclick=(M)=>{if(M.stopPropagation(),t.current)n();else o()},l.current=g;let s=document.createElement("div");s.className=`${T0.autoAddButtonClassName}-wrapper flex items-center justify-between w-full`,u.parentElement?.insertBefore(s,u),s.appendChild(g),s.appendChild(u)};I0.useEffect(()=>{if(!a.trashbinEnabled){r.current=!0,t.current=!1,c();return}d();let u=setInterval(d,ug);return()=>{clearInterval(u)}},[a.trashbinEnabled]),I0.useEffect(()=>{return()=>{r.current=!0,t.current=!1,c()}},[])};var K8=()=>{return W8(),null};var X8=Z(B1(),1);var q8=Z(B1(),1);var m0=(a,t)=>Spicetify.ReactDOMServer.renderToString(q8.default.createElement(u5,{className:t,size:a}));var Y8=Z(B1(),1),Q8=(a,t,r={})=>{let{enabled:l=!0}=r;Y8.useEffect(()=>{if(!l)return;let i=new MutationObserver((e)=>{if(t(e))a()});return i.observe(document.body,{childList:!0,subtree:!0}),()=>i.disconnect()},[l,a,t])};var x2=(a,t=!0)=>{let r=A1(),l=()=>{document.querySelectorAll(a.buttonSelector).forEach((o)=>o.remove())},i=async()=>{if(l(),!t||!r.trashbinEnabled)return;let o=document.querySelector(a.containerSelector);if(!o)return;o.querySelectorAll(a.moreButtonSelector).forEach((n)=>{let c=n.closest(a.rowSelector);if(!c)return;let d=F8(n.parentElement||c);if(!d.trackURI||c.querySelector(a.buttonSelector))return;let u=!!r.trashSongList[d.trackURI],g=document.createElement("button");g.className=`${a.buttonClassName} bg-transparent border-none p-2 opacity-70 cursor-pointer hover:opacity-100 transition-opacity`,g.innerHTML=m0(16,u?"fill-[#22c55e]":""),g.dataset.visuallyTrashed=u.toString(),g.onclick=(s)=>{s.stopPropagation();let M=g.dataset.visuallyTrashed!=="true";g.innerHTML=m0(16,M?"fill-[#22c55e]":""),g.dataset.visuallyTrashed=M.toString(),r.toggleSongTrash(d.trackURI)},n.parentElement?.insertBefore(g,n)})};X8.useEffect(()=>{if(!t||!r.trashbinEnabled)l();else i()},[t,r.trashbinEnabled,l,i]),Q8(i,(o)=>o.some((n)=>Array.from(n.addedNodes).some((c)=>{if(c.nodeType!==Node.ELEMENT_NODE)return!1;let d=c;return(d.closest?.(a.containerSelector)||d.querySelector?.(a.containerSelector))&&!d.classList?.contains(a.buttonClassName.split(" ")[0])})),{enabled:r.trashbinEnabled&&t})};var J8=()=>{let a=A1((t)=>t.queueTrashbinEnabled);return x2(Z7,a),null};var $8=()=>{let a=A1((t)=>t.tracklistTrashbinEnabled);return x2(F7,a),null};var C2=Z(B1(),1);var ar=()=>{let{t:a}=G1(),t=A1();return{handleTrashToggle:(e)=>{let o=e[0],n=Spicetify.URI.fromString(o);if(n.type===Spicetify.URI.Type.TRACK)t.toggleSongTrash(o);else if(n.type===Spicetify.URI.Type.ARTIST)t.toggleArtistTrash(o)},shouldAddContextMenu:(e)=>{if(e.length>1||!t.trashbinEnabled)return!1;let{type:o}=t.getTrashStatus(e[0]);return o===Spicetify.URI.Type.TRACK||o===Spicetify.URI.Type.ARTIST},getContextMenuLabel:(e)=>{let{isTrashed:o}=t.getTrashStatus(e);return o?a("ACTION_UNTHROW"):a("ACTION_THROW")}}};function tr(){let{t:a}=G1(),t=ar(),r=C2.useRef(null),l=(i)=>{let e=t.shouldAddContextMenu(i);if(e&&r.current)r.current.name=t.getContextMenuLabel(i[0]);return e};return C2.useEffect(()=>{let i=new Spicetify.ContextMenu.Item(a("ACTION_THROW"),t.handleTrashToggle,l,m0(15));return r.current=i,i.register(),()=>i.deregister()},[t.handleTrashToggle,l]),null}var s5=Z(B1(),1);var rr=s5.default.memo(()=>{let{t:a}=G1(),t=A1(),r=s5.useRef(null),l=(i)=>{let e=Spicetify.Player.data?.item;if(!e)return;let o=Spicetify.URI.fromString(e.uri).type===Spicetify.URI.Type.TRACK,n=!!t.trashSongList[e.uri];if(o)i.active=n,i.label=n?a("ACTION_UNTHROW"):a("ACTION_THROW"),i.icon=m0(18,n?"fill-[#22c55e]":"");else i.deregister()};return s5.useEffect(()=>{let i=new Spicetify.Playbar.Widget(a("ACTION_THROW"),m0(18),()=>{let o=Spicetify.Player.data?.item;if(o)t.toggleSongTrash(o.uri)},!1,!1,t.widgetEnabled&&t.trashbinEnabled);r.current=i,l(i);let e=()=>l(i);return Spicetify.Player.addEventListener("songchange",e),()=>{Spicetify.Player.removeEventListener("songchange",e),i.deregister()}},[t.trashbinEnabled,t.widgetEnabled,t.trashSongList]),null});var r1=Z(B1(),1);function lr(a){return A0({tag:"svg",attr:{fill:"none",viewBox:"0 0 24 24",strokeWidth:"1.5",stroke:"currentColor","aria-hidden":"true"},child:[{tag:"path",attr:{strokeLinecap:"round",strokeLinejoin:"round",d:"M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z"},child:[]}]})(a)}function p5(...a){return a.filter(Boolean).join(" ")}var gg=({children:a,content:t})=>{let[r,l]=r1.useState(!1),[i,e]=r1.useState({x:0,y:0}),o=r1.useRef(),n=(d)=>{clearTimeout(o.current);let u=d.currentTarget.getBoundingClientRect();e({x:u.left+u.width/2,y:u.top-8}),l(!0)},c=()=>{o.current=setTimeout(()=>{l(!1)},100)};return r1.useEffect(()=>{return()=>clearTimeout(o.current)},[]),r1.default.createElement(r1.default.Fragment,null,r1.default.createElement("span",{onMouseEnter:n,onMouseLeave:c},a),r&&r1.default.createElement("div",{className:"pointer-events-none fixed z-50 rounded px-2 py-1 text-xs shadow-lg",style:{left:i.x,top:i.y,transform:"translate(-50%, -100%)",maxWidth:"200px",wordWrap:"break-word",backgroundColor:"black",color:"white"}},t,r1.default.createElement("div",{className:"absolute top-full left-1/2 -translate-x-1/2 transform border-4 border-transparent",style:{borderTopColor:"black"}})))},Q1=({label:a,enabled:t,onChange:r,description:l,disabled:i})=>r1.default.createElement("div",{className:p5("flex items-center justify-between gap-2.5! py-2.5!",i&&"opacity-50!")},r1.default.createElement("label",{className:"flex w-full items-center gap-1.5! pr-4"},a,l&&r1.default.createElement(gg,{content:l},r1.default.createElement("span",{className:"inline-flex! cursor-help! text-[rgba(var(--spice-rgb-text),0.5)]! transition-colors! hover:text-(--spice-text)!"},r1.default.createElement(lr,{size:14})))),r1.default.createElement("div",{className:"text-right"},r1.default.createElement("button",{className:p5("flex! items-center! rounded-full! border-0!","ml-3! p-2! transition-colors!","bg-[rgba(var(--spice-rgb-shadow),0.7)]! text-(--spice-text)!",!t&&"text-[rgba(var(--spice-rgb-text),0.3)]!",i?"cursor-not-allowed!":"cursor-pointer!"),type:"button",disabled:i,onClick:(e)=>{if(e.preventDefault(),e.stopPropagation(),!i)r(!t)}},r1.default.createElement("svg",{height:"16",width:"16",viewBox:"0 0 16 16",fill:"currentColor"},t&&r1.default.createElement("path",{d:"M8.797 2.5a.5.5 0 0 0-.594 0L2.5 6.5v7a1 1 0 0 0 1 1h9a1 1 0 0 0 1-1v-7l-5.703-4z"}))))),_2=({label:a,description:t,onClick:r})=>r1.default.createElement("div",{className:"flex items-center justify-between gap-2.5! py-2.5!"},r1.default.createElement("label",{className:"w-full pr-4"},t),r1.default.createElement("div",{className:"text-right"},r1.default.createElement("button",{className:p5("rounded-full! bg-transparent! font-bold! transition-transform!","border! border-[#727272]! px-3.75! duration-33!","min-h-8! cursor-pointer! text-(--spice-text)!","hover:scale-[1.04]! hover:border-(--spice-text)!"),onClick:r},a))),sg=()=>{let{t:a}=G1(),t=A1(),r=()=>{let o=document.createElement("input");o.type="file",o.accept=".json",o.onchange=(n)=>{let c=n.target.files?.[0];if(!c)return;let d=new FileReader;d.onload=(u)=>{try{let g=JSON.parse(u.target?.result);t.importTrashData(g.songs||{},g.artists||{}),Spicetify.showNotification(a("BACKUP_RESTORE_SUCCESS"))}catch{Spicetify.showNotification(a("BACKUP_FILE_READ_FAILED"),!0)}},d.readAsText(c)},o.click()},l=async()=>{try{let n=await(await window.showSaveFilePicker?.({suggestedName:a("BACKUP_SUGGESTED_FILENAME"),types:[{accept:{"application/json":[".json"]}}]}))?.createWritable();await n?.write(JSON.stringify(t.exportData())),await n?.close(),Spicetify.showNotification(a("BACKUP_SAVE_SUCCESS"))}catch{Spicetify.showNotification(a("BACKUP_SAVE_FAILED"))}},i=()=>{Spicetify.Platform.ClipboardAPI.copy(JSON.stringify(t.exportData())),Spicetify.showNotification(a("MESSAGE_COPIED"))},e=()=>{t.clearTrashbin(),Spicetify.showNotification(a("MESSAGE_CLEARED"))};return r1.default.createElement("div",{className:"p-4"},r1.default.createElement("h2",{className:"my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"},a("SETTINGS_OPTIONS")),r1.default.createElement(Q1,{label:a("SETTINGS_ENABLED"),enabled:t.trashbinEnabled,onChange:t.setTrashbinEnabled,description:a("DESCRIPTION_SETTINGS_ENABLED")}),r1.default.createElement(Q1,{label:a("SETTINGS_SHOW_WIDGET"),enabled:t.widgetEnabled,onChange:t.setWidgetEnabled,description:a("DESCRIPTION_SETTINGS_SHOW_WIDGET")}),r1.default.createElement("h2",{className:"my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"},a("SETTINGS_FEATURES")),r1.default.createElement(Q1,{label:a("SETTINGS_AUTOPLAY"),enabled:t.autoplayOnStart,onChange:t.setAutoplayOnStart,description:a("DESCRIPTION_SETTINGS_AUTOPLAY")}),r1.default.createElement(Q1,{label:a("SETTINGS_QUEUE_TRASHBIN"),enabled:t.queueTrashbinEnabled,onChange:t.setQueueTrashbinEnabled,description:a("DESCRIPTION_SETTINGS_QUEUE_TRASHBIN")}),r1.default.createElement(Q1,{label:a("SETTINGS_TRACKLIST_TRASHBIN"),enabled:t.tracklistTrashbinEnabled,onChange:t.setTracklistTrashbinEnabled,description:a("DESCRIPTION_SETTINGS_TRACKLIST_TRASHBIN")}),r1.default.createElement(Q1,{label:a("SETTINGS_SKIP_TRASHED_TRACKS"),enabled:t.skipTrashedTracks,onChange:t.setSkipTrashedTracks,description:a("DESCRIPTION_SETTINGS_SKIP_TRASHED_TRACKS")}),r1.default.createElement(Q1,{label:a("SETTINGS_AUTO_CLEAN_QUEUE"),enabled:t.autoCleanQueue,onChange:t.setAutoCleanQueue,description:a("DESCRIPTION_SETTINGS_AUTO_CLEAN_QUEUE")}),r1.default.createElement(Q1,{label:a("SETTINGS_PLAYLIST_MONITOR"),enabled:t.playlistMonitorEnabled,onChange:t.setPlaylistMonitorEnabled,description:a("DESCRIPTION_SETTINGS_PLAYLIST_MONITOR")}),r1.default.createElement(Q1,{label:a("SETTINGS_TRASH_ON_NEXT_HOTKEY"),enabled:t.trashOnNextHotkey,onChange:t.setTrashOnNextHotkey,description:a("DESCRIPTION_SETTINGS_TRASH_ON_NEXT_HOTKEY")}),r1.default.createElement("h2",{className:"my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"},a("SETTINGS_REMOTE_CONTROL")),r1.default.createElement(Q1,{label:a("SETTINGS_REMOTE_TOGGLE"),enabled:t.remoteToggleEnabled,onChange:t.setRemoteToggleEnabled,description:a("DESCRIPTION_SETTINGS_REMOTE_TOGGLE")}),r1.default.createElement(Q1,{label:a("SETTINGS_REMOTE_SKIPPING"),enabled:t.remoteSkippingEnabled,onChange:t.setRemoteSkippingEnabled,description:a("DESCRIPTION_SETTINGS_REMOTE_SKIPPING"),disabled:!t.remoteToggleEnabled}),r1.default.createElement(Q1,{label:a("SETTINGS_TRASH_VIA_LIKE"),enabled:t.trashViaLikeEnabled,onChange:t.setTrashViaLikeEnabled,description:a("DESCRIPTION_SETTINGS_TRASH_VIA_LIKE"),disabled:!t.remoteToggleEnabled}),r1.default.createElement("h2",{className:"my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"},a("SETTINGS_AI_DETECTION")),r1.default.createElement(Q1,{label:a("SETTINGS_AI_DETECTION_ENABLED"),enabled:t.aiDetectionEnabled,onChange:t.setAiDetectionEnabled,description:a("DESCRIPTION_SETTINGS_AI_DETECTION_ENABLED")}),t.aiDetectionEnabled&&r1.default.createElement("div",{className:"py-1! text-xs! text-[rgba(var(--spice-rgb-text),0.5)]!"},t.aiAssetsDownloading?a("AI_ASSETS_DOWNLOADING"):t.aiAssetsReady?a("AI_ASSETS_READY"):a("AI_ASSETS_NOT_READY")),r1.default.createElement("h2",{className:"my-2.5! text-lg font-bold text-(--spice-text) first-of-type:mt-0"},a("SETTINGS_LOCAL_STORAGE")),r1.default.createElement(_2,{label:a("ACTION_COPY"),description:a("DESCRIPTION_COPY"),onClick:i}),r1.default.createElement(_2,{label:a("ACTION_EXPORT"),description:a("DESCRIPTION_EXPORT"),onClick:l}),r1.default.createElement(_2,{label:a("ACTION_IMPORT"),description:a("DESCRIPTION_IMPORT"),onClick:r}),r1.default.createElement(_2,{label:a("ACTION_CLEAR"),description:a("DESCRIPTION_CLEAR"),onClick:e}))};function ir(){let{t:a}=G1(),[t,r]=r1.useState(!1);return r1.useEffect(()=>{let l=new Spicetify.Menu.Item(a("TRASHBIN_NAME"),!1,()=>r(!0),m0(15));return l.register(),()=>l.deregister()},[]),r1.useEffect(()=>{if(!t)return;Spicetify.PopupModal.display({title:a("SETTINGS_TITLE"),content:r1.default.createElement(sg,null)});let l=new MutationObserver(()=>{if(!document.querySelector(t0.TRACK_CREDITS_MODAL_CONTAINER))r(!1)});return l.observe(document.body,{childList:!0,subtree:!0}),()=>{l.disconnect()}},[t]),null}var G0=Z(B1(),1);var W1=Z(B1(),1);var O1=Z(B1(),1);function er(a){return A0({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"m289.94 256 95-95A24 24 0 0 0 351 127l-95 95-95-95a24 24 0 0 0-34 34l95 95-95 95a24 24 0 1 0 34 34l95-95 95 95a24 24 0 0 0 34-34z"},child:[]}]})(a)}var or=({item:a,onUntrash:t})=>{let r="type"in a&&a.type==="artist",l=r?"rounded-full":"rounded",i=r?P7:G7,e=r?a.secondaryText:a.artist;return O1.default.createElement("div",{className:"trashbin-item-row flex items-center justify-between rounded-md p-3 transition-colors"},O1.default.createElement("div",{className:"flex min-w-0 flex-1 items-center gap-3"},a.imageUrl?O1.default.createElement("img",{src:a.imageUrl,alt:a.name,className:`h-12 w-12 ${l} object-cover`}):O1.default.createElement("div",{className:`flex h-12 w-12 items-center justify-center ${l}`,style:{backgroundColor:"rgba(255, 255, 255, 0.1)"}},O1.default.createElement(i,{className:"h-6 w-6",style:{color:"rgba(255, 255, 255, 0.7)"}})),O1.default.createElement("div",{className:"min-w-0 flex-1"},O1.default.createElement("div",{className:"truncate font-medium",style:{color:"white"}},a.name),O1.default.createElement("div",{className:"truncate text-sm",style:{color:"rgba(255, 255, 255, 0.6)"}},e))),O1.default.createElement("button",{onClick:()=>navigator.clipboard.writeText(a.uri),className:"trashbin-uri-btn shrink-0 cursor-pointer text-xs transition-colors",title:"Click to copy URI"},a.uri),O1.default.createElement("button",{onClick:(o)=>{o.stopPropagation(),o.preventDefault(),t(a.uri)},className:"trashbin-remove-btn mx-2! cursor-pointer rounded-full p-2! transition-colors",title:"Remove from trashbin"},O1.default.createElement(er,{className:"h-5 w-5 transition-colors"})))},q4=(a)=>{let{t}=G1();return O1.default.createElement("div",{className:"p-8 text-center"},O1.default.createElement("div",{className:"flex flex-col items-center gap-6 py-12"},O1.default.createElement(u5,{className:"h-20 w-20",style:{color:"rgba(255, 255, 255, 0.2)"}}),O1.default.createElement("div",null,O1.default.createElement("h3",{className:"mb-2 text-xl font-semibold",style:{color:"white"}},a.type==="songs"?t("ITEMS_EMPTY_SONGS_TITLE"):t("ITEMS_EMPTY_ARTISTS_TITLE")),O1.default.createElement("p",{style:{color:"rgba(255, 255, 255, 0.6)"},dangerouslySetInnerHTML:{__html:a.type==="songs"?t("ITEMS_EMPTY_SONGS"):t("ITEMS_EMPTY_ARTISTS")}}))))},nr=(a)=>O1.default.createElement("button",{onClick:a.onClick,className:p5("trashbin-tab-btn relative px-4! py-2! text-lg font-medium transition-colors","border-b-2",a.isActive&&"trashbin-tab-btn--active")},a.label,O1.default.createElement("span",{className:"trashbin-tab-count mx-1! text-xs"},"(",a.count,")"),a.isActive&&O1.default.createElement("div",{className:"trashbin-tab-indicator absolute right-0 bottom-0 left-0 h-0.5"}));var _1=Z(B1(),1);function pg(a){let t=BigInt(0);for(let r of a){let l="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(r);if(l===-1)return"0".repeat(32);t=t*62n+BigInt(l)}return t.toString(16).padStart(32,"0")}async function hr(a,t){let r=(await Spicetify.Platform.AuthorizationAPI.getState()).token.accessToken;return(await fetch(`https://spclient.wg.spotify.com/metadata/4/${a}/${pg(t)}?market=from_token`,{headers:{Accept:"application/json",Authorization:`Bearer ${r}`}})).json()}async function cr(a){return Promise.all(a.map(async(t)=>{let r=t.split(":")[2];try{let l=await hr("track",r);return{uri:t,name:l?.name||"Unknown Track",artist:l?.artist?.map((i)=>i.name).join(", ")||"Unknown Artist",imageUrl:l?.album?.cover_group?.image?.[0]?.file_id?`https://i.scdn.co/image/${l.album.cover_group.image[0].file_id}`:void 0}}catch{return{uri:t,name:"Error loading track",artist:"Failed to load"}}}))}async function dr(a){return Promise.all(a.map(async(t)=>{let r=t.split(":")[2];try{let l=await hr("artist",r);return{uri:t,name:l?.name||"Unknown Artist",type:"artist",imageUrl:l?.portrait_group?.image?.[0]?.file_id?`https://i.scdn.co/image/${l.portrait_group.image[0].file_id}`:void 0,secondaryText:"Artist"}}catch{return{uri:t,name:"Error loading artist",type:"artist",secondaryText:"Failed to load"}}}))}var O5=60,vr=5;function Sg(a,t){let[r,l]=_1.useState(a);return _1.useEffect(()=>{let i=setTimeout(()=>l(a),t);return()=>clearTimeout(i)},[a,t]),r}var ur=(a)=>{let{t}=G1(),r=_1.useRef(null),[l,i]=_1.useState(0),[e,o]=_1.useState(0),[n,c]=_1.useState(new Map),[d,u]=_1.useState(new Set),[g,s]=_1.useState(""),M=Sg(g,300),E=(()=>{if(!M.trim())return a.items.map((I,N)=>({uri:I,originalIndex:N}));let H=M.toLowerCase();return a.items.map((I,N)=>({uri:I,originalIndex:N})).filter(({uri:I,originalIndex:N})=>{let P=n.get(N);if(P){let b=P.name.toLowerCase().includes(H),G="artist"in P?P.artist.toLowerCase().includes(H):P.secondaryText.toLowerCase().includes(H);return b||G||I.toLowerCase().includes(H)}return I.toLowerCase().includes(H)})})(),x=E.length*O5,m=Math.max(0,Math.floor(l/O5)-vr),T=Math.ceil(e/O5)+vr*2,_=Math.min(E.length,m+T),C=E.slice(m,_).map((H,I)=>({...H,virtualIndex:m+I})),z=(H)=>{i(H.currentTarget.scrollTop)};_1.useEffect(()=>{let H=r.current;if(!H)return;let I=new ResizeObserver((N)=>{o(N[0]?.contentRect.height??0)});return I.observe(H),o(H.clientHeight),()=>I.disconnect()},[]);let L=async(H)=>{let I=`${a.activeTab}-${H}`;if(d.has(I))return;let N=50,P=H*N,b=Math.min(P+N,a.items.length);u((G)=>new Set(G).add(I));try{let G=a.items.slice(P,b),j=a.activeTab==="songs"?await cr(G):await dr(G);c((e1)=>{let V=new Map(e1);return j.forEach((F,a1)=>V.set(P+a1,F)),V})}catch(G){console.error(`Failed to load ${a.activeTab} batch:`,G)}finally{u((G)=>{let j=new Set(G);return j.delete(I),j})}};return _1.useEffect(()=>{let I=new Set;C.forEach((N)=>{if(!n.has(N.originalIndex))I.add(Math.floor(N.originalIndex/50))}),I.forEach(L)},[m,_,n]),_1.useEffect(()=>{c(new Map),u(new Set)},[a.activeTab,a.items]),_1.default.createElement(_1.default.Fragment,null,_1.default.createElement("div",{className:"mb-3"},_1.default.createElement("input",{type:"text",value:g,onChange:(H)=>s(H.target.value),placeholder:t("ITEMS_SEARCH_PLACEHOLDER"),className:"trashbin-search-input w-full rounded-lg border px-4 py-2 text-sm outline-none"})),_1.default.createElement("div",{ref:r,onScroll:z,className:"trashbin-list-container h-100 overflow-auto rounded-lg border"},_1.default.createElement("div",{style:{height:x,position:"relative"}},C.map((H)=>{let I=n.get(H.originalIndex);return _1.default.createElement("div",{key:H.uri,style:{position:"absolute",top:H.virtualIndex*O5,left:0,right:0,height:O5}},I?_1.default.createElement(or,{item:I,onUntrash:a.onUntrash}):_1.default.createElement("div",{className:"flex h-full items-center justify-center"},_1.default.createElement("div",{className:"trashbin-spinner h-6 w-6 animate-spin rounded-full border-2"})))}))),_1.default.createElement("div",{className:"py-4! text-center"},_1.default.createElement("p",{className:"trashbin-loaded-count text-sm"},t("ITEMS_LOADED_COUNT",{loaded:n.size,total:a.items.length,type:a.activeTab}))))};var gr=()=>{let{t:a}=G1(),t=A1(),[r,l]=W1.useState("songs"),i=W1.useMemo(()=>Object.keys(t.trashSongList),[t.trashSongList]),e=W1.useMemo(()=>Object.keys(t.trashArtistList),[t.trashArtistList]),o=[{key:"songs",label:a("ITEMS_TAB_SONGS"),count:i.length,uris:i},{key:"artists",label:a("ITEMS_TAB_ARTISTS"),count:e.length,uris:e}],n=o.find((u)=>u.key===r),c=(u)=>{if(r==="songs")t.toggleSongTrash(u,!1);else t.toggleArtistTrash(u,!1)};if(!(i.length>0||e.length>0))return W1.default.createElement(q4,{type:r});return W1.default.createElement(W1.default.Fragment,null,W1.default.createElement("style",null,`
        ${t0.TRACK_CREDITS_MODAL} {overflow-y: hidden !important;}
        .trashbin-search-input {
          border-color: rgba(255, 255, 255, 0.1) !important;
          background-color: rgba(0, 0, 0, 0.3) !important;
          color: white !important;
        }
        .trashbin-search-input::placeholder {
          color: rgba(255, 255, 255, 0.4) !important;
        }
        .trashbin-search-input:focus {
          border-color: rgba(255, 255, 255, 0.3) !important;
        }
        .trashbin-list-container {
          border-color: rgba(255, 255, 255, 0.1) !important;
          background-color: rgba(0, 0, 0, 0.2) !important;
        }
        .trashbin-item-row {
          background-color: transparent !important;
        }
        .trashbin-item-row:hover {
          background-color: rgba(255, 255, 255, 0.05) !important;
        }
        .trashbin-uri-btn {
          color: rgba(255, 255, 255, 0.4) !important;
          background: transparent !important;
          border: none !important;
        }
        .trashbin-uri-btn:hover {
          color: rgba(255, 255, 255, 0.6) !important;
        }
        .trashbin-remove-btn {
          background: transparent !important;
          border: none !important;
        }
        .trashbin-remove-btn svg {
          color: rgba(255, 255, 255, 0.7) !important;
        }
        .trashbin-remove-btn:hover {
          background-color: rgba(239, 68, 68, 0.2) !important;
        }
        .trashbin-remove-btn:hover svg {
          color: #f87171 !important;
        }
        .trashbin-spinner {
          border-color: rgba(255, 255, 255, 0.2) !important;
          border-top-color: rgba(255, 255, 255, 0.6) !important;
        }
        .trashbin-loaded-count {
          color: rgba(255, 255, 255, 0.4) !important;
        }
        .trashbin-tab-btn {
          color: rgba(255, 255, 255, 0.6) !important;
          border-color: transparent !important;
          background: transparent !important;
        }
        .trashbin-tab-btn:hover {
          color: rgba(255, 255, 255, 0.8) !important;
        }
        .trashbin-tab-btn--active {
          color: white !important;
          border-color: #22c55e !important;
        }
        .trashbin-tab-btn--active:hover {
          color: white !important;
        }
        .trashbin-tab-count {
          color: rgba(255, 255, 255, 0.6) !important;
        }
        .trashbin-tab-indicator {
          background-color: #22c55e !important;
        }
      `),W1.default.createElement("div",{className:"mb-4! flex border-b",style:{borderColor:"rgba(255, 255, 255, 0.1)"}},o.map((u)=>W1.default.createElement(nr,{key:u.key,label:u.label,count:u.count,isActive:r===u.key,onClick:()=>l(u.key)}))),n.uris.length===0?W1.default.createElement(q4,{type:r}):W1.default.createElement(ur,{items:n.uris,activeTab:r,onUntrash:c}))};function sr(){let{t:a}=G1(),[t,r]=G0.useState(!1);return G0.useEffect(()=>{let l=new Spicetify.Menu.Item(a("ITEMS_TITLE"),!1,()=>r(!0),Spicetify.ReactDOMServer.renderToString(G0.default.createElement(u5,{size:15})));return l.register(),()=>l.deregister()},[]),G0.useEffect(()=>{if(!t)return;Spicetify.PopupModal.display({title:a("ITEMS_TITLE"),content:G0.default.createElement(gr,null),isLarge:!0});let l=new MutationObserver(()=>{if(!document.querySelector(t0.TRACK_CREDITS_MODAL_CONTAINER))r(!1)});return l.observe(document.body,{childList:!0,subtree:!0}),()=>{l.disconnect()}},[t]),null}var Fh=Z(B1(),1);var f0={MODEL:"sonics_model.onnx",WASM:"ort-wasm-simd-threaded.wasm",VERSION:"version.json"};function Mr(){return new Promise((a,t)=>{let r=indexedDB.open("trashbin-ai",1);r.onupgradeneeded=()=>{let l=r.result;if(!l.objectStoreNames.contains("assets"))l.createObjectStore("assets",{keyPath:"name"})},r.onsuccess=()=>a(r.result),r.onerror=()=>t(r.error)})}async function R5(a){let t=await Mr();return new Promise((r,l)=>{let o=t.transaction("assets","readonly").objectStore("assets").get(a);o.onsuccess=()=>{t.close(),r(o.result?.data??null)},o.onerror=()=>{t.close(),l(o.error)}})}async function pr(a,t,r){let l=await Mr();return new Promise((i,e)=>{let c=l.transaction("assets","readwrite").objectStore("assets").put({name:a,data:t,version:r});c.onsuccess=()=>{l.close(),i()},c.onerror=()=>{l.close(),e(c.error)}})}async function Sr(a){let t=`https://github.com/0-don/trashbin-plus/releases/download/ai-assets/${a}`,r=await fetch(t);if(!r.ok)throw Error(`Failed to download ${a}: ${r.status}`);return r.arrayBuffer()}async function Mg(){try{let a=`https://github.com/0-don/trashbin-plus/releases/download/ai-assets/${f0.VERSION}`,t=await fetch(a);if(!t.ok)return null;return(await t.json()).version??null}catch{return null}}function Ag(){return Spicetify.LocalStorage.get("trashbin-ai-assets-version")??null}function Tg(a){Spicetify.LocalStorage.set("trashbin-ai-assets-version",a)}async function Ar(a){try{let t=await Mg();if(!t)return console.error("[trashbin+ AI] Could not fetch remote version"),!1;let r=Ag(),l=await R5(f0.MODEL),i=await R5(f0.WASM);if(r===t&&l&&i)return a?.("Assets up to date"),!0;a?.("Downloading WASM runtime...");let e=await Sr(f0.WASM);await pr(f0.WASM,e,t),a?.("Downloading AI model...");let o=await Sr(f0.MODEL);return await pr(f0.MODEL,o,t),Tg(t),a?.("Assets ready"),!0}catch(t){return console.error("[trashbin+ AI] Failed to ensure assets:",t),!1}}/*!
 * ONNX Runtime Web v1.24.1
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var{defineProperty:n6,getOwnPropertyDescriptor:Eg,getOwnPropertyNames:Ig}=Object,mg=Object.prototype.hasOwnProperty,fg=((a)=>f4)(function(a){return f4.apply(this,arguments)}),y=(a,t)=>()=>(a&&(t=a(a=0)),t),I5=(a,t)=>{for(var r in t)n6(a,r,{get:t[r],enumerable:!0})},xg=(a,t,r,l)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of Ig(t))!mg.call(a,i)&&i!==r&&n6(a,i,{get:()=>t[i],enumerable:!(l=Eg(t,i))||l.enumerable});return a},X5=(a)=>xg(n6({},"__esModule",{value:!0}),a),w5,P0,M5,Tr,Ji,$i=y(()=>{w5=new Map,P0=[],M5=(a,t,r)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let l=w5.get(a);if(l===void 0)w5.set(a,{backend:t,priority:r});else{if(l.priority>r)return;if(l.priority===r&&l.backend!==t)throw Error(`cannot register backend "${a}" using priority ${r}`)}if(r>=0){let i=P0.indexOf(a);i!==-1&&P0.splice(i,1);for(let e=0;e<P0.length;e++)if(w5.get(P0[e]).priority<=r){P0.splice(e,0,a);return}P0.push(a)}return}throw TypeError("not a valid backend")},Tr=async(a)=>{let t=w5.get(a);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(a)),await t.initPromise,t.initialized=!0,t.backend}catch(l){return r||(t.error=`${l}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Ji=async(a)=>{let t=a.executionProviders||[],r=t.map((c)=>typeof c=="string"?c:c.name),l=r.length===0?P0:r,i,e=[],o=new Set;for(let c of l){let d=await Tr(c);typeof d=="string"?e.push({name:c,err:d}):(i||(i=d),i===d&&o.add(c))}if(!i)throw Error(`no available backend found. ERR: ${e.map((c)=>`[${c.name}] ${c.err}`).join(", ")}`);for(let{name:c,err:d}of e)r.includes(c)&&console.warn(`removing requested execution provider "${c}" from session options because it is not available: ${d}`);let n=t.filter((c)=>o.has(typeof c=="string"?c:c.name));return[i,new Proxy(a,{get:(c,d)=>d==="executionProviders"?n:Reflect.get(c,d)})]}}),Cg=y(()=>{$i()}),ae,_g=y(()=>{ae="1.24.1"}),Y4,P1,te=y(()=>{_g(),Y4="warning",P1={wasm:{},webgl:{},webgpu:{},versions:{common:ae},set logLevel(a){if(a!==void 0){if(typeof a!="string"||["verbose","info","warning","error","fatal"].indexOf(a)===-1)throw Error(`Unsupported logging level: ${a}`);Y4=a}},get logLevel(){return Y4}},Object.defineProperty(P1,"logLevel",{enumerable:!0})}),m1,Bg=y(()=>{te(),m1=P1}),re,le,zg=y(()=>{re=(a,t)=>{let r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=a.dims[3],r.height=a.dims[2];let l=r.getContext("2d");if(l!=null){let i,e;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(i=a.dims[2],e=a.dims[3]):(i=a.dims[3],e=a.dims[2]);let o=t?.format!==void 0?t.format:"RGB",n=t?.norm,c,d;n===void 0||n.mean===void 0?c=[255,255,255,255]:typeof n.mean=="number"?c=[n.mean,n.mean,n.mean,n.mean]:(c=[n.mean[0],n.mean[1],n.mean[2],0],n.mean[3]!==void 0&&(c[3]=n.mean[3])),n===void 0||n.bias===void 0?d=[0,0,0,0]:typeof n.bias=="number"?d=[n.bias,n.bias,n.bias,n.bias]:(d=[n.bias[0],n.bias[1],n.bias[2],0],n.bias[3]!==void 0&&(d[3]=n.bias[3]));let u=e*i,g=0,s=u,M=u*2,A=-1;o==="RGBA"?(g=0,s=u,M=u*2,A=u*3):o==="RGB"?(g=0,s=u,M=u*2):o==="RBG"&&(g=0,M=u,s=u*2);for(let E=0;E<e;E++)for(let x=0;x<i;x++){let m=(a.data[g++]-d[0])*c[0],T=(a.data[s++]-d[1])*c[1],_=(a.data[M++]-d[2])*c[2],C=A===-1?255:(a.data[A++]-d[3])*c[3];l.fillStyle="rgba("+m+","+T+","+_+","+C+")",l.fillRect(x,E,1,1)}if("toDataURL"in r)return r.toDataURL();throw Error("toDataURL is not supported")}else throw Error("Can not access image data")},le=(a,t)=>{let r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),l;if(r!=null){let i,e,o;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(i=a.dims[2],e=a.dims[1],o=a.dims[3]):(i=a.dims[3],e=a.dims[2],o=a.dims[1]);let n=t!==void 0&&t.format!==void 0?t.format:"RGB",c=t?.norm,d,u;c===void 0||c.mean===void 0?d=[255,255,255,255]:typeof c.mean=="number"?d=[c.mean,c.mean,c.mean,c.mean]:(d=[c.mean[0],c.mean[1],c.mean[2],255],c.mean[3]!==void 0&&(d[3]=c.mean[3])),c===void 0||c.bias===void 0?u=[0,0,0,0]:typeof c.bias=="number"?u=[c.bias,c.bias,c.bias,c.bias]:(u=[c.bias[0],c.bias[1],c.bias[2],0],c.bias[3]!==void 0&&(u[3]=c.bias[3]));let g=e*i;if(t!==void 0&&(t.format!==void 0&&o===4&&t.format!=="RGBA"||o===3&&t.format!=="RGB"&&t.format!=="BGR"))throw Error("Tensor format doesn't match input tensor dims");let s=4,M=0,A=1,E=2,x=3,m=0,T=g,_=g*2,C=-1;n==="RGBA"?(m=0,T=g,_=g*2,C=g*3):n==="RGB"?(m=0,T=g,_=g*2):n==="RBG"&&(m=0,_=g,T=g*2),l=r.createImageData(i,e);for(let z=0;z<e*i;M+=s,A+=s,E+=s,x+=s,z++)l.data[M]=(a.data[m++]-u[0])*d[0],l.data[A]=(a.data[T++]-u[1])*d[1],l.data[E]=(a.data[_++]-u[2])*d[2],l.data[x]=C===-1?255:(a.data[C++]-u[3])*d[3]}else throw Error("Can not access image data");return l}}),B2,ie,ee,oe,ne,he,Lg=y(()=>{h6(),B2=(a,t)=>{if(a===void 0)throw Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw Error("NHWC Tensor layout is not supported yet");let{height:r,width:l}=t,i=t.norm??{mean:255,bias:0},e,o;typeof i.mean=="number"?e=[i.mean,i.mean,i.mean,i.mean]:e=[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],typeof i.bias=="number"?o=[i.bias,i.bias,i.bias,i.bias]:o=[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let n=t.format!==void 0?t.format:"RGBA",c=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",d=r*l,u=c==="RGBA"?new Float32Array(d*4):new Float32Array(d*3),g=4,s=0,M=1,A=2,E=3,x=0,m=d,T=d*2,_=-1;n==="RGB"&&(g=3,s=0,M=1,A=2,E=-1),c==="RGBA"?_=d*3:c==="RBG"?(x=0,T=d,m=d*2):c==="BGR"&&(T=0,m=d,x=d*2);for(let C=0;C<d;C++,s+=g,A+=g,M+=g,E+=g)u[x++]=(a[s]+o[0])/e[0],u[m++]=(a[M]+o[1])/e[1],u[T++]=(a[A]+o[2])/e[2],_!==-1&&E!==-1&&(u[_++]=(a[E]+o[3])/e[3]);return c==="RGBA"?new J1("float32",u,[1,4,r,l]):new J1("float32",u,[1,3,r,l])},ie=async(a,t)=>{let r=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,l=typeof ImageData<"u"&&a instanceof ImageData,i=typeof ImageBitmap<"u"&&a instanceof ImageBitmap,e=typeof a=="string",o,n=t??{},c=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw Error("Canvas is not supported")},d=(u)=>typeof HTMLCanvasElement<"u"&&u instanceof HTMLCanvasElement||u instanceof OffscreenCanvas?u.getContext("2d"):null;if(r){let u=c();u.width=a.width,u.height=a.height;let g=d(u);if(g!=null){let{height:s,width:M}=a;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(s=t.resizedHeight,M=t.resizedWidth),t!==void 0){if(n=t,t.tensorFormat!==void 0)throw Error("Image input config format must be RGBA for HTMLImageElement");n.tensorFormat="RGBA",n.height=s,n.width=M}else n.tensorFormat="RGBA",n.height=s,n.width=M;g.drawImage(a,0,0),o=g.getImageData(0,0,M,s).data}else throw Error("Can not access image data")}else if(l){let u,g;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(u=t.resizedHeight,g=t.resizedWidth):(u=a.height,g=a.width),t!==void 0&&(n=t),n.format="RGBA",n.height=u,n.width=g,t!==void 0){let s=c();s.width=g,s.height=u;let M=d(s);if(M!=null)M.putImageData(a,0,0),o=M.getImageData(0,0,g,u).data;else throw Error("Can not access image data")}else o=a.data}else if(i){if(t===void 0)throw Error("Please provide image config with format for Imagebitmap");let u=c();u.width=a.width,u.height=a.height;let g=d(u);if(g!=null){let{height:s,width:M}=a;return g.drawImage(a,0,0,M,s),o=g.getImageData(0,0,M,s).data,n.height=s,n.width=M,B2(o,n)}else throw Error("Can not access image data")}else{if(e)return new Promise((u,g)=>{let s=c(),M=d(s);if(!a||!M)return g();let A=new Image;A.crossOrigin="Anonymous",A.src=a,A.onload=()=>{s.width=A.width,s.height=A.height,M.drawImage(A,0,0,s.width,s.height);let E=M.getImageData(0,0,s.width,s.height);n.height=s.height,n.width=s.width,u(B2(E.data,n))}});throw Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return B2(o,n);throw Error("Input data provided is not supported - aborted tensor creation")},ee=(a,t)=>{let{width:r,height:l,download:i,dispose:e}=t;return new J1({location:"texture",type:"float32",texture:a,dims:[1,l,r,4],download:i,dispose:e})},oe=(a,t)=>{let{dataType:r,dims:l,download:i,dispose:e}=t;return new J1({location:"gpu-buffer",type:r??"float32",gpuBuffer:a,dims:l,download:i,dispose:e})},ne=(a,t)=>{let{dataType:r,dims:l,download:i,dispose:e}=t;return new J1({location:"ml-tensor",type:r??"float32",mlTensor:a,dims:l,download:i,dispose:e})},he=(a,t,r)=>new J1({location:"cpu-pinned",type:a,data:t,dims:r??[t.length]})}),$0,K5,Q4,ce,Hg=y(()=>{$0=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),K5=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Q4=!1,ce=()=>{if(!Q4){Q4=!0;let a=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,r=globalThis.Float16Array,l=typeof r<"u"&&r.from;a&&($0.set("int64",BigInt64Array),K5.set(BigInt64Array,"int64")),t&&($0.set("uint64",BigUint64Array),K5.set(BigUint64Array,"uint64")),l?($0.set("float16",r),K5.set(r,"float16")):$0.set("float16",Uint16Array)}}}),de,ve,Vg=y(()=>{h6(),de=(a)=>{let t=1;for(let r=0;r<a.length;r++){let l=a[r];if(typeof l!="number"||!Number.isSafeInteger(l))throw TypeError(`dims[${r}] must be an integer, got: ${l}`);if(l<0)throw RangeError(`dims[${r}] must be a non-negative integer, got: ${l}`);t*=l}return t},ve=(a,t)=>{switch(a.location){case"cpu":return new J1(a.type,a.data,t);case"cpu-pinned":return new J1({location:"cpu-pinned",data:a.data,type:a.type,dims:t});case"texture":return new J1({location:"texture",texture:a.texture,type:a.type,dims:t});case"gpu-buffer":return new J1({location:"gpu-buffer",gpuBuffer:a.gpuBuffer,type:a.type,dims:t});case"ml-tensor":return new J1({location:"ml-tensor",mlTensor:a.mlTensor,type:a.type,dims:t});default:throw Error(`tensorReshape: tensor location ${a.location} is not supported`)}}}),J1,h6=y(()=>{zg(),Lg(),Hg(),Vg(),J1=class{constructor(a,t,r){ce();let l,i;if(typeof a=="object"&&"location"in a)switch(this.dataLocation=a.location,l=a.type,i=a.dims,a.location){case"cpu-pinned":{let o=$0.get(l);if(!o)throw TypeError(`unsupported type "${l}" to create tensor from pinned buffer`);if(!(a.data instanceof o))throw TypeError(`buffer should be of type ${o.name}`);this.cpuData=a.data;break}case"texture":{if(l!=="float32")throw TypeError(`unsupported type "${l}" to create tensor from texture`);this.gpuTextureData=a.texture,this.downloader=a.download,this.disposer=a.dispose;break}case"gpu-buffer":{if(l!=="float32"&&l!=="float16"&&l!=="int32"&&l!=="int64"&&l!=="uint32"&&l!=="uint8"&&l!=="bool"&&l!=="uint4"&&l!=="int4")throw TypeError(`unsupported type "${l}" to create tensor from gpu buffer`);this.gpuBufferData=a.gpuBuffer,this.downloader=a.download,this.disposer=a.dispose;break}case"ml-tensor":{if(l!=="float32"&&l!=="float16"&&l!=="int32"&&l!=="int64"&&l!=="uint32"&&l!=="uint64"&&l!=="int8"&&l!=="uint8"&&l!=="bool"&&l!=="uint4"&&l!=="int4")throw TypeError(`unsupported type "${l}" to create tensor from MLTensor`);this.mlTensorData=a.mlTensor,this.downloader=a.download,this.disposer=a.dispose;break}default:throw Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,n;if(typeof a=="string")if(l=a,n=r,a==="string"){if(!Array.isArray(t))throw TypeError("A string tensor's data must be a string array.");o=t}else{let c=$0.get(a);if(c===void 0)throw TypeError(`Unsupported tensor type: ${a}.`);if(Array.isArray(t)){if(a==="float16"&&c===Uint16Array||a==="uint4"||a==="int4")throw TypeError(`Creating a ${a} tensor from number array is not supported. Please use ${c.name} as data.`);a==="uint64"||a==="int64"?o=c.from(t,BigInt):o=c.from(t)}else if(t instanceof c)o=t;else if(t instanceof Uint8ClampedArray)if(a==="uint8")o=Uint8Array.from(t);else throw TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(a==="float16"&&t instanceof Uint16Array&&c!==Uint16Array)o=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw TypeError(`A ${l} tensor's data must be type of ${c}`)}else if(n=t,Array.isArray(a)){if(a.length===0)throw TypeError("Tensor type cannot be inferred from an empty array.");let c=typeof a[0];if(c==="string")l="string",o=a;else if(c==="boolean")l="bool",o=Uint8Array.from(a);else throw TypeError(`Invalid element type of data array: ${c}.`)}else if(a instanceof Uint8ClampedArray)l="uint8",o=Uint8Array.from(a);else{let c=K5.get(a.constructor);if(c===void 0)throw TypeError(`Unsupported type for tensor data: ${a.constructor}.`);l=c,o=a}if(n===void 0)n=[o.length];else if(!Array.isArray(n))throw TypeError("A tensor's dims must be a number array");i=n,this.cpuData=o,this.dataLocation="cpu"}let e=de(i);if(this.cpuData&&e!==this.cpuData.length&&!((l==="uint4"||l==="int4")&&Math.ceil(e/2)===this.cpuData.length))throw Error(`Tensor's size(${e}) does not match data length(${this.cpuData.length}).`);this.type=l,this.dims=i,this.size=e}static async fromImage(a,t){return ie(a,t)}static fromTexture(a,t){return ee(a,t)}static fromGpuBuffer(a,t){return oe(a,t)}static fromMLTensor(a,t){return ne(a,t)}static fromPinnedBuffer(a,t,r){return he(a,t,r)}toDataURL(a){return re(this,a)}toImageData(a){return le(this,a)}get data(){if(this.ensureValid(),!this.cpuData)throw Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(a){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,a&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw Error("The tensor is disposed.")}reshape(a){if(this.ensureValid(),this.downloader||this.disposer)throw Error("Cannot reshape a tensor that owns GPU resource.");return ve(this,a)}}}),u0,ue=y(()=>{h6(),u0=J1}),Z2,X4,C0,g0,r5,l5,ge=y(()=>{te(),Z2=(a,t)=>{(typeof P1.trace>"u"?!P1.wasm.trace:!P1.trace)||console.timeStamp(`${a}::ORT::${t}`)},X4=(a,t)=>{let r=Error().stack?.split(/\r\n|\r|\n/g)||[],l=!1;for(let i=0;i<r.length;i++){if(l&&!r[i].includes("TRACE_FUNC")){let e=`FUNC_${a}::${r[i].trim().split(" ")[1]}`;t&&(e+=`::${t}`),Z2("CPU",e);return}r[i].includes("TRACE_FUNC")&&(l=!0)}},C0=(a)=>{(typeof P1.trace>"u"?!P1.wasm.trace:!P1.trace)||X4("BEGIN",a)},g0=(a)=>{(typeof P1.trace>"u"?!P1.wasm.trace:!P1.trace)||X4("END",a)},r5=(a)=>{(typeof P1.trace>"u"?!P1.wasm.trace:!P1.trace)||console.time(`ORT::${a}`)},l5=(a)=>{(typeof P1.trace>"u"?!P1.wasm.trace:!P1.trace)||console.timeEnd(`ORT::${a}`)}}),se,kg=y(()=>{$i(),ue(),ge(),se=class a{constructor(t){this.handler=t}async run(t,r,l){C0(),r5("InferenceSession.run");let i={},e={};if(typeof t!="object"||t===null||t instanceof u0||Array.isArray(t))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof r=="object"){if(r===null)throw TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof u0)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw TypeError("'fetches' cannot be an empty array.");o=!1;for(let d of r){if(typeof d!="string")throw TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(d)===-1)throw RangeError(`'fetches' contains invalid output name: ${d}.`);i[d]=null}if(typeof l=="object"&&l!==null)e=l;else if(typeof l<"u")throw TypeError("'options' must be an object.")}else{let d=!1,u=Object.getOwnPropertyNames(r);for(let g of this.outputNames)if(u.indexOf(g)!==-1){let s=r[g];(s===null||s instanceof u0)&&(d=!0,o=!1,i[g]=s)}if(d){if(typeof l=="object"&&l!==null)e=l;else if(typeof l<"u")throw TypeError("'options' must be an object.")}else e=r}}else if(typeof r<"u")throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let d of this.inputNames)if(typeof t[d]>"u")throw Error(`input '${d}' is missing in 'feeds'.`);if(o)for(let d of this.outputNames)i[d]=null;let n=await this.handler.run(t,i,e),c={};for(let d in n)if(Object.hasOwnProperty.call(n,d)){let u=n[d];u instanceof u0?c[d]=u:c[d]=new u0(u.type,u.data,u.dims)}return l5("InferenceSession.run"),g0(),c}async release(){return this.handler.dispose()}static async create(t,r,l,i){C0(),r5("InferenceSession.create");let e,o={};if(typeof t=="string"){if(e=t,typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(e=t,typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let u=t,g=0,s=t.byteLength;if(typeof r=="object"&&r!==null)o=r;else if(typeof r=="number"){if(g=r,!Number.isSafeInteger(g))throw RangeError("'byteOffset' must be an integer.");if(g<0||g>=u.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${u.byteLength}).`);if(s=t.byteLength-g,typeof l=="number"){if(s=l,!Number.isSafeInteger(s))throw RangeError("'byteLength' must be an integer.");if(s<=0||g+s>u.byteLength)throw RangeError(`'byteLength' is out of range (0, ${u.byteLength-g}].`);if(typeof i=="object"&&i!==null)o=i;else if(typeof i<"u")throw TypeError("'options' must be an object.")}else if(typeof l<"u")throw TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw TypeError("'options' must be an object.");e=new Uint8Array(u,g,s)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[n,c]=await Ji(o),d=await n.createInferenceSessionHandler(e,c);return l5("InferenceSession.create"),g0(),new a(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),Y2,Ng=y(()=>{kg(),Y2=se}),Og=y(()=>{}),Rg=y(()=>{}),wg=y(()=>{}),Dg=y(()=>{}),Gg={};I5(Gg,{InferenceSession:()=>Y2,TRACE:()=>Z2,TRACE_EVENT_BEGIN:()=>r5,TRACE_EVENT_END:()=>l5,TRACE_FUNC_BEGIN:()=>C0,TRACE_FUNC_END:()=>g0,Tensor:()=>u0,env:()=>m1,registerBackend:()=>M5});var l0=y(()=>{Cg(),Bg(),Ng(),ue(),Og(),Rg(),ge(),wg(),Dg()}),c6=y(()=>{}),pe={};I5(pe,{default:()=>Se});var J4,$4,Se,Pg=y(()=>{mh(),n5(),d6(),J4="ort-wasm-proxy-worker",$4=globalThis.self?.name===J4,$4&&(self.onmessage=(a)=>{let{type:t,in:r}=a.data;try{switch(t){case"init-wasm":v6(r.wasm).then(()=>{z6(r).then(()=>{postMessage({type:t})},(l)=>{postMessage({type:t,err:l})})},(l)=>{postMessage({type:t,err:l})});break;case"init-ep":{let{epName:l,env:i}=r;L6(i,l).then(()=>{postMessage({type:t})},(e)=>{postMessage({type:t,err:e})});break}case"copy-from":{let{buffer:l}=r,i=q2(l);postMessage({type:t,out:i});break}case"create":{let{model:l,options:i}=r;H6(l,i).then((e)=>{postMessage({type:t,out:e})},(e)=>{postMessage({type:t,err:e})});break}case"release":V6(r),postMessage({type:t});break;case"run":{let{sessionId:l,inputIndices:i,inputs:e,outputIndices:o,options:n}=r;k6(l,i,e,o,Array(o.length).fill(null),n).then((c)=>{c.some((d)=>d[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:c},O6([...e,...c]))},(c)=>{postMessage({type:t,err:c})});break}case"end-profiling":N6(r),postMessage({type:t});break;default:}}catch(l){postMessage({type:t,err:l})}}),Se=$4?null:(a)=>new Worker(a??X1,{type:"module",name:J4})}),Me={};I5(Me,{default:()=>Ae});async function Er(a={}){var t=a,r=!!globalThis.window,l=!!globalThis.WorkerGlobalScope,i=l&&self.name?.startsWith("em-pthread");t.mountExternalData=(h,v)=>{h.startsWith("./")&&(h=h.substring(2)),(t.Zc||(t.Zc=new Map)).set(h,v)},t.unmountExternalData=()=>{delete t.Zc},globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,ae:!0}).buffer.constructor;let e=(h)=>async(...v)=>{try{if(t.$c)throw Error("Session already started");let S=t.$c={Nd:v[0],errors:[]},p=await h(...v);if(t.$c!==S)throw Error("Session mismatch");t.gd?.flush();let f=S.errors;if(0<f.length){let B=await Promise.all(f);if(B=B.filter((k)=>k),0<B.length)throw Error(B.join(`
`))}return p}finally{t.$c=null}};t.jsepInit=(h,v)=>{if(h==="webgpu"){[t.gd,t.Dd,t.Hd,t.jd,t.Gd,t.ac,t.Id,t.Kd,t.Ed,t.Fd,t.Jd]=v;let S=t.gd;t.jsepRegisterBuffer=(p,f,B,k)=>S.registerBuffer(p,f,B,k),t.jsepGetBuffer=(p)=>S.getBuffer(p),t.jsepCreateDownloader=(p,f,B)=>S.createDownloader(p,f,B),t.jsepOnCreateSession=(p)=>{S.onCreateSession(p)},t.jsepOnReleaseSession=(p)=>{S.onReleaseSession(p)},t.jsepOnRunStart=(p)=>S.onRunStart(p),t.Ld=(p,f)=>{S.upload(p,f)}}else if(h==="webnn"){let S=v[0];[t.Zd,t.vd,t.webnnEnsureTensor,t.xd,t.webnnDownloadTensor,t.Yd,t.webnnEnableTraceEvent]=v.slice(1),t.webnnReleaseTensorId=t.vd,t.webnnUploadTensor=t.xd,t.webnnRegisterMLContext=t.Yd,t.webnnOnRunStart=(p)=>S.onRunStart(p),t.webnnOnRunEnd=S.onRunEnd.bind(S),t.webnnOnReleaseSession=(p)=>{S.onReleaseSession(p)},t.webnnCreateMLTensorDownloader=(p,f)=>S.createMLTensorDownloader(p,f),t.webnnRegisterMLTensor=(p,f,B,k)=>S.registerMLTensor(p,f,B,k),t.webnnCreateMLContext=(p)=>S.createMLContext(p),t.webnnRegisterMLConstant=(p,f,B,k,R,U)=>S.registerMLConstant(p,f,B,k,R,t.Zc,U),t.webnnRegisterGraphInput=S.registerGraphInput.bind(S),t.webnnIsGraphInput=S.isGraphInput.bind(S),t.webnnRegisterGraphOutput=S.registerGraphOutput.bind(S),t.webnnIsGraphOutput=S.isGraphOutput.bind(S),t.webnnCreateTemporaryTensor=S.createTemporaryTensor.bind(S),t.webnnIsGraphInputOutputTypeSupported=S.isGraphInputOutputTypeSupported.bind(S)}};let o=()=>{let h=(v)=>(...S)=>{let p=S0;return S=v(...S),S0!=p?new Promise((f,B)=>{d4={resolve:f,reject:B}}):S};(()=>{for(let v of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])t[v]=h(t[v])})(),e!==void 0&&(t._OrtRun=e(t._OrtRun),t._OrtRunWithBinding=e(t._OrtRunWithBinding)),o=void 0};t.asyncInit=()=>{o?.()};var n,c,d=(h,v)=>{throw v},u="https://localhost",g="";if(r||l){try{g=new URL(".",u).href}catch{}l&&(c=(h)=>{var v=new XMLHttpRequest;return v.open("GET",h,!1),v.responseType="arraybuffer",v.send(null),new Uint8Array(v.response)}),n=async(h)=>{if(H(h))return new Promise((S,p)=>{var f=new XMLHttpRequest;f.open("GET",h,!0),f.responseType="arraybuffer",f.onload=()=>{f.status==200||f.status==0&&f.response?S(f.response):p(f.status)},f.onerror=p,f.send(null)});var v=await fetch(h,{credentials:"same-origin"});if(v.ok)return v.arrayBuffer();throw Error(v.status+" : "+v.url)}}var s,M,A,E,x,m,T=console.log.bind(console),_=console.error.bind(console),C=T,z=_,L=!1,H=(h)=>h.startsWith("file://");function I(){N0.buffer!=b.buffer&&t1()}if(i){let h=function(v){try{var S=v.data,p=S.Uc;if(p==="load"){let f=[];self.onmessage=(B)=>f.push(B),m=()=>{postMessage({Uc:"loaded"});for(let B of f)h(B);self.onmessage=h};for(let B of S.Ad)t[B]&&!t[B].proxy||(t[B]=(...k)=>{postMessage({Uc:"callHandler",zd:B,args:k})},B=="print"&&(C=t[B]),B=="printErr"&&(z=t[B]));N0=S.Vd,t1(),M=S.Wd,i0(),g2()}else if(p==="run"){(function(f){var B=(I(),F)[f+52>>>2>>>0];f=(I(),F)[f+56>>>2>>>0],Pa(B,B-f),d1(B)})(S.Tc),p4(S.Tc,0,0,1,0,0),F6(),n4(S.Tc),P||(Na(),P=!0);try{qh(S.Pd,S.dd)}catch(f){if(f!="unwind")throw f}}else S.target!=="setimmediate"&&(p==="checkMailbox"?P&&o2():p&&(z(`worker: received unknown command ${p}`),z(S)))}catch(f){throw Oa(),f}};var N=h,P=!1;self.onunhandledrejection=(v)=>{throw v.reason||v},self.onmessage=h}var b,G,j,e1,V,F,a1,$,Y,i1,D,W=!1;function t1(){var h=N0.buffer;t.HEAP8=b=new Int8Array(h),j=new Int16Array(h),t.HEAPU8=G=new Uint8Array(h),e1=new Uint16Array(h),t.HEAP32=V=new Int32Array(h),t.HEAPU32=F=new Uint32Array(h),a1=new Float32Array(h),$=new Float64Array(h),Y=new BigInt64Array(h),i1=new BigUint64Array(h)}function s1(){W=!0,i?m():B0.tb()}function R1(h){throw z(h="Aborted("+h+")"),L=!0,h=new WebAssembly.RuntimeError(h+". Build with -sASSERTIONS for more info."),x?.(h),h}function q1(){return{a:{ma:Td,hb:Ad,g:Yh,J:Qh,f:Xh,o:Jh,h:$h,ha:ac,b:tc,T:rc,Ia:W6,n:lc,_:Q6,Ya:X6,Ea:J6,Ga:$6,Za:aa,Wa:ta,Pa:ra,Va:la,ka:ia,Fa:ea,Ca:oa,Xa:na,Da:ha,cb:ic,ea:oc,xa:nc,va:cc,da:vc,O:uc,H:gc,wa:sc,Z:Ic,ya:mc,Sa:fc,Aa:Cc,Ja:_c,ta:Bc,fa:zc,Ra:n4,$a:Lc,R:Nc,s:Gc,c:e4,ib:Pc,y:Fc,M:Zc,D:yc,m:bc,t:Sa,jb:jc,I:Uc,S:Wc,j:Kc,v:qc,r:Yc,l:Qc,Ma:Xc,Na:Jc,Oa:$c,Ka:Ea,La:Ia,ua:ma,eb:td,bb:id,u:ed,aa:od,ga:nd,ab:rd,V:hd,_a:cd,Ba:dd,F:ad,U:vd,la:v2,za:gd,gb:ud,fb:sd,Ta:_a,Ua:Ba,Ha:t4,$:za,ja:La,Qa:Ha,ia:Va,lb:rv,na:Yd,mb:tv,oa:qd,G:Pd,d:fd,q:Id,w:Ed,B:Nd,pb:Ud,K:wd,x:Cd,pa:Wd,X:Qd,ba:jd,nb:av,ob:$d,ra:Fd,qa:bd,qb:Zd,N:Dd,Y:Kd,e:xd,A:_d,k:md,kb:lv,p:zd,z:Ld,C:Bd,E:Hd,L:Od,rb:Gd,Q:Xd,ca:Rd,W:Jd,sb:kd,sa:Vd,P:yd,i:Sd,a:N0,db:a4}}}async function i0(){function h(p,f){var B=B0=p.exports;p={};for(let[k,R]of Object.entries(B))typeof R=="function"?(B=Hc(R),p[k]=B):p[k]=R;return B0=p,B0=function(){var k=B0,R=(q)=>(c1)=>q(c1)>>>0,U=(q)=>()=>q()>>>0;return(k=Object.assign({},k)).ub=R(k.ub),k.Yb=U(k.Yb),k._b=R(k._b),k.mc=R(k.mc),k.nc=U(k.nc),k.rc=R(k.rc),k}(),G6.push(B0.$b),ka=(p=B0).ub,Na=p.vb,t._OrtInit=p.wb,t._OrtGetLastError=p.xb,t._OrtCreateSessionOptions=p.yb,t._OrtAppendExecutionProvider=p.zb,t._OrtAddFreeDimensionOverride=p.Ab,t._OrtAddSessionConfigEntry=p.Bb,t._OrtReleaseSessionOptions=p.Cb,t._OrtCreateSession=p.Db,t._OrtReleaseSession=p.Eb,t._OrtGetInputOutputCount=p.Fb,t._OrtGetInputOutputMetadata=p.Gb,t._OrtFree=p.Hb,t._OrtCreateTensor=p.Ib,t._OrtGetTensorData=p.Jb,t._OrtReleaseTensor=p.Kb,t._OrtCreateRunOptions=p.Lb,t._OrtAddRunConfigEntry=p.Mb,t._OrtReleaseRunOptions=p.Nb,t._OrtCreateBinding=p.Ob,t._OrtBindInput=p.Pb,t._OrtBindOutput=p.Qb,t._OrtClearBoundOutputs=p.Rb,t._OrtReleaseBinding=p.Sb,t._OrtRunWithBinding=p.Tb,t._OrtRun=p.Ub,t._OrtEndProfiling=p.Vb,t._JsepOutput=p.Wb,t._JsepGetNodeName=p.Xb,u2=p.Yb,M0=t._free=p.Zb,C5=t._malloc=p._b,p4=p.bc,Oa=p.cc,Ra=p.dc,wa=p.ec,S4=p.fc,Da=p.gc,Ga=p.hc,u1=p.ic,_5=p.jc,Pa=p.kc,d1=p.lc,M4=p.mc,v1=p.nc,Fa=p.oc,A4=p.pc,Za=p.qc,ya=p.rc,ba=p.sc,T4=p.tc,ja=p.uc,Ua=p.vc,Wa=p.wc,Ka=p.xc,qa=p.yc,Ya=p.zc,Qa=p.Ac,Xa=p.Bc,Ja=p.Cc,$a=p.Dc,a7=p.Ec,t7=p.Fc,r7=p.Gc,l7=p.Hc,i7=p.Ic,e7=p.Jc,o7=p.Kc,n7=p.Lc,h7=p.Mc,c7=p.Nc,d7=p.Oc,v7=p.Pc,u7=p.Rc,g7=p.Sc,s7=p.bd,p7=p.cd,S7=p.hd,M7=p.kd,A7=p.ld,T7=p.md,E7=p.nd,I7=p.od,m7=p.pd,f7=p.qd,x7=p.rd,C7=p.wd,_7=p.Rd,B7=p.Sd,z7=p.Td,L7=p.Ud,M=f,B0}var v,S=q1();return t.instantiateWasm?new Promise((p)=>{t.instantiateWasm(S,(f,B)=>{p(h(f,B))})}):i?h(new WebAssembly.Instance(M,q1()),M):(D??=t.locateFile?t.locateFile?t.locateFile("ort-wasm-simd-threaded.jsep.wasm",g):g+"ort-wasm-simd-threaded.jsep.wasm":new URL("ort-wasm-simd-threaded.jsep.wasm","https://localhost").href,v=await async function(p){var f=D;if(!s&&!H(f))try{var B=fetch(f,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(B,p)}catch(k){z(`wasm streaming compile failed: ${k}`),z("falling back to ArrayBuffer instantiation")}return async function(k,R){try{var U=await async function(q){if(!s)try{var c1=await n(q);return new Uint8Array(c1)}catch{}if(q==D&&s)q=new Uint8Array(s);else{if(!c)throw"both async and sync fetching of the wasm failed";q=c(q)}return q}(k);return await WebAssembly.instantiate(U,R)}catch(q){z(`failed to asynchronously prepare wasm: ${q}`),R1(q)}}(f,p)}(S),h(v.instance,v.module))}class s0{name="ExitStatus";constructor(h){this.message=`Program terminated with exit(${h})`,this.status=h}}var k1=(h)=>{h.terminate(),h.onmessage=()=>{}},L1=[],U1=0,j0=null,a2=(h)=>{k0.length==0&&(y6(),Z6(k0[0]));var v=k0.pop();if(!v)return 6;f5.push(v),U0[h.Tc]=v,v.Tc=h.Tc;var S={Uc:"run",Pd:h.Od,dd:h.dd,Tc:h.Tc};return v.postMessage(S,h.ud),0},V0=0,z1=(h,v,...S)=>{var p,f=16*S.length,B=v1(),k=M4(f),R=k>>>3;for(p of S)typeof p=="bigint"?((I(),Y)[R++>>>0]=1n,(I(),Y)[R++>>>0]=p):((I(),Y)[R++>>>0]=0n,(I(),$)[R++>>>0]=p);return h=Ra(h,0,f,k,v),d1(B),h};function a4(h){if(i)return z1(0,1,h);if(A=h,!(0<V0)){for(var v of f5)k1(v);for(v of k0)k1(v);k0=[],f5=[],U0={},L=!0}d(0,new s0(h))}function D6(h){if(i)return z1(1,0,h);t4(h)}var t4=(h)=>{if(A=h,i)throw D6(h),"unwind";a4(h)},k0=[],f5=[],G6=[],U0={},P6=(h)=>{var v=h.Tc;delete U0[v],k0.push(h),f5.splice(f5.indexOf(h),1),h.Tc=0,wa(v)};function F6(){G6.forEach((h)=>h())}var Z6=(h)=>new Promise((v)=>{h.onmessage=(f)=>{var B=f.data;if(f=B.Uc,B.ad&&B.ad!=u2()){var k=U0[B.ad];k?k.postMessage(B,B.ud):z(`Internal error! Worker sent a message "${f}" to target pthread ${B.ad}, but that thread no longer exists!`)}else f==="checkMailbox"?o2():f==="spawnThread"?a2(B):f==="cleanupThread"?e2(()=>{P6(U0[B.Qd])}):f==="loaded"?(h.loaded=!0,v(h)):B.target==="setimmediate"?h.postMessage(B):f==="uncaughtException"?h.onerror(B.error):f==="callHandler"?t[B.zd](...B.args):f&&z(`worker sent an unknown command ${f}`)},h.onerror=(f)=>{throw z(`worker sent an error! ${f.filename}:${f.lineno}: ${f.message}`),f};var S,p=[];for(S of[])t.propertyIsEnumerable(S)&&p.push(S);h.postMessage({Uc:"load",Ad:p,Vd:N0,Wd:M})});function y6(){var h=new Worker((()=>{let v=URL;return new URL("https://localhost")})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});k0.push(h)}var N0,qh=(h,v)=>{V0=0,h=T4(h,v),0<V0?A=h:S4(h)},t2=[],r2=0;function Yh(h){var v=new l2(h>>>=0);return(I(),b)[v.Vc+12>>>0]==0&&(b6(v,!0),r2--),j6(v,!1),t2.push(v),ya(h)}var c5=0,Qh=()=>{u1(0,0);var h=t2.pop();Fa(h.ed),c5=0};function b6(h,v){v=v?1:0,(I(),b)[h.Vc+12>>>0]=v}function j6(h,v){v=v?1:0,(I(),b)[h.Vc+13>>>0]=v}class l2{constructor(h){this.ed=h,this.Vc=h-24}}var r4=(h)=>{var v=c5;if(!v)return _5(0),0;var S=new l2(v);(I(),F)[S.Vc+16>>>2>>>0]=v;var p=(I(),F)[S.Vc+4>>>2>>>0];if(!p)return _5(0),v;for(var f of h){if(f===0||f===p)break;if(Za(f,p,S.Vc+16))return _5(f),v}return _5(p),v};function Xh(){return r4([])}function Jh(h){return r4([h>>>0])}function $h(h,v,S,p){return r4([h>>>0,v>>>0,S>>>0,p>>>0])}var ac=()=>{var h=t2.pop();h||R1("no exception to throw");var v=h.ed;throw(I(),b)[h.Vc+13>>>0]==0&&(t2.push(h),j6(h,!0),b6(h,!1),r2++),A4(v),c5=v};function tc(h,v,S){var p=new l2(h>>>=0);throw v>>>=0,S>>>=0,(I(),F)[p.Vc+16>>>2>>>0]=0,(I(),F)[p.Vc+4>>>2>>>0]=v,(I(),F)[p.Vc+8>>>2>>>0]=S,A4(h),r2++,c5=h}var rc=()=>r2;function U6(h,v,S,p){return i?z1(2,1,h,v,S,p):W6(h,v,S,p)}function W6(h,v,S,p){if(h>>>=0,v>>>=0,S>>>=0,p>>>=0,!globalThis.SharedArrayBuffer)return 6;var f=[];return i&&f.length===0?U6(h,v,S,p):(h={Od:S,Tc:h,dd:p,ud:f},i?(h.Uc="spawnThread",postMessage(h,f),0):a2(h))}function lc(h){throw c5||=h>>>0,c5}var K6=globalThis.TextDecoder&&new TextDecoder,q6=(h,v,S,p)=>{if(S=v+S,p)return S;for(;h[v]&&!(v>=S);)++v;return v},Y6=(h,v=0,S,p)=>{if(16<(S=q6(h,v>>>=0,S,p))-v&&h.buffer&&K6)return K6.decode(h.buffer instanceof ArrayBuffer?h.subarray(v,S):h.slice(v,S));for(p="";v<S;){var f=h[v++];if(128&f){var B=63&h[v++];if((224&f)==192)p+=String.fromCharCode((31&f)<<6|B);else{var k=63&h[v++];65536>(f=(240&f)==224?(15&f)<<12|B<<6|k:(7&f)<<18|B<<12|k<<6|63&h[v++])?p+=String.fromCharCode(f):(f-=65536,p+=String.fromCharCode(55296|f>>10,56320|1023&f))}}else p+=String.fromCharCode(f)}return p},N1=(h,v,S)=>(h>>>=0)?Y6((I(),G),h,v,S):"";function Q6(h,v,S){return i?z1(3,1,h,v,S):0}function X6(h,v){if(i)return z1(4,1,h,v)}function J6(h,v){if(i)return z1(5,1,h,v)}function $6(h,v,S){if(i)return z1(6,1,h,v,S)}function aa(h,v,S){return i?z1(7,1,h,v,S):0}function ta(h,v){if(i)return z1(8,1,h,v)}function ra(h,v,S){if(i)return z1(9,1,h,v,S)}function la(h,v,S,p){if(i)return z1(10,1,h,v,S,p)}function ia(h,v,S,p){if(i)return z1(11,1,h,v,S,p)}function ea(h,v,S,p){if(i)return z1(12,1,h,v,S,p)}function oa(h){if(i)return z1(13,1,h)}function na(h,v){if(i)return z1(14,1,h,v)}function ha(h,v,S){if(i)return z1(15,1,h,v,S)}var ic=()=>R1(""),p0=(h)=>{h>>>=0;for(var v="";;){var S=(I(),G)[h++>>>0];if(!S)return v;v+=String.fromCharCode(S)}},l4={},i4={},ec={},d5=class extends Error{constructor(h){super(h),this.name="BindingError"}};function _0(h,v,S={}){return function(p,f,B={}){var k=f.name;if(!p)throw new d5(`type "${k}" must have a positive integer typeid pointer`);if(i4.hasOwnProperty(p)){if(B.Bd)return;throw new d5(`Cannot register type '${k}' twice`)}i4[p]=f,delete ec[p],l4.hasOwnProperty(p)&&(f=l4[p],delete l4[p],f.forEach((R)=>R()))}(h,v,S)}var ca=(h,v,S)=>{switch(v){case 1:return S?(p)=>(I(),b)[p>>>0]:(p)=>(I(),G)[p>>>0];case 2:return S?(p)=>(I(),j)[p>>>1>>>0]:(p)=>(I(),e1)[p>>>1>>>0];case 4:return S?(p)=>(I(),V)[p>>>2>>>0]:(p)=>(I(),F)[p>>>2>>>0];case 8:return S?(p)=>(I(),Y)[p>>>3>>>0]:(p)=>(I(),i1)[p>>>3>>>0];default:throw TypeError(`invalid integer width (${v}): ${h}`)}};function oc(h,v,S,p,f){h>>>=0,S>>>=0,v=p0(v>>>0);let B=(k)=>k;if(p=p===0n){let k=8*S;B=(R)=>BigInt.asUintN(k,R),f=B(f)}_0(h,{name:v,Qc:B,Xc:(k,R)=>(typeof R=="number"&&(R=BigInt(R)),R),Wc:ca(v,S,!p),Yc:null})}function nc(h,v,S,p){_0(h>>>=0,{name:v=p0(v>>>0),Qc:function(f){return!!f},Xc:function(f,B){return B?S:p},Wc:function(f){return this.Qc((I(),G)[f>>>0])},Yc:null})}var da=[],W0=[0,1,,1,null,1,!0,1,!1,1];function e4(h){9<(h>>>=0)&&--W0[h+1]==0&&(W0[h]=void 0,da.push(h))}var a0=(h)=>{if(!h)throw new d5(`Cannot use deleted val. handle = ${h}`);return W0[h]},e0=(h)=>{switch(h){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let v=da.pop()||W0.length;return W0[v]=h,W0[v+1]=1,v}};function o4(h){return this.Qc((I(),F)[h>>>2>>>0])}var hc={name:"emscripten::val",Qc:(h)=>{var v=a0(h);return e4(h),v},Xc:(h,v)=>e0(v),Wc:o4,Yc:null};function cc(h){return _0(h>>>0,hc)}var dc=(h,v)=>{switch(v){case 4:return function(S){return this.Qc((I(),a1)[S>>>2>>>0])};case 8:return function(S){return this.Qc((I(),$)[S>>>3>>>0])};default:throw TypeError(`invalid float width (${v}): ${h}`)}};function vc(h,v,S){S>>>=0,_0(h>>>=0,{name:v=p0(v>>>0),Qc:(p)=>p,Xc:(p,f)=>f,Wc:dc(v,S),Yc:null})}function uc(h,v,S,p,f){h>>>=0,S>>>=0,v=p0(v>>>0);let B=(R)=>R;if(p===0){var k=32-8*S;B=(R)=>R<<k>>>k,f=B(f)}_0(h,{name:v,Qc:B,Xc:(R,U)=>U,Wc:ca(v,S,p!==0),Yc:null})}function gc(h,v,S){function p(B){var k=(I(),F)[B>>>2>>>0];return B=(I(),F)[B+4>>>2>>>0],new f((I(),b).buffer,B,k)}var f=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][v];_0(h>>>=0,{name:S=p0(S>>>0),Qc:p,Wc:p},{Bd:!0})}var O0=(h,v,S)=>{var p=(I(),G);if(v>>>=0,0<S){var f=v;S=v+S-1;for(var B=0;B<h.length;++B){var k=h.codePointAt(B);if(127>=k){if(v>=S)break;p[v++>>>0]=k}else if(2047>=k){if(v+1>=S)break;p[v++>>>0]=192|k>>6,p[v++>>>0]=128|63&k}else if(65535>=k){if(v+2>=S)break;p[v++>>>0]=224|k>>12,p[v++>>>0]=128|k>>6&63,p[v++>>>0]=128|63&k}else{if(v+3>=S)break;p[v++>>>0]=240|k>>18,p[v++>>>0]=128|k>>12&63,p[v++>>>0]=128|k>>6&63,p[v++>>>0]=128|63&k,B++}}p[v>>>0]=0,h=v-f}else h=0;return h},i2=(h)=>{for(var v=0,S=0;S<h.length;++S){var p=h.charCodeAt(S);127>=p?v++:2047>=p?v+=2:55296<=p&&57343>=p?(v+=4,++S):v+=3}return v};function sc(h,v){_0(h>>>=0,{name:v=p0(v>>>0),Qc(S){var p=(I(),F)[S>>>2>>>0];return p=N1(S+4,p,!0),M0(S),p},Xc(S,p){p instanceof ArrayBuffer&&(p=new Uint8Array(p));var f=typeof p=="string";if(!(f||ArrayBuffer.isView(p)&&p.BYTES_PER_ELEMENT==1))throw new d5("Cannot pass non-string to std::string");var B=f?i2(p):p.length,k=C5(4+B+1),R=k+4;return(I(),F)[k>>>2>>>0]=B,f?O0(p,R,B+1):(I(),G).set(p,R>>>0),S!==null&&S.push(M0,k),k},Wc:o4,Yc(S){M0(S)}})}var va=globalThis.TextDecoder?new TextDecoder("utf-16le"):void 0,pc=(h,v,S)=>{if(h>>>=1,16<(v=q6((I(),e1),h,v/2,S))-h&&va)return va.decode((I(),e1).slice(h,v));for(S="";h<v;++h){var p=(I(),e1)[h>>>0];S+=String.fromCharCode(p)}return S},Sc=(h,v,S)=>{if(S??=2147483647,2>S)return 0;var p=v;S=(S-=2)<2*h.length?S/2:h.length;for(var f=0;f<S;++f){var B=h.charCodeAt(f);(I(),j)[v>>>1>>>0]=B,v+=2}return(I(),j)[v>>>1>>>0]=0,v-p},Mc=(h)=>2*h.length,Ac=(h,v,S)=>{var p="";h>>>=2;for(var f=0;!(f>=v/4);f++){var B=(I(),F)[h+f>>>0];if(!B&&!S)break;p+=String.fromCodePoint(B)}return p},Tc=(h,v,S)=>{if(v>>>=0,S??=2147483647,4>S)return 0;var p=v;S=p+S-4;for(var f=0;f<h.length;++f){var B=h.codePointAt(f);if(65535<B&&f++,(I(),V)[v>>>2>>>0]=B,(v+=4)+4>S)break}return(I(),V)[v>>>2>>>0]=0,v-p},Ec=(h)=>{for(var v=0,S=0;S<h.length;++S)65535<h.codePointAt(S)&&S++,v+=4;return v};function Ic(h,v,S){if(h>>>=0,v>>>=0,S=p0(S>>>=0),v===2)var p=pc,f=Sc,B=Mc;else p=Ac,f=Tc,B=Ec;_0(h,{name:S,Qc:(k)=>{var R=(I(),F)[k>>>2>>>0];return R=p(k+4,R*v,!0),M0(k),R},Xc:(k,R)=>{if(typeof R!="string")throw new d5(`Cannot pass non-string to C++ string type ${S}`);var U=B(R),q=C5(4+U+v);return(I(),F)[q>>>2>>>0]=U/v,f(R,q+4,U+v),k!==null&&k.push(M0,q),q},Wc:o4,Yc(k){M0(k)}})}function mc(h,v){_0(h>>>=0,{Cd:!0,name:v=p0(v>>>0),Qc:()=>{},Xc:()=>{}})}function fc(h){p4(h>>>0,!l,1,!r,131072,!1),F6()}var e2=(h)=>{if(!L)try{if(h(),!(0<V0))try{i?u2()&&S4(A):t4(A)}catch(v){v instanceof s0||v=="unwind"||d(0,v)}}catch(v){v instanceof s0||v=="unwind"||d(0,v)}},xc=!Atomics.waitAsync||globalThis.navigator?.userAgent&&91>Number((navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)||[])[2]);function n4(h){h>>>=0,xc||(Atomics.waitAsync((I(),V),h>>>2,h).value.then(o2),h+=128,Atomics.store((I(),V),h>>>2,1))}var o2=()=>e2(()=>{var h=u2();h&&(n4(h),Ga())});function Cc(h,v){(h>>>=0)==v>>>0?setTimeout(o2):i?postMessage({ad:h,Uc:"checkMailbox"}):(h=U0[h])&&h.postMessage({Uc:"checkMailbox"})}var h4=[];function _c(h,v,S,p,f){for(v>>>=0,f>>>=0,h4.length=0,S=f>>>3,p=f+p>>>3;S<p;){var B;B=(I(),Y)[S++>>>0]?(I(),Y)[S++>>>0]:(I(),$)[S++>>>0],h4.push(B)}return(v?E4[v]:Md[h])(...h4)}var Bc=()=>{V0=0};function zc(h){h>>>=0,i?postMessage({Uc:"cleanupThread",Qd:h}):P6(U0[h])}function Lc(h){}var n2=(h)=>{try{h()}catch(v){R1(v)}};function Hc(h){var v=(...S)=>{h2.push(h);try{return h(...S)}finally{L||(h2.pop(),S0&&R0===1&&h2.length===0&&(R0=0,V0+=1,n2(B7),typeof Fibers<"u"&&Fibers.ce()))}};return sa.set(h,v),v}var R0=0,S0=null,ua=0,h2=[],c4=new Map,ga=new Map,sa=new Map,Vc=0,d4=null,kc=[],pa=(h)=>function(v){if(!L){if(R0===0){var S=!1,p=!1;v((f=0)=>{if(!L&&(ua=f,S=!0,p)){R0=2,n2(()=>z7(S0)),typeof MainLoop<"u"&&MainLoop.yd&&MainLoop.resume(),f=!1;try{var B=function(){var U=(I(),V)[S0+8>>>2>>>0];return U=ga.get(U),U=sa.get(U),--V0,U()}()}catch(U){B=U,f=!0}var k=!1;if(!S0){var R=d4;R&&(d4=null,(f?R.reject:R.resolve)(B),k=!0)}if(f&&!k)throw B}}),p=!0,S||(R0=1,S0=function(){var f=C5(65548),B=f+12;if((I(),F)[f>>>2>>>0]=B,(I(),F)[f+4>>>2>>>0]=B+65536,B=h2[0],!c4.has(B)){var k=Vc++;c4.set(B,k),ga.set(k,B)}return B=c4.get(B),(I(),V)[f+8>>>2>>>0]=B,f}(),typeof MainLoop<"u"&&MainLoop.yd&&MainLoop.pause(),n2(()=>_7(S0)))}else R0===2?(R0=0,n2(L7),M0(S0),S0=null,kc.forEach(e2)):R1(`invalid state: ${R0}`);return ua}}((v)=>{h().then(v)});function Nc(h){return h>>>=0,pa(async()=>{var v=await a0(h);return e0(v)})}var v4=[],Oc=(h)=>{var v=v4.length;return v4.push(h),v},Rc=(h,v)=>{for(var S=Array(h),p=0;p<h;++p){var f=p,B=(I(),F)[v+4*p>>>2>>>0],k=i4[B];if(k===void 0)throw h=`parameter ${p}`,B=ka(B),v=p0(B),M0(B),new d5(`${h} has unknown type ${v}`);S[f]=k}return S},wc=(h,v,S)=>{var p=[];return h=h(p,S),p.length&&((I(),F)[v>>>2>>>0]=e0(p)),h},Dc={},c2=(h)=>{var v=Dc[h];return v===void 0?p0(h):v};function Gc(h,v,S){var[p,...f]=Rc(h,v>>>0);v=p.Xc.bind(p);var B=f.map((U)=>U.Wc.bind(U));h--;var k={toValue:a0};switch(h=B.map((U,q)=>{var c1=`argFromPtr${q}`;return k[c1]=U,`${c1}(args${q?"+"+8*q:""})`}),S){case 0:var R="toValue(handle)";break;case 2:R="new (toValue(handle))";break;case 3:R="";break;case 1:k.getStringOrSymbol=c2,R="toValue(handle)[getStringOrSymbol(methodName)]"}return R+=`(${h})`,p.Cd||(k.toReturnWire=v,k.emval_returnValue=wc,R=`return emval_returnValue(toReturnWire, destructorsRef, ${R})`),R=`return function (handle, methodName, destructorsRef, args) {
  ${R}
  }`,S=Function(Object.keys(k),R)(...Object.values(k)),R=`methodCaller<(${f.map((U)=>U.name)}) => ${p.name}>`,Oc(Object.defineProperty(S,"name",{value:R}))}function Pc(h,v){return v>>>=0,(h=a0(h>>>0))==a0(v)}function Fc(h){return(h>>>=0)?(h=c2(h),e0(globalThis[h])):e0(globalThis)}function Zc(h){return h=c2(h>>>0),e0(t[h])}function yc(h,v){return v>>>=0,h=a0(h>>>0),v=a0(v),e0(h[v])}function bc(h){9<(h>>>=0)&&(W0[h+1]+=1)}function Sa(h,v,S,p,f){return v4[h>>>0](v>>>0,S>>>0,p>>>0,f>>>0)}function jc(h,v,S,p,f){return Sa(h>>>0,v>>>0,S>>>0,p>>>0,f>>>0)}function Uc(){return e0([])}function Wc(h){h=a0(h>>>0);for(var v=Array(h.length),S=0;S<h.length;S++)v[S]=h[S];return e0(v)}function Kc(h){return e0(c2(h>>>0))}function qc(){return e0({})}function Yc(h){for(var v=a0(h>>>=0);v.length;){var S=v.pop();v.pop()(S)}e4(h)}function Qc(h,v,S){v>>>=0,S>>>=0,h=a0(h>>>0),v=a0(v),S=a0(S),h[v]=S}function Xc(h,v){h=-9007199254740992>h||9007199254740992<h?NaN:Number(h),v>>>=0,h=new Date(1000*h),(I(),V)[v>>>2>>>0]=h.getUTCSeconds(),(I(),V)[v+4>>>2>>>0]=h.getUTCMinutes(),(I(),V)[v+8>>>2>>>0]=h.getUTCHours(),(I(),V)[v+12>>>2>>>0]=h.getUTCDate(),(I(),V)[v+16>>>2>>>0]=h.getUTCMonth(),(I(),V)[v+20>>>2>>>0]=h.getUTCFullYear()-1900,(I(),V)[v+24>>>2>>>0]=h.getUTCDay(),h=(h.getTime()-Date.UTC(h.getUTCFullYear(),0,1,0,0,0,0))/86400000|0,(I(),V)[v+28>>>2>>>0]=h}var Ma=(h)=>h%4==0&&(h%100!=0||h%400==0),Aa=[0,31,60,91,121,152,182,213,244,274,305,335],Ta=[0,31,59,90,120,151,181,212,243,273,304,334];function Jc(h,v){h=-9007199254740992>h||9007199254740992<h?NaN:Number(h),v>>>=0,h=new Date(1000*h),(I(),V)[v>>>2>>>0]=h.getSeconds(),(I(),V)[v+4>>>2>>>0]=h.getMinutes(),(I(),V)[v+8>>>2>>>0]=h.getHours(),(I(),V)[v+12>>>2>>>0]=h.getDate(),(I(),V)[v+16>>>2>>>0]=h.getMonth(),(I(),V)[v+20>>>2>>>0]=h.getFullYear()-1900,(I(),V)[v+24>>>2>>>0]=h.getDay();var S=(Ma(h.getFullYear())?Aa:Ta)[h.getMonth()]+h.getDate()-1|0;(I(),V)[v+28>>>2>>>0]=S,(I(),V)[v+36>>>2>>>0]=-60*h.getTimezoneOffset(),S=new Date(h.getFullYear(),6,1).getTimezoneOffset();var p=new Date(h.getFullYear(),0,1).getTimezoneOffset();h=0|(S!=p&&h.getTimezoneOffset()==Math.min(p,S)),(I(),V)[v+32>>>2>>>0]=h}function $c(h){h>>>=0;var v=new Date((I(),V)[h+20>>>2>>>0]+1900,(I(),V)[h+16>>>2>>>0],(I(),V)[h+12>>>2>>>0],(I(),V)[h+8>>>2>>>0],(I(),V)[h+4>>>2>>>0],(I(),V)[h>>>2>>>0],0),S=(I(),V)[h+32>>>2>>>0],p=v.getTimezoneOffset(),f=new Date(v.getFullYear(),6,1).getTimezoneOffset(),B=new Date(v.getFullYear(),0,1).getTimezoneOffset(),k=Math.min(B,f);return 0>S?(I(),V)[h+32>>>2>>>0]=+(f!=B&&k==p):0<S!=(k==p)&&(f=Math.max(B,f),v.setTime(v.getTime()+60000*((0<S?k:f)-p))),(I(),V)[h+24>>>2>>>0]=v.getDay(),S=(Ma(v.getFullYear())?Aa:Ta)[v.getMonth()]+v.getDate()-1|0,(I(),V)[h+28>>>2>>>0]=S,(I(),V)[h>>>2>>>0]=v.getSeconds(),(I(),V)[h+4>>>2>>>0]=v.getMinutes(),(I(),V)[h+8>>>2>>>0]=v.getHours(),(I(),V)[h+12>>>2>>>0]=v.getDate(),(I(),V)[h+16>>>2>>>0]=v.getMonth(),(I(),V)[h+20>>>2>>>0]=v.getYear(),h=v.getTime(),BigInt(isNaN(h)?-1:h/1000)}function Ea(h,v,S,p,f,B,k){return i?z1(16,1,h,v,S,p,f,B,k):-52}function Ia(h,v,S,p,f,B){if(i)return z1(17,1,h,v,S,p,f,B)}var x5={},ad=()=>performance.timeOrigin+performance.now();function ma(h,v){if(i)return z1(18,1,h,v);if(x5[h]&&(clearTimeout(x5[h].id),delete x5[h]),!v)return 0;var S=setTimeout(()=>{delete x5[h],e2(()=>Da(h,performance.timeOrigin+performance.now()))},v);return x5[h]={id:S,be:v},0}function td(h,v,S,p){h>>>=0,v>>>=0,S>>>=0,p>>>=0;var f=new Date().getFullYear(),B=new Date(f,0,1).getTimezoneOffset();f=new Date(f,6,1).getTimezoneOffset();var k=Math.max(B,f);(I(),F)[h>>>2>>>0]=60*k,(I(),V)[v>>>2>>>0]=+(B!=f),h=(v=(R)=>{var U=Math.abs(R);return`UTC${0<=R?"-":"+"}${String(Math.floor(U/60)).padStart(2,"0")}${String(U%60).padStart(2,"0")}`})(B),v=v(f),f<B?(O0(h,S,17),O0(v,p,17)):(O0(h,p,17),O0(v,S,17))}var rd=()=>Date.now(),ld=1;function id(h,v,S){if(S>>>=0,!(0<=h&&3>=h))return 28;if(h===0)h=Date.now();else{if(!ld)return 52;h=performance.timeOrigin+performance.now()}return h=Math.round(1e6*h),(I(),Y)[S>>>3>>>0]=BigInt(h),0}var u4=[],fa=(h,v)=>{u4.length=0;for(var S;S=(I(),G)[h++>>>0];){var p=S!=105;v+=(p&=S!=112)&&v%8?4:0,u4.push(S==112?(I(),F)[v>>>2>>>0]:S==106?(I(),Y)[v>>>3>>>0]:S==105?(I(),V)[v>>>2>>>0]:(I(),$)[v>>>3>>>0]),v+=p?8:4}return u4};function ed(h,v,S){return h>>>=0,v=fa(v>>>0,S>>>0),E4[h](...v)}function od(h,v,S){return h>>>=0,v=fa(v>>>0,S>>>0),E4[h](...v)}var nd=()=>{};function hd(h,v){return z(N1(h>>>0,v>>>0))}var cd=()=>{throw V0+=1,"unwind"};function dd(){return 4294901760}var vd=()=>navigator.hardwareConcurrency,K0={},d2=(h)=>{var v;return(v=/\bwasm-function\[\d+\]:(0x[0-9a-f]+)/.exec(h))?+v[1]:(v=/:(\d+):\d+(?:\)|$)/.exec(h))?2147483648|+v[1]:0},xa=(h)=>{for(var v of h)(h=d2(v))&&(K0[h]=v)};function ud(){var h=Error().stack.toString().split(`
`);return h[0]=="Error"&&h.shift(),xa(h),K0.sd=d2(h[3]),K0.Md=h,K0.sd}function v2(h){if(!(h=K0[h>>>0]))return 0;var v;if(v=/^\s+at .*\.wasm\.(.*) \(.*\)$/.exec(h))h=v[1];else if(v=/^\s+at (.*) \(.*\)$/.exec(h))h=v[1];else{if(!(v=/^(.+?)@/.exec(h)))return 0;h=v[1]}M0(v2.td??0),v=i2(h)+1;var S=C5(v);return S&&O0(h,S,v),v2.td=S,v2.td}function gd(h){h>>>=0;var v=(I(),G).length;if(h<=v||4294901760<h)return!1;for(var S=1;4>=S;S*=2){var p=v*(1+0.2/S);p=Math.min(p,h+100663296);a:{p=(Math.min(4294901760,65536*Math.ceil(Math.max(h,p)/65536))-N0.buffer.byteLength+65535)/65536|0;try{N0.grow(p),t1();var f=1;break a}catch{}f=void 0}if(f)return!0}return!1}function sd(h,v,S){if(h>>>=0,v>>>=0,K0.sd==h)var p=K0.Md;else(p=Error().stack.toString().split(`
`))[0]=="Error"&&p.shift(),xa(p);for(var f=3;p[f]&&d2(p[f])!=h;)++f;for(h=0;h<S&&p[h+f];++h)(I(),V)[v+4*h>>>2>>>0]=d2(p[h+f]);return h}var g4,s4={},Ca=()=>{if(!g4){var h,v={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(globalThis.navigator?.language??"C").replace("-","_")+".UTF-8",_:"./this.program"};for(h in s4)s4[h]===void 0?delete v[h]:v[h]=s4[h];var S=[];for(h in v)S.push(`${h}=${v[h]}`);g4=S}return g4};function _a(h,v){if(i)return z1(19,1,h,v);h>>>=0,v>>>=0;var S,p=0,f=0;for(S of Ca()){var B=v+p;(I(),F)[h+f>>>2>>>0]=B,p+=O0(S,B,1/0)+1,f+=4}return 0}function Ba(h,v){if(i)return z1(20,1,h,v);h>>>=0,v>>>=0;var S=Ca();for(var p of((I(),F)[h>>>2>>>0]=S.length,h=0,S))h+=i2(p)+1;return(I(),F)[v>>>2>>>0]=h,0}function za(h){return i?z1(21,1,h):52}function La(h,v,S,p){return i?z1(22,1,h,v,S,p):52}function Ha(h,v,S,p){return i?z1(23,1,h,v,S,p):70}var pd=[null,[],[]];function Va(h,v,S,p){if(i)return z1(24,1,h,v,S,p);v>>>=0,S>>>=0,p>>>=0;for(var f=0,B=0;B<S;B++){var k=(I(),F)[v>>>2>>>0],R=(I(),F)[v+4>>>2>>>0];v+=8;for(var U=0;U<R;U++){var q=h,c1=(I(),G)[k+U>>>0],p1=pd[q];c1===0||c1===10?((q===1?C:z)(Y6(p1)),p1.length=0):p1.push(c1)}f+=R}return(I(),F)[p>>>2>>>0]=f,0}function Sd(h){return h>>>0}i||function(){for(var h=t.numThreads-1;h--;)y6();L1.push(async()=>{var v=async function(){if(!i)return Promise.all(k0.map(Z6))}();U1++,await v,--U1==0&&j0&&(v=j0,j0=null,v())})}(),i||(N0=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),t1()),t.wasmBinary&&(s=t.wasmBinary),t.stackSave=()=>v1(),t.stackRestore=(h)=>d1(h),t.stackAlloc=(h)=>M4(h),t.setValue=function(h,v,S="i8"){switch(S.endsWith("*")&&(S="*"),S){case"i1":case"i8":(I(),b)[h>>>0]=v;break;case"i16":(I(),j)[h>>>1>>>0]=v;break;case"i32":(I(),V)[h>>>2>>>0]=v;break;case"i64":(I(),Y)[h>>>3>>>0]=BigInt(v);break;case"float":(I(),a1)[h>>>2>>>0]=v;break;case"double":(I(),$)[h>>>3>>>0]=v;break;case"*":(I(),F)[h>>>2>>>0]=v;break;default:R1(`invalid type for setValue: ${S}`)}},t.getValue=function(h,v="i8"){switch(v.endsWith("*")&&(v="*"),v){case"i1":case"i8":return(I(),b)[h>>>0];case"i16":return(I(),j)[h>>>1>>>0];case"i32":return(I(),V)[h>>>2>>>0];case"i64":return(I(),Y)[h>>>3>>>0];case"float":return(I(),a1)[h>>>2>>>0];case"double":return(I(),$)[h>>>3>>>0];case"*":return(I(),F)[h>>>2>>>0];default:R1(`invalid type for getValue: ${v}`)}},t.UTF8ToString=N1,t.stringToUTF8=O0,t.lengthBytesUTF8=i2;var ka,Na,u2,M0,C5,p4,Oa,Ra,wa,S4,Da,Ga,u1,_5,Pa,d1,M4,v1,Fa,A4,Za,ya,ba,T4,ja,Ua,Wa,Ka,qa,Ya,Qa,Xa,Ja,$a,a7,t7,r7,l7,i7,e7,o7,n7,h7,c7,d7,v7,u7,g7,s7,p7,S7,M7,A7,T7,E7,I7,m7,f7,x7,C7,_7,B7,z7,L7,B0,Md=[a4,D6,U6,Q6,X6,J6,$6,aa,ta,ra,la,ia,ea,oa,na,ha,Ea,Ia,ma,_a,Ba,za,La,Ha,Va],E4={927244:(h,v,S,p,f)=>{if(t===void 0||!t.Zc)return 1;if((h=N1(Number(h>>>0))).startsWith("./")&&(h=h.substring(2)),!(h=t.Zc.get(h)))return 2;if(v=Number(v>>>0),S=Number(S>>>0),p=Number(p>>>0),v+S>h.byteLength)return 3;try{let B=h.subarray(v,v+S);switch(f){case 0:(I(),G).set(B,p>>>0);break;case 1:t.Xd?t.Xd(p,B):t.Ld(p,B);break;default:return 4}return 0}catch{return 4}},928068:(h,v,S)=>{t.xd(h,(I(),G).subarray(v>>>0,v+S>>>0))},928132:()=>t.Zd(),928174:(h)=>{t.vd(h)},928211:()=>{t.Ed()},928242:()=>{t.Fd()},928271:()=>{t.Jd()},928296:(h)=>t.Dd(h),928329:(h)=>t.Hd(h),928361:(h,v,S)=>{t.jd(Number(h),Number(v),Number(S),!0)},928424:(h,v,S)=>{t.jd(Number(h),Number(v),Number(S))},928481:()=>typeof wasmOffsetConverter<"u",928538:(h)=>{t.ac("Abs",h,void 0)},928589:(h)=>{t.ac("Neg",h,void 0)},928640:(h)=>{t.ac("Floor",h,void 0)},928693:(h)=>{t.ac("Ceil",h,void 0)},928745:(h)=>{t.ac("Reciprocal",h,void 0)},928803:(h)=>{t.ac("Sqrt",h,void 0)},928855:(h)=>{t.ac("Exp",h,void 0)},928906:(h)=>{t.ac("Erf",h,void 0)},928957:(h)=>{t.ac("Sigmoid",h,void 0)},929012:(h,v,S)=>{t.ac("HardSigmoid",h,{alpha:v,beta:S})},929091:(h)=>{t.ac("Log",h,void 0)},929142:(h)=>{t.ac("Sin",h,void 0)},929193:(h)=>{t.ac("Cos",h,void 0)},929244:(h)=>{t.ac("Tan",h,void 0)},929295:(h)=>{t.ac("Asin",h,void 0)},929347:(h)=>{t.ac("Acos",h,void 0)},929399:(h)=>{t.ac("Atan",h,void 0)},929451:(h)=>{t.ac("Sinh",h,void 0)},929503:(h)=>{t.ac("Cosh",h,void 0)},929555:(h)=>{t.ac("Asinh",h,void 0)},929608:(h)=>{t.ac("Acosh",h,void 0)},929661:(h)=>{t.ac("Atanh",h,void 0)},929714:(h)=>{t.ac("Tanh",h,void 0)},929766:(h)=>{t.ac("Not",h,void 0)},929817:(h,v,S)=>{t.ac("Clip",h,{min:v,max:S})},929886:(h)=>{t.ac("Clip",h,void 0)},929938:(h,v)=>{t.ac("Elu",h,{alpha:v})},929996:(h)=>{t.ac("Gelu",h,void 0)},930048:(h)=>{t.ac("Relu",h,void 0)},930100:(h,v)=>{t.ac("LeakyRelu",h,{alpha:v})},930164:(h,v)=>{t.ac("ThresholdedRelu",h,{alpha:v})},930234:(h,v)=>{t.ac("Cast",h,{to:v})},930292:(h)=>{t.ac("Add",h,void 0)},930343:(h)=>{t.ac("Sub",h,void 0)},930394:(h)=>{t.ac("Mul",h,void 0)},930445:(h)=>{t.ac("Div",h,void 0)},930496:(h)=>{t.ac("Pow",h,void 0)},930547:(h)=>{t.ac("Equal",h,void 0)},930600:(h)=>{t.ac("Greater",h,void 0)},930655:(h)=>{t.ac("GreaterOrEqual",h,void 0)},930717:(h)=>{t.ac("Less",h,void 0)},930769:(h)=>{t.ac("LessOrEqual",h,void 0)},930828:(h,v,S,p,f)=>{t.ac("ReduceMean",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},931003:(h,v,S,p,f)=>{t.ac("ReduceMax",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},931177:(h,v,S,p,f)=>{t.ac("ReduceMin",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},931351:(h,v,S,p,f)=>{t.ac("ReduceProd",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},931526:(h,v,S,p,f)=>{t.ac("ReduceSum",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},931700:(h,v,S,p,f)=>{t.ac("ReduceL1",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},931873:(h,v,S,p,f)=>{t.ac("ReduceL2",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},932046:(h,v,S,p,f)=>{t.ac("ReduceLogSum",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},932223:(h,v,S,p,f)=>{t.ac("ReduceSumSquare",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},932403:(h,v,S,p,f)=>{t.ac("ReduceLogSumExp",h,{keepDims:!!v,noopWithEmptyAxes:!!S,axes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},932583:(h)=>{t.ac("Where",h,void 0)},932636:(h,v,S)=>{t.ac("Transpose",h,{perm:v?Array.from((I(),V).subarray(Number(v)>>>0,Number(S)>>>0)):[]})},932760:(h,v,S,p)=>{t.ac("DepthToSpace",h,{blocksize:v,mode:N1(S),format:p?"NHWC":"NCHW"})},932893:(h,v,S,p)=>{t.ac("DepthToSpace",h,{blocksize:v,mode:N1(S),format:p?"NHWC":"NCHW"})},933026:(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1,w0)=>{t.ac("ConvTranspose",h,{format:U?"NHWC":"NCHW",autoPad:v,dilations:[S],group:p,kernelShape:[f],pads:[B,k],strides:[R],wIsConst:()=>!!(I(),b)[q>>>0],outputPadding:c1?Array.from((I(),V).subarray(Number(c1)>>>0,Number(p1)>>>0)):[],outputShape:I1?Array.from((I(),V).subarray(Number(I1)>>>0,Number(x1)>>>0)):[],activation:N1(w0)})},933459:(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1)=>{t.ac("ConvTranspose",h,{format:R?"NHWC":"NCHW",autoPad:v,dilations:Array.from((I(),V).subarray(Number(S)>>>0,2+(Number(S)>>>0)>>>0)),group:p,kernelShape:Array.from((I(),V).subarray(Number(f)>>>0,2+(Number(f)>>>0)>>>0)),pads:Array.from((I(),V).subarray(Number(B)>>>0,4+(Number(B)>>>0)>>>0)),strides:Array.from((I(),V).subarray(Number(k)>>>0,2+(Number(k)>>>0)>>>0)),wIsConst:()=>!!(I(),b)[U>>>0],outputPadding:q?Array.from((I(),V).subarray(Number(q)>>>0,Number(c1)>>>0)):[],outputShape:p1?Array.from((I(),V).subarray(Number(p1)>>>0,Number(I1)>>>0)):[],activation:N1(x1)})},934120:(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1,w0)=>{t.ac("ConvTranspose",h,{format:U?"NHWC":"NCHW",autoPad:v,dilations:[S],group:p,kernelShape:[f],pads:[B,k],strides:[R],wIsConst:()=>!!(I(),b)[q>>>0],outputPadding:c1?Array.from((I(),V).subarray(Number(c1)>>>0,Number(p1)>>>0)):[],outputShape:I1?Array.from((I(),V).subarray(Number(I1)>>>0,Number(x1)>>>0)):[],activation:N1(w0)})},934553:(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1)=>{t.ac("ConvTranspose",h,{format:R?"NHWC":"NCHW",autoPad:v,dilations:Array.from((I(),V).subarray(Number(S)>>>0,2+(Number(S)>>>0)>>>0)),group:p,kernelShape:Array.from((I(),V).subarray(Number(f)>>>0,2+(Number(f)>>>0)>>>0)),pads:Array.from((I(),V).subarray(Number(B)>>>0,4+(Number(B)>>>0)>>>0)),strides:Array.from((I(),V).subarray(Number(k)>>>0,2+(Number(k)>>>0)>>>0)),wIsConst:()=>!!(I(),b)[U>>>0],outputPadding:q?Array.from((I(),V).subarray(Number(q)>>>0,Number(c1)>>>0)):[],outputShape:p1?Array.from((I(),V).subarray(Number(p1)>>>0,Number(I1)>>>0)):[],activation:N1(x1)})},935214:(h,v)=>{t.ac("GlobalAveragePool",h,{format:v?"NHWC":"NCHW"})},935305:(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1)=>{t.ac("AveragePool",h,{format:x1?"NHWC":"NCHW",auto_pad:v,ceil_mode:S,count_include_pad:p,storage_order:f,dilations:B?Array.from((I(),V).subarray(Number(B)>>>0,Number(k)>>>0)):[],kernel_shape:R?Array.from((I(),V).subarray(Number(R)>>>0,Number(U)>>>0)):[],pads:q?Array.from((I(),V).subarray(Number(q)>>>0,Number(c1)>>>0)):[],strides:p1?Array.from((I(),V).subarray(Number(p1)>>>0,Number(I1)>>>0)):[]})},935784:(h,v)=>{t.ac("GlobalAveragePool",h,{format:v?"NHWC":"NCHW"})},935875:(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1)=>{t.ac("AveragePool",h,{format:x1?"NHWC":"NCHW",auto_pad:v,ceil_mode:S,count_include_pad:p,storage_order:f,dilations:B?Array.from((I(),V).subarray(Number(B)>>>0,Number(k)>>>0)):[],kernel_shape:R?Array.from((I(),V).subarray(Number(R)>>>0,Number(U)>>>0)):[],pads:q?Array.from((I(),V).subarray(Number(q)>>>0,Number(c1)>>>0)):[],strides:p1?Array.from((I(),V).subarray(Number(p1)>>>0,Number(I1)>>>0)):[]})},936354:(h,v)=>{t.ac("GlobalMaxPool",h,{format:v?"NHWC":"NCHW"})},936441:(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1)=>{t.ac("MaxPool",h,{format:x1?"NHWC":"NCHW",auto_pad:v,ceil_mode:S,count_include_pad:p,storage_order:f,dilations:B?Array.from((I(),V).subarray(Number(B)>>>0,Number(k)>>>0)):[],kernel_shape:R?Array.from((I(),V).subarray(Number(R)>>>0,Number(U)>>>0)):[],pads:q?Array.from((I(),V).subarray(Number(q)>>>0,Number(c1)>>>0)):[],strides:p1?Array.from((I(),V).subarray(Number(p1)>>>0,Number(I1)>>>0)):[]})},936916:(h,v)=>{t.ac("GlobalMaxPool",h,{format:v?"NHWC":"NCHW"})},937003:(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1)=>{t.ac("MaxPool",h,{format:x1?"NHWC":"NCHW",auto_pad:v,ceil_mode:S,count_include_pad:p,storage_order:f,dilations:B?Array.from((I(),V).subarray(Number(B)>>>0,Number(k)>>>0)):[],kernel_shape:R?Array.from((I(),V).subarray(Number(R)>>>0,Number(U)>>>0)):[],pads:q?Array.from((I(),V).subarray(Number(q)>>>0,Number(c1)>>>0)):[],strides:p1?Array.from((I(),V).subarray(Number(p1)>>>0,Number(I1)>>>0)):[]})},937478:(h,v,S,p,f)=>{t.ac("Gemm",h,{alpha:v,beta:S,transA:p,transB:f})},937582:(h)=>{t.ac("MatMul",h,void 0)},937636:(h,v,S,p)=>{t.ac("ArgMax",h,{keepDims:!!v,selectLastIndex:!!S,axis:p})},937744:(h,v,S,p)=>{t.ac("ArgMin",h,{keepDims:!!v,selectLastIndex:!!S,axis:p})},937852:(h,v)=>{t.ac("Softmax",h,{axis:v})},937915:(h,v)=>{t.ac("Concat",h,{axis:v})},937975:(h,v,S,p,f)=>{t.ac("Split",h,{axis:v,numOutputs:S,splitSizes:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},938131:(h)=>{t.ac("Expand",h,void 0)},938185:(h,v)=>{t.ac("Gather",h,{axis:Number(v)})},938256:(h,v)=>{t.ac("GatherElements",h,{axis:Number(v)})},938335:(h,v)=>{t.ac("GatherND",h,{batch_dims:Number(v)})},938414:(h,v,S,p,f,B,k,R,U,q,c1)=>{t.ac("Resize",h,{antialias:v,axes:S?Array.from((I(),V).subarray(Number(S)>>>0,Number(p)>>>0)):[],coordinateTransformMode:N1(f),cubicCoeffA:B,excludeOutside:k,extrapolationValue:R,keepAspectRatioPolicy:N1(U),mode:N1(q),nearestMode:N1(c1)})},938776:(h,v,S,p,f,B,k)=>{t.ac("Slice",h,{starts:v?Array.from((I(),V).subarray(Number(v)>>>0,Number(S)>>>0)):[],ends:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[],axes:B?Array.from((I(),V).subarray(Number(B)>>>0,Number(k)>>>0)):[]})},939040:(h)=>{t.ac("Tile",h,void 0)},939092:(h,v,S)=>{t.ac("InstanceNormalization",h,{epsilon:v,format:S?"NHWC":"NCHW"})},939206:(h,v,S)=>{t.ac("InstanceNormalization",h,{epsilon:v,format:S?"NHWC":"NCHW"})},939320:(h)=>{t.ac("Range",h,void 0)},939373:(h,v)=>{t.ac("Einsum",h,{equation:N1(v)})},939454:(h,v,S,p,f)=>{t.ac("Pad",h,{mode:v,value:S,pads:p?Array.from((I(),V).subarray(Number(p)>>>0,Number(f)>>>0)):[]})},939597:(h,v,S,p,f,B)=>{t.ac("BatchNormalization",h,{epsilon:v,momentum:S,spatial:!!f,trainingMode:!!p,format:B?"NHWC":"NCHW"})},939766:(h,v,S,p,f,B)=>{t.ac("BatchNormalization",h,{epsilon:v,momentum:S,spatial:!!f,trainingMode:!!p,format:B?"NHWC":"NCHW"})},939935:(h,v,S)=>{t.ac("CumSum",h,{exclusive:Number(v),reverse:Number(S)})},940032:(h,v,S)=>{t.ac("DequantizeLinear",h,{axis:v,blockSize:S})},940122:(h,v,S,p,f)=>{t.ac("GridSample",h,{align_corners:v,mode:N1(S),padding_mode:N1(p),format:f?"NHWC":"NCHW"})},940292:(h,v,S,p,f)=>{t.ac("GridSample",h,{align_corners:v,mode:N1(S),padding_mode:N1(p),format:f?"NHWC":"NCHW"})},940462:(h,v)=>{t.ac("ScatterND",h,{reduction:N1(v)})},940547:(h,v,S,p,f,B,k,R,U)=>{t.ac("Attention",h,{numHeads:v,isUnidirectional:S,maskFilterValue:p,scale:f,doRotary:B,qkvHiddenSizes:k?Array.from((I(),V).subarray(Number(R)>>>0,Number(R)+k>>>0)):[],pastPresentShareBuffer:!!U})},940819:(h)=>{t.ac("BiasAdd",h,void 0)},940874:(h)=>{t.ac("BiasSplitGelu",h,void 0)},940935:(h)=>{t.ac("FastGelu",h,void 0)},940991:(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1,w0,I4)=>{t.ac("Conv",h,{format:p1?"NHWC":"NCHW",auto_pad:v,dilations:S?Array.from((I(),V).subarray(Number(S)>>>0,Number(p)>>>0)):[],group:f,kernel_shape:B?Array.from((I(),V).subarray(Number(B)>>>0,Number(k)>>>0)):[],pads:R?Array.from((I(),V).subarray(Number(R)>>>0,Number(U)>>>0)):[],strides:q?Array.from((I(),V).subarray(Number(q)>>>0,Number(c1)>>>0)):[],w_is_const:()=>!!(I(),b)[Number(I1)>>>0],activation:N1(x1),activation_params:w0?Array.from((I(),a1).subarray(Number(w0)>>>0,Number(I4)>>>0)):[]})},941575:(h)=>{t.ac("Gelu",h,void 0)},941627:(h,v,S,p,f,B,k,R,U)=>{t.ac("GroupQueryAttention",h,{numHeads:v,kvNumHeads:S,scale:p,softcap:f,doRotary:B,rotaryInterleaved:k,smoothSoftmax:R,localWindowSize:U})},941844:(h,v,S,p)=>{t.ac("LayerNormalization",h,{axis:v,epsilon:S,simplified:!!p})},941955:(h,v,S,p)=>{t.ac("LayerNormalization",h,{axis:v,epsilon:S,simplified:!!p})},942066:(h,v,S,p,f,B)=>{t.ac("MatMulNBits",h,{k:v,n:S,accuracyLevel:p,bits:f,blockSize:B})},942193:(h,v,S,p,f,B)=>{t.ac("MultiHeadAttention",h,{numHeads:v,isUnidirectional:S,maskFilterValue:p,scale:f,doRotary:B})},942352:(h,v)=>{t.ac("QuickGelu",h,{alpha:v})},942416:(h,v,S,p,f)=>{t.ac("RotaryEmbedding",h,{interleaved:!!v,numHeads:S,rotaryEmbeddingDim:p,scale:f})},942555:(h,v,S)=>{t.ac("SkipLayerNormalization",h,{epsilon:v,simplified:!!S})},942657:(h,v,S)=>{t.ac("SkipLayerNormalization",h,{epsilon:v,simplified:!!S})},942759:(h,v,S,p)=>{t.ac("GatherBlockQuantized",h,{gatherAxis:v,quantizeAxis:S,blockSize:p})},942880:(h)=>{t.Id(h)},942914:(h,v)=>t.Kd(Number(h),Number(v),t.$c.Nd,t.$c.errors)};function Ad(h,v,S){return pa(async()=>{await t.Gd(Number(h),Number(v),Number(S))})}function Td(){return typeof wasmOffsetConverter<"u"}function Ed(h,v,S,p){var f=v1();try{return Xa(h,v,S,p)}catch(B){if(d1(f),B!==B+0)throw B;u1(1,0)}}function Id(h,v,S){var p=v1();try{return Ka(h,v,S)}catch(f){if(d1(p),f!==f+0)throw f;u1(1,0)}}function md(h,v,S){var p=v1();try{ba(h,v,S)}catch(f){if(d1(p),f!==f+0)throw f;u1(1,0)}}function fd(h,v){var S=v1();try{return T4(h,v)}catch(p){if(d1(S),p!==p+0)throw p;u1(1,0)}}function xd(h){var v=v1();try{ja(h)}catch(S){if(d1(v),S!==S+0)throw S;u1(1,0)}}function Cd(h,v,S,p,f,B,k){var R=v1();try{return Ya(h,v,S,p,f,B,k)}catch(U){if(d1(R),U!==U+0)throw U;u1(1,0)}}function _d(h,v){var S=v1();try{Ja(h,v)}catch(p){if(d1(S),p!==p+0)throw p;u1(1,0)}}function Bd(h,v,S,p,f,B){var k=v1();try{Ua(h,v,S,p,f,B)}catch(R){if(d1(k),R!==R+0)throw R;u1(1,0)}}function zd(h,v,S,p){var f=v1();try{Qa(h,v,S,p)}catch(B){if(d1(f),B!==B+0)throw B;u1(1,0)}}function Ld(h,v,S,p,f){var B=v1();try{Wa(h,v,S,p,f)}catch(k){if(d1(B),k!==k+0)throw k;u1(1,0)}}function Hd(h,v,S,p,f,B,k){var R=v1();try{a7(h,v,S,p,f,B,k)}catch(U){if(d1(R),U!==U+0)throw U;u1(1,0)}}function Vd(h,v,S,p,f,B,k){var R=v1();try{t7(h,v,S,p,f,B,k)}catch(U){if(d1(R),U!==U+0)throw U;u1(1,0)}}function kd(h,v,S,p,f,B,k,R){var U=v1();try{e7(h,v,S,p,f,B,k,R)}catch(q){if(d1(U),q!==q+0)throw q;u1(1,0)}}function Nd(h,v,S,p,f){var B=v1();try{return $a(h,v,S,p,f)}catch(k){if(d1(B),k!==k+0)throw k;u1(1,0)}}function Od(h,v,S,p,f,B,k,R){var U=v1();try{o7(h,v,S,p,f,B,k,R)}catch(q){if(d1(U),q!==q+0)throw q;u1(1,0)}}function Rd(h,v,S,p,f,B,k,R,U,q,c1,p1){var I1=v1();try{r7(h,v,S,p,f,B,k,R,U,q,c1,p1)}catch(x1){if(d1(I1),x1!==x1+0)throw x1;u1(1,0)}}function wd(h,v,S,p,f,B){var k=v1();try{return l7(h,v,S,p,f,B)}catch(R){if(d1(k),R!==R+0)throw R;u1(1,0)}}function Dd(h,v,S){var p=v1();try{return n7(h,v,S)}catch(f){if(d1(p),f!==f+0)throw f;return u1(1,0),0n}}function Gd(h,v,S,p,f,B,k,R,U){var q=v1();try{qa(h,v,S,p,f,B,k,R,U)}catch(c1){if(d1(q),c1!==c1+0)throw c1;u1(1,0)}}function Pd(h){var v=v1();try{return h7(h)}catch(S){if(d1(v),S!==S+0)throw S;u1(1,0)}}function Fd(h,v,S){var p=v1();try{return c7(h,v,S)}catch(f){if(d1(p),f!==f+0)throw f;u1(1,0)}}function Zd(h,v){var S=v1();try{return C7(h,v)}catch(p){if(d1(S),p!==p+0)throw p;return u1(1,0),0n}}function yd(h,v,S,p,f){var B=v1();try{d7(h,v,S,p,f)}catch(k){if(d1(B),k!==k+0)throw k;u1(1,0)}}function bd(h){var v=v1();try{return v7(h)}catch(S){if(d1(v),S!==S+0)throw S;return u1(1,0),0n}}function jd(h,v,S,p,f,B){var k=v1();try{return M7(h,v,S,p,f,B)}catch(R){if(d1(k),R!==R+0)throw R;u1(1,0)}}function Ud(h,v,S,p,f,B){var k=v1();try{return A7(h,v,S,p,f,B)}catch(R){if(d1(k),R!==R+0)throw R;u1(1,0)}}function Wd(h,v,S,p,f,B,k,R){var U=v1();try{return i7(h,v,S,p,f,B,k,R)}catch(q){if(d1(U),q!==q+0)throw q;u1(1,0)}}function Kd(h,v,S,p,f){var B=v1();try{return T7(h,v,S,p,f)}catch(k){if(d1(B),k!==k+0)throw k;return u1(1,0),0n}}function qd(h,v,S,p){var f=v1();try{return E7(h,v,S,p)}catch(B){if(d1(f),B!==B+0)throw B;u1(1,0)}}function Yd(h,v,S,p){var f=v1();try{return I7(h,v,S,p)}catch(B){if(d1(f),B!==B+0)throw B;u1(1,0)}}function Qd(h,v,S,p,f,B,k,R,U,q,c1,p1){var I1=v1();try{return m7(h,v,S,p,f,B,k,R,U,q,c1,p1)}catch(x1){if(d1(I1),x1!==x1+0)throw x1;u1(1,0)}}function Xd(h,v,S,p,f,B,k,R,U,q,c1){var p1=v1();try{p7(h,v,S,p,f,B,k,R,U,q,c1)}catch(I1){if(d1(p1),I1!==I1+0)throw I1;u1(1,0)}}function Jd(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1,w0,I4){var iv=v1();try{S7(h,v,S,p,f,B,k,R,U,q,c1,p1,I1,x1,w0,I4)}catch(m4){if(d1(iv),m4!==m4+0)throw m4;u1(1,0)}}function $d(h,v,S,p){var f=v1();try{return f7(h,v,S,p)}catch(B){if(d1(f),B!==B+0)throw B;u1(1,0)}}function av(h,v,S,p,f){var B=v1();try{return x7(h,v,S,p,f)}catch(k){if(d1(B),k!==k+0)throw k;u1(1,0)}}function tv(h,v,S){var p=v1();try{return u7(h,v,S)}catch(f){if(d1(p),f!==f+0)throw f;u1(1,0)}}function rv(h,v,S){var p=v1();try{return g7(h,v,S)}catch(f){if(d1(p),f!==f+0)throw f;u1(1,0)}}function lv(h,v,S,p){var f=v1();try{s7(h,v,S,p)}catch(B){if(d1(f),B!==B+0)throw B;u1(1,0)}}function g2(){if(0<U1)j0=g2;else if(i)E?.(t),s1();else{for(var h=L1;0<h.length;)h.shift()(t);0<U1?j0=g2:(t.calledRun=!0,L||(s1(),E?.(t)))}}return i||(B0=await i0(),g2()),t.PTR_SIZE=4,W?t:new Promise((h,v)=>{E=h,x=v})}var Ae,Ir,Fg=y(()=>{Ae=Er,Ir=globalThis.self?.name?.startsWith("em-pthread"),Ir&&Er()}),a3,U3,mr,X1,Te,z2,fr,xr,t3,Cr,r3,Ee,l3,Ie,d6=y(()=>{c6(),a3=typeof location>"u"?void 0:location.origin,U3=!1,mr=()=>{if(U3)return new URL(new URL("ort.bundle.min.mjs","https://localhost").href,a3).href;return"https://localhost"},X1=mr(),Te=()=>{if(X1&&!X1.startsWith("blob:"))return X1.substring(0,X1.lastIndexOf("/")+1)},z2=(a,t)=>{try{let r=t??X1;return(r?new URL(a,r):new URL(a)).origin===a3}catch{return!1}},fr=(a,t)=>{let r=t??X1;try{return(r?new URL(a,r):new URL(a)).href}catch{return}},xr=(a,t)=>`${t??"./"}${a}`,t3=async(a)=>{let t=await(await fetch(a,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},Cr=async(a)=>(await import(a)).default,r3=(Pg(),X5(pe)).default,Ee=async()=>{if(!X1)throw Error("Failed to load proxy worker: cannot determine the script source URL.");if(z2(X1))return[void 0,r3()];let a=await t3(X1);return[a,r3(a)]},l3=(Fg(),X5(Me)).default,Ie=async(a,t,r,l)=>{let i=l3&&!(a||t);if(i)if(X1)i=z2(X1);else if(l&&!r)i=!0;else throw Error("cannot determine the script source URL.");if(i)return[void 0,l3];{let e="ort-wasm-simd-threaded.jsep.mjs",o=a??fr(e,t),n=r&&o&&!z2(o,t),c=n?await t3(o):o??xr(e,t);return[n?c:void 0,await Cr(c)]}}}),i3,L2,D5,e3,_r,Br,zr,v6,f1,n5=y(()=>{d6(),L2=!1,D5=!1,e3=!1,_r=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Br=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},zr=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},v6=async(a)=>{if(L2)return Promise.resolve();if(D5)throw Error("multiple calls to 'initializeWebAssembly()' detected.");if(e3)throw Error("previous call to 'initializeWebAssembly()' failed.");D5=!0;let{initTimeout:t,numThreads:r}=a;if(a.simd!==!1){if(a.simd==="relaxed"){if(!zr())throw Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!Br())throw Error("WebAssembly SIMD is not supported in the current environment.")}let l=_r();r>1&&!l&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),a.numThreads=r=1);let i=a.wasmPaths,e=typeof i=="string"?i:void 0,o=i?.mjs,n=o?.href??o,c=i?.wasm,d=c?.href??c,u=a.wasmBinary,[g,s]=await Ie(n,e,r>1,!!u||!!d),M=!1,A=[];if(t>0&&A.push(new Promise((E)=>{setTimeout(()=>{M=!0,E()},t)})),A.push(new Promise((E,x)=>{let m={numThreads:r};if(u)m.wasmBinary=u;else if(d||e)m.locateFile=(T)=>d??e+T;else if(n&&n.indexOf("blob:")!==0)m.locateFile=(T)=>new URL(T,n).href;else if(g){let T=Te();T&&(m.locateFile=(_)=>T+_)}s(m).then((T)=>{D5=!1,L2=!0,i3=T,E(),g&&URL.revokeObjectURL(g)},(T)=>{D5=!1,e3=!0,x(T)})})),await Promise.race(A),M)throw Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},f1=()=>{if(L2&&i3)return i3;throw Error("WebAssembly is not initialized yet.")}}),v0,y2,E1,u6=y(()=>{n5(),v0=(a,t)=>{let r=f1(),l=r.lengthBytesUTF8(a)+1,i=r._malloc(l);return r.stringToUTF8(a,i,l),t.push(i),i},y2=(a,t,r,l)=>{if(typeof a=="object"&&a!==null){if(r.has(a))throw Error("Circular reference in options");r.add(a)}Object.entries(a).forEach(([i,e])=>{let o=t?t+i:i;if(typeof e=="object")y2(e,o+".",r,l);else if(typeof e=="string"||typeof e=="number")l(o,e.toString());else if(typeof e=="boolean")l(o,e?"1":"0");else throw Error(`Can't handle extra config type: ${typeof e}`)})},E1=(a)=>{let t=f1(),r=t.stackSave();try{let l=t.PTR_SIZE,i=t.stackAlloc(2*l);t._OrtGetLastError(i,i+l);let e=Number(t.getValue(i,l===4?"i32":"i64")),o=t.getValue(i+l,"*"),n=o?t.UTF8ToString(o):"";throw Error(`${a} ERROR_CODE: ${e}, ERROR_MESSAGE: ${n}`)}finally{t.stackRestore(r)}}}),me,Zg=y(()=>{n5(),u6(),me=(a)=>{let t=f1(),r=0,l=[],i=a||{};try{if(a?.logSeverityLevel===void 0)i.logSeverityLevel=2;else if(typeof a.logSeverityLevel!="number"||!Number.isInteger(a.logSeverityLevel)||a.logSeverityLevel<0||a.logSeverityLevel>4)throw Error(`log severity level is not valid: ${a.logSeverityLevel}`);if(a?.logVerbosityLevel===void 0)i.logVerbosityLevel=0;else if(typeof a.logVerbosityLevel!="number"||!Number.isInteger(a.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${a.logVerbosityLevel}`);a?.terminate===void 0&&(i.terminate=!1);let e=0;return a?.tag!==void 0&&(e=v0(a.tag,l)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,e),r===0&&E1("Can't create run options."),a?.extra!==void 0&&y2(a.extra,"",new WeakSet,(o,n)=>{let c=v0(o,l),d=v0(n,l);t._OrtAddRunConfigEntry(r,c,d)!==0&&E1(`Can't set a run config entry: ${o} - ${n}.`)}),[r,l]}catch(e){throw r!==0&&t._OrtReleaseRunOptions(r),l.forEach((o)=>t._free(o)),e}}}),Lr,Hr,Vr,G5,kr,fe,yg=y(()=>{n5(),u6(),Lr=(a)=>{switch(a){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw Error(`unsupported graph optimization level: ${a}`)}},Hr=(a)=>{switch(a){case"sequential":return 0;case"parallel":return 1;default:throw Error(`unsupported execution mode: ${a}`)}},Vr=(a)=>{a.extra||(a.extra={}),a.extra.session||(a.extra.session={});let t=a.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),a.executionProviders&&a.executionProviders.some((r)=>(typeof r=="string"?r:r.name)==="webgpu")&&(a.enableMemPattern=!1)},G5=(a,t,r,l)=>{let i=v0(t,l),e=v0(r,l);f1()._OrtAddSessionConfigEntry(a,i,e)!==0&&E1(`Can't set a session config entry: ${t} - ${r}.`)},kr=async(a,t,r)=>{let l=t.executionProviders;for(let i of l){let e=typeof i=="string"?i:i.name,o=[];switch(e){case"webnn":if(e="WEBNN",typeof i!="string"){let g=i?.deviceType;g&&G5(a,"deviceType",g,r)}break;case"webgpu":if(e="JS",typeof i!="string"){let g=i;if(g?.preferredLayout){if(g.preferredLayout!=="NCHW"&&g.preferredLayout!=="NHWC")throw Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${g.preferredLayout}`);G5(a,"preferredLayout",g.preferredLayout,r)}}break;case"wasm":case"cpu":continue;default:throw Error(`not supported execution provider: ${e}`)}let n=v0(e,r),c=o.length,d=0,u=0;if(c>0){d=f1()._malloc(c*f1().PTR_SIZE),r.push(d),u=f1()._malloc(c*f1().PTR_SIZE),r.push(u);for(let g=0;g<c;g++)f1().setValue(d+g*f1().PTR_SIZE,o[g][0],"*"),f1().setValue(u+g*f1().PTR_SIZE,o[g][1],"*")}await f1()._OrtAppendExecutionProvider(a,n,d,u,c)!==0&&E1(`Can't append execution provider: ${e}.`)}},fe=async(a)=>{let t=f1(),r=0,l=[],i=a||{};Vr(i);try{let e=Lr(i.graphOptimizationLevel??"all"),o=Hr(i.executionMode??"sequential"),n=typeof i.logId=="string"?v0(i.logId,l):0,c=i.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw Error(`log severity level is not valid: ${c}`);let d=i.logVerbosityLevel??0;if(!Number.isInteger(d)||d<0||d>4)throw Error(`log verbosity level is not valid: ${d}`);let u=typeof i.optimizedModelFilePath=="string"?v0(i.optimizedModelFilePath,l):0;if(r=t._OrtCreateSessionOptions(e,!!i.enableCpuMemArena,!!i.enableMemPattern,o,!!i.enableProfiling,0,n,c,d,u),r===0&&E1("Can't create session options."),i.executionProviders&&await kr(r,i,l),i.enableGraphCapture!==void 0){if(typeof i.enableGraphCapture!="boolean")throw Error(`enableGraphCapture must be a boolean value: ${i.enableGraphCapture}`);G5(r,"enableGraphCapture",i.enableGraphCapture.toString(),l)}if(i.freeDimensionOverrides)for(let[g,s]of Object.entries(i.freeDimensionOverrides)){if(typeof g!="string")throw Error(`free dimension override name must be a string: ${g}`);if(typeof s!="number"||!Number.isInteger(s)||s<0)throw Error(`free dimension override value must be a non-negative integer: ${s}`);let M=v0(g,l);t._OrtAddFreeDimensionOverride(r,M,s)!==0&&E1(`Can't set a free dimension override: ${g} - ${s}.`)}return i.extra!==void 0&&y2(i.extra,"",new WeakSet,(g,s)=>{G5(r,g,s,l)}),[r,l]}catch(e){throw r!==0&&t._OrtReleaseSessionOptions(r)!==0&&E1("Can't release session options."),l.forEach((o)=>t._free(o)),e}}}),a5,L0,t5,Q2,b2,g6,s6,W3,l1=y(()=>{a5=(a)=>{switch(a){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw Error(`unsupported data type: ${a}`)}},L0=(a)=>{switch(a){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw Error(`unsupported data type: ${a}`)}},t5=(a,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,0.5,0.5][a],l=typeof t=="number"?t:t.reduce((i,e)=>i*e,1);return r>0?Math.ceil(l*r):void 0},Q2=(a)=>{switch(a){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw Error(`unsupported type: ${a}`)}},b2=(a)=>{switch(a){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw Error(`unsupported logging level: ${a}`)}},g6=(a)=>a==="float32"||a==="float16"||a==="int32"||a==="int64"||a==="uint32"||a==="uint8"||a==="bool"||a==="uint4"||a==="int4",s6=(a)=>a==="float32"||a==="float16"||a==="int32"||a==="int64"||a==="uint32"||a==="uint64"||a==="int8"||a==="uint8"||a==="bool"||a==="uint4"||a==="int4",W3=(a)=>{switch(a){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw Error(`unsupported data location: ${a}`)}}}),p6,xe=y(()=>{c6(),p6=async(a)=>{if(typeof a=="string"){let t=await fetch(a);if(!t.ok)throw Error(`failed to load external data file: ${a}`);let r=t.headers.get("Content-Length"),l=r?parseInt(r,10):0;if(l<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw Error(`failed to load external data file: ${a}, no response body.`);let i=t.body.getReader(),e;try{e=new ArrayBuffer(l)}catch(n){if(n instanceof RangeError){let c=Math.ceil(l/65536);e=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw n}let o=0;for(;;){let{done:n,value:c}=await i.read();if(n)break;let d=c.byteLength;new Uint8Array(e,o,d).set(c),o+=d}return new Uint8Array(e,0,l)}}else return a instanceof Blob?new Uint8Array(await a.arrayBuffer()):a instanceof Uint8Array?a:new Uint8Array(a)}}),Nr,Or,Rr,wr,S6,Dr,g1,H0=y(()=>{l1(),Nr=["V","I","W","E","F"],Or=(a,t)=>{console.log(`[${Nr[a]},${new Date().toISOString()}]${t}`)},S6=(a,t)=>{Rr=a,wr=t},Dr=(a,t)=>{let r=b2(a),l=b2(Rr);r>=l&&Or(r,typeof t=="function"?t():t)},g1=(...a)=>{wr&&Dr(...a)}}),Gr,T5,O,j2,Ce,_e,Be,o1=y(()=>{Gr=class{static calcMatMulShape(a,t){return a[1]!==t[0]?void 0:[a[0],t[1]]}},T5=class{static calcShape(a,t,r=!1){let l=a.length,i=t.length;if(l===0)return t;if(i===0)return a;let e=Math.max(a.length,t.length),o=Array(e);if(r){if(l<2||i<2)return;let n=Gr.calcMatMulShape([a[l-2],a[l-1]],[t[i-2],t[i-1]]);if(n===void 0)return;[o[e-2],o[e-1]]=n}for(let n=r?3:1;n<=e;n++){let c=l-n<0?1:a[l-n],d=i-n<0?1:t[i-n];if(c!==d&&c>1&&d>1)return;let u=Math.max(c,d);if(c&&d)o[e-n]=Math.max(c,d);else{if(u>1)return;o[e-n]=0}}return o}static isValidBroadcast(a,t){let r=a.length,l=t.length;if(r>l)return!1;for(let i=1;i<=r;i++)if(a[r-i]!==1&&a[r-i]!==t[l-i])return!1;return!0}},O=class a{static size(t){return a.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let l=t.length;if(l===0)return[];let i=Array(l),e=l-1;for(;e>=0;){if(t[e]%r===0){i[e]=t[e]/r;break}if(r%t[e]!==0)throw Error("cannot convert shape");i[e]=1,r/=t[e],e--}for(e--;e>=0;e--)i[e]=t[e];return i}static sizeFromDimension(t,r){if(r<0||r>t.length)throw Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return a.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return a.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,l){let i=1;for(let e=r;e<l;e++){if(t[e]<0)throw Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=Number(t[e])}return i}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let l=Array(r);l[r-1]=1,l[r-2]=t[r-1];for(let i=r-3;i>=0;--i)l[i]=l[i+1]*t[i+1];return l}static normalizeAxis(t,r){if(t<-r&&t>=r)throw Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map((l)=>this.normalizeAxis(l,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map((l)=>t[l]):t.slice().reverse()}static padShape(t,r){let l=t.length;return t.map((i,e)=>i+r[e]+r[e+l])}static areEqual(t,r){return t.length!==r.length?!1:t.every((l,i)=>l===r[i])}},j2=class a{static adjustPoolAttributes(t,r,l,i,e,o){if(!t&&l.length!==r.length-2)throw Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let n=0;n<r.length-2;n++)n>=l.length?l.push(r[n+2]):l[n]=r[n+2];for(let n=0;n<l.length;n++)if(n<i.length){if(i[n]<0)throw Error("strides should be greater than or equal to 1")}else i.push(1);for(let n=0;n<l.length;n++)if(n<e.length){if(e[n]<0)throw Error("dilations should be greater than or equal to 1")}else e.push(1);for(let n=0;n<l.length*2;n++)if(n<o.length){if(o[n]<0)throw Error("pad should be greater than or equal to 1")}else o.push(0);for(let n=0;n<l.length;n++){if(l[n]<=0)throw Error("kernel shapes need to be greater than 0");if(o[n]>=l[n]||o[n+l.length]>=l[n])throw Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,l,i,e,o,n){if(n){if(e.length!==2*(t.length-2))throw Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw Error("length of strides should be the length of data dimensions");if(i.length!==t.length-2)throw Error("length of kernel shapes should be the length of data dimensions");for(let c=0;c<t.length-2;c++)a.adjustPadAndReturnShape(t[c+(o?1:2)],r[c],l[c],i[c],e,c,c+t.length-2,n)}}static computePoolOutputShape(t,r,l,i,e,o,n){if(r.length<=0)throw Error("input shape must be of size greater than 0");let c=[r[0],r[1]];return a.computeShapeHelper(t,r,c,l,i,e,o,n),c}static computeConvOutputShape(t,r,l,i,e,o,n){if(t.length<=0||r.length<=0)throw Error("invalid input tensor dims or invalid filter tensor dims");let c=[t[0],r[0]];return a.computeShapeHelper(!1,t,c,l,i,e,o,n),c}static computeShapeHelper(t,r,l,i,e,o,n,c){if(t)for(let d=0;d<r.length-2;d++)l.push(1);else for(let d=0;d<r.length-2;d++)l.push(a.adjustPadAndReturnShape(r[d+2],i[d],e[d],o[d],n,d,d+r.length-2,c))}static adjustPadAndReturnShape(t,r,l,i,e,o,n,c){let d=l*(i-1)+1;if(c&&c!=="NOTSET")switch(c){case"VALID":return e[o]=0,e[n]=0,Math.floor((t-d)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(l!==1)throw Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let u=((t+r-1)/r-1)*r+i-t;return e[o]=Math.floor(c==="SAME_LOWER"?(u+1)/2:u/2),e[n]=u-e[o],Math.floor((t+u-i)/r+1)}default:throw Error("Unsupported AutoPad type")}else return Math.floor((t+e[o]+e[n]-d)/r+1)}},Ce=class{static getShapeOfGemmResult(a,t,r,l,i){if(a.length!==2||r.length!==2)throw Error("shape need to be of size 2");let e,o,n;t?(e=a[1],o=a[0]):(e=a[0],o=a[1]);let c=-1;if(l?(n=r[0],c=1):(n=r[1],c=0),r[c]!==o)throw Error("dimension mismatch");if(e<=0||n<=0||o<=0)throw Error("invalid shape specified");if(i&&!T5.isValidBroadcast(i,[e,n]))throw Error("gemm: invalid bias shape for broadcast");return[e,n,o]}},_e=-340282346638528860000000000000000000000,Be=340282346638528860000000000000000000000}),M6,ze=y(()=>{l1(),M6=(a,t)=>new(Q2(t))(a)}),o3,K3,n3,Pr,h3,Fr,c3,d3,v3,Zr,Le,bg=y(()=>{l1(),H0(),o3=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),K3=(a,t)=>{if(t==="int32")return a;let r=o3.get(t);if(!r)throw Error(`WebNN backend does not support data type: ${t}`);let l=r/8;if(a.byteLength%l!==0)throw Error(`Invalid Uint8Array length - must be a multiple of ${l}.`);let i=a.byteLength/l,e=new(Q2(t))(a.buffer,a.byteOffset,i);switch(t){case"int64":case"uint64":{let o=new Int32Array(i);for(let n=0;n<i;n++){let c=e[n];if(c>2147483647n||c<-2147483648n)throw Error("Can not convert int64 data to int32 - value out of range.");o[n]=Number(c)}return new Uint8Array(o.buffer)}case"int8":case"uint8":case"uint32":{if(t==="uint32"&&e.some((n)=>n>2147483647))throw Error("Can not convert uint32 data to int32 - value out of range.");let o=Int32Array.from(e,Number);return new Uint8Array(o.buffer)}default:throw Error(`Unsupported data conversion from ${t} to 'int32'`)}},n3=(a,t)=>{if(t==="int32")return a;if(a.byteLength%4!==0)throw Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let r=a.byteLength/4,l=new Int32Array(a.buffer,a.byteOffset,r);switch(t){case"int64":{let i=BigInt64Array.from(l,BigInt);return new Uint8Array(i.buffer)}case"uint64":{if(l.some((e)=>e<0))throw Error("Can not convert int32 data to uin64 - negative value found.");let i=BigUint64Array.from(l,BigInt);return new Uint8Array(i.buffer)}case"int8":{if(l.some((e)=>e<-128||e>127))throw Error("Can not convert int32 data to int8 - value out of range.");let i=Int8Array.from(l,Number);return new Uint8Array(i.buffer)}case"uint8":{if(l.some((i)=>i<0||i>255))throw Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(l,Number)}case"uint32":{if(l.some((e)=>e<0))throw Error("Can not convert int32 data to uint32 - negative value found.");let i=Uint32Array.from(l,Number);return new Uint8Array(i.buffer)}default:throw Error(`Unsupported data conversion from 'int32' to ${t}`)}},Pr=1,h3=()=>Pr++,Fr=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),c3=(a,t)=>{let r=o3.get(a);if(!r)throw Error(`WebNN backend does not support data type: ${a}`);return t.length>0?Math.ceil(t.reduce((l,i)=>l*i)*r/8):0},d3=class{constructor(a){this.isDataConverted=!1;let{sessionId:t,context:r,tensor:l,dataType:i,shape:e,fallbackDataType:o}=a;this.sessionId=t,this.mlContext=r,this.mlTensor=l,this.dataType=i,this.tensorShape=e,this.fallbackDataType=o}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return c3(this.dataType,this.tensorShape)}destroy(){g1("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(a){this.mlContext.writeTensor(this.mlTensor,a)}async read(a){if(this.fallbackDataType){let t=await this.mlContext.readTensor(this.mlTensor),r=n3(new Uint8Array(t),this.dataType);if(a){(a instanceof ArrayBuffer?new Uint8Array(a):new Uint8Array(a.buffer,a.byteOffset,a.byteLength)).set(r);return}else return r.buffer}else return a?this.mlContext.readTensor(this.mlTensor,a):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(a,t,r){return this.mlContext===a&&this.dataType===t&&this.tensorShape.length===r.length&&this.tensorShape.every((l,i)=>l===r[i])}setIsDataConverted(a){this.isDataConverted=a}},v3=class{constructor(a,t){this.tensorManager=a,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(a,t,r,l){let i=this.tensorManager.getMLContext(a),e=this.tensorManager.getMLOpSupportLimits(a),o;if(!e?.input.dataTypes.includes(t)){if(o=Fr.get(t),!o||e?.input.dataTypes.includes(o))throw Error(`WebNN backend does not support data type: ${t}`);g1("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${t} to ${o}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(i,t,r))return this.wrapper.tensor;if(l){if(this.wrapper.byteLength!==c3(t,r))throw Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let n=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(a,t,r,n,!0,!0,o),l&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(a){let t=a;if(this.wrapper){if(this.wrapper.fallbackType)if(this.wrapper.fallbackType==="int32")t=K3(a,this.wrapper.type),this.wrapper.setIsDataConverted(!0);else throw Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);if(a.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else g1("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(a){if(this.activeUpload){let t=this.wrapper?.isDataConverted?n3(this.activeUpload,this.wrapper?.type):this.activeUpload;if(a){a instanceof ArrayBuffer?new Uint8Array(a).set(t):new Uint8Array(a.buffer,a.byteOffset,a.byteLength).set(t);return}else return t.buffer}if(!this.wrapper)throw Error("Tensor has not been created.");return a?this.wrapper.read(a):this.wrapper.read()}},Zr=class{constructor(a){this.backend=a,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(a){let t=this.backend.getMLContext(a);if(!t)throw Error("MLContext not found for session.");return t}getMLOpSupportLimits(a){return this.backend.getMLOpSupportLimits(a)}reserveTensorId(){let a=h3();return this.tensorTrackersById.set(a,new v3(this)),a}releaseTensorId(a){let t=this.tensorTrackersById.get(a);t&&(this.tensorTrackersById.delete(a),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(a,t,r,l,i){g1("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${r}, shape: ${l}, copyOld: ${i}}`);let e=this.tensorTrackersById.get(t);if(!e)throw Error("Tensor not found.");return e.ensureTensor(a,r,l,i)}upload(a,t){let r=this.tensorTrackersById.get(a);if(!r)throw Error("Tensor not found.");r.upload(t)}async download(a,t){g1("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${a}, dstBuffer: ${t?.byteLength}}`);let r=this.tensorTrackersById.get(a);if(!r)throw Error("Tensor not found.");return r.download(t)}releaseTensorsForSession(a){for(let t of this.freeTensors)t.sessionId===a&&t.destroy();this.freeTensors=this.freeTensors.filter((t)=>t.sessionId!==a)}registerTensor(a,t,r,l){let i=this.getMLContext(a),e=h3(),o=new d3({sessionId:a,context:i,tensor:t,dataType:r,shape:l});return this.tensorTrackersById.set(e,new v3(this,o)),this.externalTensors.add(o),e}async getCachedTensor(a,t,r,l,i,e,o){let n=this.getMLContext(a);for(let[d,u]of this.freeTensors.entries())if(u.canReuseTensor(n,t,r)){g1("verbose",()=>`[WebNN] Reusing tensor {dataType: ${t}, ${o?`fallbackDataType: ${o},`:""} shape: ${r}`);let g=this.freeTensors.splice(d,1)[0];return g.sessionId=a,g}g1("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, ${o?`fallbackDataType: ${o},`:""} shape: ${r}}`);let c=await n.createTensor({dataType:o??t,shape:r,dimensions:r,usage:l,writable:i,readable:e});return new d3({sessionId:a,context:n,tensor:c,dataType:t,shape:r,fallbackDataType:o})}releaseTensor(a){this.externalTensors.has(a)&&this.externalTensors.delete(a),this.freeTensors.push(a)}},Le=(...a)=>new Zr(...a)}),P5,yr,He,jg=y(()=>{l1(),n5(),ze(),bg(),H0(),P5=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),yr=(a,t)=>{if(a===t)return!0;if(a===void 0||t===void 0)return!1;let r=Object.keys(a).sort(),l=Object.keys(t).sort();return r.length===l.length&&r.every((i,e)=>i===l[e]&&a[i]===t[i])},He=class{constructor(a){this.tensorManager=Le(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.sessionGraphOutputs=new Map,this.temporaryGraphInputs=[],this.temporaryGraphOutputs=[],this.temporarySessionTensorIds=new Map,this.mlOpSupportLimitsBySessionId=new Map,S6(a.logLevel,!!a.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw Error("No active session");return this.activeSessionId}onRunStart(a){g1("verbose",()=>`[WebNN] onRunStart {sessionId: ${a}}`),this.activeSessionId=a}onRunEnd(a){g1("verbose",()=>`[WebNN] onRunEnd {sessionId: ${a}}`);let t=this.temporarySessionTensorIds.get(a);if(t){for(let r of t)g1("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${r}}`),this.tensorManager.releaseTensorId(r);this.temporarySessionTensorIds.delete(a),this.activeSessionId=void 0}}async createMLContext(a){if(a instanceof GPUDevice){let r=this.mlContextCache.findIndex((l)=>l.gpuDevice===a);if(r!==-1)return this.mlContextCache[r].mlContext;{let l=await navigator.ml.createContext(a);return this.mlContextCache.push({gpuDevice:a,mlContext:l}),l}}else if(a===void 0){let r=this.mlContextCache.findIndex((l)=>l.options===void 0&&l.gpuDevice===void 0);if(r!==-1)return this.mlContextCache[r].mlContext;{let l=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:l}),l}}let t=this.mlContextCache.findIndex((r)=>yr(r.options,a));if(t!==-1)return this.mlContextCache[t].mlContext;{let r=await navigator.ml.createContext(a);return this.mlContextCache.push({options:a,mlContext:r}),r}}registerMLContext(a,t){this.mlContextBySessionId.set(a,t);let r=this.sessionIdsByMLContext.get(t);r||(r=new Set,this.sessionIdsByMLContext.set(t,r)),r.add(a),this.mlOpSupportLimitsBySessionId.has(a)||this.mlOpSupportLimitsBySessionId.set(a,t.opSupportLimits()),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(a,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(a,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(a){this.sessionGraphInputs.delete(a),this.sessionGraphOutputs.delete(a);let t=this.mlContextBySessionId.get(a);if(!t)return;this.tensorManager.releaseTensorsForSession(a),this.mlContextBySessionId.delete(a),this.mlOpSupportLimitsBySessionId.delete(a);let r=this.sessionIdsByMLContext.get(t);if(r.delete(a),r.size===0){this.sessionIdsByMLContext.delete(t);let l=this.mlContextCache.findIndex((i)=>i.mlContext===t);l!==-1&&this.mlContextCache.splice(l,1)}}getMLContext(a){return this.mlContextBySessionId.get(a)}getMLOpSupportLimits(a){return this.mlOpSupportLimitsBySessionId.get(a)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(a){g1("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${a}}`),this.tensorManager.releaseTensorId(a)}async ensureTensor(a,t,r,l,i){let e=P5.get(r);if(!e)throw Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(a??this.currentSessionId,t,e,l,i)}async createTemporaryTensor(a,t,r){g1("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${r}}`);let l=P5.get(t);if(!l)throw Error(`Unsupported ONNX data type: ${t}`);let i=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(a,i,l,r,!1);let e=this.temporarySessionTensorIds.get(a);return e?e.push(i):this.temporarySessionTensorIds.set(a,[i]),i}uploadTensor(a,t){if(!f1().shouldTransferToMLTensor)throw Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");g1("verbose",()=>`[WebNN] uploadTensor {tensorId: ${a}, data: ${t.byteLength}}`),this.tensorManager.upload(a,t)}async downloadTensor(a,t){return this.tensorManager.download(a,t)}createMLTensorDownloader(a,t){return async()=>{let r=await this.tensorManager.download(a);return M6(r,t)}}registerMLTensor(a,t,r,l){let i=P5.get(r);if(!i)throw Error(`Unsupported ONNX data type: ${r}`);let e=this.tensorManager.registerTensor(a,t,i,l);return g1("verbose",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${i}, dimensions: ${l}} -> {tensorId: ${e}}`),e}registerMLConstant(a,t,r,l,i,e,o=!1){if(!e)throw Error("External mounted files are not available.");let n=a;a.startsWith("./")&&(n=a.substring(2));let c=e.get(n);if(!c)throw Error(`File with name ${n} not found in preloaded files.`);if(t+r>c.byteLength)throw Error("Out of bounds: data offset and length exceed the external file data size.");let d=c.slice(t,t+r).buffer,u;switch(i.dataType){case"float32":u=new Float32Array(d);break;case"float16":u=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(d):new Uint16Array(d);break;case"int32":u=new Int32Array(d);break;case"uint32":u=new Uint32Array(d);break;case"int64":if(o){let g=K3(new Uint8Array(d),"int64");u=new Int32Array(g.buffer),i.dataType="int32"}else u=new BigInt64Array(d);break;case"uint64":u=new BigUint64Array(d);break;case"int8":u=new Int8Array(d);break;case"int4":case"uint4":case"uint8":u=new Uint8Array(d);break;default:throw Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`)}return g1("verbose",()=>`[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}} ${o?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),l.constant(i,u)}registerGraphInput(a){this.temporaryGraphInputs.push(a)}registerGraphOutput(a){this.temporaryGraphOutputs.push(a)}isGraphInput(a,t){let r=this.sessionGraphInputs.get(a);return r?r.includes(t):!1}isGraphOutput(a,t){let r=this.sessionGraphOutputs.get(a);return r?r.includes(t):!1}isGraphInputOutputTypeSupported(a,t,r=!0){let l=P5.get(a5(t)),i=this.mlOpSupportLimitsBySessionId.get(a);return typeof l>"u"?!1:r?!!i?.input.dataTypes.includes(l):!!i?.output.dataTypes.includes(l)}flush(){}}}),A6=y(()=>{}),u3,H2,V2,br,jr,g3,q3,Ur,Ve,Ug=y(()=>{H0(),A6(),u3=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),H2=[],V2=(a)=>Math.ceil(Number(a)/16)*16,br=(a)=>{for(let t=0;t<H2.length;t++){let r=H2[t];if(a<=r)return r}return Math.ceil(a/16)*16},jr=1,g3=()=>jr++,q3=async(a,t,r,l)=>{let i=V2(r),e=a.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=a.getCommandEncoder();a.endComputePass(),o.copyBufferToBuffer(t,0,e,0,i),a.flush(),await e.mapAsync(GPUMapMode.READ);let n=e.getMappedRange();if(l){let c=l();return c.set(new Uint8Array(n,0,r)),c}else return new Uint8Array(n.slice(0,r))}finally{e.destroy()}},Ur=class{constructor(a){this.backend=a,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[t]of u3)H2.push(t),this.freeBuffers.set(t,[]),this.freeUniformBuffers.set(t,[]);this.sessionCount=0}upload(a,t){let{buffer:r,byteOffset:l,byteLength:i}=t,e=V2(i),o=this.storageCache.get(a);if(!o)throw Error("gpu data for uploading does not exist");if(Number(o.originalSize)!==i)throw Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${i}`);let n=this.backend.device.createBuffer({mappedAtCreation:!0,size:e,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),c=n.getMappedRange();new Uint8Array(c).set(new Uint8Array(r,l,i)),n.unmap();let d=this.backend.device.createCommandEncoder();d.copyBufferToBuffer(n,0,o.gpuData.buffer,0,e),this.backend.device.queue.submit([d.finish()]),n.destroy(),g1("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${a})`)}memcpy(a,t){let r=this.storageCache.get(a);if(!r)throw Error("source gpu data for memcpy does not exist");let l=this.storageCache.get(t);if(!l)throw Error("destination gpu data for memcpy does not exist");if(r.originalSize!==l.originalSize)throw Error("inconsistent source and destination gpu data size");let i=V2(r.originalSize),e=this.backend.getCommandEncoder();this.backend.endComputePass(),e.copyBufferToBuffer(r.gpuData.buffer,0,l.gpuData.buffer,0,i)}registerExternalBuffer(a,t,r){let l;if(r){if(l=r[0],a===r[1])return g1("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${l}, buffer is the same, skip.`),l;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else l=g3();return this.storageCache.set(l,{gpuData:{id:l,type:0,buffer:a},originalSize:t}),g1("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${l}, registered.`),l}unregisterExternalBuffer(a){a!==void 0&&(this.storageCache.delete(a),g1("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${a}`))}create(a,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let r=br(a),l,i=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,e=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||e){let n=(i?this.freeBuffers:this.freeUniformBuffers).get(r);n?n.length>0?l=n.pop():l=this.backend.device.createBuffer({size:r,usage:t}):l=this.backend.device.createBuffer({size:r,usage:t})}else l=this.backend.device.createBuffer({size:r,usage:t});let o={id:g3(),type:0,buffer:l};return this.storageCache.set(o.id,{gpuData:o,originalSize:Number(a)}),g1("verbose",()=>`[WebGPU] GpuDataManager.create(size=${a}) => id=${o.id}`),o}get(a){return this.storageCache.get(a)?.gpuData}release(a){let t=typeof a=="bigint"?Number(a):a,r=this.storageCache.get(t);if(!r){if(this.storageCache.size===0)return 0;throw Error("releasing data does not exist")}return g1("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(a,t){let r=this.storageCache.get(Number(a));if(!r)throw Error("data does not exist");await q3(this.backend,r.gpuData.buffer,r.originalSize,t)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let a of this.buffersPending){let t=u3.get(a.size);if((a.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let r=this.freeBuffers.get(a.size)||[];t===void 0||r.length>=t?a.destroy():r.push(a)}else if((a.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let r=this.freeUniformBuffers.get(a.size)||[];t===void 0||r.length>=t?a.destroy():r.push(a)}else a.destroy()}this.buffersPending=[]}else{let a=this.capturedPendingBuffers.get(this.backend.currentSessionId);a||(a=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,a));for(let t of this.buffersPending)a.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach((a)=>{a.forEach((t)=>{t.destroy()})}),this.freeUniformBuffers.forEach((a)=>{a.forEach((t)=>{t.destroy()})}),this.storageCache.forEach((a)=>{a.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach((a)=>{a.forEach((t)=>{t.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(a){let t=this.capturedPendingBuffers.get(a);t&&(t.forEach((r)=>{r.destroy()}),this.capturedPendingBuffers.delete(a)),this.sessionCount-=1,this.sessionCount===0&&(g1("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach((r)=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Ve=(...a)=>new Ur(...a)}),Wr,T1,V1=y(()=>{Wr=class{constructor(a){Object.assign(this,a)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((a)=>`${this[a]}`).join(";")),this.key}},T1=(a)=>new Wr(a)}),E5,k2,w1,Z1,J,H1,Y3,A5,y0,X,F5,w,Q,ke,T6,Kr,Ne,h1=y(()=>{l1(),o1(),E5=64,k2=(a,t)=>{if(t===3)throw Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(a)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw Error(`Unknown data type: ${a}`)}},w1=(a,t=1)=>{let r=k2(a,t);return typeof r=="string"?r:r[0]},Z1=(a,t=1)=>{let r=k2(a,t);return typeof r=="string"?r:r[1]},J=(...a)=>{let t=[];return a.forEach((r)=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:O.computeStrides(r)})}),t},H1=(a)=>a%4===0?4:a%2===0?2:1,Y3=(a="f32",t,r="0")=>!t||t===1?`${a}(${r})`:`vec${t}<${a}>(${r})`,A5=(a,t,r)=>a==="f32"?r:t===1?`f32(${r})`:`vec${t}<f32>(${r})`,y0=(a,t)=>t===4?`(${a}.x + ${a}.y + ${a}.z + ${a}.w)`:t===2?`(${a}.x + ${a}.y)`:t===3?`(${a}.x + ${a}.y + ${a}.z)`:a,X=(a,t,r,l)=>a.startsWith("uniforms.")&&r>4?typeof t=="string"?l==="f16"?`${a}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${a}[(${t}) / 4][(${t}) % 4]`:l==="f16"?`${a}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${a}[${Math.floor(t/4)}][${t%4}]`:r>1?`${a}[${t}]`:a,F5=(a,t,r,l,i)=>{let e=typeof r=="number",o=e?r:r.length,n=[...Array(o).keys()],c=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,d=k2(t,i),u=typeof d=="string"?d:d[1],g=typeof d=="string"?d:d[0],s={indices:c,value:u,storage:g,tensor:t},M=(D)=>typeof D=="string"?D:`${D}u`,A={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},E=e?"uniforms.":"",x=`${E}${a}_shape`,m=`${E}${a}_strides`,T="";for(let D=0;D<o-1;D++)T+=`
    let dim${D} = current / ${X(m,D,o)};
    let rest${D} = current % ${X(m,D,o)};
    indices[${D}] = dim${D};
    current = rest${D};
    `;T+=`indices[${o-1}] = current;`;let _=o<2?"":`
  fn o2i_${a}(offset: u32) -> ${s.indices} {
    var indices: ${s.indices};
    var current = offset;
    ${T}
    return indices;
  }`,C=(D)=>(A.offsetToIndices=!0,o<2?D:`o2i_${a}(${D})`),z=[];if(o>=2)for(let D=o-1;D>=0;D--)z.push(`${X(m,D,o)} * (indices[${D}])`);let L=o<2?"":`
  fn i2o_${a}(indices: ${s.indices}) -> u32 {
    return ${z.join("+")};
  }`,H=(D)=>(A.indicesToOffset=!0,o<2?D:`i2o_${a}(${D})`),I=(...D)=>o===0?"0u":`${s.indices}(${D.map(M).join(",")})`,N=(D,W)=>o<2?`${D}`:`${X(D,W,o)}`,P=(D,W,t1)=>o<2?`${D}=${t1};`:`${X(D,W,o)}=${t1};`,b={},G=(D,W)=>{A.broadcastedIndicesToOffset=!0;let t1=`${W.name}broadcastedIndicesTo${a}Offset`;if(t1 in b)return`${t1}(${D})`;let s1=[];for(let R1=o-1;R1>=0;R1--){let q1=W.indicesGet("outputIndices",R1+W.rank-o);s1.push(`${N(m,R1)} * (${q1} % ${N(x,R1)})`)}return b[t1]=`fn ${t1}(outputIndices: ${W.type.indices}) -> u32 {
             return ${s1.length>0?s1.join("+"):"0u"};
           }`,`${t1}(${D})`},j=(D,W)=>(()=>{if(s.storage===s.value)return`${a}[${D}]=${W};`;if(s.storage==="vec2<u32>"&&s.value==="i32")return`${a}[${D}]=vec2<u32>(u32(${W}), select(0u, 0xFFFFFFFFu, ${W} < 0));`;if(s.storage==="vec2<u32>"&&s.value==="u32")return`${a}[${D}]=vec2<u32>(u32(${W}), 0u);`;if(s.storage==="u32"&&s.value==="vec4<bool>")return`${a}[${D}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${W}));`;throw Error(`not supported combination of storage type ${s.storage} and value type ${s.value} yet`)})(),e1=(D)=>(()=>{if(s.storage===s.value)return`${a}[${D}]`;if(s.storage==="vec2<u32>"&&s.value==="i32")return`i32(${a}[${D}].x)`;if(s.storage==="vec2<u32>"&&s.value==="u32")return`u32(${a}[${D}].x)`;if(s.storage==="u32"&&s.value==="vec4<bool>")return`vec4<bool>(bool(${a}[${D}] & 0xFFu), bool(${a}[${D}] & 0xFF00u), bool(${a}[${D}] & 0xFF0000u), bool(${a}[${D}] & 0xFF000000u))`;throw Error(`not supported combination of storage type ${s.storage} and value type ${s.value} yet`)})(),V=o<2?"":`
  fn get_${a}ByIndices(indices: ${s.indices}) -> ${u} {
    return ${e1(`i2o_${a}(indices)`)};
  }`,F=o<2?"":(()=>{let D=n.map((t1)=>`d${t1}: u32`).join(", "),W=n.map((t1)=>`d${t1}`).join(", ");return`
  fn get_${a}(${D}) -> ${u} {
    return get_${a}ByIndices(${I(W)});
  }`})(),a1=(...D)=>{if(D.length!==o)throw Error(`indices length must be ${o}`);let W=D.map(M).join(",");return o===0?e1("0u"):o===1?e1(W[0]):(A.get=!0,A.getByIndices=!0,A.indicesToOffset=!0,`get_${a}(${W})`)},$=(D)=>o<2?e1(D):(A.getByIndices=!0,A.indicesToOffset=!0,`get_${a}ByIndices(${D})`),Y=o<2?"":`
  fn set_${a}ByIndices(indices: ${s.indices}, value: ${u}) {
    ${j(`i2o_${a}(indices)`,"value")}
  }`,i1=o<2?"":(()=>{let D=n.map((t1)=>`d${t1}: u32`).join(", "),W=n.map((t1)=>`d${t1}`).join(", ");return`
  fn set_${a}(${D}, value: ${u}) {
    set_${a}ByIndices(${I(W)}, value);
  }`})();return{impl:()=>{let D=[],W=!1;return A.offsetToIndices&&(D.push(_),W=!0),A.indicesToOffset&&(D.push(L),W=!0),A.broadcastedIndicesToOffset&&(Object.values(b).forEach((t1)=>D.push(t1)),W=!0),A.set&&(D.push(i1),W=!0),A.setByIndices&&(D.push(Y),W=!0),A.get&&(D.push(F),W=!0),A.getByIndices&&(D.push(V),W=!0),!e&&W&&D.unshift(`const ${x} = ${s.indices}(${r.join(",")});`,`const ${m} = ${s.indices}(${O.computeStrides(r).join(",")});`),D.join(`
`)},type:s,offsetToIndices:C,indicesToOffset:H,broadcastedIndicesToOffset:G,indices:I,indicesGet:N,indicesSet:P,set:(...D)=>{if(D.length!==o+1)throw Error(`indices length must be ${o}`);let W=D[o];if(typeof W!="string")throw Error("value must be string");let t1=D.slice(0,o).map(M).join(",");return o===0?j("0u",W):o===1?j(t1[0],W):(A.set=!0,A.setByIndices=!0,A.indicesToOffset=!0,`set_${a}(${t1}, ${W})`)},setByOffset:j,setByIndices:(D,W)=>o<2?j(D,W):(A.setByIndices=!0,A.indicesToOffset=!0,`set_${a}ByIndices(${D}, ${W});`),get:a1,getByOffset:e1,getByIndices:$,usage:l,name:a,strides:m,shape:x,rank:o}},w=(a,t,r,l=1)=>F5(a,t,r,"input",l),Q=(a,t,r,l=1)=>F5(a,t,r,"output",l),ke=(a,t,r)=>F5(a,t,r,"atomicOutput",1),T6=(a,t,r,l=1)=>F5(a,t,r,"internal",l),Kr=class{constructor(a,t){this.normalizedDispatchGroup=a,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(a){return`if (global_idx >= ${typeof a=="number"?`${a}u`:a}) { return; }`}mainStart(a=E5){let t=typeof a=="number"?a:a[0],r=typeof a=="number"?1:a[1],l=typeof a=="number"?1:a[2];if(t>this.limits.maxComputeWorkgroupSizeX||r>this.limits.maxComputeWorkgroupSizeY||l>this.limits.maxComputeWorkgroupSizeZ)throw Error(`workgroup size [${t}, ${r}, ${l}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*r*l>this.limits.maxComputeInvocationsPerWorkgroup)throw Error(`workgroup size [${t}, ${r}, ${l}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,e=i?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,o=i?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${t*r*l}u + local_idx;`;return`@compute @workgroup_size(${t}, ${r}, ${l})
  fn main(${e}) {
    ${o}
  `}appendVariableUniforms(a){a.rank!==0&&(a.shape.startsWith("uniforms.")&&this.uniforms.push({name:a.shape.replace("uniforms.",""),type:"u32",length:a.rank}),a.strides.startsWith("uniforms.")&&this.uniforms.push({name:a.strides.replace("uniforms.",""),type:"u32",length:a.rank}))}declareVariable(a,t){if(a.usage==="internal")throw Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(a),this.appendVariableUniforms(a);let r=a.usage==="input"?"read":"read_write",l=a.usage==="atomicOutput"?"atomic<i32>":a.type.storage;return`@group(0) @binding(${t}) var<storage, ${r}> ${a.name}: array<${l}>;`}declareVariables(...a){return a.map((t)=>this.declareVariable(t,this.variableIndex++)).join(`
`)}registerInternalVariable(a){if(a.usage!=="internal")throw Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(a),this.appendVariableUniforms(a)}registerInternalVariables(...a){return a.forEach((t)=>this.registerInternalVariable(t)),this}registerUniform(a,t,r=1){return this.uniforms.push({name:a,type:t,length:r}),this}registerUniforms(a){return this.uniforms=this.uniforms.concat(a),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let a=[];for(let{name:t,type:r,length:l}of this.uniforms)if(l&&l>4)r==="f16"?a.push(`@align(16) ${t}:array<mat2x4<${r}>, ${Math.ceil(l/8)}>`):a.push(`${t}:array<vec4<${r}>, ${Math.ceil(l/4)}>`);else{let i=l==null||l===1?r:`vec${l}<${r}>`;a.push(`${t}:${i}`)}return`
      struct Uniforms { ${a.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map((a)=>a.impl()).join(`
`)+this.internalVariables.map((a)=>a.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let a=(t)=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(t)];return this.uniforms.map((t)=>[a(t.type),t.length??1])}},Ne=(a,t)=>new Kr(a,t)}),qr,s3,Yr,Qr,Xr,Jr,$1,Oe,Re,b0=y(()=>{l1(),o1(),V1(),h1(),qr=(a,t)=>{if(!a||a.length!==1)throw Error("Transpose requires 1 input.");if(t.length!==0&&t.length!==a[0].dims.length)throw Error(`perm size ${t.length} does not match input rank ${a[0].dims.length}`)},s3=(a,t)=>t.length!==0?t:[...Array(a).keys()].reverse(),Yr=(a,t)=>O.sortBasedOnPerm(a,s3(a.length,t)),Qr=(a,t,r,l)=>{let i=`fn perm(i: ${l.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`;for(let e=0;e<t;++e)i+=`a[${a[e]}]=i[${e}];`;return i+="return a;}"},Xr=(a,t)=>{let r=[],l=[];for(let i=0;i<a.length;++i)a[i]!==1&&r.push(a[i]),a[t[i]]!==1&&l.push(t[i]);return{newShape:r,newPerm:l}},Jr=(a,t)=>{let r=0;for(let l=0;l<a.length;++l)if(t[a[l]]!==1){if(a[l]<r)return!1;r=a[l]}return!0},$1=(a,t)=>{let r=a.dataType,l=a.dims.length,i=s3(l,t),e=Yr(a.dims,i),o=a.dims,n=e,c=l<2||Jr(i,a.dims),d;if(c)return d=(A)=>{let E=w("input",r,o,4),x=Q("output",r,n,4);return`
  ${A.registerUniform("output_size","u32").declareVariables(E,x)}
  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let A=O.size(e);return{outputs:[{dims:e,dataType:a.dataType}],dispatchGroup:{x:Math.ceil(A/64/4)},programUniforms:[{type:12,data:Math.ceil(A/4)}]}},getShaderSource:d};let{newShape:u,newPerm:g}=Xr(a.dims,i),s=O.areEqual(g,[2,3,1]),M=O.areEqual(g,[3,1,2]);if(u.length===2||s||M){o=s?[u[0],u[1]*u[2]]:M?[u[0]*u[1],u[2]]:u,n=[o[1],o[0]];let A=16;return d=(E)=>{let x=w("a",r,o.length),m=Q("output",r,n.length);return`
  ${E.registerUniform("output_size","u32").declareVariables(x,m)}
  var<workgroup> tile : array<array<${m.type.value}, ${A+1}>, ${A}>;
  ${E.mainStart([A,A,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${A} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${A}u + local_id.x;
    let input_row = workgroup_id_x * ${A}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${x.getByIndices(`${x.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${A}u + local_id.x;
    let output_row = workgroup_id_y * ${A}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${m.setByIndices(`${m.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let E=O.size(e);return{outputs:[{dims:e,dataType:a.dataType}],dispatchGroup:{x:Math.ceil(n[1]/A),y:Math.ceil(n[0]/A)},programUniforms:[{type:12,data:E},...J(o,n)]}},getShaderSource:d}}return d=(A)=>{let E=w("a",r,o.length),x=Q("output",r,n.length);return`
  ${A.registerUniform("output_size","u32").declareVariables(E,x)}

  ${Qr(i,l,E,x)}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${x.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${x.setByOffset("global_idx",E.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let A=O.size(e);return{outputs:[{dims:e,dataType:a.dataType}],dispatchGroup:{x:Math.ceil(A/64)},programUniforms:[{type:12,data:A},...J(o,n)]}},getShaderSource:d}},Oe=(a,t)=>{qr(a.inputs,t.perm),a.compute($1(a.inputs[0],t.perm))},Re=(a)=>T1({perm:a.perm})}),$r,a9,t9,r9,l9,i9,e9,o9,n9,h9,o0,we,De,Ge,Pe,Fe,Ze,ye,be,je,Ue,Wg=y(()=>{l1(),o1(),h1(),E6(),b0(),$r={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},a9={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},t9={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},r9={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},l9=(a,t)=>{let r=[];for(let l=t-a;l<t;++l)r.push(l);return r},i9=(a,t)=>{let r=[],l=a.length;for(let e=0;e<l;e++)t.indexOf(e)===-1&&r.push(a[e]);let i=t.map((e)=>a[e]);return[r,i]},e9=(a,t)=>{let r=a.length+t.length,l=[],i=0;for(let e=0;e<r;e++)t.indexOf(e)===-1?l.push(a[i++]):l.push(1);return l},o9=(a,t)=>{for(let r=0;r<a.length;++r)if(a[a.length-r-1]!==t-1-r)return!1;return!0},n9=(a,t)=>{let r=[];if(!o9(a,t)){for(let l=0;l<t;++l)a.indexOf(l)===-1&&r.push(l);a.forEach((l)=>r.push(l))}return r},h9=(a,t,r,l,i,e,o)=>{let n=r[0].dims,c=O.size(e),d=O.size(o),u=w("_A",r[0].dataType,n),g=Q("output",i,e),s=64;c===1&&(s=256);let M=`
          var<workgroup> aBestValues : array<f32, ${s}>;
       `,A=(E)=>`
        ${E.registerUniform("reduceSize","u32").declareVariables(u,g)}
        ${M}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${E.mainStart(s)}

          let outputIndex = global_idx / ${s};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${t9[l]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${s}) {
           let candidate = f32(${u.getByOffset("offset + k")});
           bestValue = ${$r[l]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${a9[l]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${g.setByOffset("outputIndex",`${l==="mean"?`${g.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${g.type.storage}(${r9[l]})`}`)};
         }
        }`;return{name:a,shaderCache:{hint:`${t};${s}`,inputDependencies:["type"]},getShaderSource:A,getRunData:()=>({outputs:[{dims:e,dataType:i}],dispatchGroup:{x:c},programUniforms:[{type:12,data:d}]})}},o0=(a,t,r,l)=>{let i=a.inputs.length===1?r:Q3(a.inputs,r),e=i.axes;e.length===0&&!i.noopWithEmptyAxes&&(e=a.inputs[0].dims.map((M,A)=>A));let o=O.normalizeAxes(e,a.inputs[0].dims.length),n=o,c=a.inputs[0],d=n9(n,a.inputs[0].dims.length);d.length>0&&(c=a.compute($1(a.inputs[0],d),{inputs:[0],outputs:[-1]})[0],n=l9(n.length,c.dims.length));let[u,g]=i9(c.dims,n),s=u;i.keepDims&&(s=e9(u,o)),a.compute(h9(t,i.cacheKey,[c],l,a.inputs[0].dataType,s,g),{inputs:[c]})},we=(a,t)=>{o0(a,"ReduceMeanShared",t,"mean")},De=(a,t)=>{o0(a,"ReduceL1Shared",t,"l1")},Ge=(a,t)=>{o0(a,"ReduceL2Shared",t,"l2")},Pe=(a,t)=>{o0(a,"ReduceLogSumExpShared",t,"logSumExp")},Fe=(a,t)=>{o0(a,"ReduceMaxShared",t,"max")},Ze=(a,t)=>{o0(a,"ReduceMinShared",t,"min")},ye=(a,t)=>{o0(a,"ReduceProdShared",t,"prod")},be=(a,t)=>{o0(a,"ReduceSumShared",t,"sum")},je=(a,t)=>{o0(a,"ReduceSumSquareShared",t,"sumSquare")},Ue=(a,t)=>{o0(a,"ReduceLogSumShared",t,"logSum")}}),n0,c9,U2,Q3,h0,d9,v9,u9,g9,s9,p9,S9,M9,A9,T9,c0,We,Ke,qe,Ye,Qe,Xe,Je,$e,ao,to,E6=y(()=>{l1(),o1(),V1(),h1(),Wg(),n0=(a)=>{if(!a||a.length===0||a.length>2)throw Error("Reduce op requires 1 or 2 inputs.");if(a.length===2&&a[1].dims.length!==1)throw Error("Invalid axes input dims.")},c9=(a)=>["","",`var value = ${a.getByIndices("input_indices")};`,""],U2=(a,t,r,l,i,e,o=!1,n=!1)=>{let c=[],d=r[0].dims,u=d.length,g=O.normalizeAxes(i,u),s=!n&&g.length===0;d.forEach((E,x)=>{s||g.indexOf(x)>=0?o&&c.push(1):c.push(E)});let M=c.length,A=O.size(c);return{name:a,shaderCache:t,getShaderSource:(E)=>{let x=[],m=w("_A",r[0].dataType,u),T=Q("output",e,M),_=l(m,T,g),C=_[2];for(let z=0,L=0;z<u;z++)s||g.indexOf(z)>=0?(o&&L++,C=`for(var j${z}: u32 = 0; j${z} < ${d[z]}; j${z}++) {
                  ${_[2].includes("last_index")?`let last_index = j${z};`:""}
                  ${m.indicesSet("input_indices",z,`j${z}`)}
                  ${C}
                }`):(x.push(`${m.indicesSet("input_indices",z,T.indicesGet("output_indices",L))};`),L++);return`

        ${E.registerUniform("output_size","u32").declareVariables(m,T)}

        ${E.mainStart()}
          ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${m.type.indices};
          let output_indices = ${T.offsetToIndices("global_idx")};

          ${x.join(`
`)}
          ${_[0]}       // init ops for reduce max/min
          ${_[1]}
          ${C}
          ${_[3]}
          ${_.length===4?T.setByOffset("global_idx","value"):_.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:c,dataType:e}],dispatchGroup:{x:Math.ceil(A/64)},programUniforms:[{type:12,data:A},...J(d,c)]})}},Q3=(a,t)=>{let r=[];return a[1].dims[0]>0&&a[1].getBigInt64Array().forEach((l)=>r.push(Number(l))),T1({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},h0=(a,t,r,l)=>{let i=a.inputs,e=i.length===1?r:Q3(i,r);a.compute(U2(t,{hint:e.cacheKey,inputDependencies:["rank"]},[i[0]],e.noopWithEmptyAxes&&e.axes.length===0?c9:l,e.axes,i[0].dataType,e.keepDims,e.noopWithEmptyAxes),{inputs:[0]})},d9=(a,t)=>{n0(a.inputs),h0(a,"ReduceLogSum",t,(r,l)=>[`var value = ${l.type.storage}(0);`,"",`value += ${r.getByIndices("input_indices")};`,"value = log(value);"])},v9=(a,t)=>{n0(a.inputs),h0(a,"ReduceL1",t,(r,l)=>[`var value = ${l.type.storage}(0);`,"",`value += abs(${r.getByIndices("input_indices")});`,""])},u9=(a,t)=>{n0(a.inputs),h0(a,"ReduceL2",t,(r,l)=>[`var t = ${l.type.value}(0); var value = ${l.type.value}(0);`,"",`t = ${r.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},g9=(a,t)=>{n0(a.inputs),h0(a,"ReduceLogSumExp",t,(r,l)=>[`var value = ${l.type.storage}(0);`,"",`value += exp(${r.getByIndices("input_indices")});`,"value = log(value);"])},s9=(a,t)=>{n0(a.inputs),h0(a,"ReduceMax",t,(r,l,i)=>{let e=[];for(let o=0;o<r.rank;o++)(i.indexOf(o)>=0||i.length===0)&&e.push(r.indicesSet("input_indices",o,0));return[`${e.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};`,`value = max(value, ${r.getByIndices("input_indices")});`,""]})},p9=(a,t)=>{n0(a.inputs),h0(a,"ReduceMean",t,(r,l,i)=>{let e=1;for(let o=0;o<r.rank;o++)(i.indexOf(o)>=0||i.length===0)&&(e*=a.inputs[0].dims[o]);return["var sum = f32(0);","",`sum += f32(${r.getByIndices("input_indices")});`,`let value = ${l.type.value}(sum / ${e});`]})},S9=(a,t)=>{n0(a.inputs),h0(a,"ReduceMin",t,(r,l,i)=>{let e=[];for(let o=0;o<r.rank;o++)(i.indexOf(o)>=0||i.length===0)&&e.push(`input_indices[${o}] = 0;`);return[`${e.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};`,`value = min(value, ${r.getByIndices("input_indices")});`,""]})},M9=(a,t)=>{n0(a.inputs),h0(a,"ReduceProd",t,(r,l)=>[`var value = ${l.type.storage}(1);`,"",`value *= ${r.getByIndices("input_indices")};`,""])},A9=(a,t)=>{n0(a.inputs),h0(a,"ReduceSum",t,(r,l)=>[`var value = ${l.type.storage}(0);`,"",`value += ${r.getByIndices("input_indices")};`,""])},T9=(a,t)=>{n0(a.inputs),h0(a,"ReduceSumSquare",t,(r,l)=>[`var t = ${l.type.value}(0); var value = ${l.type.value}(0);`,"",`t = ${r.getByIndices("input_indices")}; value += t * t;`,""])},c0=(a,t,r)=>{if(t.length===0)return r;let l=1,i=1;for(let e=0;e<t.length;e++)t.indexOf(e)===-1?l*=a[e]:i*=a[e];return i<32&&l>1024},We=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?p9(a,t):we(a,t)},Ke=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?v9(a,t):De(a,t)},qe=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?u9(a,t):Ge(a,t)},Ye=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?g9(a,t):Pe(a,t)},Qe=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?s9(a,t):Fe(a,t)},Xe=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?S9(a,t):Ze(a,t)},Je=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?M9(a,t):ye(a,t)},$e=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?A9(a,t):be(a,t)},ao=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?T9(a,t):je(a,t)},to=(a,t)=>{c0(a.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?d9(a,t):Ue(a,t)}}),p3,ro,lo,X3,Kg=y(()=>{l1(),V1(),E6(),p3=(a)=>{if(!a||a.length===0||a.length>2)throw Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(a[0].dataType!==1)throw Error("Invalid input type.")},ro=(a,t)=>{p3(a.inputs);let r=(l,i,e)=>{let o=[];for(let n=0;n<l.rank;n++)(e.indexOf(n)>=0||e.length===0)&&o.push(`input_indices[${n}] = 0;`);return[`${o.join(`
`)}`,`var value = ${l.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${l.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${l.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",i.setByOffset("global_idx","best_index")]};a.compute(U2("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[a.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},lo=(a,t)=>{p3(a.inputs);let r=(l,i,e)=>{let o=[];for(let n=0;n<l.rank;n++)(e.indexOf(n)>=0||e.length===0)&&o.push(`input_indices[${n}] = 0;`);return[`${o.join(`
`)}`,`var value = ${l.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${l.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${l.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",i.setByOffset("global_idx","best_index")]};a.compute(U2("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[a.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},X3=(a)=>T1(a)}),E9,N2,I9,m9,f9,J5,x9,io,I6=y(()=>{l1(),o1(),A6(),h1(),E9=(a,t)=>{let r=a[0],l=a[1],i=a[2],e=a[3],o=a[4],n=a[5];if(o&&n)throw Error("Attention cannot have both past and attention_bias");if(r.dims.length!==3)throw Error('Input "input" must have 3 dimensions');let c=r.dims[0],d=r.dims[1],u=r.dims[2];if(i.dims.length!==1)throw Error('Input "bias" is expected to have 1 dimensions');if(l.dims.length!==2)throw Error('Input "weights" is expected to have 2 dimensions');if(l.dims[0]!==u)throw Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(i.dims[0]!==l.dims[1])throw Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let g=i.dims[0]/3,s=g,M=s;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw Error("qkv_hidden_sizes attribute should have 3 elements");for(let _ of t.qkvHiddenSizes)if(_%t.numHeads!==0)throw Error("qkv_hidden_sizes should be divisible by num_heads");g=t.qkvHiddenSizes[0],s=t.qkvHiddenSizes[1],M=t.qkvHiddenSizes[2]}let A=d;if(g!==s)throw Error("qkv_hidden_sizes first element should be same as the second");if(i.dims[0]!==g+s+M)throw Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let E=0;if(o){if(s!==M)throw Error('Input "past" expect k_hidden_size == v_hidden_size');if(o.dims.length!==5)throw Error('Input "past" must have 5 dimensions');if(o.dims[0]!==2)throw Error('Input "past" first dimension must be 2');if(o.dims[1]!==c)throw Error('Input "past" second dimension must be batch_size');if(o.dims[2]!==t.numHeads)throw Error('Input "past" third dimension must be num_heads');if(o.dims[4]!==s/t.numHeads)throw Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(E=o.dims[3])}let x=A+E,m=-1,T=0;if(e)throw Error("Mask not supported");if(o)throw Error("past is not supported");if(n){if(n.dims.length!==4)throw Error('Input "attention_bias" must have 4 dimensions');if(n.dims[0]!==c||n.dims[1]!==t.numHeads||n.dims[2]!==d||n.dims[3]!==x)throw Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:c,sequenceLength:d,pastSequenceLength:E,kvSequenceLength:A,totalSequenceLength:x,maxSequenceLength:m,inputHiddenSize:u,hiddenSize:g,vHiddenSize:M,headSize:Math.floor(g/t.numHeads),vHeadSize:Math.floor(M/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:T,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},N2=(a,t,r)=>t&&a?`
      let total_sequence_length_input = u32(${t.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${a?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${r?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,I9=(a,t,r,l,i,e,o,n)=>{let c=H1(o?1:e),d=64,u=e/c;u<d&&(d=32);let g=Math.ceil(e/c/d),s=[{type:12,data:t},{type:12,data:r},{type:12,data:l},{type:12,data:i},{type:12,data:u},{type:12,data:g}],M=w1(a.dataType,c),A=Z1(1,c),E=["type"];o&&E.push("type"),n&&E.push("type");let x=(m)=>{let T=Q("x",a.dataType,a.dims,c),_=[T],C=o?w("seq_lens",o.dataType,o.dims):void 0;C&&_.push(C);let z=n?w("total_sequence_length_input",n.dataType,n.dims):void 0;z&&_.push(z);let L=Z1(a.dataType),H=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${d}>;
  var<workgroup> thread_sum: array<f32, ${d}>;
  ${m.registerUniforms(H).declareVariables(..._)}
  ${m.mainStart([d,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${N2(C,z,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${d}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${o?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${A}(-3.4028234663852886e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${A}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(c){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw Error(`Unsupported components: ${c}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.4028234663852886e+38f);
    for (var i = 0u; i < ${d}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${A}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${A}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(c){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw Error(`Unsupported components: ${c}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${d}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${T.type.value}(${L}(1.0) / ${L}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${A}(x[offset + i]);
        x[offset + i] = ${T.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${o?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${T.type.value}(${L}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${d};${M};${c}`,inputDependencies:E},getShaderSource:x,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:i,z:t*r},programUniforms:s})}},m9=(a,t,r,l,i,e,o,n,c)=>{let d=o+e.kvSequenceLength,u=[e.batchSize,e.numHeads,e.sequenceLength,d],g=a>1&&l,s=e.kvNumHeads?e.kvNumHeads:e.numHeads,M=g?[e.batchSize,s,d,e.headSize]:void 0,A=e.nReps?e.nReps:1,E=e.scale===0?1/Math.sqrt(e.headSize):e.scale,x=H1(e.headSize),m=e.headSize/x,T=12,_={x:Math.ceil(d/T),y:Math.ceil(e.sequenceLength/T),z:e.batchSize*e.numHeads},C=[{type:12,data:e.sequenceLength},{type:12,data:m},{type:12,data:d},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:1,data:E},{type:12,data:o},{type:12,data:e.kvSequenceLength},{type:12,data:A}],z=g&&l&&O.size(l.dims)>0,L=["type","type"];z&&L.push("type"),i&&L.push("type"),n&&L.push("type"),c&&L.push("type");let H=[{dims:u,dataType:t.dataType,gpuDataType:0}];g&&H.push({dims:M,dataType:t.dataType,gpuDataType:0});let I=(N)=>{let P=w("q",t.dataType,t.dims,x),b=w("key",r.dataType,r.dims,x),G=[P,b];if(z){let Y=w("past_key",l.dataType,l.dims,x);G.push(Y)}i&&G.push(w("attention_bias",i.dataType,i.dims));let j=n?w("seq_lens",n.dataType,n.dims):void 0;j&&G.push(j);let e1=c?w("total_sequence_length_input",c.dataType,c.dims):void 0;e1&&G.push(e1);let V=Q("output",t.dataType,u),F=[V];g&&F.push(Q("present_key",t.dataType,M,x));let a1=Z1(1,x),$=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${T}u;

  var<workgroup> tileQ: array<${P.type.storage}, ${T*T}>;
  var<workgroup> tileK: array<${P.type.storage}, ${T*T}>;
  ${N.registerUniforms($).declareVariables(...G,...F)}
  ${N.mainStart([T,T,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${A===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${A===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${N2(j,e1,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${z&&g?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${g?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${a1}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${z&&g?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${g?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${a1}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(x){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw Error(`Unsupported components: ${x}`)}})()};
        output[outputIdx] = ${V.type.value} (sum * uniforms.alpha) + ${i?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${x};${i!==void 0};${l!==void 0};${a}`,inputDependencies:L},getRunData:()=>({outputs:H,dispatchGroup:_,programUniforms:C}),getShaderSource:I}},f9=(a,t,r,l,i,e,o=void 0,n=void 0)=>{let c=e+i.kvSequenceLength,d=i.nReps?i.nReps:1,u=i.vHiddenSize*d,g=a>1&&l,s=i.kvNumHeads?i.kvNumHeads:i.numHeads,M=g?[i.batchSize,s,c,i.headSize]:void 0,A=[i.batchSize,i.sequenceLength,u],E=12,x={x:Math.ceil(i.vHeadSize/E),y:Math.ceil(i.sequenceLength/E),z:i.batchSize*i.numHeads},m=[{type:12,data:i.sequenceLength},{type:12,data:c},{type:12,data:i.vHeadSize},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:12,data:u},{type:12,data:e},{type:12,data:i.kvSequenceLength},{type:12,data:d}],T=g&&l&&O.size(l.dims)>0,_=["type","type"];T&&_.push("type"),o&&_.push("type"),n&&_.push("type");let C=[{dims:A,dataType:t.dataType,gpuDataType:0}];g&&C.push({dims:M,dataType:t.dataType,gpuDataType:0});let z=(L)=>{let H=w("probs",t.dataType,t.dims),I=w("v",r.dataType,r.dims),N=[H,I];T&&N.push(w("past_value",l.dataType,l.dims));let P=o?w("seq_lens",o.dataType,o.dims):void 0;o&&N.push(P);let b=n?w("total_sequence_length_input",n.dataType,n.dims):void 0;n&&N.push(b);let G=[Q("output",t.dataType,A)];g&&G.push(Q("present_value",t.dataType,M));let j=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${E}u;
  var<workgroup> tileQ: array<${H.type.value}, ${E*E}>;
  var<workgroup> tileV: array<${H.type.value}, ${E*E}>;
  ${L.registerUniforms(j).declareVariables(...N,...G)}
  ${L.mainStart([E,E,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${d===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${d===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${N2(P,b,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${T&&g?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${g?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${H.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${T&&g?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${g?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${l!==void 0};${a}`,inputDependencies:_},getRunData:()=>({outputs:C,dispatchGroup:x,programUniforms:m}),getShaderSource:z}},J5=(a,t,r,l,i,e,o,n,c,d,u=void 0,g=void 0)=>{let s=Math.min(a.outputCount,1+(o?1:0)+(n?1:0)),M=s>1?d.pastSequenceLength:0,A=M+d.kvSequenceLength,E=c&&O.size(c.dims)>0?c:void 0,x=[t,r];s>1&&o&&O.size(o.dims)>0&&x.push(o),E&&x.push(E),u&&x.push(u),g&&x.push(g);let m=a.compute(m9(s,t,r,o,E,d,M,u,g),{inputs:x,outputs:s>1?[-1,1]:[-1]})[0];a.compute(I9(m,d.batchSize,d.numHeads,M,d.sequenceLength,A,u,g),{inputs:u&&g?[m,u,g]:[m],outputs:[]});let T=[m,l];s>1&&n&&O.size(n.dims)>0&&T.push(n),u&&T.push(u),g&&T.push(g),a.compute(f9(s,m,l,n,d,M,u,g),{inputs:T,outputs:s>1?[0,2]:[0]})},x9=(a,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],l=t.sequenceLength,i=t.inputHiddenSize,e=t.headSize,o=12,n={x:Math.ceil(t.headSize/o),y:Math.ceil(t.sequenceLength/o),z:t.batchSize*t.numHeads},c=[a.inputs[0],a.inputs[1],a.inputs[2]],d=[{type:12,data:l},{type:12,data:i},{type:12,data:e},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],u=(g)=>{let s=Q("output_q",c[0].dataType,r),M=Q("output_k",c[0].dataType,r),A=Q("output_v",c[0].dataType,r),E=w("input",c[0].dataType,c[0].dims),x=w("weight",c[1].dataType,c[1].dims),m=w("bias",c[2].dataType,c[2].dims),T=E.type.storage,_=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${o}u;
  var<workgroup> tileInput: array<${T}, ${o*o}>;
  var<workgroup> tileWeightQ: array<${T}, ${o*o}>;
  var<workgroup> tileWeightK: array<${T}, ${o*o}>;
  var<workgroup> tileWeightV: array<${T}, ${o*o}>;
  ${g.registerUniforms(_).declareVariables(E,x,m,s,M,A)}
  ${g.mainStart([o,o,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${T}(0);
    var valueK = ${T}(0);
    var valueV = ${T}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return a.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:a.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:a.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:a.inputs[0].dataType,gpuDataType:0}],dispatchGroup:n,programUniforms:d}),getShaderSource:u},{inputs:c,outputs:[-1,-1,-1]})},io=(a,t)=>{let r=E9(a.inputs,t),[l,i,e]=x9(a,r);return J5(a,l,i,e,a.inputs[4],void 0,void 0,void 0,a.inputs[5],r)}}),C9,_9,B9,eo,qg=y(()=>{l0(),l1(),o1(),V1(),h1(),C9=(a,t)=>{if(!a||a.length!==5)throw Error("BatchNormalization requires 5 inputs");let r=(l,i,e)=>{let o=i.length;if(o!==l.length)throw Error(`${e}: num dimensions != ${o}`);i.forEach((n,c)=>{if(n!==l[c])throw Error(`${e}: dim[${c}] do not match`)})};if(a[0].dims.length>1){let l=t.format==="NHWC"?t.spatial?a[0].dims.slice(-1):a[0].dims.slice(-1).concat(a[0].dims.slice(1,a[0].dims.length-1)):a[0].dims.slice(1,t.spatial?2:void 0);r(a[1].dims,l,"Invalid input scale"),r(a[2].dims,l,"Invalid input B"),r(a[3].dims,l,"Invalid input mean"),r(a[4].dims,l,"Invalid input var")}else r(a[1].dims,[1],"Invalid input scale"),r(a[2].dims,[1],"Invalid input B"),r(a[3].dims,[1],"Invalid input mean"),r(a[4].dims,[1],"Invalid input var")},_9=(a,t)=>{let{epsilon:r,spatial:l,format:i}=t,e=a[0].dims,o=l?H1(e[e.length-1]):1,n=i==="NHWC"&&e.length>1?o:1,c=O.size(e)/o,d=l,u=d?e.length:e,g=w("x",a[0].dataType,a[0].dims,o),s=w("scale",a[1].dataType,a[1].dims,n),M=w("bias",a[2].dataType,a[2].dims,n),A=w("inputMean",a[3].dataType,a[3].dims,n),E=w("inputVar",a[4].dataType,a[4].dims,n),x=Q("y",a[0].dataType,u,o),m=()=>{let _="";if(l)_=`let cOffset = ${e.length===1?"0u":i==="NHWC"?`outputIndices[${e.length-1}] / ${o}`:"outputIndices[1]"};`;else if(i==="NCHW")_=`
            ${x.indicesSet("outputIndices","0","0")}
            let cOffset = ${x.indicesToOffset("outputIndices")};`;else{_=`var cIndices = ${s.type.indices}(0);
                       cIndices[0] = outputIndices[${e.length-1}];`;for(let C=1;C<s.rank;C++)_+=`cIndices[${C}] = outputIndices[${C}];`;_+=`let cOffset = ${s.indicesToOffset("cIndices")};`}return _},T=(_)=>`
  const epsilon = ${r};
  ${_.registerUniform("outputSize","u32").declareVariables(g,s,M,A,E,x)}
  ${_.mainStart()}
  ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${x.offsetToIndices(`global_idx * ${o}`)};
    ${m()}
    let scale = ${s.getByOffset("cOffset")};
    let bias = ${M.getByOffset("cOffset")};
    let inputMean = ${A.getByOffset("cOffset")};
    let inputVar = ${E.getByOffset("cOffset")};
    let x = ${g.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${x.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${l}_${o}`,inputDependencies:d?["rank","type","type","type","type"]:void 0},getShaderSource:T,getRunData:()=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:d?[{type:12,data:c},...J(e)]:[{type:12,data:c}]})}},B9=(a)=>T1(a),eo=(a,t)=>{let{inputs:r,outputCount:l}=a,i=B9({...t,outputCount:l});if(m1.webgpu.validateInputContent&&C9(r,i),t.trainingMode)throw Error("BatchNormalization trainingMode is not supported yet.");a.compute(_9(r,i))}}),z9,L9,oo,Yg=y(()=>{o1(),h1(),z9=(a)=>{if(a[0].dims.length!==3)throw Error("input should have 3 dimensions");if(![320,640,1280].includes(a[0].dims[2]))throw Error("number of channels should be 320, 640 or 1280");if(a[1].dims.length!==1)throw Error("bias is expected to have 1 dimensions");if(a[0].dims[2]!==a[1].dims[0])throw Error("last dimension of input and bias are not the same")},L9=(a)=>{let t=a[0].dims,r=a[0].dims[2],l=O.size(t)/4,i=a[0].dataType,e=w("input",i,t,4),o=w("bias",i,[r],4),n=w("residual",i,t,4),c=Q("output",i,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:(d)=>`
  const channels = ${r}u / 4;
  ${d.declareVariables(e,o,n,c)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(l)}
    let value = ${e.getByOffset("global_idx")}
      + ${o.getByOffset("global_idx % channels")} + ${n.getByOffset("global_idx")};
    ${c.setByOffset("global_idx","value")}
  }`}},oo=(a)=>{z9(a.inputs),a.compute(L9(a.inputs))}}),H9,M1,no,ho,co,vo,uo,go,so,po,So,V9,Mo,Ao,To,Eo,q5,Io,F2,mo,fo,xo,Co,_o,Bo,zo,Lo,Ho,Vo,ko,No,Oo,Ro,wo,Do,S3,Go,J3,$3,Po,Fo,Zo,k9,N9,yo,m6=y(()=>{l1(),o1(),V1(),h1(),H9=(a,t,r,l,i,e,o)=>{let n=Math.ceil(t/4),c="";typeof i=="string"?c=`${i}(a)`:c=i("a");let d=w("inputData",r,[n],4),u=Q("outputData",l,[n],4),g=[{name:"vec_size",type:"u32"}];return o&&g.push(...o),`
      ${a.registerUniforms(g).declareVariables(d,u)}

  ${e??""}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${d.getByOffset("global_idx")};
    ${u.setByOffset("global_idx",c)}
  }`},M1=(a,t,r,l,i,e=a.dataType,o,n)=>{let c=[{type:12,data:Math.ceil(O.size(a.dims)/4)}];return o&&c.push(...o),{name:t,shaderCache:{hint:i,inputDependencies:["type"]},getShaderSource:(d)=>H9(d,O.size(a.dims),a.dataType,e,r,l,n),getRunData:(d)=>({outputs:[{dims:a.dims,dataType:e}],dispatchGroup:{x:Math.ceil(O.size(d[0].dims)/64/4)},programUniforms:c})}},no=(a)=>{a.compute(M1(a.inputs[0],"Abs","abs"))},ho=(a)=>{a.compute(M1(a.inputs[0],"Acos","acos"))},co=(a)=>{a.compute(M1(a.inputs[0],"Acosh","acosh"))},vo=(a)=>{a.compute(M1(a.inputs[0],"Asin","asin"))},uo=(a)=>{a.compute(M1(a.inputs[0],"Asinh","asinh"))},go=(a)=>{a.compute(M1(a.inputs[0],"Atan","atan"))},so=(a)=>{a.compute(M1(a.inputs[0],"Atanh","atanh"))},po=(a)=>T1(a),So=(a,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}a.compute(M1(a.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},V9=(a)=>{let t,r,l=a.length>=2&&a[1].data!==0,i=a.length>=3&&a[2].data!==0;switch(a[0].dataType){case 1:t=l?a[1].getFloat32Array()[0]:-340282346638528860000000000000000000000,r=i?a[2].getFloat32Array()[0]:340282346638528860000000000000000000000;break;case 10:t=l?a[1].getUint16Array()[0]:64511,r=i?a[2].getUint16Array()[0]:31743;break;default:throw Error("Unsupport data type")}return T1({min:t,max:r})},Mo=(a,t)=>{let r=t||V9(a.inputs),l=Z1(a.inputs[0].dataType);a.compute(M1(a.inputs[0],"Clip",(i)=>`clamp(${i}, vec4<${l}>(uniforms.min), vec4<${l}>(uniforms.max))`,void 0,r.cacheKey,void 0,[{type:a.inputs[0].dataType,data:r.min},{type:a.inputs[0].dataType,data:r.max}],[{name:"min",type:l},{name:"max",type:l}]),{inputs:[0]})},Ao=(a)=>{a.compute(M1(a.inputs[0],"Ceil","ceil"))},To=(a)=>{a.compute(M1(a.inputs[0],"Cos","cos"))},Eo=(a)=>{a.compute(M1(a.inputs[0],"Cosh","cosh"))},q5=(a)=>T1(a),Io=(a,t)=>{let r=Z1(a.inputs[0].dataType);a.compute(M1(a.inputs[0],"Elu",(l)=>`elu_vf32(${l})`,`
  const elu_alpha_ = ${r}(${t.alpha});

  fn elu_f32(a: ${r}) -> ${r} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},F2=(a="f32")=>`
const r0: ${a} = 0.3275911;
const r1: ${a} = 0.254829592;
const r2: ${a} = -0.284496736;
const r3: ${a} = 1.421413741;
const r4: ${a} = -1.453152027;
const r5: ${a} = 1.061405429;

fn erf_vf32(v: vec4<${a}>) -> vec4<${a}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,mo=(a)=>{let t=Z1(a.inputs[0].dataType);a.compute(M1(a.inputs[0],"Erf",(r)=>`erf_vf32(${r})`,F2(t)))},fo=(a)=>{a.compute(M1(a.inputs[0],"Exp","exp"))},xo=(a)=>{a.compute(M1(a.inputs[0],"Floor","floor"))},Co=(a)=>{let t=Z1(a.inputs[0].dataType);a.compute(M1(a.inputs[0],"Gelu",(r)=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,F2(t)))},_o=(a,t)=>{let r=Z1(a.inputs[0].dataType);a.compute(M1(a.inputs[0],"LeakyRelu",(l)=>`select(leaky_relu_alpha_ * ${l}, ${l}, ${l} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},Bo=(a)=>{a.compute(M1(a.inputs[0],"Not",(t)=>`!${t}`))},zo=(a)=>{a.compute(M1(a.inputs[0],"Neg",(t)=>`-${t}`))},Lo=(a)=>{a.compute(M1(a.inputs[0],"Reciprocal",(t)=>`1.0/${t}`))},Ho=(a)=>{let t=Z1(a.inputs[0].dataType);a.compute(M1(a.inputs[0],"Relu",(r)=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},Vo=(a)=>{a.compute(M1(a.inputs[0],"Sigmoid",(t)=>`(1.0 / (1.0 + exp(-${t})))`))},ko=(a)=>T1(a),No=(a,t)=>{let r=Z1(a.inputs[0].dataType);a.compute(M1(a.inputs[0],"HardSigmoid",(l)=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${l} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},Oo=(a)=>{a.compute(M1(a.inputs[0],"Sin","sin"))},Ro=(a)=>{a.compute(M1(a.inputs[0],"Sinh","sinh"))},wo=(a)=>{a.compute(M1(a.inputs[0],"Sqrt","sqrt"))},Do=(a)=>{a.compute(M1(a.inputs[0],"Tan","tan"))},S3=(a)=>`sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`,Go=(a)=>{a.compute(M1(a.inputs[0],"Tanh",S3))},J3=(a="f32")=>`
const fast_gelu_a: ${a} = 0.5;
const fast_gelu_b: ${a} = 0.7978845608028654;
const fast_gelu_c: ${a} = 0.035677408136300125;

fn tanh_v(v: vec4<${a}>) -> vec4<${a}> {
  return ${S3("v")};
}
`,$3=(a)=>`(fast_gelu_a + fast_gelu_a * tanh_v(${a} * (fast_gelu_c * ${a} * ${a} + fast_gelu_b))) * ${a}`,Po=(a)=>{let t=Z1(a.inputs[0].dataType);a.compute(M1(a.inputs[0],"FastGelu",$3,J3(t),void 0,a.inputs[0].dataType))},Fo=(a,t)=>{let r=Z1(a.inputs[0].dataType);return a.compute(M1(a.inputs[0],"ThresholdedRelu",(l)=>`select(vec4<${r}>(0.0), ${l}, ${l} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},Zo=(a)=>{a.compute(M1(a.inputs[0],"Log","log"))},k9=(a,t)=>`
const alpha = vec4<${a}>(${t});
const one = ${a}(1.0);
const zero = ${a}(0.0);

fn quick_gelu_impl(x: vec4<${a}>) -> vec4<${a}> {
  let v = x *alpha;
  var x1 : vec4<${a}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,N9=(a)=>`quick_gelu_impl(${a})`,yo=(a,t)=>{let r=Z1(a.inputs[0].dataType);a.compute(M1(a.inputs[0],"QuickGelu",N9,k9(r,t.alpha),t.cacheKey,a.inputs[0].dataType))}}),O9,R9,bo,Qg=y(()=>{o1(),h1(),m6(),O9=(a)=>{if(a[0].dims.length!==3)throw Error("input should have 3 dimensions");if(![2560,5120,10240].includes(a[0].dims[2]))throw Error("hidden state should be 2560, 5120 or 10240");if(a[1].dims.length!==1)throw Error("bias is expected to have 1 dimensions");if(a[0].dims[2]!==a[1].dims[0])throw Error("last dimension of input and bias are not the same")},R9=(a)=>{let t=a[0].dims.slice();t[2]=t[2]/2;let r=w("input",a[0].dataType,a[0].dims,4),l=w("bias",a[0].dataType,[a[0].dims[2]],4),i=Q("output",a[0].dataType,t,4),e=O.size(t)/4,o=w1(a[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(e/64)}}),getShaderSource:(n)=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${a[0].dims[2]/4/2}u;

  ${n.declareVariables(r,l,i)}

  ${F2(o)}

  ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes(e)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${i.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},bo=(a)=>{O9(a.inputs),a.compute(R9(a.inputs))}}),w9,D9,d0,jo,Uo,Wo,Ko,qo,Yo,Qo,Xo,Jo,$o,Xg=y(()=>{l1(),o1(),h1(),w9=(a,t,r,l,i,e,o,n,c,d,u,g)=>{let s,M;typeof n=="string"?s=M=(T,_)=>`${n}((${T}),(${_}))`:typeof n=="function"?s=M=n:(s=n.scalar,M=n.vector);let A=Q("outputData",u,l.length,4),E=w("aData",c,t.length,4),x=w("bData",d,r.length,4),m;if(i)if(e){let T=O.size(t)===1,_=O.size(r)===1,C=t.length>0&&t[t.length-1]%4===0,z=r.length>0&&r[r.length-1]%4===0;T||_?m=A.setByOffset("global_idx",M(T?`${E.type.value}(${E.getByOffset("0")}.x)`:E.getByOffset("global_idx"),_?`${x.type.value}(${x.getByOffset("0")}.x)`:x.getByOffset("global_idx"))):m=`
            let outputIndices = ${A.offsetToIndices("global_idx * 4u")};
            let offsetA = ${E.broadcastedIndicesToOffset("outputIndices",A)};
            let offsetB = ${x.broadcastedIndicesToOffset("outputIndices",A)};
            ${A.setByOffset("global_idx",M(o||C?E.getByOffset("offsetA / 4u"):`${E.type.value}(${E.getByOffset("offsetA / 4u")}[offsetA % 4u])`,o||z?x.getByOffset("offsetB / 4u"):`${x.type.value}(${x.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else m=A.setByOffset("global_idx",M(E.getByOffset("global_idx"),x.getByOffset("global_idx")));else{if(!e)throw Error("no necessary to use scalar implementation for element-wise binary op implementation.");let T=(_,C,z="")=>{let L=`aData[indexA${C}][componentA${C}]`,H=`bData[indexB${C}][componentB${C}]`;return`
            let outputIndices${C} = ${A.offsetToIndices(`global_idx * 4u + ${C}u`)};
            let offsetA${C} = ${E.broadcastedIndicesToOffset(`outputIndices${C}`,A)};
            let offsetB${C} = ${x.broadcastedIndicesToOffset(`outputIndices${C}`,A)};
            let indexA${C} = offsetA${C} / 4u;
            let indexB${C} = offsetB${C} / 4u;
            let componentA${C} = offsetA${C} % 4u;
            let componentB${C} = offsetB${C} % 4u;
            ${_}[${C}] = ${z}(${s(L,H)});
          `};u===9?m=`
            var data = vec4<u32>(0);
            ${T("data",0,"u32")}
            ${T("data",1,"u32")}
            ${T("data",2,"u32")}
            ${T("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:m=`
            ${T("outputData[global_idx]",0)}
            ${T("outputData[global_idx]",1)}
            ${T("outputData[global_idx]",2)}
            ${T("outputData[global_idx]",3)}
          `}return`
        ${a.registerUniform("vec_size","u32").declareVariables(E,x,A)}

        ${g??""}

        ${a.mainStart()}
        ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${m}
      }`},D9=(a,t,r,l,i,e,o=r.dataType)=>{let n=r.dims.map(Number),c=l.dims.map(Number),d=!O.areEqual(n,c),u=n,g=O.size(n),s=!1,M=!1,A=[d];if(d){let E=T5.calcShape(n,c,!1);if(!E)throw Error("Can't perform binary op on the given tensors");u=E.slice(),g=O.size(u);let x=O.size(n)===1,m=O.size(c)===1,T=n.length>0&&n[n.length-1]%4===0,_=c.length>0&&c[c.length-1]%4===0;A.push(x),A.push(m),A.push(T),A.push(_);let C=1;for(let z=1;z<u.length;z++){let L=n[n.length-z],H=c[c.length-z];if(L===H)C*=L;else break}C%4===0?(M=!0,s=!0):(x||m||T||_)&&(s=!0)}else s=!0;return A.push(s),{name:a,shaderCache:{hint:t+A.map((E)=>E.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:(E)=>w9(E,n,c,u,s,d,M,i,r.dataType,l.dataType,o,e),getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(g/64/4)},programUniforms:[{type:12,data:Math.ceil(O.size(u)/4)},...J(n,c,u)]})}},d0=(a,t,r,l,i,e)=>{a.compute(D9(t,i??"",a.inputs[0],a.inputs[1],r,l,e))},jo=(a)=>{d0(a,"Add",(t,r)=>`${t}+${r}`)},Uo=(a)=>{d0(a,"Div",(t,r)=>`${t}/${r}`)},Wo=(a)=>{d0(a,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Ko=(a)=>{d0(a,"Mul",(t,r)=>`${t}*${r}`)},qo=(a)=>{let t=w("input",a.inputs[0].dataType,a.inputs[0].dims).type.value;d0(a,"Pow",{scalar:(r,l)=>`pow_custom(${r},${l})`,vector:(r,l)=>`pow_vector_custom(${r},${l})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Yo=(a)=>{d0(a,"Sub",(t,r)=>`${t}-${r}`)},Qo=(a)=>{d0(a,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Xo=(a)=>{d0(a,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Jo=(a)=>{d0(a,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},$o=(a)=>{d0(a,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}}),G9,P9,F9,Z9,an,tn,Jg=y(()=>{l1(),o1(),V1(),h1(),G9=(a,t)=>{if(!a||a.length<1)throw Error("too few inputs");let r=0,l=a[r],i=l.dataType,e=l.dims.length;a.forEach((o,n)=>{if(n!==r){if(o.dataType!==i)throw Error("input tensors should be one type");if(o.dims.length!==e)throw Error("input tensors should have the same shape");o.dims.forEach((c,d)=>{if(d!==t&&c!==l.dims[d])throw Error("non concat dimensions must match")})}})},P9=(a,t)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${a}u>(${t});
    for (var i: u32 = 0u; i < ${a}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${a}u;
  }`,F9=(a,t)=>{let r=a.length,l=[];for(let i=0;i<r;++i){let e=t.setByOffset("global_idx",a[i].getByIndices("indices"));r===1?l.push(e):i===0?l.push(`if (inputIndex == ${i}u) { ${e} }`):i===r-1?l.push(`else { ${e} }`):l.push(`else if (inputIndex == ${i}) { ${e} }`)}return l.join(`
`)},Z9=(a,t,r,l)=>{let i=O.size(r),e=Array(a.length),o=Array(a.length),n=0,c=[],d=[],u=[{type:12,data:i}];for(let E=0;E<a.length;++E)n+=a[E].dims[t],e[E]=n,d.push(a[E].dims.length),o[E]=w(`input${E}`,l,d[E]),c.push("rank"),u.push({type:12,data:e[E]});for(let E=0;E<a.length;++E)u.push(...J(a[E].dims));u.push(...J(r));let g=Q("output",l,r.length),s=g.indicesGet("indices",t),M=Array.from(Array(e.length).keys()).map((E)=>`uniforms.sizeInConcatAxis${E}`).join(","),A=(E)=>`

  ${(()=>{E.registerUniform("outputSize","u32");for(let x=0;x<a.length;x++)E.registerUniform(`sizeInConcatAxis${x}`,"u32");return E.declareVariables(...o,g)})()}

  ${P9(e.length,M)}

  ${E.mainStart()}
    ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${g.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${s});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${e.length}u>(${M});
      ${s} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${F9(o,g)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:r,dataType:l}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:u}),getShaderSource:A}},an=(a,t)=>{let r=a.inputs,l=r[0].dims,i=O.normalizeAxis(t.axis,l.length);G9(r,i);let e=l.slice();e[i]=r.reduce((n,c)=>n+(c.dims.length>i?c.dims[i]:0),0);let o=r.filter((n)=>O.size(n.dims)>0);a.compute(Z9(o,i,e,r[0].dataType),{inputs:o})},tn=(a)=>T1({axis:a.axis})}),i5,e5,o5,f6,h5=y(()=>{l1(),o1(),i5=(a,t,r="f32")=>{switch(a.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw Error(`Unsupported activation ${a.activation}`)}},e5=(a,t)=>{a.activation==="Clip"?t.push({type:1,data:a.clipMax},{type:1,data:a.clipMin}):a.activation==="HardSigmoid"?t.push({type:1,data:a.alpha},{type:1,data:a.beta}):a.activation==="LeakyRelu"&&t.push({type:1,data:a.alpha})},o5=(a,t)=>{a.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):a.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):a.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},f6=(a)=>{let t=a?.activation||"";if(t==="HardSigmoid"){let[r,l]=a?.activation_params||[0.2,0.5];return{activation:t,alpha:r,beta:l}}else if(t==="Clip"){let[r,l]=a?.activation_params||[_e,Be];return{activation:t,clipMax:l,clipMin:r}}else if(t==="LeakyRelu"){let[r]=a?.activation_params||[0.01];return{activation:t,alpha:r}}return{activation:t}}}),F1,rn,x6=y(()=>{F1=(a,t)=>{switch(a){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw Error(`${a}-component is not supported.`)}},rn=(a)=>`
      ${a?"value = value + getBiasByOutputCoords(coords);":""}
      `}),ln,$g=y(()=>{ln=(a)=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${a}.x), i32(${a}.y), i32(${a}.z), 1));
}
`}),Q5,C6,_6=y(()=>{l1(),o1(),h1(),h5(),Q5=(a,t,r,l,i)=>{let e=l-r;return`
      ${Array.from({length:r}).map((o,n)=>`
      if (${X(t.shape,n,t.rank)} != 1) {
        ${t.indicesSet(a,n,X(i,n+e,l))}
      } else {
        ${t.indicesSet(a,n,0)}
      }`).join("")}
`},C6=(a,t,r,l,i=!1,e)=>{let o=a[0].dims,n=a[1].dims,c=o[o.length-2],d=n[n.length-1],u=o[o.length-1],g=H1(d),s=H1(u),M=H1(c),A=O.size(r)/g/M,E=a.length>2,x=l?l.slice(0,-2):r.slice(0,-2),m=[O.size(x),c,d],T=[{type:12,data:A},{type:12,data:c},{type:12,data:d},{type:12,data:u}];e5(t,T),T.push(...J(x,o,n)),E&&T.push(...J(a[2].dims)),T.push(...J(m));let _=(C)=>{let z=T6("batch_dims",a[0].dataType,x.length),L=w("a",a[0].dataType,o.length,s),H=w("b",a[1].dataType,n.length,g),I=Q("output",a[0].dataType,m.length,g),N=w1(I.type.tensor),P=i5(t,I.type.value,N),b=[L,H],G="";if(E){let V=i?g:1;b.push(w("bias",a[2].dataType,a[2].dims.length,V)),G=`${i?`value += bias[col / ${V}];`:`value += ${I.type.value}(bias[row + i]);`}`}let j=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];o5(t,j);let e1=()=>{let V=`var a_data: ${L.type.value};`;for(let F=0;F<s;F++)V+=`
              let b_data${F} = b[(b_offset + (k + ${F}) * uniforms.N + col) / ${g}];`;for(let F=0;F<M;F++){V+=`a_data = a[(a_offset + (row + ${F}) * uniforms.K + k) / ${s}];`;for(let a1=0;a1<s;a1++)V+=`
            values[${F}] = fma(${H.type.value}(a_data${s===1?"":`[${a1}]`}), b_data${a1}, values[${F}]);
`}return V};return`
  ${C.registerUniforms(j).registerInternalVariables(z).declareVariables(...b,I)}
  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${g})) * ${g};
    var index1 = global_idx / (uniforms.N / ${g});
    let stride1 = uniforms.M / ${M};
    let row = (index1 % stride1) * ${M};
    let batch = index1 / stride1;

    ${r.length===2?"":`let batch_indices = ${z.offsetToIndices("batch")};`}

    var a_indices: ${L.type.indices};
    ${Q5("a_indices",L,L.rank-2,z.rank,"batch_indices")}
    ${L.indicesSet("a_indices",L.rank-2,0)}
    ${L.indicesSet("a_indices",L.rank-1,0)}
    let a_offset = ${L.indicesToOffset("a_indices")};

    var b_indices: ${H.type.indices};
    ${Q5("b_indices",H,H.rank-2,z.rank,"batch_indices")}
    ${H.indicesSet("b_indices",H.rank-2,0)}
    ${H.indicesSet("b_indices",H.rank-1,0)}
    let b_offset = ${H.indicesToOffset("b_indices")};
    var values: array<${I.type.value}, ${M}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${s}) {
      ${e1()}
    }
    for (var i = 0u; i < ${M}u; i++) {
      var value = values[i];
      ${G}
      ${P}
      let cur_indices = ${I.type.indices}(batch, row + i, col);
      let offset = ${I.indicesToOffset("cur_indices")};
      ${I.setByOffset(`offset / ${g}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${g};${s};${M};${i}`,inputDependencies:E?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:e?e(r):r,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(A/64)},programUniforms:T}),getShaderSource:_}}}),y9,b9,a6,M3,j9,t6,U9,W2,B6=y(()=>{l1(),o1(),h1(),h5(),_6(),x6(),y9=(a,t)=>a?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,b9=(a,t)=>a?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,a6=(a,t,r="f32",l,i=!1,e=32,o=!1,n=32)=>{let c=t[1]*a[1],d=t[0]*a[0],u=i?c:e,g=i?e:c,s=u/t[0],M=e/t[1];if(!((i&&s===4&&a[1]===4||!i&&(s===3||s===4))&&u%t[0]===0&&e%t[1]===0&&a[0]===4))throw Error(`If transposeA ${i} is true, innerElementSize ${s} and workPerThread[1] ${a[1]} must be 4.
      Otherwise, innerElementSize ${s} must be 3 or 4.
  tileAWidth ${u} must be divisible by workgroupSize[0]${t[0]}. tileInner ${e} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${a[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${s}<${r}>, ${u/s}>, ${g}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${d/a[0]}>, ${e}>;

const rowPerThread = ${a[1]};
const colPerThread = ${a[0]};
const innerElementSize = ${s};
const tileInner = ${e};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${o?"0":"i32(globalId.z)"};
  ${l?`let batchIndices = ${l.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${c};

  let num_tiles = ${o?`${Math.ceil(n/e)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${o?`i32(globalId.z) * ${n}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${M};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${y9(i,l)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${M}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${l?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${s===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${b9(i,s)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},M3=(a,t)=>a?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,j9=(a)=>a?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",t6=(a,t,r="f32",l,i=!1,e=32,o=!1,n=32,c=!1)=>{let d=a[1]*t[1],u=a[0]*t[0],g=i?d:e,s=i?e:d;if(!(s%t[1]===0&&g%t[0]===0&&e%t[1]===0))throw Error(`tileAHight ${s} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}, tileInner ${e} must be divisible by workgroupSize[1]${t[1]}`);let M=s/t[1],A=g/t[0],E=e/t[1],x=c?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${d};
    let globalColStart = i32(workgroupId.x) * ${u};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {
          ${M3(i,l)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${e}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${l?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${i?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${d};

let tileRowA = i32(localId.y) * ${M};
let tileColA = i32(localId.x) * ${A};
let tileRowB = i32(localId.y) * ${E};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${M}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${A}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${M3(i,l)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${E}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${l?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${j9(i)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${g}>, ${s}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${u}>, ${e}>;
  const rowPerThread = ${a[1]};
  const colPerThread = ${a[0]};
  const tileInner = ${e};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${o?"0":"i32(globalId.z)"};
    ${l?`let batchIndices = ${l.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${o?`${Math.ceil(n/e)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${o?`i32(globalId.z) * ${n}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;
    ${x}
  }
`},U9=(a,t,r,l,i=!1)=>{let[e,o,n,c]=l,d=w1(l[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${e.type.indices}) -> ${F1(a,d)} {
      var value = ${F1(a,d)}(0.0);
      let col = colIn * ${a};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${o.type.indices};
        ${Q5("aIndices",o,o.rank-2,e.rank,"batchIndices")}
        ${o.indicesSet("aIndices",o.rank-2,"u32(row)")}
        ${o.indicesSet("aIndices",o.rank-1,"u32(colIn)")}
        value = ${o.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${e.type.indices}) -> ${F1(a,d)} {
      var value = ${F1(a,d)}(0.0);
      let col = colIn * ${a};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${n.type.indices};
        ${Q5("bIndices",n,n.rank-2,e.rank,"batchIndices")}
        ${n.indicesSet("bIndices",n.rank-2,"u32(row)")}
        ${n.indicesSet("bIndices",n.rank-1,"u32(colIn)")}
        value = ${n.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${F1(a,d)}) {
      let col = colIn * ${a};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${i?"bias[colIn]":`${F1(a,d)}(bias[row])`};`:""}
        ${r}
        ${c.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},W2=(a,t,r,l,i=!1,e)=>{let o=a[0].dims,n=a[1].dims,c=o.slice(0,-2),d=n.slice(0,-2),u=l?l.slice(0,-2):r.slice(0,-2),g=O.size(u),s=o[o.length-2],M=o[o.length-1],A=n[n.length-1],E=M%4===0&&A%4===0,x=s<=8?[4,1,1]:[4,4,1],m=[8,8,1],T=[Math.ceil(A/m[0]/x[0]),Math.ceil(s/m[1]/x[1]),Math.ceil(g/m[2]/x[2])],_=E?4:1,C=[...c,s,M/_],z=C.length,L=[...d,M,A/_],H=L.length,I=[g,s,A/_],N=[{type:6,data:s},{type:6,data:A},{type:6,data:M}];e5(t,N),N.push(...J(u,C,L));let P=["rank","rank"],b=a.length>2;b&&(N.push(...J(a[2].dims)),P.push("rank")),N.push(...J(I));let G=(j)=>{let e1=u.length,V=T6("batchDims",a[0].dataType,e1,1),F=w1(a[0].dataType),a1=w("a",a[0].dataType,z,_),$=w("b",a[1].dataType,H,_),Y=Q("result",a[0].dataType,I.length,_),i1=[a1,$];if(b){let R1=i?_:1;i1.push(w("bias",a[2].dataType,a[2].dims.length,R1))}let D=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];o5(t,D);let W=w1(Y.type.tensor),t1=i5(t,Y.type.value,W),s1=U9(_,b,t1,[V,a1,$,Y],i);return`
  ${j.registerUniforms(D).registerInternalVariables(V).declareVariables(...i1,Y)}
  ${s1}
  ${E?a6(x,m,F,V):t6(x,m,F,V)}
                   `};return{name:"MatMul",shaderCache:{hint:`${x};${t.activation};${E};${i}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:e?e(r):r,dataType:a[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]},programUniforms:N}),getShaderSource:G}}}),W9,en,as=y(()=>{l1(),H0(),h1(),h5(),x6(),$g(),B6(),W9=(a,t,r,l,i=!1,e,o=4,n=4,c=4,d="f32")=>{let u=(N)=>{switch(N){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw Error(`innerElementSize ${N} is not supported.`)}},g=(N)=>{switch(N){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw Error(`innerElementSize ${N} is not supported.`)}},s=a?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,M=a?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,A=a?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",E=a?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",x=a?"row":"col",m=a?"col":"row",T=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${a?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${x} / outWidth;
    let outCol = ${x} % outWidth;

    let WRow = ${m} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${m} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${m} % inChannels;
    var resData = ${F1(o,d)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${A} && xCol >= 0 && xCol < ${E}) {
      ${s}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${u(o)}
    }
    return resData;`,_=a?t&&l?`
    let col = colIn * ${o};
    ${T}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${T}
    }
    return ${F1(o,d)}(0.0);`:l&&r?`
    let col = colIn * ${o};
    ${T}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${T}
    }
    return ${F1(o,d)}(0.0);`,C=a?l&&r?g(n):`
    let col = colIn * ${n};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${g(n)}
    }
    return ${F1(n,d)}(0.0);`:`
    let col = colIn * ${n};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${g(n)}
    }
    return ${F1(n,d)}(0.0);`,z=F1(c,d),L=a?F1(o,d):F1(n,d),H=a?F1(n,d):F1(o,d),I=i5(e,z,d);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${L} {
      ${a?_:C}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${H} {
      ${a?C:_}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${z}) {
      let col = colIn * ${c};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${a?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${M}
      ${rn(i)}
      ${I}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},en=(a,t,r,l,i,e,o,n,c)=>{let d=t.format==="NHWC",u=d?a[0].dims[3]:a[0].dims[1],g=r[0],s=d?r[2]:r[3],M=d?r[1]:r[2],A=d?r[3]:r[1],E=d&&(u%4===0||u%3===0)&&A%4===0,x=d?A:s*M,m=d?s*M:A,T=[8,8,1],_=l<=8?[4,1,1]:[4,4,1],C=[Math.ceil(x/T[0]/_[0]),Math.ceil(m/T[1]/_[1]),Math.ceil(g/T[2]/_[2])];g1("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${C}`);let z=E?d&&u%4!==0?3:4:1,L=T[1]*_[1],H=T[0]*_[0],I=Math.max(T[0]*z,T[1]),N=l%L===0,P=i%H===0,b=e%I===0,G=E?[z,4,4]:[1,1,1],j=[{type:6,data:l},{type:6,data:i},{type:6,data:e},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];e5(t,j),j.push(...J(a[0].dims,a[1].dims));let e1=["rank","rank"];o&&(j.push(...J(a[2].dims)),e1.push("rank")),j.push(...J(r));let V=(F)=>{let a1=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];o5(t,a1);let $=E?4:1,Y=w1(a[0].dataType),i1=`
      fn setOutputAtIndex(flatIndex : i32, value : ${E?`vec4<${Y}>`:Y}) {
        result[flatIndex] = ${E?`vec4<${Y}>`:Y}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${E?`vec4<${Y}>`:Y}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${E?"/ 4":""}, value);
      }`,D=w("x",a[0].dataType,a[0].dims.length,z===3?1:z),W=w("w",a[1].dataType,a[1].dims.length,$),t1=[D,W],s1=Q("result",a[0].dataType,r.length,$);if(o){let R1=w("bias",a[2].dataType,a[2].dims.length,$);t1.push(R1),i1+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${E?`vec4<${Y}>`:Y} {
          return bias[coords.${d?"w":"y"}${E?"/ 4":""}];
        }`}return`
        ${ln("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${F.registerUniforms(a1).declareVariables(...t1,s1)}
        ${i1}
        ${W9(d,N,P,b,o,t,G[0],G[1],G[2],Y)}
        ${E?a6(_,T,Y,void 0,!d,I):t6(_,T,Y,void 0,!d,I,!1,void 0,n)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${z};${E};${N};${P};${b};${L};${H};${I}`,inputDependencies:e1},getRunData:()=>({outputs:[{dims:c?c(r):r,dataType:a[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:j}),getShaderSource:V}}}),K9,A3,Z5,q9,T3,Y9,on,nn,ts=y(()=>{l1(),H0(),o1(),h1(),h5(),x6(),K9=(a)=>{let t=1;for(let r=0;r<a.length;r++)t*=a[r];return t},A3=(a)=>typeof a=="number"?[a,a,a]:a,Z5=(a,t)=>t<=1?a:a+(a-1)*(t-1),q9=(a,t,r,l=1)=>{let i=Z5(t,l);return Math.floor((a[0]*(r-1)-r+i)/2)},T3=(a,t,r,l,i)=>{i==null&&(i=q9(a,t[0],l[0]));let e=[0,0,0,r];for(let o=0;o<3;o++)a[o]+2*i>=t[o]&&(e[o]=Math.trunc((a[o]-t[o]+2*i)/l[o]+1));return e},Y9=(a,t,r,l,i,e,o,n,c,d)=>{let u,g,s,M;if(a==="VALID"&&(a=0),typeof a=="number"){u={top:a,bottom:a,left:a,right:a,front:a,back:a};let A=T3([t,r,l,1],[n,c,d],1,[i,e,o],a);g=A[0],s=A[1],M=A[2]}else if(Array.isArray(a)){if(!a.every((E,x,m)=>E===m[0]))throw Error(`Unsupported padding parameter: ${a}`);u={top:a[0],bottom:a[1],left:a[2],right:a[3],front:a[4],back:a[5]};let A=T3([t,r,l,1],[n,c,d],1,[i,e,o],a[0]);g=A[0],s=A[1],M=A[2]}else if(a==="SAME_UPPER"){g=Math.ceil(t/i),s=Math.ceil(r/e),M=Math.ceil(l/o);let A=(g-1)*i+n-t,E=(s-1)*e+c-r,x=(M-1)*o+d-l,m=Math.floor(A/2),T=A-m,_=Math.floor(E/2),C=E-_,z=Math.floor(x/2),L=x-z;u={top:_,bottom:C,left:z,right:L,front:m,back:T}}else throw Error(`Unknown padding parameter: ${a}`);return{padInfo:u,outDepth:g,outHeight:s,outWidth:M}},on=(a,t,r,l,i,e=!1,o="channelsLast")=>{let n,c,d,u,g;if(o==="channelsLast")[n,c,d,u,g]=a;else if(o==="channelsFirst")[n,g,c,d,u]=a;else throw Error(`Unknown dataFormat ${o}`);let[s,,M,A,E]=t,[x,m,T]=A3(r),[_,C,z]=A3(l),L=Z5(M,_),H=Z5(A,C),I=Z5(E,z),{padInfo:N,outDepth:P,outHeight:b,outWidth:G}=Y9(i,c,d,u,x,m,T,L,H,I),j=e?s*g:s,e1=[0,0,0,0,0];return o==="channelsFirst"?e1=[n,j,P,b,G]:o==="channelsLast"&&(e1=[n,P,b,G,j]),{batchSize:n,dataFormat:o,inDepth:c,inHeight:d,inWidth:u,inChannels:g,outDepth:P,outHeight:b,outWidth:G,outChannels:j,padInfo:N,strideDepth:x,strideHeight:m,strideWidth:T,filterDepth:M,filterHeight:A,filterWidth:E,effectiveFilterDepth:L,effectiveFilterHeight:H,effectiveFilterWidth:I,dilationDepth:_,dilationHeight:C,dilationWidth:z,inShape:a,outShape:e1,filterShape:t}},nn=(a,t,r,l,i,e)=>{let o=e==="channelsLast",n=o?a[0].dims[3]:a[0].dims[1],c=!1,d=[64,1,1],u={x:r.map((T,_)=>_)},g=[Math.ceil(K9(u.x.map((T)=>r[T]))/d[0]),1,1];g1("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${g}`);let s=c?o&&n%4!==0?3:4:1,M=O.size(r),A=[{type:12,data:M},{type:12,data:l},{type:12,data:i},{type:12,data:t.strides},{type:12,data:t.dilations}];e5(t,A),A.push(...J(a[0].dims,a[1].dims));let E=["rank","rank"],x=a.length===3;x&&(A.push(...J(a[2].dims)),E.push("rank")),A.push(...J(r));let m=(T)=>{let _=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:l.length},{name:"pads",type:"u32",length:i.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];o5(t,_);let C=c?4:1,z=w1(a[0].dataType),L=w("x",a[0].dataType,a[0].dims.length,s===3?1:s),H=w("W",a[1].dataType,a[1].dims.length,C),I=[L,H],N=Q("result",a[0].dataType,r.length,C),P="";if(x){let j=w("bias",a[2].dataType,a[2].dims.length,C);I.push(j),P+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${c?`vec4<${z}>`:z} {
          return bias[${o?X("coords",4,5):X("coords",1,5)}${c?"/ 4":""}];
        }`}let b=F1(s,z),G=i5(t,b,z);return`
            ${P}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${L.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${H.getByIndices("aIndices")};
            }
          ${T.registerUniforms(_).declareVariables(...I,N)}
          ${T.mainStart()}
          ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${N.offsetToIndices("global_idx")};
              let batch = ${X("coords",0,L.rank)};
              let d2 = ${o?X("coords",L.rank-1,L.rank):X("coords",1,L.rank)};
              let xFRCCorner = vec3<u32>(${o?X("coords",1,L.rank):X("coords",2,L.rank)},
              ${o?X("coords",2,L.rank):X("coords",3,L.rank)},
              ${o?X("coords",3,L.rank):X("coords",4,L.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${o?X("uniforms.x_shape",1,L.rank):X("uniforms.x_shape",2,L.rank)};
              let xShapeZ = ${o?X("uniforms.x_shape",2,L.rank):X("uniforms.x_shape",3,L.rank)};
              let xShapeW = ${o?X("uniforms.x_shape",3,L.rank):X("uniforms.x_shape",4,L.rank)};
              let xShapeU = ${o?X("uniforms.x_shape",4,L.rank):X("uniforms.x_shape",1,L.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${o?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${o?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${o?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${o?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${x?"value = value + getBiasByOutputCoords(coords)":""};
              ${G}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${o};${s};${x}`,inputDependencies:E},getRunData:()=>({outputs:[{dims:r,dataType:a[0].dataType}],dispatchGroup:{x:g[0],y:g[1],z:g[2]},programUniforms:A}),getShaderSource:m}}}),hn,cn,rs=y(()=>{l1(),o1(),h1(),h5(),hn=(a,t,r,l)=>{let i=a.length>2,e=i?"value += b[output_channel];":"",o=a[0].dims,n=a[1].dims,c=t.format==="NHWC",d=c?r[3]:r[1],u=d/t.group,g=c&&u>=4?H1(d):1,s=O.size(r)/g,M=[{type:12,data:s},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:u}];e5(t,M),M.push(...J(o,[n[0],n[1],n[2],n[3]/g]));let A=i?["rank","rank","rank"]:["rank","rank"];M.push(...J([r[0],r[1],r[2],r[3]/g]));let E=(x)=>{let m=Q("output",a[0].dataType,r.length,g),T=w1(m.type.tensor),_=i5(t,m.type.value,T),C=w("x",a[0].dataType,o.length),z=w("w",a[1].dataType,n.length,g),L=[C,z];i&&L.push(w("b",a[2].dataType,a[2].dims,g));let H=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];o5(t,H);let I=c?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${C.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${z.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${C.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${z.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${x.registerUniforms(H).declareVariables(...L,m)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${m.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${c?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${c?1:2}], outputIndices[${c?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${g} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${c?2:1}];

    var value: ${m.type.value} = ${m.type.value}(0);
    ${I}
    ${e}
    ${_}
    ${m.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${g}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:l?l(r):r,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:M}),getShaderSource:E}},cn=(a,t,r,l)=>{let i=a.length>2,e=H1(r[3]),o=H1(r[2]),n=O.size(r)/e/o,c=[a[0].dims[0],a[0].dims[1],a[0].dims[2],a[0].dims[3]/e],d=[a[1].dims[0],a[1].dims[1],a[1].dims[2],a[1].dims[3]/e],u=[r[0],r[1],r[2],r[3]/e],g=[{type:12,data:n},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];e5(t,g),g.push(...J(c,d,u));let s=(o-1)*t.strides[1]+d[1],M=(A)=>{let E=Q("output",a[0].dataType,u.length,e),x=w1(E.type.tensor),m=i5(t,E.type.value,x),T=w("x",a[0].dataType,c.length,e),_=w("w",a[1].dataType,d.length,e),C=[T,_];i&&C.push(w("b",a[2].dataType,a[2].dims,e));let z=i?"value += b[output_channel];":"",L=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return o5(t,L),`
  ${A.registerUniforms(L).declareVariables(...C,E)}
  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${o}u;
    let col = (index1 % width1) * ${o}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${T.type.value}, ${s}>;
    var values: array<${E.type.value}, ${o}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${d[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${s}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${T.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${T.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${d[1]}; w_width++) {
          let w_val = ${_.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${o}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${o}u; i++) {
      var value = values[i];
      ${z}
      ${m}
      ${E.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${e};${o};${s};${d[0]};${d[1]}`,inputDependencies:i?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:l?l(r):r,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:g}),getShaderSource:M}}}),Q9,O2,X9,R2,r6,E3,J9,$9,l6,ls=y(()=>{o1(),as(),ts(),B6(),rs(),h5(),_6(),b0(),Q9=(a,t,r,l,i,e)=>{let o=a[0],n=a.slice(e?1:2,e?3:4),c=n.length,d=t[0],u=t.slice(2).map((s,M)=>s+(s-1)*(r[M]-1)),g=n.map((s,M)=>s+l[M]+l[M+c]).map((s,M)=>Math.floor((s-u[M]+i[M])/i[M]));return g.splice(0,0,o),g.splice(e?3:1,0,d),g},O2=[2,3,1,0],X9=(a,t)=>{if(!a||a.length!==2&&a.length!==3)throw Error("Conv requires 2 or 3 inputs");if(a[0].dims.length>5)throw Error("greater than 5D is not supported");if(a[0].dims.length!==a[1].dims.length)throw Error("filter does not have same dimension as input");let r=a[0].dims[t.format==="NHWC"?a[0].dims.length-1:1],l=a[1].dims[1]*t.group;if(r!==l)throw Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(a.length===3&&(a[2].dims.length!==1||a[1].dims[0]!==a[2].dims[0]))throw Error("invalid bias");let i=a[0].dims.length-2;if(t.dilations.length!==i)throw Error(`dilations should be ${i}D`);if(t.strides.length!==i)throw Error(`strides should be ${i}D`);if(t.pads.length!==i*2)throw Error(`pads should be ${i*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==a[1].dims.length-2)throw Error("invalid kernel shape")},R2=(a,t)=>{let r=a.kernelShape.slice();r.length<t[1].dims.length-2&&r.push(...Array(t[1].dims.length-2-r.length).fill(0));for(let e=2;e<t[1].dims.length;++e)r[e-2]===0&&(r[e-2]=t[1].dims[e]);let l=a.pads.slice();j2.adjustPadsBasedOnAutoPad(t[0].dims,a.strides,a.dilations,r,l,a.format==="NHWC",a.autoPad);let i=Object.assign({},a);return Object.assign(i,{kernelShape:r,pads:l}),i},r6=(a)=>{let t=f6(a),r=a.format,l=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][a.auto_pad],i=a.dilations,e=a.group,o=a.kernel_shape,n=a.pads,c=a.strides,d=a.w_is_const();return{autoPad:l,format:r,dilations:i,group:e,kernelShape:o,pads:n,strides:c,wIsConst:d,...t,cacheKey:`${a.format};${t.activation};`}},E3=(a,t,r,l)=>{let i=r.format==="NHWC",e=Q9(t[0].dims,t[1].dims,r.dilations,r.pads,r.strides,i);if(r.group!==1){let L=[t[0]];if(i){let H=a.kernelCustomData.wT??a.compute($1(t[1],O2),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!a.kernelCustomData.wT&&(a.kernelCustomData.wT=H),L.push(H)}else L.push(t[1]);t.length===3&&L.push(t[2]),!a.adapterInfo.isArchitecture("ampere")&&i&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1?a.compute(cn(L,r,e,l),{inputs:L}):a.compute(hn(L,r,e,l),{inputs:L});return}let o=t.length===3,n=t[0].dims[i?1:2],c=t[0].dims[i?2:3],d=t[0].dims[i?3:1],u=t[1].dims[2],g=t[1].dims[3],s=e[i?1:2],M=e[i?2:3],A=e[i?3:1],E=i&&u===n&&g===c&&r.pads[0]===0&&r.pads[1]===0;if(E||u===1&&g===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let L=e[0],H,I,N,P=[];if(i){let j=a.kernelCustomData.wT??a.compute($1(t[1],O2),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!a.kernelCustomData.wT&&(a.kernelCustomData.wT=j),E){let e1=n*c*d;H=t[0].reshape([1,L,e1]),I=j.reshape([1,e1,A]),N=[1,L,A]}else H=t[0].reshape([L,n*c,d]),I=j.reshape([1,d,A]),N=[L,s*M,A];P.push(H),P.push(I)}else H=t[0].reshape([L,d,n*c]),I=t[1].reshape([1,A,d]),N=[L,A,s*M],P.push(I),P.push(H);o&&P.push(t[2]);let b=N[2],G=P[0].dims[P[0].dims.length-1];b<8&&G<8?a.compute(C6(P,r,e,N,i,l),{inputs:P}):a.compute(W2(P,r,e,N,i,l),{inputs:P});return}let x=!0,m=a.kernelCustomData.wT??a.compute($1(t[1],O2),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!a.kernelCustomData.wT&&(a.kernelCustomData.wT=m);let T=[t[0],m];o&&T.push(t[2]);let _=i?s*M:A,C=i?A:s*M,z=u*g*d;a.compute(en(T,r,e,_,C,z,o,x,l),{inputs:T})},J9=(a,t)=>{let r=t.format==="NHWC",l=[a.inputs[0].reshape(r?[a.inputs[0].dims[0],1,a.inputs[0].dims[1],a.inputs[0].dims[2]]:[a.inputs[0].dims[0],a.inputs[0].dims[1],1,a.inputs[0].dims[2]]),a.inputs[1].reshape([a.inputs[1].dims[0],a.inputs[1].dims[1],1,a.inputs[1].dims[2]])];a.inputs.length===3&&l.push(a.inputs[2]);let i=[0,t.pads[0],0,t.pads[1]],e=[1].concat(t.strides),o=[1].concat(t.dilations),n=[1].concat(t.kernelShape),c=R2({...t,pads:i,strides:e,dilations:o,kernelShape:n},l);E3(a,l,c,(d)=>r?[d[0],d[2],d[3]]:[d[0],d[1],d[3]])},$9=(a,t,r)=>{let l=r.format==="NHWC"?"channelsLast":"channelsFirst",i=R2(r,t),e=r.autoPad==="NOTSET"?r.pads:r.autoPad,o=on(t[0].dims,t[1].dims,r.strides,r.dilations,e,!1,l);a.compute(nn(t,i,o.outShape,[o.filterDepth,o.filterHeight,o.filterWidth],[o.padInfo.front,o.padInfo.top,o.padInfo.left],l))},l6=(a,t)=>{if(X9(a.inputs,t),a.inputs[0].dims.length===3)J9(a,t);else if(a.inputs[0].dims.length===5)$9(a,a.inputs,t);else{let r=R2(t,a.inputs);E3(a,a.inputs,r)}}}),dn,is=y(()=>{l1(),H0(),o1(),h1(),dn=(a,t,r)=>{let l=a.length>2,i=t.outputShape,e=t.format==="NHWC",o=t.group,n=a[1].dims,c=n[2]/o,d=n[3],u=e?H1(c):1,g=e&&d===1&&c>=4,s=g?Math.floor(c/4)*4:Math.floor(c/u)*u,M=c-s,A=e?H1(d):1,E=e?d===1?u:A:1,x=O.size(i)/A,m=[Math.ceil(x/64),1,1];g1("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${m}`);let T=["rank","rank"],_=[t.strides[0],t.strides[1]],C=[t.kernelShape[e?1:2],t.kernelShape[e?2:3]],z=[t.dilations[0],t.dilations[1]],L=[C[0]+(t.dilations[0]<=1?0:(t.kernelShape[e?1:2]-1)*(t.dilations[0]-1)),C[1]+(t.dilations[1]<=1?0:(t.kernelShape[e?2:3]-1)*(t.dilations[1]-1))],H=[L[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),L[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],I=[{type:12,data:x},{type:12,data:_},{type:12,data:C},{type:12,data:z},{type:12,data:L},{type:6,data:H},{type:12,data:s},{type:12,data:c},{type:12,data:d},...J(a[0].dims,a[1].dims)];l&&(I.push(...J(a[2].dims)),T.push("rank")),I.push(...J(i));let N=(P)=>{let b=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:_.length},{name:"filter_dims",type:"u32",length:C.length},{name:"dilations",type:"u32",length:C.length},{name:"effective_filter_dims",type:"u32",length:L.length},{name:"pads",type:"i32",length:H.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],G=w1(a[0].dataType),j=e?1:2,e1=e?2:3,V=e?3:1,F=w("W",a[1].dataType,a[1].dims.length,E),a1=w("Dy",a[0].dataType,a[0].dims.length,u),$=[a1,F];l&&$.push(w("bias",a[2].dataType,[i[V]].length,A));let Y=Q("result",a[0].dataType,i.length,A),i1=()=>{let t1="";if(g)u===4?t1+=`
        let xValue = ${a1.getByOffset("x_offset")};
        let wValue = ${F.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:u===2?t1+=`
          dotProd = dotProd + dot(vec4<${G}>(${a1.getByOffset("x_offset")}, ${a1.getByOffset("x_offset + 1u")}), vec4<${G}>(${F.getByOffset("w_offset")}, ${F.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:u===1&&(t1+=`
          dotProd = dotProd + dot(vec4<${G}>(${a1.getByOffset("x_offset")}, ${a1.getByOffset("x_offset + 1u")}, ${a1.getByOffset("x_offset + 2u")}, ${a1.getByOffset("x_offset + 3u")}), vec4<${G}>(${F.getByOffset("w_offset")}, ${F.getByOffset("w_offset + 1u")}, ${F.getByOffset("w_offset + 2u")}, ${F.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(t1+=`
                  let xValue = ${e?a1.getByOffset(`${a1.indicesToOffset(`${a1.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${u}`):a1.get("batch","inputChannel","idyR","idyC")};
        `,u===1)t1+=`
          let w_offset = ${F.indicesToOffset(`${F.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${F.getByOffset(`w_offset / ${E}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let s1=0;s1<u;s1++)t1+=`
            let wValue${s1} = ${F.getByOffset(`${F.indicesToOffset(`${F.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${s1}, wOutChannel)`)} / ${E}`)};
            dotProd = dotProd + xValue[${s1}] * wValue${s1};`;return t1},D=()=>{if(M===0)return"";if(!g)throw Error(`packInputAs4 ${g} is not true.`);let t1="";if(u===1){t1+="dotProd = dotProd";for(let s1=0;s1<M;s1++)t1+=`
            + ${a1.getByOffset(`x_offset + ${s1}`)} * ${F.getByOffset(`w_offset + ${s1}`)}`;t1+=";"}else if(u===2){if(M!==2)throw Error(`Invalid inputChannelsRemainder ${M}.`);t1+=`
          let xValue = ${a1.getByOffset("x_offset")};
          let wValue = ${F.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return t1},W=`
            let outputIndices = ${Y.offsetToIndices(`global_idx * ${A}`)};
            let batch = ${Y.indicesGet("outputIndices",0)};
            let d1 = ${Y.indicesGet("outputIndices",V)};
            let r = ${Y.indicesGet("outputIndices",j)};
            let c = ${Y.indicesGet("outputIndices",e1)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${Y.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${G}(dyRCorner) + ${G}(wR)) / ${G}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${G}(uniforms.Dy_shape[${j}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${G}(dyCCorner) + ${G}(wC)) / ${G}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${G}(uniforms.Dy_shape[${e1}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${g?`
                var x_offset = ${a1.indicesToOffset(`${a1.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${u};
                var w_offset = ${F.indicesToOffset(`${F.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${E};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${g?4:u}) {
                  ${i1()}
                  inputChannel = inputChannel + ${g?4:u};
                }
                ${D()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${l?` + bias[d1 / ${A}]`:""};
            ${Y.setByOffset("global_idx","value")};
          `;return`
    ${P.registerUniforms(b).declareVariables(...$,Y)}
      ${P.mainStart()}
      ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${W}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${u}${E}${A}${g}${M}`,inputDependencies:T},getRunData:()=>({dispatchGroup:{x:m[0],y:m[1],z:m[2]},outputs:[{dims:r?r(i):i,dataType:a[0].dataType}],programUniforms:I}),getShaderSource:N}}}),al,tl,rl,I3,vn,ll,m3,il,un,es=y(()=>{is(),h5(),b0(),al=(a,t,r,l,i,e)=>(a-1)*t+r+(l-1)*i+1-e,tl=(a,t,r,l,i)=>{let e=Math.floor(a/2);t==="SAME_UPPER"?(r[l]=e,r[i]=a-e):t==="SAME_LOWER"&&(r[l]=a-e,r[i]=e)},rl=(a,t,r,l,i,e,o,n,c,d)=>{let u=a.length-2,g=d.length===0;c.length<u&&c.push(...Array(u-c.length).fill(0));let s=a[0],M=t[n?3:1]*i;for(let A=0,E=a.length-u-(n?1:0);A<u;++A,++E){let x=a[E],m=g?x*o[A]:d[A],T=al(x,o[A],e[A],t[E],r[A],m);tl(T,l,e,A,A+u),g&&d.push(o[A]*(x-1)+c[A]+(t[E]-1)*r[A]+1-e[A]-e[A+u])}d.splice(0,0,s),d.splice(n?3:1,0,M)},I3=(a,t)=>{let r=a.kernelShape.slice();if(a.kernelShape.length===0||a.kernelShape.reduce((g,s)=>g*s,1)===0){r.length=0;for(let g=2;g<t[1].dims.length;++g)r.push(t[1].dims[g])}let l=a.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(l?3:1,0,t[1].dims[1]);let i=a.pads.slice(),e=a.outputShape.slice(),o=a.outputPadding.slice(),n=t[0].dims,c=a.dilations.slice();if(c.reduce((g,s)=>g+s,0)===0){let g=t[0].dims.length-2;c=Array(g).fill(1)}let d=a.strides.slice();if(d.reduce((g,s)=>g+s,0)===0){let g=t[0].dims.length-2;d=Array(g).fill(1)}rl(n,r,c,a.autoPad,a.group,i,d,l,o,e);let u=Object.assign({},a);return Object.assign(u,{kernelShape:r,pads:i,outputPadding:o,outputShape:e,dilations:c,strides:d}),u},vn=(a)=>{let t=f6(a),r=a.format,l=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof a.autoPad>"u"?0:a.autoPad],i=a.dilations,e=a.group,o=a.kernelShape,n=a.pads,c=a.strides,d=a.wIsConst(),u=a.outputPadding,g=a.outputShape;return{autoPad:l,format:r,dilations:i,group:e,kernelShape:o,outputPadding:u,outputShape:g,pads:n,strides:c,wIsConst:d,...t,cacheKey:`${a.format};${t.activation};`}},ll=(a,t)=>{if(!a||a.length!==2&&a.length!==3)throw Error("Conv requires 2 or 3 inputs");if(a[0].dims.length!==4&&a[0].dims.length!==3)throw Error("currently only support 2-dimensional conv");if(a[0].dims.length!==a[1].dims.length)throw Error("filter does not have same dimension as input");let r=a[0].dims[t.format==="NHWC"?a[0].dims.length-1:1],l=a[1].dims[0];if(r!==l)throw Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=a[1].dims[1]*t.group;if(a.length===3&&(a[2].dims.length!==1||a[2].dims[0]!==i))throw Error("invalid bias");let e=a[0].dims.length-2;if(t.dilations.reduce((o,n)=>o+n,0)>0&&t.dilations.length!==e)throw Error(`dilations should be ${e}D`);if(t.strides.reduce((o,n)=>o+n,0)>0&&t.strides.length!==e)throw Error(`strides should be ${e}D`);if(t.pads.reduce((o,n)=>o+n,0)>0&&t.pads.length!==e*2)throw Error(`pads should be ${e*2}D`);if(t.outputPadding.length!==e&&t.outputPadding.length!==0)throw Error(`output_padding should be ${e}D`);if(t.kernelShape.reduce((o,n)=>o+n,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==a[1].dims.length-2)throw Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==a[0].dims.length-2)throw Error("invalid output shape")},m3=(a,t,r,l)=>{let i=a.kernelCustomData.wT??a.compute($1(t[1],[2,3,0,1]),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!a.kernelCustomData.wT&&(a.kernelCustomData.wT=i);let e=[t[0],i];t.length===3&&e.push(t[2]),a.compute(dn(e,r,l),{inputs:e})},il=(a,t)=>{let r=t.format==="NHWC",l=[a.inputs[0].reshape(r?[a.inputs[0].dims[0],1,a.inputs[0].dims[1],a.inputs[0].dims[2]]:[a.inputs[0].dims[0],a.inputs[0].dims[1],1,a.inputs[0].dims[2]]),a.inputs[1].reshape([a.inputs[1].dims[0],a.inputs[1].dims[1],1,a.inputs[1].dims[2]])];a.inputs.length===3&&l.push(a.inputs[2]);let i=t.kernelShape;(i.length===0||i[0]===0)&&(i=[a.inputs[1].dims[2]]);let e=t.dilations;(e.length===0||e[0]===0)&&(e=[1]);let o=t.strides;(o.length===0||o[0]===0)&&(o=[1]);let n=t.pads;n.length===0&&(n=[0,0]),n=[0,n[0],0,n[1]],o=[1].concat(o),e=[1].concat(e),i=[1].concat(i);let c=t.outputPadding;c=[0].concat(c);let d=I3({...t,pads:n,strides:o,dilations:e,kernelShape:i,outputPadding:c},l);m3(a,l,d,(u)=>r?[u[0],u[2],u[3]]:[u[0],u[1],u[3]])},un=(a,t)=>{if(ll(a.inputs,t),a.inputs[0].dims.length===3)il(a,t);else{let r=I3(t,a.inputs);m3(a,a.inputs,r)}}}),el,gn,sn,os=y(()=>{l1(),o1(),V1(),h1(),el=(a,t,r,l)=>{let i=O.size(t),e=t.length,o=w("input",a,e),n=Q("output",a,e),c=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),d=O.normalizeAxis(c,e),u=(g)=>{let s=` i32(${o.indicesGet("inputIndices","uniforms.axis")}) `,M=X("uniforms.input_shape","uniforms.axis",e),A=l.reverse?s+(l.exclusive?" + 1":""):"0",E=l.reverse?M:s+(l.exclusive?"":" + 1");return`
                ${g.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(o,n)}
                ${g.mainStart()}
                  ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${n.offsetToIndices("global_idx")};
                  var sum = ${n.type.value}(0);
                  let first : i32 = ${A};
                  let last : i32 = ${E};
                  for (var i : i32 = first; i < last; i++) {
                    ${o.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${o.getByIndices("inputIndices")};
                  }
                  ${n.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:l.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:a}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},{type:12,data:d},...J(t,t)]}),getShaderSource:u}},gn=(a,t)=>{let r=a.inputs[0].dims,l=a.inputs[0].dataType,i=a.inputs[1];a.compute(el(l,r,i,t),{inputs:[0]})},sn=(a)=>{let t=a.exclusive===1,r=a.reverse===1;return T1({exclusive:t,reverse:r})}}),ol,nl,hl,pn,Sn,ns=y(()=>{l1(),o1(),V1(),h1(),ol=(a)=>{if(!a||a.length!==1)throw Error("DepthToSpace requires 1 input.");if(a[0].dims.length!==4)throw Error("DepthToSpace requires 4D input.")},nl=(a,t,r,l)=>{let i=[];i.push(`fn perm(i: ${l.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let e=0;e<t;++e)i.push(r.indicesSet("a",a[e],`i[${e}]`));return i.push("return a;}"),i.join(`
`)},hl=(a,t)=>{let r,l,i,e,o,n,c=t.format==="NHWC",d=t.blocksize,u=t.mode==="DCR";c?([r,l,i,e]=a.dims,o=u?[r,l,i,d,d,e/d**2]:[r,l,i,e/d**2,d,d],n=u?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,l,i,e]=[a.dims[0],a.dims[2],a.dims[3],a.dims[1]],o=u?[r,d,d,e/d**2,l,i]:[r,e/d**2,d,d,l,i],n=u?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let g=a.reshape(o),s=g.dims.length,M=a.dataType,A=w("a",M,s),E=Q("output",M,s),x=(m)=>`
  ${m.registerUniform("output_size","u32").declareVariables(A,E)}

  ${nl(n,s,A,E)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${E.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${E.setByOffset("global_idx",A.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${a.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:(m)=>{let T=c?[r,l*d,i*d,e/d**2]:[r,e/d**2,l*d,i*d],_=O.size(T),C=g.dims,z=O.sortBasedOnPerm(C,n);return{outputs:[{dims:T,dataType:m[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:[{type:12,data:_},...J(C,z)]}},getShaderSource:x}},pn=(a,t)=>{ol(a.inputs),a.compute(hl(a.inputs[0],t))},Sn=(a)=>T1({blocksize:a.blocksize,mode:a.mode,format:a.format})}),w2,y5,f3,cl,dl,vl,ul,x3,gl,Mn,An,hs=y(()=>{l1(),o1(),V1(),h1(),w2="[a-zA-Z]|\\.\\.\\.",y5="("+w2+")+",f3="^"+y5+"$",cl="("+y5+",)*"+y5,dl="^"+cl+"$",vl=class{constructor(a=-1){this.symbolToIndices=new Map,this.inputIndex=a}addSymbol(a,t){let r=this.symbolToIndices.get(a);r===void 0?r=[t]:r.push(t),this.symbolToIndices.set(a,r)}},ul=class{constructor(a,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=[],this.outputDims=[];let[r,l]=t.includes("->")?t.split("->",2):[t,""];if(!r.match(RegExp(dl)))throw Error("Invalid LHS term");if(r.split(",").forEach((i,e)=>{let o=a[e].dims.slice();if(!i.match(RegExp(f3)))throw Error("Invalid LHS term");let n=this.processTerm(i,!0,o,e);this.lhs.push(n)}),l==="")l+=[...this.symbolToInfo.entries()].filter(([i,e])=>e.count===1||i==="...").map(([i])=>i).join("");else if(!l.match(RegExp(y5)))throw Error("Invalid RHS");l.match(RegExp(w2,"g"))?.forEach((i)=>{if(i==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let e=this.symbolToInfo.get(i);if(e===void 0)throw Error("Invalid RHS symbol");this.outputDims.push(e.dimValue)}}),this.rhs=this.processTerm(l,!1,this.outputDims)}addSymbol(a,t,r){let l=this.symbolToInfo.get(a);if(l!==void 0){if(l.dimValue!==t&&l.count!==1)throw Error("Dimension mismatch");l.count++,l.inputIndices.push(r)}else l={count:1,dimValue:t,inputIndices:[r]};this.symbolToInfo.set(a,l)}processTerm(a,t,r,l=-1){let i=r.length,e=!1,o=[],n=0;if(!a.match(RegExp(f3))&&!t&&a!=="")throw Error("Invalid LHS term");let c=a.match(RegExp(w2,"g")),d=new vl(l);return c?.forEach((u,g)=>{if(u==="..."){if(e)throw Error("Only one ellipsis is allowed per input term");e=!0;let s=i-c.length+1;if(s<0)throw Error("Ellipsis out of bounds");if(o=r.slice(n,n+s),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw Error("Ellipsis dimensions mismatch")}else if(t)this.hasEllipsis=!0,this.ellipsisDims=o;else throw Error("Ellipsis must be specified in the LHS");for(let M=0;M<o.length;M++){let A=String.fromCharCode(48+M);d.addSymbol(A,g+M),this.addSymbol(A,r[n++],l)}}else d.addSymbol(u,g+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(u,r[n++],l)}),d}},x3=(a)=>a+"_max",gl=(a,t,r,l)=>{let i=a.map((d)=>d.length).map((d,u)=>w(`input${u}`,t,d)),e=O.size(l),o=Q("output",t,l.length),n=[...r.symbolToInfo.keys()].filter((d)=>!r.rhs.symbolToIndices.has(d)),c=(d)=>{let u=[],g="var prod = 1.0;",s="var sum = 0.0;",M="sum += prod;",A=[],E=[],x=[],m=[],T=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((C,z)=>{if(r.rhs.symbolToIndices.has(z)){let L=r.rhs.symbolToIndices.get(z)?.[0];L!==void 0&&r.lhs.forEach((H,I)=>{if(C.inputIndices.includes(I)){let N=H.symbolToIndices.get(z);if(N===void 0)throw Error("Invalid symbol error");N.forEach((P)=>{u.push(`${i[I].indicesSet(`input${I}Indices`,P,o.indicesGet("outputIndices",L))}`)})}})}else r.lhs.forEach((L,H)=>{if(C.inputIndices.includes(H)){let I=L.symbolToIndices.get(z);if(I===void 0)throw Error("Invalid symbol error");I.forEach((N)=>{A.push(`${i[H].indicesSet(`input${H}Indices`,N,`${z}`)}`)}),m.push(`prod *= ${i[H].getByIndices(`input${H}Indices`)};`)}}),E.push(`for(var ${z}: u32 = 0; ${z} < uniforms.${x3(z)}; ${z}++) {`),x.push("}")});let _=T?[...u,`let sum = ${i.map((C,z)=>C.getByIndices(`input${z}Indices`)).join(" * ")};`]:[...u,s,...E,...A,g,...m,M,...x];return`
            ${d.registerUniforms(n.map((C)=>({name:`${x3(C)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...i,o)}

            ${d.mainStart()}
            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${o.offsetToIndices("global_idx")};
            ${i.map((C,z)=>`var input${z}Indices: ${i[z].type.indices};`).join(`
`)}
            ${_.join(`
`)};
            ${o.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:r.equation,inputDependencies:a.map(()=>"rank")},getRunData:()=>{let d=n.filter((g)=>r.symbolToInfo.has(g)).map((g)=>({type:12,data:r.symbolToInfo.get(g)?.dimValue||0}));d.push({type:12,data:e});let u=a.map((g,s)=>[...J(g)]).reduce((g,s)=>g.concat(s),d);return u.push(...J(l)),{outputs:[{dims:l,dataType:t}],dispatchGroup:{x:Math.ceil(e/64)},programUniforms:u}},getShaderSource:c}},Mn=(a,t)=>{let r=new ul(a.inputs,t.equation),l=r.outputDims,i=a.inputs.map((e,o)=>e.dims);a.compute(gl(i,a.inputs[0].dataType,r,l))},An=(a)=>{let t=a.equation.replace(/\s+/g,"");return T1({equation:t})}}),sl,C3,pl,Sl,Tn,cs=y(()=>{l1(),o1(),h1(),sl=(a)=>{if(!a||a.length!==2)throw Error("Expand requires 2 input.");let t=a[0].dims,r=Array.from(a[1].getBigInt64Array(),Number),l=r.length<t.length?0:r.length-t.length,i=t.length<r.length?0:t.length-r.length;for(;l<r.length&&i<t.length;++l,++i)if(r[l]!==t[i]&&r[l]!==1&&t[i]!==1)throw Error("Expand requires shape to be broadcastable to input")},C3=(a,t)=>{let r=a.length-t.length,l=[];for(let i=0;i<r;++i)l.push(a[i]);for(let i=0;i<t.length;++i)l.push(t[i]===1?a[i+r]:t[i]);return l},pl=(a,t)=>a.length>t.length?C3(a,t):C3(t,a),Sl=(a)=>{let t=a[0].dims,r=Array.from(a[1].getBigInt64Array(),Number),l=pl(t,r),i=a[0].dataType,e=i===9||O.size(t)===1,o=i===9||t.length>0&&t[t.length-1]%4===0?4:1,n=e||l.length>0&&l[l.length-1]%4===0?4:1,c=Math.ceil(O.size(l)/n),d=(g)=>{let s=w("input",i,t.length,o),M=Q("output",i,l.length,n),A;if(i===9){let E=(x,m,T="")=>`
          let outputIndices${m} = ${M.offsetToIndices(`outputOffset + ${m}u`)};
          let offset${m} = ${s.broadcastedIndicesToOffset(`outputIndices${m}`,M)};
          let index${m} = offset${m} / 4u;
          let component${m} = offset${m} % 4u;
          ${x}[${m}] = ${T}(${s.getByOffset(`index${m}`)}[component${m}]);
        `;A=`
        let outputOffset = global_idx * ${n};
        var data = vec4<u32>(0);
        ${E("data",0,"u32")}
        ${E("data",1,"u32")}
        ${E("data",2,"u32")}
        ${E("data",3,"u32")}
        ${M.setByOffset("global_idx","data")}
      }`}else A=`
        let outputIndices = ${M.offsetToIndices(`global_idx * ${n}`)};
        let inputOffset = ${s.broadcastedIndicesToOffset("outputIndices",M)};
        let data = ${M.type.value}(${s.getByOffset(`inputOffset / ${o}`)});
        ${M.setByOffset("global_idx","data")}
      }`;return`
    ${g.registerUniform("vec_size","u32").declareVariables(s,M)}
    ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${A}`},u=[{type:12,data:c},...J(t,l)];return{name:"Expand",shaderCache:{hint:`${l.length};${o}${n}`,inputDependencies:["rank"]},getShaderSource:d,getRunData:()=>({outputs:[{dims:l,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:u})}},Tn=(a)=>{sl(a.inputs),a.compute(Sl(a.inputs),{inputs:[0]})}}),Ml,En,ds=y(()=>{l1(),o1(),h1(),m6(),Ml=(a)=>{let t=a[0].dataType,r=O.size(a[0].dims),l=O.size(a[1].dims),i=l%4===0,e=(o)=>{let n=w("x",t,[1],4),c=w("bias",t,[1],4),d=Q("y",t,[1],4),u=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],g=(M)=>`
      let bias${M}_offset: u32 = (global_idx * 4 + ${M}) % uniforms.bias_size;
      let bias${M} = ${c.getByOffset(`bias${M}_offset / 4`)}[bias${M}_offset % 4];`,s=i?`
      let bias = ${c.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${g(0)}${g(1)}${g(2)}${g(3)}
      let bias = ${n.type.value}(bias0, bias1, bias2, bias3);`;return`${o.registerUniforms(u).declareVariables(n,c,d)}

    ${J3(Z1(t))}

    ${o.mainStart(E5)}
      ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${n.getByOffset("global_idx")};
      ${s}
      let x_in = x + bias;
      ${d.setByOffset("global_idx",$3("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${i}`,inputDependencies:["type","type"]},getShaderSource:e,getRunData:(o)=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:l}],dispatchGroup:{x:Math.ceil(r/E5/4)}})}},En=(a)=>{a.inputs.length<2||O.size(a.inputs[1].dims)===0?Po(a):a.compute(Ml(a.inputs))}}),Al,Tl,In,mn,vs=y(()=>{l1(),o1(),V1(),h1(),Al=(a)=>{if(!a||a.length!==2)throw Error("Gather requires 2 inputs.")},Tl=(a,t)=>{let r=a[0].dims,l=a[1].dims,i=r.length,e=O.normalizeAxis(t.axis,i),o=r.slice(0);o.splice(e,1,...l);let n=r[e],c=a[0].dataType===9?4:1,d=Math.ceil(O.size(o)/c),u=[{type:12,data:d},{type:6,data:n},{type:12,data:e},...J(a[0].dims,a[1].dims,o)],g=(s)=>{let M=w("data",a[0].dataType,a[0].dims.length,c),A=w("inputIndices",a[1].dataType,a[1].dims.length),E=Q("output",a[0].dataType,o.length,c),x=(T)=>{let _=l.length,C=`var indicesIndices${T}  = ${A.type.indices}(0);`;for(let z=0;z<_;z++)C+=`${_>1?`indicesIndices${T}[${z}]`:`indicesIndices${T}`} = ${o.length>1?`outputIndices${T}[uniforms.axis + ${z}]`:`outputIndices${T}`};`;C+=`
          var idx${T} = ${A.getByIndices(`indicesIndices${T}`)};
          if (idx${T} < 0) {
            idx${T} = idx${T} + uniforms.axisDimLimit;
          }
          var dataIndices${T} : ${M.type.indices};
        `;for(let z=0,L=0;z<i;z++)z===e?(C+=`${i>1?`dataIndices${T}[${z}]`:`dataIndices${T}`} = u32(idx${T});`,L+=_):(C+=`${i>1?`dataIndices${T}[${z}]`:`dataIndices${T}`} = ${o.length>1?`outputIndices${T}[${L}]`:`outputIndices${T}`};`,L++);return C},m;if(a[0].dataType===9){let T=(_,C,z="")=>`
          let outputIndices${C} = ${E.offsetToIndices(`outputOffset + ${C}u`)};
          ${x(C)};
          let offset${C} = ${M.indicesToOffset(`dataIndices${C}`)};
          let index${C} = offset${C} / 4u;
          let component${C} = offset${C} % 4u;
          ${_}[${C}] = ${z}(${M.getByOffset(`index${C}`)}[component${C}]);
        `;m=`
        let outputOffset = global_idx * ${c};
        var value = vec4<u32>(0);
        ${T("value",0,"u32")}
        ${T("value",1,"u32")}
        ${T("value",2,"u32")}
        ${T("value",3,"u32")}
        ${E.setByOffset("global_idx","value")}
      `}else m=`
      let outputIndices = ${E.offsetToIndices("global_idx")};
      ${x("")};
      let value = ${M.getByIndices("dataIndices")};
      ${E.setByOffset("global_idx","value")};
      `;return`
      ${s.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(M,A,E)}
      ${s.mainStart()}
        ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${m}
      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}),getShaderSource:g}},In=(a)=>T1({axis:a.axis}),mn=(a,t)=>{let r=a.inputs;Al(r),a.compute(Tl(a.inputs,t))}}),El,fn,xn,us=y(()=>{l1(),o1(),h1(),El=(a,t,r,l,i,e,o,n,c)=>{let d=[{type:12,data:e},{type:12,data:l},{type:12,data:i},{type:12,data:r},{type:12,data:o},{type:12,data:n},{type:12,data:c}],u=[e];d.push(...J(t.dims,u));let g=(s)=>{let M=w("indices_data",t.dataType,t.dims.length),A=Q("input_slice_offsets_data",12,1,1),E=[M,A],x=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:i.length},{name:"sizes_from_slice_dims_data",type:"u32",length:r.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${s.registerUniforms(x).declareVariables(...E)}
  ${s.mainStart()}
    ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${i.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${r.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return a.compute({name:"computeSliceOffsets",shaderCache:{hint:`${i.length}_${r.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:u,dataType:a.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(e/64)},programUniforms:d}),getShaderSource:g},{inputs:[t],outputs:[-1]})[0]},fn=(a,t)=>{let r=a.inputs,l=r[0].dims,i=r[0].dataType,e=r[1].dims,o=e[e.length-1],n=O.sizeToDimension(e,e.length-1),c=O.sizeFromDimension(l,t.batchDims+o),d=O.sizeToDimension(l,t.batchDims),u=O.sizeFromDimension(l,t.batchDims),g=n/d,s=Array(o),M=c;for(let C=0;C<o;++C)s[o-1-C]=M,M*=l[t.batchDims+o-1-C];let A=El(a,r[1],s,t.batchDims,l,n,g,u,o),E=t.batchDims+o;if(E>l.length)throw Error("last dimension of indices must not be larger than rank of input tensor");let x=e.slice(0,-1).concat(l.slice(E)),m=O.size(x),T=[{type:12,data:m},{type:12,data:c},...J(r[0].dims,A.dims,x)],_=(C)=>{let z=w("data",r[0].dataType,r[0].dims.length),L=w("slice_offsets",12,A.dims.length),H=Q("output",r[0].dataType,x.length);return`
          ${C.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(z,L,H)}
            ${C.mainStart()}
            ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};a.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:x,dataType:i}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:T}),getShaderSource:_},{inputs:[r[0],A]})},xn=(a)=>({batchDims:a.batch_dims,cacheKey:""})}),Il,ml,Cn,_n,gs=y(()=>{l1(),o1(),V1(),h1(),Il=(a,t)=>{if(a.length<3||a.length>4)throw Error("GatherBlockQuantized requires 3 or 4 inputs.");let r=O.normalizeAxis(t.quantizeAxis,a[0].dims.length),l=t.blockSize,i=a[0],e=a[2],o=a.length===4?a[3]:void 0;if(e.dims.length!==i.dims.length||!i.dims.map((n,c)=>c===r?Math.ceil(n/l)===e.dims[c]:n===e.dims[c]).reduce((n,c)=>n&&c,!0))throw Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(o){if(o.dataType!==i.dataType)throw Error("Zero point must have the same data type as the input tensor.");if(o.dims.length!==e.dims.length||!o.dims.map((n,c)=>n===e.dims[c]).reduce((n,c)=>n&&c,!0))throw Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},ml=(a,t)=>{let r=a[0].dims,l=a[1].dims,i=r.length,e=O.normalizeAxis(t.gatherAxis,i),o=O.normalizeAxis(t.quantizeAxis,i),n=r.slice(0);n.splice(e,1,...l);let c=O.size(n),d=a[2].dataType,u=a[0].dataType===22,g=[{type:12,data:c},{type:12,data:o},{type:12,data:e},{type:12,data:t.blockSize},...J(...a.map((M,A)=>M.dims),n)],s=(M)=>{let A=w("data",a[0].dataType,a[0].dims.length),E=w("inputIndices",a[1].dataType,a[1].dims.length),x=w("scales",a[2].dataType,a[2].dims.length),m=a.length>3?w("zeroPoint",a[3].dataType,a[3].dims.length):void 0,T=Q("output",d,n.length),_=[A,E,x];m&&_.push(m);let C=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${M.registerUniforms(C).declareVariables(..._,T)}
        ${M.mainStart()}
        let output_indices = ${T.offsetToIndices("global_idx")};
        var indices_indices = ${E.type.indices}(0);
        ${l.length>1?`
          for (var i: u32 = 0; i < ${l.length}; i++) {
            let index = ${T.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${E.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${T.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${A.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${T.indicesGet("output_indices","i")};
          ${A.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${E.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${r[e]};
        }
        ${A.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${n.length}; i++) {
          let index = ${T.indicesGet("output_indices",`i + ${l.length} - 1`)};
          ${A.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${A.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${A.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${u?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${x.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${x.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${x.getByIndices("scale_indices")};
        ${m?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${m.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${m.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${u?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${Z1(d)}(quantized_data - zero_point) * scale;
        ${T.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${a.filter((M,A)=>A!==1).map((M)=>M.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:a.length},(M,A)=>"rank")},getRunData:()=>({outputs:[{dims:n,dataType:d}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:g}),getShaderSource:s}},Cn=(a,t)=>{let r=a.inputs;Il(r,t),a.compute(ml(a.inputs,t))},_n=(a)=>T1({blockSize:a.blockSize,gatherAxis:a.gatherAxis,quantizeAxis:a.quantizeAxis})}),fl,xl,Bn,zn,ss=y(()=>{l1(),o1(),V1(),h1(),fl=(a)=>{if(!a||a.length!==2)throw Error("GatherElements requires 2 inputs.");if(a[0].dims.length<1)throw Error("GatherElements requires that the data input be rank >= 1.");if(a[0].dims.length!==a[1].dims.length)throw Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},xl=(a,t)=>{let r=a[0].dims,l=a[0].dataType,i=r.length,e=a[1].dims,o=a[1].dataType,n=O.normalizeAxis(t.axis,i),c=r[n],d=e.slice(0),u=O.size(d),g=w("input",l,i),s=w("indicesInput",o,e.length),M=Q("output",l,d.length),A=[{type:12,data:u},{type:6,data:c},{type:12,data:n}];return A.push(...J(r,e,d)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:d,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:A}),getShaderSource:(E)=>`
      ${E.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(g,s,M)}
      ${E.mainStart()}
      ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${M.offsetToIndices("global_idx")};

      var idx = ${s.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${g.type.indices}(outputIndices);
      ${g.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${g.getByIndices("inputIndices")};

      ${M.setByOffset("global_idx","value")};
  }`}},Bn=(a)=>T1({axis:a.axis}),zn=(a,t)=>{let r=a.inputs;fl(r),a.compute(xl(a.inputs,t))}}),Cl,_l,Ln,Hn,ps=y(()=>{l1(),o1(),h1(),Cl=(a)=>{if(!a)throw Error("Input is missing");if(a.length<2||a.length>3)throw Error("Invaid input number.");if(a.length===3&&a[2].dims.length>2)throw Error("Invalid input shape of C");if(a[0].dataType!==a[1].dataType||a.length===3&&a[0].dataType!==a[2].dataType)throw Error("Input types are mismatched")},_l=(a,t)=>{let r=a[0].dims.slice(),l=a[1].dims.slice(),[i,e,o]=Ce.getShapeOfGemmResult(r,t.transA,l,t.transB,a.length===3?a[2].dims:void 0),n=[i,e];if(!n)throw Error("Can't use gemm on the given tensors");let c=16,d=Math.ceil(e/c),u=Math.ceil(i/c),g=!0,s=O.size(n),M=[{type:12,data:g?d:s},{type:12,data:i},{type:12,data:e},{type:12,data:o},{type:1,data:t.alpha},{type:1,data:t.beta}],A=["type","type"];a.length===3&&(M.push(...J(a[2].dims)),A.push("rank")),M.push(...J(n));let E=(m)=>{let T="";t.transA&&t.transB?T="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?T="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?T="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(T="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let _=t.alpha===1?"":"value *= uniforms.alpha;",C=w("a",a[0].dataType,a[0].dims),z=w("b",a[1].dataType,a[1].dims),L=C.type.value,H=null,I=[C,z];a.length===3&&(H=w("c",a[2].dataType,a[2].dims.length),I.push(H));let N=Q("output",a[0].dataType,n.length);I.push(N);let P=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${m.registerUniforms(P).declareVariables(...I)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${L}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${T}
    }

    ${_}
    ${H!=null?`let cOffset = ${H.broadcastedIndicesToOffset("vec2(m, n)",N)}; value += ${L}(uniforms.beta) * ${H.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},x=(m)=>{let T=w("a",a[0].dataType,a[0].dims),_=w("b",a[1].dataType,a[1].dims),C=null,z=[T,_];a.length===3&&(C=w("c",a[2].dataType,a[2].dims.length),z.push(C));let L=Q("output",a[0].dataType,n.length);z.push(L);let H=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],I="",N="";t.transA&&t.transB?(N=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${T.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${_.type.value}(0);
      }
      `,I="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(N=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${T.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${_.type.value}(0);
      }
      `,I="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(N=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${T.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${_.type.value}(0);
      }
      `,I="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(N=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${T.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${_.type.value}(0);
      }
      `,I="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let P=t.alpha===1?"":"value *= uniforms.alpha;";return`
  ${m.registerUniforms(H).declareVariables(...z)}
  var<workgroup> tile_a: array<array<${T.type.storage}, ${c}>, ${c}>;
  var<workgroup> tile_b: array<array<${_.type.storage}, ${c}>, ${c}>;
  ${m.mainStart([c,c,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${c};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${c};
    let num_tiles = (uniforms.K - 1) / ${c} + 1;
    var k_start = 0u;
    var value = ${L.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${N}
      k_start = k_start + ${c};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${c}; k++) {
        ${I}
      }
      workgroupBarrier();
    }

    ${P}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset("vec2(m, n)",L)}; value += ${L.type.value}(uniforms.beta) * ${C.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return g?{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:n,dataType:a[0].dataType}],dispatchGroup:{x:d*u},programUniforms:M}),getShaderSource:x}:{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:n,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:M}),getShaderSource:E}},Ln=(a)=>{let{transA:t,transB:r,alpha:l,beta:i}=a;return{transA:t,transB:r,alpha:l,beta:i,cacheKey:`${a.transA};${a.transB};${a.alpha===1}`}},Hn=(a,t)=>{Cl(a.inputs),a.compute(_l(a.inputs,t))}}),x0,z0,Y0,Q0,Bl,zl,Ll,Hl,Vl,kl,Nl,Ol,Vn,kn,Ss=y(()=>{l1(),o1(),V1(),h1(),[x0,z0,Y0,Q0]=[0,1,2,3],Bl=(a)=>{if(a[0].dims.length!==4)throw Error("only 4-D tensor is supported.");if(a[0].dims.length!==a[1].dims.length)throw Error("input dimensions must be equal to grid dimensions");if(a[0].dims.length-2!==a[1].dims[a[1].dims.length-1])throw Error(`last dimension of grid must be equal to ${a[0].dims.length-2}`);if(a[0].dims[0]!==a[1].dims[0])throw Error("grid batch size must match input batch size")},zl=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,Ll=(a)=>`
  fn gs_bicubic_interpolate(p: mat4x4<${a}>, x: f32, y: f32) -> ${a} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${a}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,Hl=(a)=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${a.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,Vl=(a)=>`
  ${a.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,kl=(a,t,r)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {
     var pixel = ${t}(0);
     var indices = vec4<u32>(0);
     indices[${x0}] = batch;
     indices[${z0}] = channel;`+(()=>{switch(r.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${Y0}] = u32(r);
            indices[${Q0}] = u32(c);
          } else {
            return ${t}(0);
          }
        `;case"border":return`
          indices[${Y0}] = u32(clamp(r, 0, H - 1));
          indices[${Q0}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${Y0}] = gs_reflect(r, border[1], border[3]);
          indices[${Q0}] = gs_reflect(c, border[0], border[2]);
        `;default:throw Error(`padding mode ${r.paddingMode} is not supported`)}})()+`
    return ${a.getByIndices("indices")};
  }
`,Nl=(a,t,r)=>(()=>{switch(r.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${x0}], indices[${z0}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${x0}], indices[${z0}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${x0}], indices[${z0}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${x0}], indices[${z0}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${x0}], indices[${z0}], border);

          let dx2 = ${t}(f32(x2) - x);
          let dx1 = ${t}(x - f32(x1));
          let dy2 = ${t}(f32(y2) - y);
          let dy1 = ${t}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${t}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${x0}], indices[${z0}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw Error(`mode ${r.mode} is not supported`)}})()+`${a.setByOffset("global_idx","result")}`,Ol=(a,t)=>{let r=w("x",a[0].dataType,a[0].dims.length),l=[a[1].dims[0],a[1].dims[1],a[1].dims[2]],i=w("grid",a[1].dataType,l.length,2),e=[a[0].dims[0],a[0].dims[1],a[1].dims[1],a[1].dims[2]];t.format==="NHWC"&&(e=[a[0].dims[0],a[1].dims[1],a[1].dims[2],a[0].dims[3]],[x0,z0,Y0,Q0]=[0,3,1,2]);let o=Q("output",a[0].dataType,e.length),n=r.type.value,c=O.size(e),d=[{type:12,data:c},...J(a[0].dims,l,e)],u=(g)=>`
  ${g.registerUniform("output_size","u32").declareVariables(r,i,o)}
  ${zl}
  ${Ll(n)}
  ${Hl(t)}
  ${Vl(t)}
  ${kl(r,n,t)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${Y0}]);
      let W_in = i32(uniforms.x_shape[${Q0}]);

      ${t.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${o.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${x0}], indices[${Y0}], indices[${Q0}]);
      let nxy = ${i.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${Nl(o,n,t)}
  }`;return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:(g)=>{let s=O.size(e);return{outputs:[{dims:e,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:d}},getShaderSource:u}},Vn=(a,t)=>{Bl(a.inputs),a.compute(Ol(a.inputs,t))},kn=(a)=>T1({alignCorners:a.align_corners,mode:a.mode,paddingMode:a.padding_mode,format:a.format})}),j1,Rl,Nn,_3,wl,Y5,On,Rn=y(()=>{l1(),o1(),V1(),A6(),I6(),h1(),b0(),j1=(a,t)=>a.length>t&&a[t].dims.length>0?a[t]:void 0,Rl=(a,t)=>{let r=a[0],l=j1(a,1),i=j1(a,2),e=j1(a,3),o=j1(a,4),n=j1(a,5),c=j1(a,6),d=j1(a,7);if(r.dims.length!==3&&r.dims.length!==5)throw Error("Input query is expected to have 3 or 5 dimensions");let u=r.dims[0],g=r.dims[1],s=r.dims.length===3?r.dims[2]:t.numHeads*r.dims[4],M=g,A=0,E=0,x=Math.floor(s/t.numHeads);if(c&&d&&O.size(c.dims)&&O.size(d.dims)){if(c.dims.length!==4)throw Error('Input "past_key" is expected to have 4 dimensions');if(c.dims[0]!==u||c.dims[1]!==t.numHeads||c.dims[3]!==x)throw Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(d.dims[0]!==u||d.dims[1]!==t.numHeads||d.dims[3]!==x)throw Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(c.dims[2]!==d.dims[2])throw Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(d.dims.length!==4)throw Error('Input "past_value" is expected to have 4 dimensions');A=c.dims[2],E=c.dims[2]}else if(c&&O.size(c.dims)||d&&O.size(d.dims))throw Error('Input "past_key" and "past_value" shall be both present or both absent');let m;if(l&&O.size(l.dims)>0){if(r.dims.length!==3)throw Error('Input "query" is expected to have 3 dimensions when key is given');if(l.dims.length<3||l.dims.length>5)throw Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==l.dims[0])throw Error('Input "query" and "key" shall have same dim 0 (batch size)');if(l.dims.length===3){if(l.dims[2]!==r.dims[2])throw Error('Input "query" and "key" shall have same dim 2 (hidden_size)');m=2,M=l.dims[1]}else if(l.dims.length===5){if(l.dims[2]!==t.numHeads||l.dims[3]!==2||l.dims[4]!==x)throw Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(i)throw Error('Expect "value" be none when "key" has packed kv format.');m=5,M=l.dims[1]}else{if(l.dims[1]!==t.numHeads||l.dims[3]!==x)throw Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');m=0,M=l.dims[2]}}else{if(r.dims.length!==5)throw Error('Input "query" is expected to have 5 dimensions when key is empty');if(r.dims[2]!==t.numHeads||r.dims[3]!==3)throw Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');m=3}if(e&&O.size(e.dims)>0){if(e.dims.length!==1)throw Error('Input "bias" is expected to have 1 dimension');if(l&&l.dims.length===5&&l.dims[3]===2)throw Error("bias is not allowed for packed kv.")}let T=A+M,_=0;if(o&&O.size(o.dims)>0){_=8;let H=o.dims;throw H.length===1?H[0]===u?_=1:H[0]===3*u+2&&(_=3):H.length===2&&H[0]===u&&H[1]===T&&(_=5),_===8?Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):Error("Mask not supported")}let C=!1,z=s;if(i&&O.size(i.dims)>0){if(i.dims.length!==3&&i.dims.length!==4)throw Error('Input "value" is expected to have 3 or 4 dimensions');if(r.dims[0]!==i.dims[0])throw Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(i.dims.length===3){if(M!==i.dims[1])throw Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');z=i.dims[2]}else{if(M!==i.dims[2])throw Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');z=i.dims[1]*i.dims[3],C=!0}}let L=!1;if(o&&O.size(o.dims)>0)throw Error("Key padding mask is not supported");if(n&&O.size(n.dims)>0){if(n.dims.length!==4)throw Error('Input "attention_bias" is expected to have 4 dimensions');if(n.dims[0]!==u||n.dims[1]!==t.numHeads||n.dims[2]!==g||n.dims[3]!==T)throw Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:u,sequenceLength:g,pastSequenceLength:A,kvSequenceLength:M,totalSequenceLength:T,maxSequenceLength:E,inputHiddenSize:0,hiddenSize:s,vHiddenSize:z,headSize:x,vHeadSize:Math.floor(z/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:_,scale:t.scale,broadcastResPosBias:L,passPastInKv:C,qkvFormat:m}},Nn=(a)=>T1({...a}),_3=T1({perm:[0,2,1,3]}),wl=(a,t,r,l,i,e,o)=>{let n=[l,i,e],c=O.size(n),d=[{type:12,data:c},{type:12,data:o},{type:12,data:e}],u=(g)=>{let s=Q("qkv_with_bias",t.dataType,n),M=w("qkv",t.dataType,n),A=w("bias",r.dataType,n),E=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${g.registerUniforms(E).declareVariables(M,A,s)}
  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return a.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:d}),getShaderSource:u},{inputs:[t,r],outputs:[-1]})[0]},Y5=(a,t,r,l,i,e,o,n)=>{let c=e;if(o&&O.size(o.dims)>0){if(l===1)throw Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return c=wl(a,e,o,t,l,r*i,n),c=c.reshape([t,l,r,i]),r===1||l===1?c:a.compute($1(c,_3.perm),{inputs:[c],outputs:[-1]})[0]}else return e.dims.length===3&&(c=e.reshape([t,l,r,i])),r===1||l===1?c:a.compute($1(c,_3.perm),{inputs:[c],outputs:[-1]})[0]},On=(a,t)=>{let r=Rl(a.inputs,t),l=a.inputs[0],i=j1(a.inputs,1),e=j1(a.inputs,2),o=j1(a.inputs,3),n=j1(a.inputs,4),c=j1(a.inputs,5),d=j1(a.inputs,6),u=j1(a.inputs,7);if(l.dims.length===5)throw Error("Packed QKV is not implemented");if(i?.dims.length===5)throw Error("Packed KV is not implemented");let g=i&&e&&i.dims.length===4&&e.dims.length===4,s=Y5(a,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,l,o,0);if(g)return J5(a,s,i,e,n,void 0,d,u,c,r);if(!i||!e)throw Error("key and value must be provided");let M=Y5(a,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,i,o,r.hiddenSize),A=Y5(a,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,e,o,2*r.hiddenSize);J5(a,s,M,A,n,void 0,d,u,c,r)}}),Dl,Gl,Pl,Fl,i6,wn,Dn,Gn=y(()=>{l1(),o1(),V1(),h1(),Dl=(a)=>{if(!a||a.length<1)throw Error("too few inputs")},Gl=(a,t)=>{let r=[],l=t.numOutputs;return a[1].dims[0]>0&&(a[1].getBigInt64Array().forEach((i)=>r.push(Number(i))),l=r.length),T1({numOutputs:l,axis:t.axis,splitSizes:r})},Pl=(a)=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${a}u; i += 1u ) {
    if (index < ${X("uniforms.size_in_split_axis","i",a)}) {
        return i;
    }
    }
    return ${a}u;
}`,Fl=(a)=>{let t=a.length,r=[];for(let l=0;l<t;++l){let i=a[l].setByIndices("indices","input[global_idx]");t===1?r.push(i):l===0?r.push(`if (output_number == ${l}u) { ${i} }`):l===t-1?r.push(`else { ${i} }`):r.push(`else if (output_number == ${l}) { ${i} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${a[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},i6=(a,t)=>{let r=a[0].dims,l=O.size(r),i=a[0].dataType,e=O.normalizeAxis(t.axis,r.length),o=Array(t.numOutputs),n=w("input",i,r.length),c=Array(t.numOutputs),d=[],u=[],g=0,s=[{type:12,data:l}];for(let A=0;A<t.numOutputs;A++){g+=t.splitSizes[A],c[A]=g;let E=r.slice();E[e]=t.splitSizes[A],u.push(E),o[A]=Q(`output${A}`,i,E.length),d.push({dims:u[A],dataType:a[0].dataType})}s.push({type:12,data:c},...J(r,...u));let M=(A)=>`
  ${A.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",c.length).declareVariables(n,...o)}
  ${Pl(c.length)}
  ${Fl(o)}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${n.offsetToIndices("global_idx")};
    var index = ${n.indicesGet("indices",e)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${X("uniforms.size_in_split_axis","output_number - 1u",c.length)};
      ${n.indicesSet("indices",e,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:M,getRunData:()=>({outputs:d,dispatchGroup:{x:Math.ceil(l/64)},programUniforms:s})}},wn=(a,t)=>{Dl(a.inputs);let r=a.inputs.length===1?t:Gl(a.inputs,t);a.compute(i6(a.inputs,r),{inputs:[0]})},Dn=(a)=>{let{axis:t,splitSizes:r}=a,l=a.numOutputs<0?r.length:a.numOutputs;if(l!==r.length)throw Error("numOutputs and splitSizes length must be equal");return T1({axis:t,numOutputs:l,splitSizes:r})}}),Zl,K2,Pn,Fn=y(()=>{l1(),o1(),V1(),h1(),Zl=(a,t)=>{let[r,l,i,e]=a,{numHeads:o,rotaryEmbeddingDim:n}=t;if(r.dims.length!==3&&r.dims.length!==4)throw Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!O.areEqual(l.dims,[])&&!O.areEqual(l.dims,[1])&&l.dims.length!==2)throw Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${l.dims.length}`);if(i.dims.length!==2)throw Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(e.dims.length!==2)throw Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${e.dims.length}`);if(!O.areEqual(i.dims,e.dims))throw Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(n>0&&o===0)throw Error("num_heads must be provided if rotary_embedding_dim is specified");let c=r.dims[0],d=r.dims[r.dims.length-2],u=i.dims[0],g=O.sizeFromDimension(r.dims,1)/d,s=n===0?i.dims[1]*2:g/o;if(n>s)throw Error("rotary_embedding_dim must be less than or equal to head_size");if(l.dims.length===2){if(c!==l.dims[0])throw Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${l.dims[0]}`);if(d!==l.dims[1])throw Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${l.dims[1]}`)}if(s/2!==i.dims[1]&&n/2!==i.dims[1])throw Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${i.dims[1]}`);if(d>u)throw Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},K2=(a,t)=>{let{interleaved:r,numHeads:l,rotaryEmbeddingDim:i,scale:e}=t,o=a[0].dims[0],n=O.sizeFromDimension(a[0].dims,1),c=a[0].dims[a[0].dims.length-2],d=n/c,u=a[2].dims[1],g=i===0?u*2:d/l,s=[o,c,d/g,g-u],M=O.computeStrides(s),A=[{type:1,data:e},{type:12,data:s},{type:12,data:M},...a[0].dims.length===3?[{type:12,data:[n,d,g,1]}]:[],...a[0].dims.length===4?[{type:12,data:[n,g,c*g,1]}]:[],...J(a[0].dims,a[1].dims,a[2].dims,a[3].dims,a[0].dims)],E=(x)=>{let m=w("input",a[0].dataType,a[0].dims.length),T=w("position_ids",a[1].dataType,a[1].dims.length),_=w("cos_cache",a[2].dataType,a[2].dims.length),C=w("sin_cache",a[3].dataType,a[3].dims.length),z=Q("output",a[0].dataType,a[0].dims.length);return x.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:s.length},{name:"global_strides",type:"u32",length:M.length},{name:"input_output_strides",type:"u32",length:M.length}]),`
        ${x.declareVariables(m,T,_,C,z)}

        ${x.mainStart(E5)}
          let half_rotary_emb_dim = uniforms.${_.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${x.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${T.broadcastedIndicesToOffset("bsnh.xy",Q("",T.type.tensor,2))};
            let position_id =
                u32(${T.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});
            let j = i + select(half_rotary_emb_dim, 1, ${r});
            let re = ${m.getByOffset("i")} * ${_.get("position_id","bsnh[3]")} -
                ${m.getByOffset("j")} * ${C.get("position_id","bsnh[3]")};
            ${z.setByOffset("i","re")}
            let im = ${m.getByOffset("i")} * ${C.get("position_id","bsnh[3]")} +
                ${m.getByOffset("j")} * ${_.get("position_id","bsnh[3]")};
            ${z.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${z.setByOffset("k",m.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:T1({interleaved:r}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:E,getRunData:()=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(O.size(s)/E5)},programUniforms:A})}},Pn=(a,t)=>{Zl(a.inputs,t),a.compute(K2(a.inputs,t))}}),yl,bl,B3,jl,Zn,Ms=y(()=>{V1(),l1(),I6(),Rn(),Gn(),b0(),Fn(),h1(),yl=(a,t)=>{if(t.doRotary&&a.length<=7)throw Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let r=a[0],l=a[1],i=a[2],e=a[3],o=a[4];if(t.doRotary!==0&&a.length<=7)throw Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(t.localWindowSize!==-1)throw Error("Local attention is not supported");if(t.softcap!==0)throw Error("Softcap is not supported");if(t.rotaryInterleaved!==0)throw Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw Error("Smooth softmax is not supported");if(r.dims.length!==3&&r.dims.length!==5)throw Error("Input query is expected to have 3 or 5 dimensions");let n=!1,c=r.dims[0],d=r.dims[1],u=r.dims.length===3?n?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],g=d,s=0,M=!l||l.dims.length===0,A=Math.floor(M?u/(t.numHeads+2*t.kvNumHeads):u/t.numHeads);M&&(u=A*t.numHeads);let E=e&&e.dims.length!==0,x=o&&o.dims.length!==0;if(E&&e.dims.length===4&&e.dims[0]===c&&e.dims[1]!==t.kvNumHeads&&e.dims[2]===t.kvNumHeads&&e.dims[3]===A)throw Error("BSNH pastKey/pastValue is not supported");if(E&&x){if(e.dims.length!==4)throw Error('Input "past_key" is expected to have 4 dimensions');if(o.dims.length!==4)throw Error('Input "past_value" is expected to have 4 dimensions');s=e.dims[2]}else if(E||x)throw Error('Input "past_key" and "past_value" shall be both present or both absent');let m=1;if(l&&l.dims.length>0){if(r.dims.length!==3)throw Error('Input "query" is expected to have 3 dimensions when key is given');if(l.dims.length<3||l.dims.length>5)throw Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==l.dims[0])throw Error('Input "query" and "key" shall have same dim 0 (batch size)');if(l.dims.length===3){if(r.dims[2]%l.dims[2]!==0)throw Error('Dimension 2 of "query" should be a multiple of "key"');g=l.dims[1]}else if(l.dims.length===5){if(l.dims[2]!==t.numHeads||l.dims[3]!==2||l.dims[4]!==A)throw Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(i)throw Error('Expect "value" be none when "key" has packed kv format.');g=l.dims[1]}else{if(l.dims[1]!==t.numHeads||l.dims[3]!==A)throw Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');g=l.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');m=3}let T=0,_=!1,C=t.kvNumHeads?A*t.kvNumHeads:u;if(i&&i.dims.length>0){if(i.dims.length!==3&&i.dims.length!==4)throw Error('Input "value" is expected to have 3 or 4 dimensions');if(r.dims[0]!==i.dims[0])throw Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(i.dims.length===3){if(g!==i.dims[1])throw Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');C=i.dims[2]}else{if(g!==i.dims[2])throw Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');C=i.dims[1]*i.dims[3],_=!0}}let z=a.length>4?a[5]:void 0;if(z&&z.dims.length!==1&&z.dims[0]!==c)throw Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:c,sequenceLength:d,pastSequenceLength:s,kvSequenceLength:g,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:u,vHiddenSize:C,headSize:A,vHeadSize:Math.floor(C/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:T,scale:t.scale,broadcastResPosBias:!1,passPastInKv:_,qkvFormat:m}},bl=T1({perm:[0,2,1,3]}),B3=(a,t,r)=>{let l=t,i=r.kvNumHeads;return t.dims.length===3&&r.kvSequenceLength!==0&&(l=t.reshape([r.batchSize,r.kvSequenceLength,i,r.headSize]),l=a.compute($1(l,bl.perm),{inputs:[l],outputs:[-1]})[0]),l},jl=(a,t,r,l)=>{let i=7,e=["type","type"],o=[a*t],n=a*t,c=[{type:12,data:n},{type:12,data:t},{type:12,data:a}],d=(u)=>{let g=w("seq_lens",r.dataType,r.dims),s=w("total_seq_lens",l.dataType,l.dims),M=Q("pos_ids",i,o),A=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${u.registerUniforms(A).declareVariables(g,s,M)}
  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${s.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${g.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${M.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${M.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${M.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${a};${t}`,inputDependencies:e},getRunData:()=>({outputs:[{dims:o,dataType:i}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:c}),getShaderSource:d}},Zn=(a,t)=>{let r=yl(a.inputs,t);if(a.inputs[0].dims.length===5)throw Error("Packed QKV is not implemented");if(a.inputs[1]?.dims.length===5)throw Error("Packed KV is not implemented");let l=a.inputs[0],i=a.inputs[1]&&a.inputs[1].dims.length>0?a.inputs[1]:void 0,e=a.inputs[2]&&a.inputs[2].dims.length>0?a.inputs[2]:void 0,o=a.inputs[3]&&a.inputs[3].dims.length!==0?a.inputs[3]:void 0,n=a.inputs[4]&&a.inputs[4].dims.length!==0?a.inputs[4]:void 0,c=a.inputs.length>4?a.inputs[5]:void 0,d=a.inputs.length>5?a.inputs[6]:void 0,u=r.kvNumHeads?r.kvNumHeads:r.numHeads,g=T1({axis:2,numOutputs:3,splitSizes:[r.numHeads*r.headSize,u*r.headSize,u*r.headSize]}),[s,M,A]=!i&&!e?a.compute(i6([l],g),{inputs:[l],outputs:[-1,-1,-1]}):[l,i,e],E,x;if(t.doRotary){let C=a.compute(jl(r.batchSize,r.sequenceLength,c,d),{inputs:[c,d],outputs:[-1]})[0],z=a.inputs[7],L=a.inputs[8],H=T1({interleaved:t.rotaryInterleaved!==0,numHeads:r.numHeads,rotaryEmbeddingDim:0,scale:t.scale}),I=[s,C,z,L],N=[-1];E=a.compute(K2(I,H),{inputs:I,outputs:N})[0],I.splice(0,1,M);let P=T1({interleaved:t.rotaryInterleaved!==0,numHeads:r.kvNumHeads,rotaryEmbeddingDim:0,scale:t.scale});x=a.compute(K2(I,P),{inputs:I,outputs:N})[0]}let m=Y5(a,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,t.doRotary?E:s,void 0,0),T=B3(a,t.doRotary?x:M,r),_=B3(a,A,r);J5(a,m,T,_,void 0,void 0,o,n,void 0,r,c,d)}}),z3,Ul,Wl,yn,As=y(()=>{l1(),o1(),b0(),h1(),z3=(a,t,r,l,i,e,o,n)=>{let c=H1(e),d=c===1?"f32":`vec${c}f`,u=c===1?"vec2f":`mat2x${c}f`,g=i*o,s=64;g===1&&(s=256);let M=[i,o,e/c],A=[i,o,2],E=["rank","type","type"],x=[];x.push(...J(M,A));let m=(T)=>{let _=w("x",t.dataType,3,c),C=w("scale",r.dataType,r.dims),z=w("bias",l.dataType,l.dims),L=Q("output",1,3,2),H=[_,C,z,L];return`
  var<workgroup> workgroup_shared : array<${u}, ${s}>;
  const workgroup_size = ${s}u;
  ${T.declareVariables(...H)}
  ${T.mainStart(s)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${d}(0);
    var squared_sum = ${d}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${d}(${_.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${u}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${y0("workgroup_shared[0][0]",c)} / f32(hight * ${c});
      let squared_sum_final = ${y0("workgroup_shared[0][1]",c)} / f32(hight * ${c});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${n}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return a.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${c};${n};${s}`,inputDependencies:E},getRunData:()=>({outputs:[{dims:A,dataType:1}],dispatchGroup:{x:g},programUniforms:x}),getShaderSource:m},{inputs:[t,r,l],outputs:[-1]})[0]},Ul=(a,t,r)=>{let l=t[0].dims,i=l,e=2,o=l[0],n=l[1],c=O.sizeFromDimension(l,e),d=H1(c),u=O.size(i)/d,g=z3(a,t[0],t[1],t[2],o,c,n,r.epsilon),s=[o,n,c/d],M=[o,n],A=["type","none"],E=(x)=>{let m=w("x",t[0].dataType,s.length,d),T=w("scale_shift",1,M.length,2),_=Q("output",t[0].dataType,s.length,d),C=[m,T,_];return`
  ${x.registerUniform("output_size","u32").declareVariables(...C)}
  ${x.mainStart()}
  ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${_.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${T.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${m.getByOffset("global_idx")} * ${_.type.value}(scale_shift.x) + ${_.type.value}(scale_shift.y);
      ${_.setByOffset("global_idx","value")};
  }`};a.compute({name:"InstanceNormalization",shaderCache:{hint:`${d}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:[{type:12,data:u},...J(s,M,s)]}),getShaderSource:E},{inputs:[t[0],g]})},Wl=(a,t,r)=>{let l=t[0].dims,i=l,e=l[0],o=l[l.length-1],n=O.sizeFromDimension(l,1)/o,c=H1(o),d=O.size(i)/c,u=[{type:12,data:n},{type:12,data:Math.floor(o/c)}],g=["type","type"],s=!1,M=[0,l.length-1];for(let m=0;m<l.length-2;m++)s=s||l[m+1]!==1,M.push(m+1);s=s&&l[l.length-1]!==1;let A=s?a.compute($1(a.inputs[0],M),{inputs:[a.inputs[0]],outputs:[-1]})[0]:a.inputs[0].reshape(Array.from({length:l.length},(m,T)=>l[M[T]])),E=z3(a,A,t[1],t[2],e,n,o,r.epsilon),x=(m)=>{let T=w1(t[0].dataType),_=c===1?"vec2f":`mat${c}x2f`,C=(H)=>{let I=H===0?"x":"y",N=c===1?"f32":`vec${c}f`;switch(c){case 1:return`${T}(${N}(scale.${I}))`;case 2:return`vec2<${T}>(${N}(scale[0].${I}, scale[1].${I}))`;case 4:return`vec4<${T}>(${N}(scale[0].${I}, scale[1].${I}, scale[2].${I}, scale[3].${I}))`;default:throw Error(`Not supported compoents ${c}`)}},z=w("input",t[0].dataType,t[0].dims,c),L=Q("output",t[0].dataType,i,c);return`
  @group(0) @binding(0) var<storage, read> input : array<${z.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${_}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${L.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${m.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${C(0)}, ${C(1)});
  }`};a.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${c}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}),getShaderSource:x},{inputs:[t[0],E]})},yn=(a,t)=>{t.format==="NHWC"?Wl(a,a.inputs,t):Ul(a,a.inputs,t)}}),Kl,ql,bn,Ts=y(()=>{l1(),o1(),h1(),Kl=(a)=>{if(!a||a.length<2)throw Error("layerNorm requires at least 2 inputs.")},ql=(a,t,r)=>{let l=t.simplified,i=a[0].dims,e=a[1],o=!l&&a[2],n=i,c=O.normalizeAxis(t.axis,i.length),d=O.sizeToDimension(i,c),u=O.sizeFromDimension(i,c),g=O.size(e.dims),s=o?O.size(o.dims):0;if(g!==u||o&&s!==u)throw Error(`Size of X.shape()[axis:] == ${u}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${g} and bias size of ${s}`);let M=[];for(let z=0;z<i.length;++z)z<c?M.push(i[z]):M.push(1);let A=H1(u),E=["type","type"],x=[{type:12,data:d},{type:1,data:u},{type:12,data:Math.floor(u/A)},{type:1,data:t.epsilon}];o&&E.push("type");let m=r>1,T=r>2,_=(z)=>{let L=w1(a[0].dataType),H=[w("x",a[0].dataType,a[0].dims,A),w("scale",e.dataType,e.dims,A)];o&&H.push(w("bias",o.dataType,o.dims,A)),H.push(Q("output",a[0].dataType,n,A)),m&&H.push(Q("mean_data_output",1,M)),T&&H.push(Q("inv_std_output",1,M));let I=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${z.registerUniforms(I).declareVariables(...H)}
  ${z.mainStart()}
    ${z.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Y3("f32",A)};
    var mean_square_vector = ${Y3("f32",A)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${A5(L,A,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${y0("mean_vector",A)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${y0("mean_square_vector",A)} / uniforms.norm_size ${l?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${A5(L,A,"x[j + offset]")};
      let f32scale = ${A5(L,A,"scale[j]")};
      output[j + offset] = ${H[0].type.value}((f32input ${l?"":"- mean"}) * inv_std_dev * f32scale
        ${o?`+ ${A5(L,A,"bias[j]")}`:""}
      );
    }

    ${m?"mean_data_output[global_idx] = mean":""};
    ${T?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},C=[{dims:n,dataType:a[0].dataType}];return m&&C.push({dims:M,dataType:1}),T&&C.push({dims:M,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${A};${r};${l}`,inputDependencies:E},getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(d/64)},programUniforms:x}),getShaderSource:_}},bn=(a,t)=>{Kl(a.inputs),a.compute(ql(a.inputs,t,a.outputCount))}}),Yl,jn,Es=y(()=>{o1(),_6(),B6(),Yl=(a)=>{if(!a||a.length!==2)throw Error("MatMul requires 2 inputs.");if(a[0].dims[a[0].dims.length-1]!==a[1].dims[a[1].dims.length-2])throw Error("shared dimension does not match.")},jn=(a)=>{Yl(a.inputs);let t=T5.calcShape(a.inputs[0].dims,a.inputs[1].dims,!0);if(!t)throw Error("Can't use matmul on the given tensors");let r=t[t.length-1],l=a.inputs[0].dims[a.inputs[0].dims.length-1];if(r<8&&l<8)a.compute(C6(a.inputs,{activation:""},t));else{let i=t[t.length-2],e=O.size(a.inputs[0].dims.slice(0,-2)),o=O.size(a.inputs[1].dims.slice(0,-2));if(e!==1&&i===1&&o===1){let n=a.inputs[0].reshape([1,e,l]),c=a.inputs[1].reshape([1,l,r]),d=[1,e,r],u=[n,c];a.compute(W2(u,{activation:""},t,d),{inputs:u})}else a.compute(W2(a.inputs,{activation:""},t))}}}),Ql,Xl,Jl,Un,Wn,Is=y(()=>{l1(),o1(),V1(),h1(),Ql=(a,t)=>{if(a.length<3||a.length>4)throw Error("MatMulNBits requires 3 or 4 inputs");let r=a[0],l=r.dims.length;if(r.dims[l-1]!==t.k)throw Error("The last dim of input shape does not match the k value");let i=Math.floor((t.k+t.blockSize-1)/t.blockSize),e=t.blockSize/8*t.bits,o=a[1];if(!O.areEqual(o.dims,[t.n,i,e]))throw Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let n=a[2].dims;if(O.size(n)!==t.n*i)throw Error("scales input size error.");if(a.length===4){let c=a[3].dims,d=t.n*(t.bits===8?i:Math.floor((i*t.bits+7)/8));if(O.size(c)!==d)throw Error("zeroPoints input size error.")}},Xl=(a,t)=>{let r=a[0].dims,l=r.length,i=r[l-2],e=t.k,o=t.n,n=r.slice(0,l-2),c=O.size(n),d=a[1].dims[2]/4,u=a[0].dataType,g=H1(t.k),s=H1(d),M=H1(o),A=n.concat([i,o]),E=i>1&&o/M%2===0?2:1,x=O.size(A)/M/E,m=64,T=[],_=[c,i,e/g],C=O.convertShape(a[1].dims).slice();C.splice(-1,1,d/s),T.push(...J(_)),T.push(...J(C)),T.push(...J(a[2].dims)),a.length===4&&T.push(...J(O.convertShape(a[3].dims)));let z=[c,i,o/M];T.push(...J(z));let L=(H)=>{let I=_.length,N=w("a",a[0].dataType,I,g),P=w("b",12,C.length,s),b=w("scales",a[2].dataType,a[2].dims.length),G=[N,P,b],j=a.length===4?w("zero_points",12,a[3].dims.length):void 0;j&&G.push(j);let e1=z.length,V=Q("output",a[0].dataType,e1,M),F=w1(a[0].dataType),a1=(()=>{switch(g){case 1:return`array<${F}, 8>`;case 2:return`mat4x2<${F}>`;case 4:return`mat2x4<${F}>`;default:throw Error(`${g}-component is not supported.`)}})(),$=()=>{let D=`
          // reuse a data
            var input_offset = ${N.indicesToOffset(`${N.type.indices}(batch, row, word_offset)`)};
            var a_data: ${a1};
            for (var j: u32 = 0; j < ${8/g}; j++) {
              a_data[j] = ${N.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let W=0;W<M*E;W++)D+=`
            b_value = ${s===1?`b${W}_data`:`b${W}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${a1}(${Array.from({length:4},(t1,s1)=>`${F}(b_value_lower[${s1}]), ${F}(b_value_upper[${s1}])`).join(", ")});
            b_dequantized_values = ${g===1?`${a1}(${Array.from({length:8},(t1,s1)=>`(b_quantized_values[${s1}] - ${j?`zero_point${W}`:"zero_point"}) * scale${W}`).join(", ")});`:`(b_quantized_values - ${a1}(${Array(8).fill(`${j?`zero_point${W}`:"zero_point"}`).join(",")})) * scale${W};`};
            workgroup_shared[local_id.x * ${E} + ${Math.floor(W/M)}]${M>1?`[${W%M}]`:""} += ${Array.from({length:8/g},(t1,s1)=>`${g===1?`a_data[${s1}] * b_dequantized_values[${s1}]`:`dot(a_data[${s1}], b_dequantized_values[${s1}])`}`).join(" + ")};
          `;return D},Y=()=>{let D=`
            var col_index = col * ${M};
            ${j?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${F}(8);`}
            `;for(let W=0;W<M*E;W++)D+=`
            let scale${W} = ${b.getByOffset("col_index * nBlocksPerCol + block")};
            ${j?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${j.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${W} = ${F}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return D},i1=()=>{let D=`col_index = col * ${M};`;for(let W=0;W<M*E;W++)D+=`
            let b${W}_data = ${P.getByIndices(`${P.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return D+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${a1};
            var b_dequantized_values: ${a1};`,D};return`
        var<workgroup> workgroup_shared: array<${V.type.value}, ${E*m}>;
        ${H.declareVariables(...G,V)}
        ${H.mainStart([m,1,1])}
          let output_indices = ${V.offsetToIndices(`(global_idx / ${m}) * ${E}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${m}) {
            //process one block
            var word_offset: u32 = block * ${t.blockSize/g};
            ${Y()}
            for (var word: u32 = 0; word < ${d}; word += ${s}) {
              ${i1()}
              for (var i: u32 = 0; i < ${s}; i++) {
                ${$()}
                word_offset += ${8/g};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${E}) {
            var output_value: ${V.type.value} = ${V.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${m}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${E};
            }
            ${V.setByIndices(`${V.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${g};${s};${M};${E};${m}`,inputDependencies:Array(a.length).fill("rank")},getRunData:()=>({outputs:[{dims:A,dataType:u}],dispatchGroup:{x},programUniforms:T}),getShaderSource:L}},Jl=(a,t)=>{let r=a[0].dims,l=r.length,i=r[l-2],e=t.k,o=t.n,n=r.slice(0,l-2),c=O.size(n),d=a[1].dims[2]/4,u=a[0].dataType,g=H1(t.k),s=H1(d),M=n.concat([i,o]),A=128,E=o%8===0?8:o%4===0?4:1,x=A/E,m=x*s*8,T=m/g,_=m/t.blockSize,C=O.size(M)/E,z=[],L=[c,i,e/g],H=O.convertShape(a[1].dims).slice();H.splice(-1,1,d/s),z.push(...J(L)),z.push(...J(H)),z.push(...J(a[2].dims)),a.length===4&&z.push(...J(O.convertShape(a[3].dims)));let I=[c,i,o];z.push(...J(I));let N=(P)=>{let b=L.length,G=w("a",a[0].dataType,b,g),j=w("b",12,H.length,s),e1=w("scales",a[2].dataType,a[2].dims.length),V=[G,j,e1],F=a.length===4?w("zero_points",12,a[3].dims.length):void 0;F&&V.push(F);let a1=I.length,$=Q("output",a[0].dataType,a1),Y=w1(a[0].dataType),i1=()=>{switch(g){case 1:return`
          let a_data0 = vec4<${Y}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${Y}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${Y}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${Y}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw Error(`${g}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${G.type.value}, ${T}>;
        var<workgroup> inter_results: array<array<${$.type.value}, ${x}>, ${E}>;
        ${P.declareVariables(...V,$)}
        ${P.mainStart([x,E,1])}
          let output_indices = ${$.offsetToIndices(`workgroup_index * ${E}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${_} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${T};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${T}; a_offset += ${A})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${G.getByIndices(`${G.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${G.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${_} + local_id.x;
            ${F?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${F.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${Y}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Y}(8);`}
            let scale = ${e1.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${j.getByIndices(`${j.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${t.blockSize/g};
            for (var i: u32 = 0; i < ${s}; i++) {
              ${i1()}
              let b_value = ${s===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${Y}>(${Array.from({length:4},(D,W)=>`${Y}(b_value_lower[${W}]), ${Y}(b_value_upper[${W}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${Y}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(D,W)=>`${`dot(a_data${W}, b_dequantized_values[${W}])`}`).join(" + ")};
              word_offset += ${8/g};
            }
            workgroupBarrier();
          }

          if (local_idx < ${E}) {
            var output_value: ${$.type.value} = ${$.type.value}(0);
            for (var b = 0u; b < ${x}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${$.setByIndices(`${$.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${g};${s};${x};${E}`,inputDependencies:Array(a.length).fill("rank")},getRunData:()=>({outputs:[{dims:M,dataType:u}],dispatchGroup:{x:C},programUniforms:z}),getShaderSource:N}},Un=(a,t)=>{Ql(a.inputs,t),t.blockSize===32&&a.adapterInfo.isVendor("intel")&&a.adapterInfo.isArchitecture("gen-12lp")?a.compute(Jl(a.inputs,t)):a.compute(Xl(a.inputs,t))},Wn=(a)=>T1(a)}),$l,ai,ti,ri,li,ii,ei,oi,Kn,ms=y(()=>{l1(),o1(),h1(),$l=(a)=>{if(!a||a.length<1)throw Error("Too few inputs");if(a[0].dataType!==1&&a[0].dataType!==10)throw Error("Input type must be float or float16.");if(a.length>=2){let t=a[0].dims.length*2===a[1].dims[0];if(a.length===4&&(t=a[3].dims[0]*2===a[1].dims[0]),!t)throw Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},ai=(a,t,r)=>{let l="";for(let i=t-1;i>=0;--i)l+=`
            k = i32(${a.indicesGet("indices",i)}) - ${X("uniforms.pads",i,r)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${X("uniforms.x_shape",i,t)})) {
              break;
            }
            offset += k * i32(${X("uniforms.x_strides",i,t)});
        `;return`
          value = ${a.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${l}
            value = x[offset];
          }
      `},ti=(a,t,r)=>{let l="";for(let i=t-1;i>=0;--i)l+=`
                k = i32(${a.indicesGet("indices",i)}) - ${X("uniforms.pads",i,r)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${X("uniforms.x_shape",i,t)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${X("uniforms.x_shape",i,t)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${X("uniforms.x_strides",i,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${l}
              value = x[offset];
          `},ri=(a,t,r)=>{let l="";for(let i=t-1;i>=0;--i)l+=`
                k = i32(${a.indicesGet("indices",i)}) - ${X("uniforms.pads",i,r)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${X("uniforms.x_shape",i,t)})) {
                  k = i32(${X("uniforms.x_shape",i,t)}) - 1;
                }
                offset += k * i32(${X("uniforms.x_strides",i,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${l}
              value = x[offset];
          `},li=(a,t,r)=>{let l="";for(let i=t-1;i>=0;--i)l+=`
                k = i32(${a.indicesGet("indices",i)}) - ${X("uniforms.pads",i,r)};
                if (k < 0)  {
                  k += i32(${X("uniforms.x_shape",i,t)}]);
                }
                if (k >= i32(${X("uniforms.x_shape",i,t)})) {
                  k -= i32(${X("uniforms.x_shape",i,t)});
                }
                offset += k * i32(${X("uniforms.x_strides",i,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${l}
              value = x[offset];
          `},ii=(a,t,r)=>{switch(r.mode){case 0:return ai(a,t,r.pads.length);case 1:return ti(a,t,r.pads.length);case 2:return ri(a,t,r.pads.length);case 3:return li(a,t,r.pads.length);default:throw Error("Invalid mode")}},ei=(a,t)=>{let r=O.padShape(a[0].dims.slice(),t.pads),l=a[0].dims,i=O.size(r),e=[{type:12,data:i},{type:6,data:t.pads}],o=a.length>=3&&a[2].data;t.mode===0&&e.push({type:o?a[2].dataType:1,data:t.value}),e.push(...J(a[0].dims,r));let n=["rank"],c=(d)=>{let u=Q("output",a[0].dataType,r.length),g=w("x",a[0].dataType,l.length),s=g.type.value,M=ii(u,l.length,t),A=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&A.push({name:"constant_value",type:o?s:"f32"}),`
            ${d.registerUniforms(A).declareVariables(g,u)}
            ${d.mainStart()}
            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${u.offsetToIndices("global_idx")};

            var value = ${s}(0);
            ${M}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}${o}`,inputDependencies:n},getRunData:()=>({outputs:[{dims:r,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(O.size(r)/64)},programUniforms:e}),getShaderSource:c}},oi=(a,t)=>{if(a.length>1){let r=a[1].getBigInt64Array(),l=a.length>=3&&a[2].data?a[2].dataType===10?a[2].getUint16Array()[0]:a[2].getFloat32Array()[0]:0,i=a[0].dims.length,e=new Int32Array(2*i).fill(0);if(a.length>=4){let n=a[3].getBigInt64Array();for(let c=0;c<n.length;c++)e[Number(n[c])]=Number(r[c]),e[Number(n[c])+i]=Number(r[c+n.length])}else r.forEach((n,c)=>e[Number(c)]=Number(n));let o=[];return e.forEach((n)=>o.push(n)),{mode:t.mode,value:l,pads:o}}else return t},Kn=(a,t)=>{$l(a.inputs);let r=oi(a.inputs,t);a.compute(ei(a.inputs,r),{inputs:[0]})}}),b5,L3,H3,V3,k3,ni,hi,N3,O3,qn,Yn,R3,Qn,Xn,w3,Jn,$n,ah,th,fs=y(()=>{l0(),l1(),o1(),h1(),b5=(a)=>{if(m1.webgpu.validateInputContent&&(!a||a.length!==1))throw Error("Pool ops requires 1 input.")},L3=(a,t,r)=>{let l=t.format==="NHWC",i=a.dims.slice();l&&i.splice(1,0,i.pop());let e=Object.hasOwnProperty.call(t,"dilations"),o=t.kernelShape.slice(),n=t.strides.slice(),c=e?t.dilations.slice():[],d=t.pads.slice();j2.adjustPoolAttributes(r,i,o,n,c,d);let u=j2.computePoolOutputShape(r,i,n,c,o,d,t.autoPad),g=Object.assign({},t);e?Object.assign(g,{kernelShape:o,strides:n,pads:d,dilations:c,cacheKey:t.cacheKey}):Object.assign(g,{kernelShape:o,strides:n,pads:d,cacheKey:t.cacheKey});let s=u.slice();return s.push(s.splice(1,1)[0]),[g,l?s:u]},H3=(a,t)=>{let r=t.format==="NHWC",l=O.size(a),i=O.size(t.kernelShape),e=[{type:12,data:l},{type:12,data:i}],o=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let n=t.kernelShape[t.kernelShape.length-1],c=t.strides[t.strides.length-1],d=t.pads[t.pads.length/2-1],u=t.pads[t.pads.length-1],g=!!(d+u);e.push({type:12,data:n},{type:12,data:c},{type:12,data:d},{type:12,data:u}),o.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let s=!1;if(t.kernelShape.length===2){let M=t.kernelShape[t.kernelShape.length-2],A=t.strides[t.strides.length-2],E=t.pads[t.pads.length/2-2],x=t.pads[t.pads.length-2];s=!!(E+x),e.push({type:12,data:M},{type:12,data:A},{type:12,data:E},{type:12,data:x}),o.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[e,o,!0,g,s]}else{if(r)throw Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let n=O.computeStrides(t.kernelShape);e.push({type:12,data:n},{type:12,data:t.pads},{type:12,data:t.strides}),o.push({name:"kernelStrides",type:"u32",length:n.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let c=t.pads.reduce((d,u)=>d+u);return[e,o,!!c,!1,!1]}},V3=(a,t,r,l,i,e,o,n,c,d,u,g)=>{let s=i.format==="NHWC",M=t.type.value,A=Q("output",t.type.tensor,l);if(i.kernelShape.length<=2){let E="",x="",m="",T=r-(s?2:1);if(u?E=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${T}] < 0 || xIndices[${T}]
                      >= uniforms.x_shape[${T}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${e}
                }`:E=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${e}
                }`,i.kernelShape.length===2){let _=r-(s?3:2);g?x=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${_}] < 0 || xIndices[${_}] >= uniforms.x_shape[${_}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:x=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sh - uniforms.phStart + j;
                `,m=`
              }
            `}return`
            ${a.registerUniforms(c).declareVariables(t,A)}

            ${a.mainStart()}
              ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${A.offsetToIndices("global_idx")};
              var xIndices = ${A.offsetToIndices("global_idx")};

              var value = ${M}(${n});
              var pad = 0;
              ${x}
              ${E}
              ${m}
              ${o}

              output[global_idx] = value;
            }`}else{if(s)throw Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let E=i.kernelShape.length,x=i.pads.length,m="";return d?m=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${e}
              }`:m=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${e}
            `,`
            ${a.registerUniforms(c).declareVariables(t,A)}

            ${a.mainStart()}
              ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${A.offsetToIndices("global_idx")};
              var xIndices = ${A.offsetToIndices("global_idx")};

              var offsets: array<u32, ${E}>;

              var value = ${M}(${n});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${E-1}u; j++) {
                  offsets[j] = offset / ${X("uniforms.kernelStrides","j",E)};
                  offset -= offsets[j] * ${X("uniforms.kernelStrides","j",E)};
                }
                offsets[${E-1}] = offset;

                isPad = false;
                for (var j = ${r-E}u; j < ${r}u; j++) {
                  xIndices[j] = indices[j] * ${X("uniforms.strides",`j - ${r-E}u`,E)}
                    + offsets[j - ${r-E}u] - ${X("uniforms.pads","j - 2u",x)};
                  ${m}
              }
              ${o}

              output[global_idx] = value;
            }`}},k3=(a)=>`${a.format};${a.ceilMode};${a.autoPad};${a.kernelShape.length}`,ni=(a)=>`${k3(a)};${a.countIncludePad}`,hi=(a)=>`${k3(a)};${a.storageOrder};${a.dilations}`,N3=(a)=>({format:a.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][a.auto_pad],ceilMode:a.ceil_mode,kernelShape:a.kernel_shape,strides:a.strides,pads:a.pads}),O3=(a,t,r,l)=>{let[i,e]=L3(t,l,r),o=w("x",t.dataType,t.dims.length),n=o.type.value,c="value += x_val;",d="";i.countIncludePad?d+=`value /= ${n}(uniforms.kernelSize);`:d+=`value /= ${n}(i32(uniforms.kernelSize) - pad);`;let[u,g,s,M,A]=H3(e,i);u.push(...J(t.dims,e));let E=["rank"];return{name:a,shaderCache:{hint:`${l.cacheKey};${s};${M};${A}`,inputDependencies:E},getRunData:()=>({outputs:[{dims:e,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(O.size(e)/64)},programUniforms:u}),getShaderSource:(x)=>V3(x,o,t.dims.length,e.length,i,c,d,0,g,s,M,A)}},qn=(a)=>{let t=a.count_include_pad!==0,r=N3(a);if(r.ceilMode!==0)throw Error("using ceil() in shape computation is not yet supported for AveragePool");let l={countIncludePad:t,...r,cacheKey:""};return{...l,cacheKey:ni(l)}},Yn=(a,t)=>{b5(a.inputs),a.compute(O3("AveragePool",a.inputs[0],!1,t))},R3={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Qn=(a)=>{let t=a.format;return{format:t,...R3,cacheKey:t}},Xn=(a,t)=>{b5(a.inputs),a.compute(O3("GlobalAveragePool",a.inputs[0],!0,t))},w3=(a,t,r,l)=>{let[i,e]=L3(t,l,r),o=`
      value = max(x_val, value);
    `,n="",c=w("x",t.dataType,t.dims.length),d=["rank"],[u,g,s,M,A]=H3(e,i);return u.push(...J(t.dims,e)),{name:a,shaderCache:{hint:`${l.cacheKey};${s};${M};${A}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:e,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(O.size(e)/64)},programUniforms:u}),getShaderSource:(E)=>V3(E,c,t.dims.length,e.length,i,o,n,t.dataType===10?-65504:-1e5,g,s,M,A)}},Jn=(a,t)=>{b5(a.inputs),a.compute(w3("MaxPool",a.inputs[0],!1,t))},$n=(a)=>{let{storage_order:t,dilations:r}=a,l=N3(a);if(t!==0)throw Error("column major storage order is not yet supported for MaxPool");if(l.ceilMode!==0)throw Error("using ceil() in shape computation is not yet supported for MaxPool");let i={storageOrder:t,dilations:r,...l,cacheKey:""};return{...i,cacheKey:hi(i)}},ah=(a)=>{let t=a.format;return{format:t,...R3,cacheKey:t}},th=(a,t)=>{b5(a.inputs),a.compute(w3("GlobalMaxPool",a.inputs[0],!0,t))}}),ci,di,rh,lh,xs=y(()=>{l1(),o1(),V1(),h1(),ci=(a,t)=>{if(a.length<2||a.length>3)throw Error("DequantizeLinear requires 2 or 3 inputs.");if(a.length===3&&a[1].dims===a[2].dims)throw Error("x-scale and x-zero-point must have the same shape.");if(a.length===3&&a[0].dataType!==a[2].dataType)throw Error("x and x-zero-point must have the same data type.");if(a[0].dataType===6&&a.length>2)throw Error("In the case of dequantizing int32 there is no zero point.");if(a[1].dims.length!==0&&a[1].dims.length!==1&&a[1].dims.length!==a[0].dims.length)throw Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(a.length>2){if(a[0].dataType!==a[2].dataType)throw Error("x and x-zero-point must have the same data type.");if(a[1].dims.length!==a[2].dims.length)throw Error("scale and zero-point inputs must have the same rank.");if(!a[1].dims.map((r,l)=>r===a[2].dims[l]).reduce((r,l)=>r&&l,!0))throw Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(a[1].dims.length===0||a[1].dims.length===1&&a[1].dims[0]===1)throw Error("blockSize must be set only for block quantization.");if(!a[1].dims.map((i,e)=>e===t.axis||i===a[0].dims[e]).reduce((i,e)=>i&&e,!0))throw Error("For block qunatization, scale input shape to match the input shape except for the axis");if(a[1].dims.length!==a[0].dims.length)throw Error("For block qunatization the scale input rank must be the same as the x rank.");let r=a[0].dims[t.axis],l=a[1].dims[t.axis];if(t.blockSize<Math.ceil(r/l)||t.blockSize>Math.ceil(r/(l-1)-1))throw Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},di=(a,t)=>{let r=O.normalizeAxis(t.axis,a[0].dims.length),l=a[0].dataType,i=l===3,e=a[0].dims,o=a[1].dataType,n=O.size(e),c=l===3||l===2,d=c?[Math.ceil(O.size(a[0].dims)/4)]:a[0].dims,u=a[1].dims,g=a.length>2?a[2]:void 0,s=g?c?[Math.ceil(O.size(g.dims)/4)]:g.dims:void 0,M=u.length===0||u.length===1&&u[0]===1,A=M===!1&&u.length===1,E=H1(n),x=M&&(!c||E===4),m=x?E:1,T=x&&!c?E:1,_=w("input",c?12:l,d.length,T),C=w("scale",o,u.length),z=g?w("zero_point",c?12:l,s.length):void 0,L=Q("output",o,e.length,m),H=[_,C];z&&H.push(z);let I=[d,u];g&&I.push(s);let N=[{type:12,data:n/m},{type:12,data:r},{type:12,data:t.blockSize},...J(...I,e)],P=(b)=>{let G=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${b.registerUniforms(G).declareVariables(...H,L)}
      ${b.mainStart()}
          ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${L.offsetToIndices("global_idx")};

          // Set input x
          ${c?`
            let input = ${_.getByOffset("global_idx / 4")};
            let x_vec = ${i?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${m===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${_.getByOffset("global_idx")};`};

          // Set scale input
          ${M?`let scale_value= ${C.getByOffset("0")}`:A?`
            let scale_index = ${L.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${C.getByOffset("scale_index")};`:`
            var scale_indices: ${C.type.indices} = output_indices;
            let index = ${C.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${C.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${C.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${z?M?c?`
                let zero_point_input = ${z.getByOffset("0")};
                let zero_point_vec =  ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${z.getByOffset("0")}`:A?c?`
                let zero_point_index = ${L.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${z.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${L.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${z.getByOffset("zero_point_index")};`:c?`
                let zero_point_offset = ${C.indicesToOffset("scale_indices")};
                let zero_point_input = ${z.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${z.getByIndices("scale_indices")};`:`let zero_point_value = ${c?i?"i32":"u32":_.type.value}(0);`};
      // Compute and write output
      ${L.setByOffset("global_idx",`${L.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:z?["rank","rank","rank"]:["rank","rank"]},getShaderSource:P,getRunData:()=>({outputs:[{dims:e,dataType:o}],dispatchGroup:{x:Math.ceil(n/m/64),y:1,z:1},programUniforms:N})}},rh=(a,t)=>{ci(a.inputs,t),a.compute(di(a.inputs,t))},lh=(a)=>T1({axis:a.axis,blockSize:a.blockSize})}),vi,ui,ih,Cs=y(()=>{l0(),l1(),h1(),vi=(a,t,r)=>{let l=a===t,i=a<t&&r<0,e=a>t&&r>0;if(l||i||e)throw Error("Range these inputs' contents are invalid.")},ui=(a,t,r,l)=>{let i=Math.abs(Math.ceil((t-a)/r)),e=[i],o=i,n=[{type:12,data:o},{type:l,data:a},{type:l,data:r},...J(e)],c=(d)=>{let u=Q("output",l,e.length),g=u.type.value,s=[{name:"outputSize",type:"u32"},{name:"start",type:g},{name:"delta",type:g}];return`
        ${d.registerUniforms(s).declareVariables(u)}
        ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${g}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${l}`},getShaderSource:c,getRunData:()=>({outputs:[{dims:e,dataType:l}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:n})}},ih=(a)=>{let t=0,r=0,l=0;a.inputs[0].dataType===6?(t=a.inputs[0].getInt32Array()[0],r=a.inputs[1].getInt32Array()[0],l=a.inputs[2].getInt32Array()[0]):a.inputs[0].dataType===1&&(t=a.inputs[0].getFloat32Array()[0],r=a.inputs[1].getFloat32Array()[0],l=a.inputs[2].getFloat32Array()[0]),m1.webgpu.validateInputContent&&vi(t,r,l),a.compute(ui(t,r,l,a.inputs[0].dataType),{inputs:[]})}}),gi,si,eh,oh,_s=y(()=>{l1(),o1(),V1(),h1(),gi=(a,t,r,l)=>{if(a!=="none"&&l!=="i32"&&l!=="u32"&&l!=="f32")throw Error(`Input ${l} is not supported with reduction ${a}.`);let i=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,e=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(a){case"none":return`${t}=${r};`;case"add":return l==="i32"||l==="u32"?`atomicAdd(&${t}, bitcast<${l}>(${r}));`:`
              ${i}bitcast<${l}>(oldValue) + (${r})${e}`;case"max":return l==="i32"||l==="u32"?`atomicMax(&${t}, bitcast<${l}>(${r}));`:`
                ${i}max(bitcast<f32>(oldValue), (${r}))${e}`;case"min":return l==="i32"||l==="u32"?`atomicMin(&${t}, bitcast<${l}>(${r}));`:`${i}min(bitcast<${l}>(oldValue), (${r}))${e}`;case"mul":return`${i}(bitcast<${l}>(oldValue) * (${r}))${e}`;default:throw Error(`Reduction ${a} is not supported.`)}},si=(a,t)=>{let r=a[0].dims,l=a[1].dims,i=r,e=1,o=Math.ceil(O.sizeToDimension(l,l.length-1)/e),n=l[l.length-1],c=O.sizeFromDimension(r,n),d=[{type:12,data:o},{type:12,data:n},{type:12,data:c},...J(a[1].dims,a[2].dims,i)],u=(g)=>{let s=w("indices",a[1].dataType,a[1].dims.length),M=w("updates",a[2].dataType,a[2].dims.length,e),A=t.reduction!=="none"&&t.reduction!==""?ke("output",a[0].dataType,i.length):Q("output",a[0].dataType,i.length,e);return`
      ${g.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(s,M,A)}
      ${g.mainStart()}
        ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var data_offset = 0u;
  let indices_start = uniforms.last_index_dimension * global_idx;
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${a[0].dims.length===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${gi(t.reduction,"output[data_offset + i]","value",A.type.value)}
  }

      }`};return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:i,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:d}),getShaderSource:u}},eh=(a)=>T1({reduction:a.reduction}),oh=(a,t)=>{a.compute(si(a.inputs,t),{inputs:[a.inputs[1],a.inputs[2]],outputs:[]})}}),pi,Si,Mi,D3,Ai,Ti,Ei,Ii,mi,fi,xi,Ci,G3,_i,Bi,zi,Li,Hi,nh,hh,Bs=y(()=>{l1(),o1(),V1(),h1(),pi=(a,t)=>{if(a.every((r)=>r>0||(()=>{throw Error("Resize requires scales input values to be positive")})),a.length>0){if(t.mode==="linear"){if(!(a.length===2||a.length===3||a.length===4&&a[0]===1&&a[1]===1||a.length===4&&a[0]===1&&a[3]===1||a.length===5&&a[0]===1&&a[1]===1))throw Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(a.length===2||a.length===4&&a[0]===1&&a[1]===1||a.length===4&&a[0]===1&&a[3]===1))throw Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Si=(a,t,r)=>{t.every((i)=>i>=0&&i<r||(()=>{throw Error("Resize requires axes input values to be positive and less than rank")}));let l=Array(r).fill(1);return t.forEach((i,e)=>l[i]=a[e]),l},Mi=(a,t,r,l,i,e)=>{let[o,n,c]=r>10?[1,2,3]:[-1,a.length>1?1:-1,-1],d=a[0].dims.length;if(o>0&&a.length>o&&a[o].dims.length>0)a[o].getFloat32Array().forEach((u)=>e.push(u));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(n>0&&a.length>n&&a[n].dims.length===1&&a[n].dims[0]>0){if(a[n].getFloat32Array().forEach((u)=>l.push(u)),l.length!==0&&l.length!==d&&r>=18&&l.length!==t.axes.length)throw Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");pi(l,t),t.axes.length>0&&Si(l,t.axes,d).forEach((u,g)=>l[g]=u)}if(c>0&&a.length>c&&a[c].dims.length===1&&a[c].dims[0]>0&&(a[c].getBigInt64Array().forEach((u)=>i.push(Number(u))),i.length!==0&&i.length!==d&&r>=18&&i.length!==t.axes.length))throw Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(l.length!==0&&l.length!==t.axes.length)throw Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(i.length!==0&&i.length!==t.axes.length)throw Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof l<"u"&&typeof i<"u"&&l.length>0&&i.length>d)throw Error("Resize requires only of scales or sizes to be specified")},D3=(a,t,r,l)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${a}) * (${t});
  let whole = ${l}(big / (${r}));
  let fract = ${l}(big % (${r})) / ${l}(${r});
  return whole + fract;
`,Ai=(a,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(a){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${t}(xResized) / ${t}(xScale);
          } else {
            ${D3("xResized","lengthOriginal","lengthResized",t)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${D3("xResized","lengthOriginal - 1","lengthResized - 1",t)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +
                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /
                        ${t}(lengthResized - 1);
                  } else {
                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);
                  const adjustment = ${t}(lengthResized) / outputWidth;
                  const center = ${t}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw Error(`Coordinate transform mode ${a} is not supported`)}})()+"}",Ti=(a,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(a){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw Error(`Nearest mode ${a} is not supported`)}})()+"}",Ei=(a,t,r)=>{let l=Array(r).fill(0).concat(Array(r).fill(1)),i=a.length===0?l:a.slice();return t.length>0?(t.forEach((e,o)=>{l[e]=i[o],l[o+r]=i[t.length+o]}),l):i},Ii=(a,t,r,l)=>{let i=[];if(r.length>0)if(l.length>0){if(a.forEach((e)=>i.push(e)),Math.max(...l)>a.length)throw Error("axes is out of bound");l.forEach((e,o)=>i[e]=r[o])}else r.forEach((e)=>i.push(e));else{if(t.length===0)throw Error("Resize requires either scales or sizes.");i=a.map((e,o)=>Math.round(e*t[o]))}return i},mi=(a,t,r)=>{let l=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map((e)=>t[e]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map((e)=>t[e]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let i=a.slice();return r.axes.length>0?(r.axes.forEach((e)=>t[e]=l),r.axes.forEach((e)=>i[e]=Math.round(a[e]*t[e]))):(t.fill(l,0,t.length),i.forEach((e,o)=>i[o]=Math.round(e*t[o]))),i},fi=(a,t,r,l,i)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${a.type.indices}) -> array<${a.type.value}, ${r.length}> {
      var original_indices: array<${a.type.value}, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var output_index = ${a.indicesGet("output_indices","i")};
        var scale = ${X("uniforms.scales","i",l)};
        var roi_low = ${X("uniforms.roi","i",i)};
        var roi_hi = ${X("uniforms.roi",`i + ${t.length}`,i)};
        if (scale == 1.0) {
          original_indices[i] = ${a.type.value}(output_index);
        } else {
          var input_shape_i = ${X("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${X("uniforms.output_shape","i",r.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,xi=(a,t,r,l,i,e,o)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${a.type.indices} {
      var input_indices: ${a.type.indices};
      for (var i:u32 = 0; i < ${l.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${X("uniforms.scales","i",i)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${X("uniforms.roi","i",e)};
          var roi_hi = ${X("uniforms.roi",`i + ${r.length}`,e)};
          var input_shape_i = ${X("uniforms.input_shape","i",r.length)};
          var output_shape_i = ${X("uniforms.output_shape","i",l.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${o} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${a.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,Ci=(a,t)=>`
    fn checkInputIndices(input_indices: ${a.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var input_index = ${a.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${X("uniforms.input_shape","i",t.length)}) {
          return false;
        }
      }
      return true;
    }`,G3=(a,t,r,l)=>a.rank>l?`
    ${a.indicesSet("input_indices",t,"channel")};
    ${a.indicesSet("input_indices",r,"batch")};
`:"",_i=(a,t,r,l,i)=>{let[e,o,n,c]=r.length===2?[-1,0,1,-1]:[0,2,3,1],d=a.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {
      var input_indices: ${a.type.indices};
      ${a.indicesSet("input_indices",o,`max(0, min(row, ${r[o]} - 1))`)};
      ${a.indicesSet("input_indices",n,`max(0, min(col, ${r[n]} - 1))`)};
      ${G3(a,c,e,2)}
      return ${a.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${d} = originalIndices[${o}];
      var col:${d} = originalIndices[${n}];
      ${l?`if (row < 0 || row > (${r[o]} - 1) || col < 0 || col > (${r[n]} - 1)) {
        return ${i};
      }`:""};
      row = max(0, min(row, ${r[o]} - 1));
      col = max(0, min(col, ${r[n]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${r.length>2?`u32(originalIndices[${c}])`:"0"};
      var batch: u32 =  ${r.length>2?`u32(originalIndices[${e}])`:"0"};
      var x11: ${d} = getInputValue(batch, channel, row1, col1);
      var x12: ${d} = getInputValue(batch, channel, row1, col2);
      var x21: ${d} = getInputValue(batch, channel, row2, col1);
      var x22: ${d} = getInputValue(batch, channel, row2, col2);
      var dx1: ${d} = abs(row - ${d}(row1));
      var dx2: ${d} = abs(${d}(row2) - row);
      var dy1: ${d} = abs(col - ${d}(col1));
      var dy2: ${d} = abs(${d}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Bi=(a,t,r,l,i,e,o,n,c,d)=>{let u=r.length===2,g=!0,[s,M]=u?[0,1]:g?[2,3]:[1,2],A=a.type.value,E=(x)=>{let m=x===s?"row":"col";return`
      fn ${m}CubicInterpolation(input_indices: ${a.type.indices}, output_indices: ${t.type.indices}) -> ${A} {
        var output_index = ${t.indicesGet("output_indices",x)};
        var originalIdx: ${A} = getOriginalCoordinateFromResizedCoordinate(output_index, ${i[x]},
        ${l[x]}, ${r[x]}, ${e[x]}, ${e[x]} + ${r.length});
        var fractOriginalIdx: ${A} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${n} && (originalIdx < 0 || originalIdx > (${r[x]} - 1))) {
          return ${c};
        }
        var data: array<${A}, 4> = array<${A}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${m}: ${A} = originalIdx + ${A}(i);
          if (${m} < 0 || ${m} >= ${r[x]}) {
            ${d?`coefs[i + 1] = 0.0;
                        continue;`:n?`return ${c};`:`${m} = max(0, min(${m}, ${r[x]} - 1));`};
          }
        var input_indices_copy: ${a.type.indices} = input_indices;
          ${a.indicesSet("input_indices_copy",x,`u32(${m})`)};
          data[i + 1] = ${x===s?a.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${E(s)};
    ${E(M)};
  fn getCubicInterpolationCoefs(s: ${A}) -> array<${A}, 4> {
    var absS = abs(s);
    var coeffs: array<${A}, 4> = array<${A}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${A} = 1.0 - absS;
    var twoMinusAbsS: ${A} = 2.0 - absS;
    var onePlusAbsS: ${A} = 1.0 + absS;
    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};
    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;
    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${A}, 4>, coefs: array<${A}, 4>) -> ${A} {
    var coefsSum: ${A} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${A} {
    var input_indices: ${a.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},zi=(a,t,r,l,i)=>{let[e,o,n,c,d]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],u=a.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${u} {
      var input_indices: ${a.type.indices};
      ${a.indicesSet("input_indices",o,`max(0, min(depth, ${r[o]} - 1))`)};
      ${a.indicesSet("input_indices",n,`max(0, min(height, ${r[n]} - 1))`)};
      ${a.indicesSet("input_indices",c,`max(0, min(width, ${r[c]} - 1))`)};
      ${G3(a,d,e,3)}
      return ${a.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${u} = originalIndices[${o}];
      var height:${u} = originalIndices[${n}];
      var width:${u} = originalIndices[${c}];
      ${l?`if (depth < 0 || depth > (${r[o]} - 1) || height < 0 || height > (${r[n]} - 1) || width < 0 || (width > ${r[c]} - 1)) {
      return ${i};
        }`:""};

    depth = max(0, min(depth, ${r[o]} - 1));
      height = max(0, min(height, ${r[n]} - 1));
      width = max(0, min(width, ${r[c]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${r.length>3?`u32(originalIndices[${d}])`:"0"};
      var batch: u32 =  ${r.length>3?`u32(originalIndices[${e}])`:"0"};

      var x111: ${u} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${u} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${u} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${u} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${u} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${u} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${u} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${u} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${u} = abs(depth - ${u}(depth1));
      var dx2: ${u} = abs(${u}(depth2) - depth);
      var dy1: ${u} = abs(height - ${u}(height1));
      var dy2: ${u} = abs(${u}(height2) - height);
      var dz1: ${u} = abs(width - ${u}(width1));
      var dz2: ${u} = abs(${u}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Li=(a,t,r,l,i,e)=>{let o=a.dims,n=Ei(e,t.axes,o.length),c=Ii(o,l,i,t.axes),d=l.slice();l.length===0&&(d=o.map((T,_)=>T===0?1:c[_]/T),t.keepAspectRatioPolicy!=="stretch"&&(c=mi(o,d,t)));let u=Q("output",a.dataType,c.length),g=w("input",a.dataType,o.length),s=O.size(c),M=o.length===c.length&&o.every((T,_)=>T===c[_]),A=t.coordinateTransformMode==="tf_crop_and_resize",E=t.extrapolationValue,x=g.type.value,m=(T)=>`
      ${M?"":`
      ${Ai(t.coordinateTransformMode,x)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${Ci(g,o)};
              ${Ti(t.nearestMode,r,x)};
              ${xi(g,u,o,c,d.length,n.length,A)};
              `;case"linear":return`
              ${fi(u,o,c,d.length,n.length)};
              ${(()=>{if(o.length===2||o.length===4)return`${_i(g,u,o,A,E)}`;if(o.length===3||o.length===5)return`${zi(g,u,o,A,E)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(o.length===2||o.length===4)return`${Bi(g,u,o,c,d,n,t.cubicCoeffA,A,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${T.registerUniform("output_size","u32").registerUniform("scales","f32",d.length).registerUniform("roi","f32",n.length).declareVariables(g,u)}
      ${T.mainStart()}
        ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${M?"output[global_idx] = input[global_idx];":`
        let output_indices = ${u.offsetToIndices("global_idx")};
        var input_indices: ${g.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${g.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${o.length===2||o.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${d.length>0?t.mode==="cubic"?d:d.length:""}|${i.length>0?i:""}|${n.length>0?n:""}|${M}|${t.mode==="nearest"?o.length:o}`,inputDependencies:["rank"]},getShaderSource:m,getRunData:()=>({outputs:[{dims:c,dataType:a.dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:1,data:d},{type:1,data:n},...J(o,c)]})}},Hi=(a)=>{let t=a.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},nh=(a,t)=>{let r=[],l=[],i=[],e=Hi(a);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");Mi(a.inputs,t,e,r,l,i),a.compute(Li(a.inputs[0],t,e,r,l,i),{inputs:[0]})},hh=(a)=>{let{antialias:t,axes:r,coordinateTransformMode:l,cubicCoeffA:i}=a,e=a.excludeOutside!==0,o=a.extrapolationValue,n=a.keepAspectRatioPolicy,c=a.mode,d=a.nearestMode===""?"simple":a.nearestMode;return T1({antialias:t,axes:r,coordinateTransformMode:l,cubicCoeffA:i,excludeOutside:e,extrapolationValue:o,keepAspectRatioPolicy:n,mode:c,nearestMode:d})}}),Vi,ki,ch,zs=y(()=>{l1(),o1(),h1(),Vi=(a)=>{if(!a||a.length<3)throw Error("layerNorm requires at least 3 inputs.");let t=a[0],r=a[1],l=a[2];if(t.dataType!==r.dataType||t.dataType!==l.dataType)throw Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw Error("Skip must be 2D or 3D");let i=t.dims[t.dims.length-1],e=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==i)throw Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==e)throw Error("Skip must have the same sequence length as input");if(l.dims.length!==1)throw Error("Gamma must be 1D");if(l.dims[l.dims.length-1]!==i)throw Error("Gamma must have the same hidden size as input");if(a.length>3){let o=a[3];if(o.dims.length!==1)throw Error("Beta must be 1D");if(o.dims[o.dims.length-1]!==i)throw Error("Beta must have the same hidden size as input")}if(a.length>4){let o=a[4];if(o.dims.length!==1)throw Error("Bias must be 1D");if(o.dims[o.dims.length-1]!==i)throw Error("Bias must have the same hidden size as input")}},ki=(a,t,r,l)=>{let i=t.simplified,e=a[0].dims,o=O.size(e),n=e,c=o,d=e.slice(-1)[0],u=l?e.slice(0,-1).concat(1):[],g=!i&&a.length>3,s=a.length>4,M=l&&r>1,A=l&&r>2,E=r>3,x=64,m=H1(d),T=[{type:12,data:c},{type:12,data:m},{type:12,data:d},{type:1,data:t.epsilon}],_=(z)=>{let L=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],H=[w("x",a[0].dataType,a[0].dims,m),w("skip",a[1].dataType,a[1].dims,m),w("gamma",a[2].dataType,a[2].dims,m)];g&&H.push(w("beta",a[3].dataType,a[3].dims,m)),s&&H.push(w("bias",a[4].dataType,a[4].dims,m)),H.push(Q("output",a[0].dataType,n,m)),M&&H.push(Q("mean_output",1,u)),A&&H.push(Q("inv_std_output",1,u)),E&&H.push(Q("input_skip_bias_sum",a[0].dataType,n,m));let I=w1(a[0].dataType),N=w1(1,m);return`

      ${z.registerUniforms(L).declareVariables(...H)}
      var<workgroup> sum_shared : array<${N}, ${x}>;
      var<workgroup> sum_squared_shared : array<${N}, ${x}>;

      ${z.mainStart([x,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${x};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${x};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${x-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${s?"bias[offset1d + i]":I+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${E?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${A5(I,m,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${x};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${y0("sum",m)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${y0("square_sum",m)} / f32(uniforms.hidden_size) ${i?"":"- mean * mean"} + uniforms.epsilon);
        ${M?"mean_output[global_idx] = mean;":""}
        ${A?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${i?"":`- ${I}(mean)`}) *
            ${I}(inv_std_dev) * gamma[offset1d + i]
            ${g?"+ beta[offset1d + i]":""};
        }
      }`},C=[{dims:n,dataType:a[0].dataType}];return r>1&&C.push({dims:u,dataType:1}),r>2&&C.push({dims:u,dataType:1}),r>3&&C.push({dims:e,dataType:a[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${m};${M};${A};${E}`,inputDependencies:a.map((z,L)=>"type")},getShaderSource:_,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(c/d)},programUniforms:T})}},ch=(a,t)=>{Vi(a.inputs);let r=[0];a.outputCount>1&&r.push(-3),a.outputCount>2&&r.push(-3),a.outputCount>3&&r.push(3),a.compute(ki(a.inputs,t,a.outputCount,!1),{outputs:r})}}),Ni,j5,Oi,P3,Ri,wi,dh,vh,Ls=y(()=>{l1(),o1(),V1(),h1(),Ni=(a,t)=>{if(!a||a.length<1)throw Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw Error("starts and ends must have the same length");a.slice(1).forEach((r,l)=>{if(a[l+1].dataType!==6&&a[l+1].dataType!==7)throw Error(`Input ${l} must be an array of int32 or int64`)})},j5=(a,t)=>{let r=[];if(a.length>t)if(a[t].dataType===7)a[t].getBigInt64Array().forEach((l)=>r.push(Number(l)));else if(a[t].dataType===6)a[t].getInt32Array().forEach((l)=>r.push(Number(l)));else throw Error(`Input ${t} must be an array of int32 or int64`);return r},Oi=(a,t)=>{if(a.length>1){let r=j5(a,1),l=j5(a,2),i=j5(a,3);return i.length===0&&(i=[...Array(a[0].dims.length).keys()]),T1({starts:r,ends:l,axes:i})}else return t},P3=(a,t,r,l,i)=>{let e=a;return a<0&&(e+=r[l[t]]),i[t]<0?Math.max(0,Math.min(e,r[l[t]]-1)):Math.max(0,Math.min(e,r[l[t]]))},Ri=(a,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${a.type.indices} {
          var input_indices: ${a.type.indices};
          var carry = 0u;
          for (var i = ${r.length-1}; i >= 0; i--) {
            let input_shape_i = ${X("uniforms.input_shape","i",r.length)};
            let steps_i = ${X("uniforms.steps","i",r.length)};
            let signs_i = ${X("uniforms.signs","i",r.length)};
            let starts_i = ${X("uniforms.starts","i",r.length)};
            var output_index = ${t.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${a.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,wi=(a,t)=>{let r=a[0].dims,l=O.size(r),i=t.axes.length>0?O.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],e=j5(a,4);e.forEach((m)=>m!==0||(()=>{throw Error("step cannot be 0")})),e.length===0&&(e=Array(i.length).fill(1));let o=t.starts.map((m,T)=>P3(m,T,r,i,e)),n=t.ends.map((m,T)=>P3(m,T,r,i,e));if(i.length!==o.length||i.length!==n.length)throw Error("start, ends and axes should have the same number of elements");if(i.length!==r.length)for(let m=0;m<r.length;++m)i.includes(m)||(o.splice(m,0,0),n.splice(m,0,r[m]),e.splice(m,0,1));let c=e.map((m)=>Math.sign(m));e.forEach((m,T,_)=>{if(m<0){let C=(n[T]-o[T])/m,z=o[T],L=z+C*e[T];o[T]=L,n[T]=z,_[T]=-m}});let d=r.slice(0);i.forEach((m,T)=>{d[m]=Math.ceil((n[m]-o[m])/e[m])});let u={dims:d,dataType:a[0].dataType},g=Q("output",a[0].dataType,d.length),s=w("input",a[0].dataType,a[0].dims.length),M=O.size(d),A=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:o.length},{name:"signs",type:"i32",length:c.length},{name:"steps",type:"u32",length:e.length}],E=[{type:12,data:M},{type:12,data:o},{type:6,data:c},{type:12,data:e},...J(a[0].dims,d)],x=(m)=>`
      ${m.registerUniforms(A).declareVariables(s,g)}
        ${Ri(s,g,r)}
        ${m.mainStart()}
          ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${g.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${g.setByOffset("global_idx",s.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${c.length}_${o.length}_${e.length}`,inputDependencies:["rank"]},getShaderSource:x,getRunData:()=>({outputs:[u],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:E})}},dh=(a,t)=>{Ni(a.inputs,t);let r=Oi(a.inputs,t);a.compute(wi(a.inputs,r),{inputs:[0]})},vh=(a)=>{let{starts:t,ends:r,axes:l}=a;return T1({starts:t,ends:r,axes:l})}}),Di,Gi,uh,gh,Hs=y(()=>{l1(),o1(),V1(),b0(),h1(),Di=(a)=>{if(!a||a.length!==1)throw Error("Softmax op requires 1 input.")},Gi=(a,t)=>{let r=a.inputs[0],l=r.dims,i=O.size(l),e=l.length,o=O.normalizeAxis(t.axis,e),n=o<l.length-1,c,d=[];n?(d=Array.from({length:e},(H,I)=>I),d[o]=e-1,d[e-1]=o,c=a.compute($1(r,d),{inputs:[r],outputs:[-1]})[0]):c=r;let u=c.dims,g=u[e-1],s=i/g,M=H1(g),A=g/M,E=64;s===1&&(E=256);let x=(H,I)=>I===4?`max(max(${H}.x, ${H}.y), max(${H}.z, ${H}.w))`:I===2?`max(${H}.x, ${H}.y)`:I===3?`max(max(${H}.x, ${H}.y), ${H}.z)`:H,m=w("x",c.dataType,c.dims,M),T=Q("result",c.dataType,c.dims,M),_=m.type.value,C=w1(c.dataType)==="f32"?`var threadMax = ${_}(-3.4028234663852886e+38f);`:`var threadMax = ${_}(-65504.0h);`,z=(H)=>`
      var<workgroup> rowMaxShared : ${_};
      var<workgroup> rowSumShared : ${_};
      var<workgroup> threadShared : array<${_}, ${E}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${_} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${_}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${H.registerUniform("packedCols","i32").declareVariables(m,T)}
      ${H.mainStart(E)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${E};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${C}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${_}(${x("threadShared[0]",M)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${_}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${_}(${y0("threadShared[0]",M)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          // max operation protects against NaN since all values should be >=0
          value = max(value, ${_}(0.0));
          setValue(row, col, row_stride, value);
        }
      }`,L=a.compute({name:"Softmax",shaderCache:{hint:`${M};${E}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:u,dataType:c.dataType}],dispatchGroup:{x:s},programUniforms:[{type:6,data:A}]}),getShaderSource:z},{inputs:[c],outputs:[n?-1:0]})[0];n&&a.compute($1(L,d),{inputs:[L]})},uh=(a,t)=>{Di(a.inputs),Gi(a,t)},gh=(a)=>T1({axis:a.axis})}),F3,Pi,Fi,Zi,sh,Vs=y(()=>{l1(),o1(),h1(),F3=(a)=>Array.from(a.getBigInt64Array(),Number),Pi=(a)=>{if(!a||a.length!==2)throw Error("Tile requires 2 inputs.");if(a[0].dataType!==1&&a[0].dataType!==10&&a[0].dataType!==6&&a[0].dataType!==12)throw Error("Tile only support float, float16, int32, and uint32 data types");if(a[1].dataType!==7)throw Error("Tile `repeats` input should be of int64 data type");if(a[1].dims.length!==1)throw Error("Tile `repeats` input should be 1-D");if(F3(a[1]).length!==a[0].dims.length)throw Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Fi=(a,t)=>{let r=[];for(let l=0;l<a.length;++l)r.push(a[l]*t[l]);return r},Zi=(a,t)=>{let r=a[0].dims,l=t??F3(a[1]),i=Fi(r,l),e=O.size(i),o=a[0].dataType,n=w("input",o,r.length),c=Q("output",o,i.length),d=(u)=>`
      const inputShape = ${n.indices(...r)};
      ${u.registerUniform("output_size","u32").declareVariables(n,c)}
      ${u.mainStart()}
      ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${c.offsetToIndices("global_idx")};
      var input_indices: ${n.type.indices};
      for (var i = 0; i < ${r.length}; i++) {
        let input_dim_i = ${n.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${c.indicesGet("output_indices","i")}  % input_dim_i;

        ${n.indicesSet("input_indices","i","input_dim_value")}
      }
      ${c.setByOffset("global_idx",n.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${l}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(e/64)},programUniforms:[{type:12,data:e},...J(a[0].dims,i)]}),getShaderSource:d}},sh=(a)=>{Pi(a.inputs),a.compute(Zi(a.inputs),{inputs:[0]})}}),yi,bi,ph,ks=y(()=>{l1(),o1(),h1(),yi=(a,t,r,l,i)=>{let e=Q("output_data",i,r.length,4),o=w("a_data",t[1].dataType,t[1].dims.length,4),n=w("b_data",t[2].dataType,t[2].dims.length,4),c=w("c_data",t[0].dataType,t[0].dims.length,4),d,u=(g,s,M)=>`select(${s}, ${g}, ${M})`;if(!l)d=e.setByOffset("global_idx",u(o.getByOffset("global_idx"),n.getByOffset("global_idx"),c.getByOffset("global_idx")));else{let g=(s,M,A="")=>{let E=`a_data[index_a${M}][component_a${M}]`,x=`b_data[index_b${M}][component_b${M}]`,m=`bool(c_data[index_c${M}] & (0xffu << (component_c${M} * 8)))`;return`
            let output_indices${M} = ${e.offsetToIndices(`global_idx * 4u + ${M}u`)};
            let offset_a${M} = ${o.broadcastedIndicesToOffset(`output_indices${M}`,e)};
            let offset_b${M} = ${n.broadcastedIndicesToOffset(`output_indices${M}`,e)};
            let offset_c${M} = ${c.broadcastedIndicesToOffset(`output_indices${M}`,e)};
            let index_a${M} = offset_a${M} / 4u;
            let index_b${M} = offset_b${M} / 4u;
            let index_c${M} = offset_c${M} / 4u;
            let component_a${M} = offset_a${M} % 4u;
            let component_b${M} = offset_b${M} % 4u;
            let component_c${M} = offset_c${M} % 4u;
            ${s}[${M}] = ${A}(${u(E,x,m)});
          `};i===9?d=`
            var data = vec4<u32>(0);
            ${g("data",0,"u32")}
            ${g("data",1,"u32")}
            ${g("data",2,"u32")}
            ${g("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:d=`
            ${g("output_data[global_idx]",0)}
            ${g("output_data[global_idx]",1)}
            ${g("output_data[global_idx]",2)}
            ${g("output_data[global_idx]",3)}
          `}return`
        ${a.registerUniform("vec_size","u32").declareVariables(c,o,n,e)}
        ${a.mainStart()}
        ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${d}
      }`},bi=(a)=>{let t=a[1].dims,r=a[2].dims,l=a[0].dims,i=a[1].dataType,e=!(O.areEqual(t,r)&&O.areEqual(r,l)),o=t,n=O.size(t);if(e){let d=T5.calcShape(T5.calcShape(t,r,!1),l,!1);if(!d)throw Error("Can't perform where op on the given tensors");o=d,n=O.size(o)}let c=Math.ceil(n/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:(d)=>yi(d,a,o,e,i),getRunData:()=>({outputs:[{dims:o,dataType:i}],dispatchGroup:{x:Math.ceil(n/64/4)},programUniforms:[{type:12,data:c},...J(l,t,r,o)]})}},ph=(a)=>{a.compute(bi(a.inputs))}}),Sh,Ns=y(()=>{Kg(),I6(),qg(),Yg(),Qg(),Xg(),Jg(),ls(),es(),os(),ns(),hs(),cs(),ds(),vs(),us(),gs(),ss(),ps(),Ss(),Ms(),As(),Ts(),Es(),Is(),Rn(),ms(),fs(),xs(),Cs(),_s(),E6(),Bs(),Fn(),zs(),Ls(),Hs(),Gn(),Vs(),b0(),m6(),ks(),Sh=new Map([["Abs",[no]],["Acos",[ho]],["Acosh",[co]],["Add",[jo]],["ArgMax",[lo,X3]],["ArgMin",[ro,X3]],["Asin",[vo]],["Asinh",[uo]],["Atan",[go]],["Atanh",[so]],["Attention",[io]],["AveragePool",[Yn,qn]],["BatchNormalization",[eo]],["BiasAdd",[oo]],["BiasSplitGelu",[bo]],["Cast",[So,po]],["Ceil",[Ao]],["Clip",[Mo]],["Concat",[an,tn]],["Conv",[l6,r6]],["ConvTranspose",[un,vn]],["Cos",[To]],["Cosh",[Eo]],["CumSum",[gn,sn]],["DepthToSpace",[pn,Sn]],["DequantizeLinear",[rh,lh]],["Div",[Uo]],["Einsum",[Mn,An]],["Elu",[Io,q5]],["Equal",[Wo]],["Erf",[mo]],["Exp",[fo]],["Expand",[Tn]],["FastGelu",[En]],["Floor",[xo]],["FusedConv",[l6,r6]],["Gather",[mn,In]],["GatherElements",[zn,Bn]],["GatherBlockQuantized",[Cn,_n]],["GatherND",[fn,xn]],["Gelu",[Co]],["Gemm",[Hn,Ln]],["GlobalAveragePool",[Xn,Qn]],["GlobalMaxPool",[th,ah]],["Greater",[Qo]],["GreaterOrEqual",[Jo]],["GridSample",[Vn,kn]],["GroupQueryAttention",[Zn]],["HardSigmoid",[No,ko]],["InstanceNormalization",[yn]],["LayerNormalization",[bn]],["LeakyRelu",[_o,q5]],["Less",[Xo]],["LessOrEqual",[$o]],["Log",[Zo]],["MatMul",[jn]],["MatMulNBits",[Un,Wn]],["MaxPool",[Jn,$n]],["Mul",[Ko]],["MultiHeadAttention",[On,Nn]],["Neg",[zo]],["Not",[Bo]],["Pad",[Kn]],["Pow",[qo]],["QuickGelu",[yo,q5]],["Range",[ih]],["Reciprocal",[Lo]],["ReduceMin",[Xe]],["ReduceMean",[We]],["ReduceMax",[Qe]],["ReduceSum",[$e]],["ReduceProd",[Je]],["ReduceL1",[Ke]],["ReduceL2",[qe]],["ReduceLogSum",[to]],["ReduceLogSumExp",[Ye]],["ReduceSumSquare",[ao]],["Relu",[Ho]],["Resize",[nh,hh]],["RotaryEmbedding",[Pn]],["ScatterND",[oh,eh]],["Sigmoid",[Vo]],["Sin",[Oo]],["Sinh",[Ro]],["Slice",[dh,vh]],["SkipLayerNormalization",[ch]],["Split",[wn,Dn]],["Sqrt",[wo]],["Softmax",[uh,gh]],["Sub",[Yo]],["Tan",[Do]],["Tanh",[Go]],["ThresholdedRelu",[Fo,q5]],["Tile",[sh]],["Transpose",[Oe,Re]],["Where",[ph]]])}),Mh,Os=y(()=>{l0(),H0(),h1(),Mh=class{constructor(a){this.backend=a,this.repo=new Map,this.attributesBound=!1}getArtifact(a){return this.repo.get(a)}setArtifact(a,t){this.repo.set(a,t)}run(a,t,r,l,i){C0(a.programInfo.name);let e=this.backend.device,o=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let n=[];for(let d of t)n.push({binding:n.length,resource:{buffer:d.buffer}});for(let d of r)n.push({binding:n.length,resource:{buffer:d.buffer}});i&&n.push({binding:n.length,resource:i});let c=e.createBindGroup({layout:a.computePipeline.getBindGroupLayout(0),entries:n,label:a.programInfo.name});if(this.backend.sessionStatus==="capturing"){let d={kernelId:this.backend.currentKernelId,computePipeline:a.computePipeline,bindGroup:c,dispatchGroup:l};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(d)}o.setPipeline(a.computePipeline),o.setBindGroup(0,c),o.dispatchWorkgroups(...l),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),g0(a.programInfo.name)}dispose(){}build(a,t){C0(a.name);let r=this.backend.device,l=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach((d)=>{r.features.has(d.feature)&&l.push(`enable ${d.extension};`)});let i=Ne(t,this.backend.device.limits),e=a.getShaderSource(i),o=`${l.join(`
`)}
${i.additionalImplementations}
${e}`,n=r.createShaderModule({code:o,label:a.name});g1("verbose",()=>`[WebGPU] ${a.name} shader code: ${o}`);let c=r.createComputePipeline({compute:{module:n,entryPoint:"main"},layout:"auto",label:a.name});return g0(a.name),{programInfo:a,computePipeline:c,uniformVariablesInfo:i.variablesInfo}}normalizeDispatchGroupSize(a){let t=typeof a=="number"?a:a.x,r=typeof a=="number"?1:a.y||1,l=typeof a=="number"?1:a.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=i&&r<=i&&l<=i)return[t,r,l];let e=t*r*l,o=Math.ceil(Math.sqrt(e));if(o>i){if(o=Math.ceil(Math.cbrt(e)),o>i)throw Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}else return[o,o,1]}}}),Ah={};I5(Ah,{WebGpuBackend:()=>Th});var ji,Ui,Wi,Th,Rs=y(()=>{l0(),l1(),H0(),ze(),Ug(),Ns(),Os(),ji=(a,t)=>{if(t.length!==a.length)throw Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${a.length}.`);let r=[];for(let l=0;l<a.length;++l){let i=a[l].dataType;switch(t[l]){case"none":{r.push("");break}case"type":{r.push(`${i}`);break}case"rank":{let e=a[l].dims.length;r.push(`${i};${e}`);break}case"dims":{let e=a[l].dims.join(",");r.push(`${i};${e}`);break}default:throw Error(`unsupported input dependency: ${t[l]}`)}}return r.join("|")},Ui=(a,t,r)=>{let l=a.name;return a.shaderCache?.hint&&(l+="["+a.shaderCache.hint+"]"),l+=":"+r+`:${ji(t,a.shaderCache?.inputDependencies??Array(t.length).fill("dims"))}`,l},Wi=class{constructor(a){a&&(this.architecture=a.architecture,this.vendor=a.vendor)}isArchitecture(a){return this.architecture===a}isVendor(a){return this.vendor===a}},Th=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let a=this.kernelCustomData.get(this.currentKernelId);return a||(a={},this.kernelCustomData.set(this.currentKernelId,a)),a}async initialize(a,t){this.env=a;let r=[],l={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:r},i=(e)=>t.features.has(e)&&r.push(e)&&!0;i("chromium-experimental-timestamp-query-inside-passes")||i("timestamp-query"),i("shader-f16"),i("subgroups"),this.device=await t.requestDevice(l),this.adapterInfo=new Wi(t.info||await t.requestAdapterInfo()),this.gpuDataManager=Ve(this),this.programManager=new Mh(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,S6(a.logLevel,!!a.debug),this.device.onuncapturederror=(e)=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let a=this.getCommandEncoder(),t={};this.queryType==="at-passes"&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=a.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;C0(),this.endComputePass();let a;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),a=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(a,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,a,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&a.mapAsync(GPUMapMode.READ).then(()=>{let t=new BigUint64Array(a.getMappedRange()),r=this.pendingQueries.get(a);for(let l=0;l<t.length/2;l++){let i=r[l],e=i.kernelId,o=this.kernels.get(e),n=o.kernelType,c=o.kernelName,d=i.programName,u=i.inputTensorViews,g=i.outputTensorViews,s=t[l*2],M=t[l*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=s);let A=Number(s-this.queryTimeBase),E=Number(M-this.queryTimeBase);if(!Number.isSafeInteger(A)||!Number.isSafeInteger(E))throw RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:u.map((x)=>({dims:x.dims,dataType:L0(x.dataType)})),outputsMetadata:g.map((x)=>({dims:x.dims,dataType:L0(x.dataType)})),kernelId:e,kernelType:n,kernelName:c,programName:d,startTime:A,endTime:E});else{let x="";u.forEach((T,_)=>{x+=`input[${_}]: [${T.dims}] | ${L0(T.dataType)}, `});let m="";g.forEach((T,_)=>{m+=`output[${_}]: [${T.dims}] | ${L0(T.dataType)}, `}),console.log(`[profiling] kernel "${e}|${n}|${c}|${d}" ${x}${m}start time: ${A} ns, execution time: ${E-A} ns`)}Z2("GPU",`${d}::${s}::${M}`)}a.unmap(),this.pendingQueries.delete(a)}),g0()}run(a,t,r,l,i,e){C0(a.name);let o=[];for(let T=0;T<t.length;++T){let _=t[T].data;if(_===0)continue;let C=this.gpuDataManager.get(_);if(!C)throw Error(`no GPU data for input: ${_}`);o.push(C)}let{outputs:n,dispatchGroup:c,programUniforms:d}=a.getRunData(t),u=r.length===0?n.map((T,_)=>_):r;if(u.length!==n.length)throw Error(`Output size ${u.length} must be equal to ${n.length}.`);let g=[],s=[];for(let T=0;T<n.length;++T){if(!Number.isInteger(u[T])||u[T]<-3||u[T]>=e)throw Error(`Invalid output index: ${u[T]}`);if(u[T]===-3)continue;let _=u[T]===-1,C=u[T]===-2,z=_||C?i(n[T].dataType,n[T].dims):l(u[T],n[T].dataType,n[T].dims);if(g.push(z),z.data===0)continue;let L=this.gpuDataManager.get(z.data);if(!L)throw Error(`no GPU data for output: ${z.data}`);if(_&&this.temporaryData.push(L),C){let H=this.kernelPersistentData.get(this.currentKernelId);H||(H=[],this.kernelPersistentData.set(this.currentKernelId,H)),H.push(L)}s.push(L)}if(o.length!==t.length||s.length!==g.length){if(s.length===0)return g0(a.name),g;throw Error(`Program ${a.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let M;if(d){let T=0,_=[];d.forEach((H)=>{let I=typeof H.data=="number"?[H.data]:H.data;if(I.length===0)return;let N=H.type===10?2:4,P,b;H.type===10?(b=I.length>4?16:I.length>2?8:I.length*N,P=I.length>4?16:N*I.length):(b=I.length<=2?I.length*N:16,P=16),T=Math.ceil(T/b)*b,_.push(T);let G=H.type===10?8:4;T+=I.length>4?Math.ceil(I.length/G)*P:I.length*N});let C=16;T=Math.ceil(T/C)*C;let z=new ArrayBuffer(T);d.forEach((H,I)=>{let N=_[I],P=typeof H.data=="number"?[H.data]:H.data;if(H.type===6)new Int32Array(z,N,P.length).set(P);else if(H.type===12)new Uint32Array(z,N,P.length).set(P);else if(H.type===10)new Uint16Array(z,N,P.length).set(P);else if(H.type===1)new Float32Array(z,N,P.length).set(P);else throw Error(`Unsupported uniform type: ${L0(H.type)}`)});let L=this.gpuDataManager.create(T,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(L.buffer,0,z,0,T),this.gpuDataManager.release(L.id),M={offset:0,size:T,buffer:L.buffer}}let A=this.programManager.normalizeDispatchGroupSize(c),E=A[1]===1&&A[2]===1,x=Ui(a,t,E),m=this.programManager.getArtifact(x);if(m||(m=this.programManager.build(a,A),this.programManager.setArtifact(x,m),g1("info",()=>`[artifact] key: ${x}, programName: ${a.name}`)),d&&m.uniformVariablesInfo){if(d.length!==m.uniformVariablesInfo.length)throw Error(`Uniform variables count mismatch: expect ${m.uniformVariablesInfo.length}, got ${d.length} in program "${m.programInfo.name}".`);for(let T=0;T<d.length;T++){let _=d[T],C=_.type,z=typeof _.data=="number"?1:_.data.length,[L,H]=m.uniformVariablesInfo[T];if(C!==L||z!==H)throw Error(`Uniform variable ${T} mismatch: expect type ${L} with size ${H}, got type ${C} with size ${z} in program "${m.programInfo.name}".`)}}if(g1("info",()=>`[ProgramManager] run "${a.name}" (key=${x}) with ${A[0]}x${A[1]}x${A[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let T={kernelId:this.currentKernelId,programName:m.programInfo.name,inputTensorViews:t,outputTensorViews:g};this.pendingKernels.push(T),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(T)}return this.programManager.run(m,o,s,A,M),g0(a.name),g}upload(a,t){this.gpuDataManager.upload(a,t)}memcpy(a,t){this.gpuDataManager.memcpy(a,t)}async download(a,t){await this.gpuDataManager.download(a,t)}alloc(a){return this.gpuDataManager.create(a).id}free(a){return this.gpuDataManager.release(a)}createKernel(a,t,r,l){let i=Sh.get(a);if(!i)throw Error(`kernel not implemented: ${a}`);let e={kernelType:a,kernelName:l,kernelEntry:i[0],attributes:[i[1],r]};this.kernels.set(t,e)}releaseKernel(a){let t=this.kernelPersistentData.get(a);if(t){for(let r of t)this.gpuDataManager.release(r.id);this.kernelPersistentData.delete(a)}this.kernelCustomData.delete(a),this.kernels.delete(a)}computeKernel(a,t,r){let l=this.kernels.get(a);if(!l)throw Error(`kernel not created: ${a}`);let{kernelType:i,kernelName:e,kernelEntry:o,attributes:n}=l;if(this.currentKernelId!==null)throw Error(`kernel "[${i}] ${e}" is not allowed to be called recursively`);this.currentKernelId=a,n[0]&&(n[1]=n[0](n[1]),n[0]=void 0),g1("info",()=>`[WebGPU] Start to run kernel "[${i}] ${e}"...`);let c=this.env.debug;this.temporaryData=[];try{return c&&this.device.pushErrorScope("validation"),o(t,n[1]),0}catch(d){return r.push(Promise.resolve(`[WebGPU] Kernel "[${i}] ${e}" failed. ${d}`)),1}finally{c&&r.push(this.device.popErrorScope().then((d)=>d?`GPU validation error for kernel "[${i}] ${e}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(a,t,r,l){let i=this.sessionExternalDataMapping.get(a);i||(i=new Map,this.sessionExternalDataMapping.set(a,i));let e=i.get(t),o=this.gpuDataManager.registerExternalBuffer(r,l,e);return i.set(t,[o,r]),o}unregisterBuffers(a){let t=this.sessionExternalDataMapping.get(a);t&&(t.forEach((r)=>this.gpuDataManager.unregisterExternalBuffer(r[0])),this.sessionExternalDataMapping.delete(a))}getBuffer(a){let t=this.gpuDataManager.get(a);if(!t)throw Error(`no GPU data for buffer: ${a}`);return t.buffer}createDownloader(a,t,r){return async()=>{let l=await q3(this,a,t);return M6(l.buffer,r)}}writeTimestamp(a){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,a)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){g1("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){g1("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){g1("info","replay"),this.sessionStatus="replaying";let a=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),r=a.length;this.pendingKernels=[];for(let l=0;l<r;l++){let i=this.getComputePassEncoder(),e=a[l];this.writeTimestamp(this.pendingDispatchNumber*2),i.setPipeline(e.computePipeline),i.setBindGroup(0,e.bindGroup),i.dispatchWorkgroups(...e.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(t[l]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(a){this.unregisterBuffers(a),this.capturedCommandList.has(a)&&this.capturedCommandList.delete(a),this.capturedPendingKernels.has(a)&&this.capturedPendingKernels.delete(a),this.gpuDataManager.onReleaseSession(a)}onRunStart(a){this.currentSessionId=a,this.setQueryType()}}}),Eh={};I5(Eh,{init:()=>Ih});var D2,Ki,Ih,ws=y(()=>{l1(),H0(),o1(),jg(),D2=class a{constructor(t,r,l,i){this.module=t,this.dataType=r,this.data=l,this.dims=i}getFloat32Array(){if(this.dataType!==1)throw Error("Invalid data type");let t=O.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw Error("Invalid data type");let t=O.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw Error("Invalid data type");let t=O.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw Error("Invalid data type");let t=O.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(O.size(t)!==O.size(this.dims))throw Error("Invalid new shape");return new a(this.module,this.dataType,this.data,t)}},Ki=class{constructor(a,t,r){this.module=a,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let l=a.PTR_SIZE,i=r/a.PTR_SIZE,e=l===4?"i32":"i64";this.opKernelContext=Number(a.getValue(l*i++,e));let o=Number(a.getValue(l*i++,e));this.outputCount=Number(a.getValue(l*i++,e)),this.customDataOffset=Number(a.getValue(l*i++,"*")),this.customDataSize=Number(a.getValue(l*i++,e));let n=[];for(let c=0;c<o;c++){let d=Number(a.getValue(l*i++,e)),u=Number(a.getValue(l*i++,"*")),g=Number(a.getValue(l*i++,e)),s=[];for(let M=0;M<g;M++)s.push(Number(a.getValue(l*i++,e)));n.push(new D2(a,d,u,s))}this.inputs=n}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(a,t){let r=t?.inputs?.map((o)=>typeof o=="number"?this.inputs[o]:o)??this.inputs,l=t?.outputs??[],i=(o,n,c)=>new D2(this.module,n,this.output(o,c),c),e=(o,n)=>{let c=t5(o,n);if(!c)throw Error(`Unsupported data type: ${o}`);let d=c>0?this.backend.gpuDataManager.create(c).id:0;return new D2(this.module,o,d,n)};return this.backend.run(a,r,l,i,e,this.outputCount)}output(a,t){let r=this.module.stackSave();try{let l=this.module.PTR_SIZE,i=l===4?"i32":"i64",e=this.module.stackAlloc((1+t.length)*l);this.module.setValue(e,t.length,i);for(let o=0;o<t.length;o++)this.module.setValue(e+l*(o+1),t[o],i);return this.module._JsepOutput(this.opKernelContext,a,e)}catch(l){throw Error(`Failed to generate kernel's output[${a}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${l}`)}finally{this.module.stackRestore(r)}}},Ih=async(a,t,r,l)=>{let i=t.jsepInit;if(!i)throw Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(a==="webgpu"){let e=(Rs(),X5(Ah)).WebGpuBackend,o=new e;await o.initialize(r,l),i("webgpu",[o,(n)=>o.alloc(Number(n)),(n)=>o.free(n),(n,c,d,u=!1)=>{if(u)g1("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(n)}, dst=${Number(c)}, size=${Number(d)}`),o.memcpy(Number(n),Number(c));else{g1("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(n)}, gpuDataId=${Number(c)}, size=${Number(d)}`);let g=t.HEAPU8.subarray(Number(n>>>0),Number(n>>>0)+Number(d));o.upload(Number(c),g)}},async(n,c,d)=>{g1("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${c}, size=${d}`),await o.download(Number(n),()=>t.HEAPU8.subarray(Number(c)>>>0,Number(c+d)>>>0))},(n,c,d)=>o.createKernel(n,Number(c),d,t.UTF8ToString(t._JsepGetNodeName(Number(c)))),(n)=>o.releaseKernel(n),(n,c,d,u)=>{g1("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${d}, kernel=${n}, contextDataOffset=${c}`);let g=new Ki(t,o,Number(c));return o.computeKernel(Number(n),g,u)},()=>o.captureBegin(),()=>o.captureEnd(),()=>o.replay()])}else{let e=new He(r);i("webnn",[e,()=>e.reserveTensorId(),(o)=>e.releaseTensorId(o),async(o,n,c,d,u)=>e.ensureTensor(o,n,c,d,u),(o,n)=>{e.uploadTensor(o,n)},async(o,n)=>e.downloadTensor(o,n),(o,n)=>e.registerMLContext(o,n),!!r.trace])}}}),qi,z6,L6,F0,Yi,Z3,q2,H6,V6,y3,k6,N6,O6,mh=y(()=>{l0(),Zg(),yg(),l1(),n5(),u6(),xe(),qi=(a,t)=>{f1()._OrtInit(a,t)!==0&&E1("Can't initialize onnxruntime.")},z6=async(a)=>{qi(a.wasm.numThreads,b2(a.logLevel))},L6=async(a,t)=>{f1().asyncInit?.();let r=a.webgpu.adapter;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw Error("WebGPU is not supported in current environment");if(r){if(typeof r.limits!="object"||typeof r.features!="object"||typeof r.requestDevice!="function")throw Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let l=a.webgpu.powerPreference;if(l!==void 0&&l!=="low-power"&&l!=="high-performance")throw Error(`Invalid powerPreference setting: "${l}"`);let i=a.webgpu.forceFallbackAdapter;if(i!==void 0&&typeof i!="boolean")throw Error(`Invalid forceFallbackAdapter setting: "${i}"`);if(r=await navigator.gpu.requestAdapter({powerPreference:l,forceFallbackAdapter:i}),!r)throw Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if(t==="webnn"&&(typeof navigator>"u"||!navigator.ml))throw Error("WebNN is not supported in current environment");{let l=(ws(),X5(Eh)).init;t==="webgpu"&&await l("webgpu",f1(),a,r),t==="webnn"&&await l("webnn",f1(),a)}},F0=new Map,Yi=(a)=>{let t=f1(),r=t.stackSave();try{let l=t.PTR_SIZE,i=t.stackAlloc(2*l);t._OrtGetInputOutputCount(a,i,i+l)!==0&&E1("Can't get session input/output count.");let e=l===4?"i32":"i64";return[Number(t.getValue(i,e)),Number(t.getValue(i+l,e))]}finally{t.stackRestore(r)}},Z3=(a,t)=>{let r=f1(),l=r.stackSave(),i=0;try{let e=r.PTR_SIZE,o=r.stackAlloc(2*e);r._OrtGetInputOutputMetadata(a,t,o,o+e)!==0&&E1("Can't get session input/output metadata.");let n=Number(r.getValue(o,"*"));i=Number(r.getValue(o+e,"*"));let c=r.HEAP32[i/4];if(c===0)return[n,0];let d=r.HEAPU32[i/4+1],u=[];for(let g=0;g<d;g++){let s=Number(r.getValue(i+8+g*e,"*"));u.push(s!==0?r.UTF8ToString(s):Number(r.getValue(i+8+(g+d)*e,"*")))}return[n,c,u]}finally{r.stackRestore(l),i!==0&&r._OrtFree(i)}},q2=(a)=>{let t=f1(),r=t._malloc(a.byteLength);if(r===0)throw Error(`Can't create a session. failed to allocate a buffer of size ${a.byteLength}.`);return t.HEAPU8.set(a,r),[r,a.byteLength]},H6=async(a,t)=>{let r,l,i=f1();Array.isArray(a)?[r,l]=a:a.buffer===i.HEAPU8.buffer?[r,l]=[a.byteOffset,a.byteLength]:[r,l]=q2(a);let e=0,o=0,n=0,c=[],d=[],u=[];try{if([o,c]=await fe(t),t?.externalData&&i.mountExternalData){let C=[];for(let z of t.externalData){let L=typeof z=="string"?z:z.path;C.push(p6(typeof z=="string"?z:z.data).then((H)=>{i.mountExternalData(L,H)}))}await Promise.all(C)}for(let C of t?.executionProviders??[])if((typeof C=="string"?C:C.name)==="webnn"){if(i.shouldTransferToMLTensor=!1,typeof C!="string"){let z=C,L=z?.context,H=z?.gpuDevice,I=z?.deviceType,N=z?.powerPreference;L?i.currentContext=L:H?i.currentContext=await i.webnnCreateMLContext(H):i.currentContext=await i.webnnCreateMLContext({deviceType:I,powerPreference:N})}else i.currentContext=await i.webnnCreateMLContext();break}e=await i._OrtCreateSession(r,l,o),i.webgpuOnCreateSession?.(e),e===0&&E1("Can't create a session."),i.jsepOnCreateSession?.(),i.currentContext&&(i.webnnRegisterMLContext(e,i.currentContext),i.currentContext=void 0,i.shouldTransferToMLTensor=!0);let[g,s]=Yi(e),M=!!t?.enableGraphCapture,A=[],E=[],x=[],m=[],T=[];for(let C=0;C<g;C++){let[z,L,H]=Z3(e,C);z===0&&E1("Can't get an input name."),d.push(z);let I=i.UTF8ToString(z);A.push(I),x.push(L===0?{name:I,isTensor:!1}:{name:I,isTensor:!0,type:L0(L),shape:H})}for(let C=0;C<s;C++){let[z,L,H]=Z3(e,C+g);z===0&&E1("Can't get an output name."),u.push(z);let I=i.UTF8ToString(z);E.push(I),m.push(L===0?{name:I,isTensor:!1}:{name:I,isTensor:!0,type:L0(L),shape:H});{if(M&&t?.preferredOutputLocation===void 0){T.push("gpu-buffer");continue}let N=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[I]??"cpu",P=i.webnnIsGraphOutput;if(N==="cpu"&&P&&P(e,I)){T.push("ml-tensor-cpu-output");continue}if(N!=="cpu"&&N!=="cpu-pinned"&&N!=="gpu-buffer"&&N!=="ml-tensor")throw Error(`Not supported preferred output location: ${N}.`);if(M&&N!=="gpu-buffer")throw Error(`Not supported preferred output location: ${N}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);T.push(N)}}let _=null;return T.some((C)=>C==="gpu-buffer"||C==="ml-tensor"||C==="ml-tensor-cpu-output")&&(n=i._OrtCreateBinding(e),n===0&&E1("Can't create IO binding."),_={handle:n,outputPreferredLocations:T,outputPreferredLocationsEncoded:T.map((C)=>C==="ml-tensor-cpu-output"?"ml-tensor":C).map((C)=>W3(C))}),F0.set(e,[e,d,u,_,M,!1]),[e,A,E,x,m]}catch(g){throw d.forEach((s)=>i._OrtFree(s)),u.forEach((s)=>i._OrtFree(s)),n!==0&&i._OrtReleaseBinding(n)!==0&&E1("Can't release IO binding."),e!==0&&i._OrtReleaseSession(e)!==0&&E1("Can't release session."),g}finally{i._free(r),o!==0&&i._OrtReleaseSessionOptions(o)!==0&&E1("Can't release session options."),c.forEach((g)=>i._free(g)),i.unmountExternalData?.()}},V6=(a)=>{let t=f1(),r=F0.get(a);if(!r)throw Error(`cannot release session. invalid session id: ${a}`);let[l,i,e,o,n]=r;o&&(n&&t._OrtClearBoundOutputs(o.handle)!==0&&E1("Can't clear bound outputs."),t._OrtReleaseBinding(o.handle)!==0&&E1("Can't release IO binding.")),t.jsepOnReleaseSession?.(a),t.webnnOnReleaseSession?.(a),t.webgpuOnReleaseSession?.(a),i.forEach((c)=>t._OrtFree(c)),e.forEach((c)=>t._OrtFree(c)),t._OrtReleaseSession(l)!==0&&E1("Can't release session."),F0.delete(a)},y3=async(a,t,r,l,i,e,o=!1)=>{if(!a){t.push(0);return}let n=f1(),c=n.PTR_SIZE,d=a[0],u=a[1],g=a[3],s=g,M,A;if(d==="string"&&(g==="gpu-buffer"||g==="ml-tensor"))throw Error("String tensor is not supported on GPU.");if(o&&g!=="gpu-buffer")throw Error(`External buffer must be provided for input/output index ${e} when enableGraphCapture is true.`);if(g==="gpu-buffer"){let m=a[2].gpuBuffer;A=t5(a5(d),u);{let T=n.jsepRegisterBuffer;if(!T)throw Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');M=T(l,e,m,A)}}else if(g==="ml-tensor"){let m=a[2].mlTensor;A=t5(a5(d),u);let T=n.webnnRegisterMLTensor;if(!T)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');M=T(l,m,a5(d),u)}else{let m=a[2];if(Array.isArray(m)){A=c*m.length,M=n._malloc(A),r.push(M);for(let T=0;T<m.length;T++){if(typeof m[T]!="string")throw TypeError(`tensor data at index ${T} is not a string`);n.setValue(M+T*c,v0(m[T],r),"*")}}else{let{webnnIsGraphInput:T,webnnIsGraphOutput:_}=n;if(d!=="string"&&T&&_){let C=n.UTF8ToString(i);if(T(l,C)||_(l,C)){let z=a5(d);A=t5(z,u),s="ml-tensor";let{webnnCreateTemporaryTensor:L,webnnUploadTensor:H}=n;if(!L||!H)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');let I=await L(l,z,u);H(I,new Uint8Array(m.buffer,m.byteOffset,m.byteLength)),M=I}else A=m.byteLength,M=n._malloc(A),r.push(M),n.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,A),M)}else A=m.byteLength,M=n._malloc(A),r.push(M),n.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,A),M)}}let E=n.stackSave(),x=n.stackAlloc(4*u.length);try{u.forEach((T,_)=>n.setValue(x+_*c,T,c===4?"i32":"i64"));let m=n._OrtCreateTensor(a5(d),M,A,x,u.length,W3(s));m===0&&E1(`Can't create tensor for input/output. session=${l}, index=${e}.`),t.push(m)}finally{n.stackRestore(E)}},k6=async(a,t,r,l,i,e)=>{let o=f1(),n=o.PTR_SIZE,c=F0.get(a);if(!c)throw Error(`cannot run inference. invalid session id: ${a}`);let d=c[0],u=c[1],g=c[2],s=c[3],M=c[4],A=c[5],E=t.length,x=l.length,m=0,T=[],_=[],C=[],z=[],L=[],H=o.stackSave(),I=o.stackAlloc(E*n),N=o.stackAlloc(E*n),P=o.stackAlloc(x*n),b=o.stackAlloc(x*n);try{[m,T]=me(e),r5("wasm prepareInputOutputTensor");for(let V=0;V<E;V++)await y3(r[V],_,z,a,u[t[V]],t[V],M);for(let V=0;V<x;V++)await y3(i[V],C,z,a,g[l[V]],E+l[V],M);l5("wasm prepareInputOutputTensor");for(let V=0;V<E;V++)o.setValue(I+V*n,_[V],"*"),o.setValue(N+V*n,u[t[V]],"*");for(let V=0;V<x;V++)o.setValue(P+V*n,C[V],"*"),o.setValue(b+V*n,g[l[V]],"*");if(s&&!A){let{handle:V,outputPreferredLocations:F,outputPreferredLocationsEncoded:a1}=s;if(u.length!==E)throw Error(`input count from feeds (${E}) is expected to be always equal to model's input count (${u.length}).`);r5("wasm bindInputsOutputs");for(let $=0;$<E;$++){let Y=t[$];await o._OrtBindInput(V,u[Y],_[$])!==0&&E1(`Can't bind input[${$}] for session=${a}.`)}for(let $=0;$<x;$++){let Y=l[$];i[$]?.[3]?(L.push(C[$]),o._OrtBindOutput(V,g[Y],C[$],0)!==0&&E1(`Can't bind pre-allocated output[${$}] for session=${a}.`)):o._OrtBindOutput(V,g[Y],0,a1[Y])!==0&&E1(`Can't bind output[${$}] to ${F[$]} for session=${a}.`)}l5("wasm bindInputsOutputs"),F0.set(a,[d,u,g,s,M,!0])}o.jsepOnRunStart?.(d),o.webnnOnRunStart?.(d);let G;s?G=await o._OrtRunWithBinding(d,s.handle,x,P,m):G=await o._OrtRun(d,N,I,E,b,x,P,m),G!==0&&E1("failed to call OrtRun().");let j=[],e1=[];r5("wasm ProcessOutputTensor");for(let V=0;V<x;V++){let F=Number(o.getValue(P+V*n,"*"));if(F===C[V]||L.includes(C[V])){j.push(i[V]),F!==C[V]&&o._OrtReleaseTensor(F)!==0&&E1("Can't release tensor.");continue}let a1=o.stackSave(),$=o.stackAlloc(4*n),Y=!1,i1,D=0;try{o._OrtGetTensorData(F,$,$+n,$+2*n,$+3*n)!==0&&E1(`Can't access output tensor data on index ${V}.`);let W=n===4?"i32":"i64",t1=Number(o.getValue($,W));D=o.getValue($+n,"*");let s1=o.getValue($+n*2,"*"),R1=Number(o.getValue($+n*3,W)),q1=[];for(let k1=0;k1<R1;k1++)q1.push(Number(o.getValue(s1+k1*n,W)));o._OrtFree(s1)!==0&&E1("Can't free memory for tensor dims.");let i0=q1.reduce((k1,L1)=>k1*L1,1);i1=L0(t1);let s0=s?.outputPreferredLocations[l[V]];if(i1==="string"){if(s0==="gpu-buffer"||s0==="ml-tensor")throw Error("String tensor is not supported on GPU.");let k1=[];for(let L1=0;L1<i0;L1++){let U1=o.getValue(D+L1*n,"*"),j0=o.getValue(D+(L1+1)*n,"*"),a2=L1===i0-1?void 0:j0-U1;k1.push(o.UTF8ToString(U1,a2))}j.push([i1,q1,k1,"cpu"])}else if(s0==="gpu-buffer"&&i0>0){let k1=o.jsepGetBuffer;if(!k1)throw Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let L1=k1(D),U1=t5(t1,i0);if(U1===void 0||!g6(i1))throw Error(`Unsupported data type: ${i1}`);Y=!0,j.push([i1,q1,{gpuBuffer:L1,download:o.jsepCreateDownloader(L1,U1,i1),dispose:()=>{o._OrtReleaseTensor(F)!==0&&E1("Can't release tensor.")}},"gpu-buffer"])}else if(s0==="ml-tensor"&&i0>0){let{webnnEnsureTensor:k1,webnnIsGraphInputOutputTypeSupported:L1}=o;if(!k1||!L1)throw Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(t5(t1,i0)===void 0||!s6(i1))throw Error(`Unsupported data type: ${i1}`);if(!L1(a,i1,!1))throw Error(`preferredLocation "ml-tensor" for ${i1} output is not supported by current WebNN Context.`);let U1=await k1(a,D,t1,q1,!1);Y=!0,j.push([i1,q1,{mlTensor:U1,download:o.webnnCreateMLTensorDownloader(D,i1),dispose:()=>{o.webnnReleaseTensorId(D),o._OrtReleaseTensor(F)}},"ml-tensor"])}else if(s0==="ml-tensor-cpu-output"&&i0>0){let k1=o.webnnCreateMLTensorDownloader(D,i1)(),L1=j.length;Y=!0,e1.push((async()=>{let U1=[L1,await k1];return o.webnnReleaseTensorId(D),o._OrtReleaseTensor(F),U1})()),j.push([i1,q1,[],"cpu"])}else{let k1=Q2(i1),L1=new k1(i0);new Uint8Array(L1.buffer,L1.byteOffset,L1.byteLength).set(o.HEAPU8.subarray(D,D+L1.byteLength)),j.push([i1,q1,L1,"cpu"])}}finally{o.stackRestore(a1),i1==="string"&&D&&o._free(D),Y||o._OrtReleaseTensor(F)}}s&&!M&&(o._OrtClearBoundOutputs(s.handle)!==0&&E1("Can't clear bound outputs."),F0.set(a,[d,u,g,s,M,!1]));for(let[V,F]of await Promise.all(e1))j[V][2]=F;return l5("wasm ProcessOutputTensor"),j}finally{o.webnnOnRunEnd?.(d),o.stackRestore(H),_.forEach((G)=>o._OrtReleaseTensor(G)),C.forEach((G)=>o._OrtReleaseTensor(G)),z.forEach((G)=>o._free(G)),m!==0&&o._OrtReleaseRunOptions(m),T.forEach((G)=>o._free(G))}},N6=(a)=>{let t=f1(),r=F0.get(a);if(!r)throw Error("invalid session id");let l=r[0],i=t._OrtEndProfiling(l);i===0&&E1("Can't get an profile file name."),t._OrtFree(i)},O6=(a)=>{let t=[];for(let r of a){let l=r[2];!Array.isArray(l)&&"buffer"in l&&t.push(l.buffer)}return t}}),Z0,r0,S5,U5,W5,G2,b3,P2,X0,J0,Qi,fh,xh,Ch,_h,Bh,zh,Lh,Hh=y(()=>{l0(),mh(),n5(),d6(),Z0=()=>!!m1.wasm.proxy&&typeof document<"u",S5=!1,U5=!1,W5=!1,P2=new Map,X0=(a,t)=>{let r=P2.get(a);r?r.push(t):P2.set(a,[t])},J0=()=>{if(S5||!U5||W5||!r0)throw Error("worker not ready")},Qi=(a)=>{switch(a.data.type){case"init-wasm":S5=!1,a.data.err?(W5=!0,b3[1](a.data.err)):(U5=!0,b3[0]()),G2&&(URL.revokeObjectURL(G2),G2=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=P2.get(a.data.type);a.data.err?t.shift()[1](a.data.err):t.shift()[0](a.data.out);break}default:}},fh=async()=>{if(!U5){if(S5)throw Error("multiple calls to 'initWasm()' detected.");if(W5)throw Error("previous call to 'initWasm()' failed.");if(S5=!0,Z0())return new Promise((a,t)=>{r0?.terminate(),Ee().then(([r,l])=>{try{r0=l,r0.onerror=(e)=>t(e),r0.onmessage=Qi,b3=[a,t];let i={type:"init-wasm",in:m1};!i.in.wasm.wasmPaths&&(r||U3)&&(i.in.wasm.wasmPaths={wasm:new URL("ort-wasm-simd-threaded.jsep.wasm","https://localhost").href}),r0.postMessage(i),G2=r}catch(i){t(i)}},t)});try{await v6(m1.wasm),await z6(m1),U5=!0}catch(a){throw W5=!0,a}finally{S5=!1}}},xh=async(a)=>{if(Z0())return J0(),new Promise((t,r)=>{X0("init-ep",[t,r]);let l={type:"init-ep",in:{epName:a,env:m1}};r0.postMessage(l)});await L6(m1,a)},Ch=async(a)=>Z0()?(J0(),new Promise((t,r)=>{X0("copy-from",[t,r]);let l={type:"copy-from",in:{buffer:a}};r0.postMessage(l,[a.buffer])})):q2(a),_h=async(a,t)=>{if(Z0()){if(t?.preferredOutputLocation)throw Error('session option "preferredOutputLocation" is not supported for proxy.');return J0(),new Promise((r,l)=>{X0("create",[r,l]);let i={type:"create",in:{model:a,options:{...t}}},e=[];a instanceof Uint8Array&&e.push(a.buffer),r0.postMessage(i,e)})}else return H6(a,t)},Bh=async(a)=>{if(Z0())return J0(),new Promise((t,r)=>{X0("release",[t,r]);let l={type:"release",in:a};r0.postMessage(l)});V6(a)},zh=async(a,t,r,l,i,e)=>{if(Z0()){if(r.some((o)=>o[3]!=="cpu"))throw Error("input tensor on GPU is not supported for proxy.");if(i.some((o)=>o))throw Error("pre-allocated output tensor is not supported for proxy.");return J0(),new Promise((o,n)=>{X0("run",[o,n]);let c=r,d={type:"run",in:{sessionId:a,inputIndices:t,inputs:c,outputIndices:l,options:e}};r0.postMessage(d,O6(c))})}else return k6(a,t,r,l,i,e)},Lh=async(a)=>{if(Z0())return J0(),new Promise((t,r)=>{X0("end-profiling",[t,r]);let l={type:"end-profiling",in:a};r0.postMessage(l)});N6(a)}}),j3,Xi,Vh,Ds=y(()=>{l0(),Hh(),l1(),c6(),xe(),j3=(a,t)=>{switch(a.location){case"cpu":return[a.type,a.dims,a.data,"cpu"];case"gpu-buffer":return[a.type,a.dims,{gpuBuffer:a.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[a.type,a.dims,{mlTensor:a.mlTensor},"ml-tensor"];default:throw Error(`invalid data location: ${a.location} for ${t()}`)}},Xi=(a)=>{switch(a[3]){case"cpu":return new u0(a[0],a[2],a[1]);case"gpu-buffer":{let t=a[0];if(!g6(t))throw Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:l,dispose:i}=a[2];return u0.fromGpuBuffer(r,{dataType:t,dims:a[1],download:l,dispose:i})}case"ml-tensor":{let t=a[0];if(!s6(t))throw Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:l,dispose:i}=a[2];return u0.fromMLTensor(r,{dataType:t,dims:a[1],download:l,dispose:i})}default:throw Error(`invalid data location: ${a[3]}`)}},Vh=class{async fetchModelAndCopyToWasmMemory(a){return Ch(await p6(a))}async loadModel(a,t){C0();let r;typeof a=="string"?r=await this.fetchModelAndCopyToWasmMemory(a):r=a,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await _h(r,t),g0()}async dispose(){return Bh(this.sessionId)}async run(a,t,r){C0();let l=[],i=[];Object.entries(a).forEach((g)=>{let s=g[0],M=g[1],A=this.inputNames.indexOf(s);if(A===-1)throw Error(`invalid input '${s}'`);l.push(M),i.push(A)});let e=[],o=[];Object.entries(t).forEach((g)=>{let s=g[0],M=g[1],A=this.outputNames.indexOf(s);if(A===-1)throw Error(`invalid output '${s}'`);e.push(M),o.push(A)});let n=l.map((g,s)=>j3(g,()=>`input "${this.inputNames[i[s]]}"`)),c=e.map((g,s)=>g?j3(g,()=>`output "${this.outputNames[o[s]]}"`):null),d=await zh(this.sessionId,i,n,o,c,r),u={};for(let g=0;g<d.length;g++)u[this.outputNames[o[g]]]=e[g]??Xi(d[g]);return g0(),u}startProfiling(){}endProfiling(){Lh(this.sessionId)}}}),kh={};I5(kh,{OnnxruntimeWebAssemblyBackend:()=>o6,initializeFlags:()=>e6,wasmBackend:()=>Nh});var e6,o6,Nh,Gs=y(()=>{l0(),Hh(),Ds(),e6=()=>{(typeof m1.wasm.initTimeout!="number"||m1.wasm.initTimeout<0)&&(m1.wasm.initTimeout=0);let a=m1.wasm.simd;if(typeof a!="boolean"&&a!==void 0&&a!=="fixed"&&a!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${a}". Reset it to \`false\` and ignore SIMD feature checking.`),m1.wasm.simd=!1),typeof m1.wasm.proxy!="boolean"&&(m1.wasm.proxy=!1),typeof m1.wasm.trace!="boolean"&&(m1.wasm.trace=!1),typeof m1.wasm.numThreads!="number"||!Number.isInteger(m1.wasm.numThreads)||m1.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)m1.wasm.numThreads=1;else{let t=typeof navigator>"u"?fg("node:os").cpus().length:navigator.hardwareConcurrency;m1.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},o6=class{async init(a){e6(),await fh(),await xh(a)}async createInferenceSessionHandler(a,t){let r=new Vh;return await r.loadModel(a,t),r}},Nh=new o6});l0();l0();l0();var Ps="1.24.1";{let a=(Gs(),X5(kh)).wasmBackend;M5("webgpu",a,5),M5("webnn",a,5),M5("cpu",a,10),M5("wasm",a,10)}Object.defineProperty(m1.versions,"web",{value:Ps,enumerable:!0});var Oh=44100,Zs=5,ys=Oh*Zs,X2=null,bs=Promise.resolve(null);async function Rh(a,t){try{return m1.wasm.numThreads=1,m1.wasm.wasmBinary=t,X2=await Y2.create(a,{executionProviders:["wasm"]}),console.log("[trashbin+ AI] Inference engine initialized"),!0}catch(r){return console.error("[trashbin+ AI] Failed to init engine:",r),!1}}function wh(){if(X2)X2.release(),X2=null;bs=Promise.resolve(null),console.log("[trashbin+ AI] Engine disposed")}var J2=null;function Dh(){if(J2&&J2.state!=="closed")J2.close(),J2=null}class Gh{map;maxLength;constructor(a){this.map=new Map,this.maxLength=a}set(a,t){if(this.map.size>=this.maxLength){let r=this.map.keys().next().value;this.map.delete(r)}this.map.set(a,t)}get(a){return this.map.get(a)}clear(){this.map.clear()}}var js=new Gh(1000),Us=new Set;async function Ph(a){try{if(a?.("Checking assets..."),!await Ar(a))return!1;a?.("Loading WASM runtime...");let r=await R5(f0.WASM);if(!r)return!1;a?.("Loading AI model...");let l=await R5(f0.MODEL);if(!l)return!1;a?.("Initializing engine...");let i=await Rh(l,r);if(i)a?.("Ready");return i}catch(t){return console.error("[trashbin+ AI] Initialization failed:",t),!1}}function R6(){wh(),Dh(),js.clear(),Us.clear()}var Zh=()=>{let a=A1();Fh.useEffect(()=>{if(!a.aiDetectionEnabled){R6(),a.setAiAssetsReady(!1);return}let t=!1;return(async()=>{a.setAiAssetsDownloading(!0);let l=await Ph((i)=>{console.log(`[trashbin+ AI] ${i}`)});if(!t){if(a.setAiAssetsReady(l),a.setAiAssetsDownloading(!1),l)Spicetify.showNotification("AI detection ready")}})(),()=>{t=!0,R6()}},[a.aiDetectionEnabled])};var $2=Z(B1(),1);var yh=()=>{let a=A1(),t=$2.useRef(null);$2.useEffect(()=>{if(!a.trashbinEnabled||!a.trashOnNextHotkey)return;let r=()=>{let i=Spicetify.Player.data?.item;if(i?.uri)t.current=i.uri,Spicetify.Player.next()},l=()=>{if(t.current)a.toggleSongTrash(t.current,!0),t.current=null};return Spicetify.Mousetrap.bind("ctrl+right",r),Spicetify.Player.addEventListener("songchange",l),()=>{Spicetify.Mousetrap.unbind("ctrl+right"),Spicetify.Player.removeEventListener("songchange",l)}},[a.trashbinEnabled,a.trashOnNextHotkey,a.toggleSongTrash])};var K1=Z(B1(),1);var Ws=3000,bh="trashbin-playlist-monitor";function jh(){let a=A1(),t=K1.useRef(null),r=K1.useRef({currentPlaylistUri:null}),l=K1.useCallback(()=>{try{let u=Spicetify.LocalStorage.get(bh);if(u){let g=JSON.parse(u);r.current.currentPlaylistUri=g.currentPlaylistUri}}catch(u){console.error("usePlaylistMonitor: Failed to load state:",u)}},[]),i=K1.useCallback(()=>{try{Spicetify.LocalStorage.set(bh,JSON.stringify({currentPlaylistUri:r.current.currentPlaylistUri}))}catch(u){console.error("usePlaylistMonitor: Failed to save state:",u)}},[]),e=K1.useCallback(()=>{let u=Spicetify.Player.data?.context?.uri;if(u&&Spicetify.URI.isPlaylistV1OrV2(u))r.current.currentPlaylistUri=u,i()},[i]),o=K1.useCallback(async()=>{if(!r.current.currentPlaylistUri)return;try{await Spicetify.Player.playUri(r.current.currentPlaylistUri)}catch(u){console.error("usePlaylistMonitor: Failed to resume playlist:",u)}},[]),n=K1.useCallback(()=>{let u=Spicetify.Player.data,g=Spicetify.Player.isPlaying(),s=!!u?.context?.uri,M=!!u?.item;if(r.current.currentPlaylistUri&&g&&!s&&!M)o()},[o]),c=K1.useCallback(()=>{if(t.current)clearInterval(t.current);t.current=setInterval(n,Ws)},[n]),d=K1.useCallback(()=>{if(t.current)clearInterval(t.current),t.current=null},[]);K1.useEffect(()=>{l()},[l]),K1.useEffect(()=>{if(!a.playlistMonitorEnabled){d(),Spicetify.Player.removeEventListener("songchange",e);return}return Spicetify.Player.addEventListener("songchange",e),c(),()=>{d(),Spicetify.Player.removeEventListener("songchange",e)}},[a.playlistMonitorEnabled,e,c,d])}var m5=Z(B1(),1);var Uh=()=>{let a=A1(),t=m5.useRef(!1),r=m5.useRef(null),l=m5.useRef(!1);m5.useEffect(()=>{if(!a.trashbinEnabled||!a.remoteToggleEnabled||!a.trashViaLikeEnabled)return;let i=setInterval(async()=>{if(l.current)return;if(Spicetify.Platform.ConnectAPI.state.activeDevice.id==="local_device")return;let e=Spicetify.Player.data?.item;if(!e?.uri)return;let o=Spicetify.Player.getHeart();if(e.uri!==r.current){r.current=e.uri,t.current=o;return}if(!t.current&&o){l.current=!0;try{let n=e.uri.split(":")[2];if(await Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/me/tracks?ids=${n}`),!a.getTrashStatus(e.uri).isTrashed)a.toggleSongTrash(e.uri,!1),Spicetify.showNotification(C1.t("MESSAGE_SONG_ADDED_REMOTE")),Spicetify.Player.next()}catch(n){console.error("Remote trash failed:",n)}l.current=!1}t.current=o},2000);return()=>clearInterval(i)},[a.trashbinEnabled,a.remoteToggleEnabled,a.trashViaLikeEnabled,a.getTrashStatus,a.toggleSongTrash])};var $5=Z(B1(),1);var Wh=()=>{let a=A1(),t=$5.useRef(0),r=$5.useRef(!1);$5.useEffect(()=>{if(!a.trashbinEnabled||!a.remoteToggleEnabled)return;let l=(i)=>{if(Spicetify.Platform.ConnectAPI.state.activeDevice.id==="local_device")return;if(r.current)return;let e=i?.data?.isPaused,o=Date.now();if(e)t.current=o;else if(t.current>0&&o-t.current<3000){r.current=!0;let n=A1.getState().remoteSkippingEnabled;a.toggleRemoteSkipping(),Spicetify.showNotification(C1.t(n?"MESSAGE_REMOTE_SKIPPING_DISABLED":"MESSAGE_REMOTE_SKIPPING_ENABLED")),Spicetify.Player.next(),t.current=0,setTimeout(()=>{r.current=!1},3000)}};return Spicetify.Player.addEventListener("onplaypause",l),()=>Spicetify.Player.removeEventListener("onplaypause",l)},[a.trashbinEnabled,a.remoteToggleEnabled,a.toggleRemoteSkipping])};function Ks(){console.log("trashbin+ loaded v1.0.10!");let a=A1();return yh(),jh(),Wh(),Uh(),Zh(),y1.useEffect(()=>{a.initializeFromStorage()},[a.initializeFromStorage]),y1.useEffect(()=>{if(a.autoplayOnStart&&!Spicetify.Player.isPlaying())setTimeout(Spicetify.Player.play,5000),setTimeout(Spicetify.Player.play,60000)},[a.autoplayOnStart]),y1.useEffect(()=>{if(!a.trashbinEnabled)return;let t=document.querySelector(t0.SKIP_BACK_BUTTON)??document.querySelector(t0.SKIP_BACK_BUTTON_ALT),r=()=>a.setUserHitBack(!0),l=async()=>{let i=Spicetify.Player.data?.item,e=A1.getState();if(Spicetify.Platform.ConnectAPI.state.activeDevice.id!=="local_device"&&!e.remoteSkippingEnabled)return;if(e.userHitBack){a.setUserHitBack(!1);return}if(e.autoCleanQueue)y8();if(e.skipTrashedTracks&&U4(i))Z8()};return t?.addEventListener("click",r),Spicetify.Player.addEventListener("songchange",l),()=>{t?.removeEventListener("click",r),Spicetify.Player.removeEventListener("songchange",l)}},[a.trashbinEnabled]),y1.default.createElement(y1.default.Fragment,null,y1.default.createElement(G8,null,y1.default.createElement(rr,null),y1.default.createElement(ir,null),y1.default.createElement(sr,null),y1.default.createElement(tr,null),y1.default.createElement($8,null),y1.default.createElement(J8,null),y1.default.createElement(K8,null)))}async function qs(){let a=document.createElement("div");return a.id="trashbin-plus-root",a.className="fixed top-0 left-0 z-50 pointer-events-none",document.body.appendChild(a),w6.default.render(y1.default.createElement(Ks,null),a),()=>{w6.default.unmountComponentAtNode(a),a.remove()}}var Kh=qs;(async()=>{await Kh()})();

;(()=>{if(!document.getElementById("trashbinDplus")){const s=document.createElement("style");s.id="trashbinDplus";s.textContent=String.raw`/*! tailwindcss v4.1.18 | MIT License | https://tailwindcss.com */@layer properties;@layer theme;@layer theme{:root,:host{--color-red-400:oklch(70.4% .191 22.216);--color-red-500:oklch(63.7% .237 25.331);--color-green-500:oklch(72.3% .219 149.579);--color-black:#000;--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-xl:1.25rem;--text-xl--line-height:calc(1.75/1.25);--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--radius-md:.375rem;--radius-lg:.5rem;--ease-out:cubic-bezier(0,0,.2,1);--animate-spin:spin 1s linear infinite;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1)}}.pointer-events-auto{pointer-events:auto}.pointer-events-auto\!{pointer-events:auto!important}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.absolute\!{position:absolute!important}.fixed{position:fixed}.fixed\!{position:fixed!important}.relative{position:relative}.relative\!{position:relative!important}.static{position:static}.top-0{top:calc(var(--spacing)*0)}.top-full{top:100%}.right-0{right:calc(var(--spacing)*0)}.right-0\!{right:calc(var(--spacing)*0)!important}.bottom-0{bottom:calc(var(--spacing)*0)}.left-0{left:calc(var(--spacing)*0)}.left-1{left:calc(var(--spacing)*1)}.left-1\/2{left:50%}.z-50{z-index:50}.z-50\!{z-index:50!important}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.mx-1{margin-inline:calc(var(--spacing)*1)}.mx-1\!{margin-inline:calc(var(--spacing)*1)!important}.mx-2{margin-inline:calc(var(--spacing)*2)}.mx-2\!{margin-inline:calc(var(--spacing)*2)!important}.my-2{margin-block:calc(var(--spacing)*2)}.my-2\.5\!{margin-block:calc(var(--spacing)*2.5)!important}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.mb-4\!{margin-bottom:calc(var(--spacing)*4)!important}.ml-3{margin-left:calc(var(--spacing)*3)}.ml-3\!{margin-left:calc(var(--spacing)*3)!important}.block{display:block}.contents{display:contents}.flex{display:flex}.flex\!{display:flex!important}.grid{display:grid}.hidden{display:none}.inline{display:inline}.inline-block{display:inline-block}.inline-block\!{display:inline-block!important}.inline-flex{display:inline-flex}.inline-flex\!{display:inline-flex!important}.table{display:table}.h-0{height:calc(var(--spacing)*0)}.h-0\.5{height:calc(var(--spacing)*.5)}.h-2{height:calc(var(--spacing)*2)}.h-2\!{height:calc(var(--spacing)*2)!important}.h-5{height:calc(var(--spacing)*5)}.h-6{height:calc(var(--spacing)*6)}.h-12{height:calc(var(--spacing)*12)}.h-20{height:calc(var(--spacing)*20)}.h-100{height:calc(var(--spacing)*100)}.h-full{height:100%}.h-full\!{height:100%!important}.min-h-8{min-height:calc(var(--spacing)*8)}.min-h-8\!{min-height:calc(var(--spacing)*8)!important}.w-5{width:calc(var(--spacing)*5)}.w-6{width:calc(var(--spacing)*6)}.w-12{width:calc(var(--spacing)*12)}.w-12\!{width:calc(var(--spacing)*12)!important}.w-20{width:calc(var(--spacing)*20)}.w-full{width:100%}.min-w-0{min-width:calc(var(--spacing)*0)}.flex-1{flex:1}.flex-shrink{flex-shrink:1}.shrink-0{flex-shrink:0}.-translate-x-1{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-x-1\/2{--tw-translate-x:calc(calc(1/2*100%)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.animate-spin{animation:var(--animate-spin)}.cursor-help{cursor:help}.cursor-help\!{cursor:help!important}.cursor-not-allowed{cursor:not-allowed}.cursor-not-allowed\!{cursor:not-allowed!important}.cursor-pointer{cursor:pointer}.cursor-pointer\!{cursor:pointer!important}.resize{resize:both}.flex-col{flex-direction:column}.items-center{align-items: center}.items-center\!{align-items: center!important}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-0{gap:calc(var(--spacing)*0)}.gap-0\.5\!{gap:calc(var(--spacing)*.5)!important}.gap-1{gap:calc(var(--spacing)*1)}.gap-1\.5\!{gap:calc(var(--spacing)*1.5)!important}.gap-2{gap:calc(var(--spacing)*2)}.gap-2\.5\!{gap:calc(var(--spacing)*2.5)!important}.gap-3{gap:calc(var(--spacing)*3)}.gap-6{gap:calc(var(--spacing)*6)}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-hidden\!{overflow:hidden!important}.rounded{border-radius:.25rem}.rounded-full{border-radius:3.40282e38px}.rounded-full\!{border-radius:3.40282e38px!important}.rounded-lg{border-radius:var(--radius-lg)}.rounded-md{border-radius:var(--radius-md)}.border{border-style:var(--tw-border-style);border-width:1px}.border\!{border-style:var(--tw-border-style)!important;border-width:1px!important}.border-0{border-style:var(--tw-border-style);border-width:0}.border-0\!{border-style:var(--tw-border-style)!important;border-width:0!important}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-4{border-style:var(--tw-border-style);border-width:4px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-b-2{border-bottom-style:var(--tw-border-style);border-bottom-width:2px}.border-none{--tw-border-style:none;border-style:none}.border-\[\#727272\]\!{border-color:#727272!important}.border-green-500{border-color:var(--color-green-500)}.border-transparent{border-color:#0000}.border-white{border-color:var(--color-white)}.border-t-white{border-top-color:var(--color-white)}.bg-\[rgba\(var\(--spice-rgb-shadow\)\,0\.7\)\]\!{background-color:rgba(var(--spice-rgb-shadow),.7)!important}.bg-black{background-color:var(--color-black)}.bg-transparent{background-color:#0000}.bg-transparent\!{background-color:#0000!important}.bg-white{background-color:var(--color-white)}.fill-\[\#22c55e\]{fill:#22c55e}.object-cover{object-fit:cover}.p-2{padding:calc(var(--spacing)*2)}.p-2\!{padding:calc(var(--spacing)*2)!important}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.p-8{padding:calc(var(--spacing)*8)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-3\.75\!{padding-inline:calc(var(--spacing)*3.75)!important}.px-4{padding-inline:calc(var(--spacing)*4)}.px-4\!{padding-inline:calc(var(--spacing)*4)!important}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\!{padding-block:calc(var(--spacing)*1)!important}.py-2{padding-block:calc(var(--spacing)*2)}.py-2\!{padding-block:calc(var(--spacing)*2)!important}.py-2\.5\!{padding-block:calc(var(--spacing)*2.5)!important}.py-4{padding-block:calc(var(--spacing)*4)}.py-4\!{padding-block:calc(var(--spacing)*4)!important}.py-12{padding-block:calc(var(--spacing)*12)}.pr-4{padding-right:calc(var(--spacing)*4)}.text-center{text-align:center}.text-right{text-align:right}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xl{font-size:var(--text-xl);line-height:var(--tw-leading,var(--text-xl--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-xs\!{font-size:var(--text-xs)!important;line-height:var(--tw-leading,var(--text-xs--line-height))!important}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-bold\!{--tw-font-weight:var(--font-weight-bold)!important;font-weight:var(--font-weight-bold)!important}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.whitespace-nowrap{white-space:nowrap}.whitespace-nowrap\!{white-space:nowrap!important}.text-\(--spice-text\){color:var(--spice-text)}.text-\(--spice-text\)\!{color:var(--spice-text)!important}.text-\[rgba\(var\(--spice-rgb-text\)\,0\.3\)\]\!{color:rgba(var(--spice-rgb-text),.3)!important}.text-\[rgba\(var\(--spice-rgb-text\)\,0\.5\)\]\!{color:rgba(var(--spice-rgb-text),.5)!important}.text-green-500{color:var(--color-green-500)}.text-white{color:var(--color-white)}.lowercase{text-transform:lowercase}.uppercase{text-transform:uppercase}.ordinal{--tw-ordinal:ordinal;font-variant-numeric:var(--tw-ordinal,)var(--tw-slashed-zero,)var(--tw-numeric-figure,)var(--tw-numeric-spacing,)var(--tw-numeric-fraction,)}.opacity-50{opacity:.5}.opacity-50\!{opacity:.5!important}.opacity-70{opacity:.7}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors\!{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to!important;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function))!important;transition-duration:var(--tw-duration,var(--default-transition-duration))!important}.transition-opacity{transition-property:opacity;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform\!{transition-property:transform,translate,scale,rotate!important;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function))!important;transition-duration:var(--tw-duration,var(--default-transition-duration))!important}.duration-33{--tw-duration:33ms;transition-duration:33ms}.duration-33\!{--tw-duration:33ms!important;transition-duration:33ms!important}.ease-out{--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.outline-none{--tw-outline-style:none;outline-style:none}.first-of-type\:mt-0:first-of-type{margin-top:calc(var(--spacing)*0)}@media (hover:hover){.hover\:scale-\[1\.04\]\!:hover{scale:1.04!important}}@media (hover:hover){.hover\:border-\(--spice-text\)\!:hover{border-color:var(--spice-text)!important}}@media (hover:hover){.hover\:text-\(--spice-text\)\!:hover{color:var(--spice-text)!important}}@media (hover:hover){.hover\:opacity-100:hover{opacity:1}}.main-trackCreditsModal-mainSection button,.main-addButton-button{background-color:#0000!important;border:none!important;margin:0!important;padding:0!important}.main-addButton-button{padding-top:4px!important;padding-left:3px!important}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-ordinal{syntax:"*";inherits:false}@property --tw-slashed-zero{syntax:"*";inherits:false}@property --tw-numeric-figure{syntax:"*";inherits:false}@property --tw-numeric-spacing{syntax:"*";inherits:false}@property --tw-numeric-fraction{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}@keyframes spin{to{transform:rotate(360deg)}}@layer properties{@supports ((-webkit-hyphens: none) and ( not (margin-trim: inline))) or ((-moz-orient: inline) and ( not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-border-style:solid;--tw-font-weight:initial;--tw-ordinal:initial;--tw-slashed-zero:initial;--tw-numeric-figure:initial;--tw-numeric-spacing:initial;--tw-numeric-fraction:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-duration:initial;--tw-ease:initial}}}
`.trim();document.head.appendChild(s)}})()})()